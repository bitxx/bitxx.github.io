<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>(置顶)区块链的未来究竟是什么？</title>
    <url>/articles/e71eb575/</url>
    <content><![CDATA[<iframe width="100%" height="300" src="//player.bilibili.com/player.html?aid=290076960&bvid=BV13f4y1s7xH&cid=322038660&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
]]></content>
  </entry>
  <entry>
    <title>ubuntu22.04部署bitcoin全节点教程</title>
    <url>/articles/a91be150/</url>
    <content><![CDATA[<p>最近铭文不是一般的火，动不动百八十倍，想快速低成本打个有潜力的铭文，没个自己的全节点怎么能行？借此缘故，本文重新整理下部署Bitcoin全节点的过程。</p>
<span id="more"></span>  
<h2 id="1-环境">1. 环境</h2>
<p>硬盘：1T左右，优先NVME。Bitcoin截止本文发布时占610GB左右，保不准你后面还要部署闪电网络什么的，多给自己预留点空间。<br>
内存：16GB，查询历史记录什么的，要加载完整索引，需要的内存比较大<br>
cpu：这个目前常规cpu足够了，4核以上<br>
带宽：常规<br>
系统：ubuntu22.04<br>
同步时常：很多人说，需要3到5天；但我的只用了十几个小时，貌似是nvme盘+千兆带宽的缘故</p>
<h2 id="2-基本部署">2. 基本部署</h2>
<ol>
<li>下载btc程序最新版：<a href="https://bitcoincore.org/en/download/">bitcoin</a> 根据自己系统环境选，我这里选的<code>Linux(tgz)</code>，amd的。当前我下载后的文件名是：<code>bitcoin-25.1-x86_64-linux-gnu.tar.gz</code></li>
<li>放在你合适的位置，我直接放<code>/root/</code>目录了，执行如下：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压</span></span><br><span class="line">tar -zxvf bitcoin-25.1-x86_64-linux-gnu.tar.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">改文件名</span></span><br><span class="line">mv bitcoin-25.1 bitcoin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入根目录</span></span><br><span class="line">cd bitcoin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改配置，具体配置内容查看下文</span></span><br><span class="line">vim bitcoin.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动节点，至此节点开始在后台自动同步了</span></span><br><span class="line">/root/bitcoin/bin/bitcoind -conf=/root/bitcoin/bitcoin.conf -daemon</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止节点，安全稳定的关闭节点。有说法是，不使用该命令，直接强制杀死bitcoin进程，可能导致数据异常，需要重新同步</span></span><br><span class="line">bitcoin-cli rpcuser=rpcuser -rpcpassword=rpcpassword stop</span><br></pre></td></tr></table></figure>
<p>常规配置内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 节点数据目录</span><br><span class="line">datadir=/root/bitcoin/data/</span><br><span class="line">dbcache=4096</span><br><span class="line">txindex=1</span><br><span class="line">irc=1</span><br><span class="line">upnp=1</span><br><span class="line"># rpc连接账户</span><br><span class="line">rpcuser=username</span><br><span class="line"># rpc连接密码</span><br><span class="line">rpcpassword=password</span><br><span class="line">daemon=1</span><br><span class="line">server=1</span><br><span class="line">addressindex=1</span><br><span class="line">rest=1</span><br><span class="line">rpcbind=0.0.0.0:8332</span><br><span class="line">rpcallowip=0.0.0.0/0</span><br><span class="line"># 启用已废弃的rpc接口，这个具体咋用，还不确定</span><br><span class="line">deprecatedrpc=accounts</span><br></pre></td></tr></table></figure>
<h2 id="3-进阶部署">3. 进阶部署</h2>
<p>上述的<code>基本部署</code>，只是满足了最低要求的部署方式，如果想要开机自启，能够快捷使用btc的不同命令，还需要进一步操作</p>
<ol>
<li>环境变量配置：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新增内容</span></span><br><span class="line">export BTCPATH=/root/bitcoin/bin</span><br><span class="line">export PATH=$BTCPATH:$PATH</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>supervisor安装(守护进程，用于确保btc服务开机自启，异常重启等)</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建日志目录，后续用到</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> /root/bitcoin/logs/</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装</span></span><br><span class="line">sudo apt update &amp;&amp; sudo apt install supervisor</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置</span></span><br><span class="line">vim /etc/supervisor/conf.d/bitcoind.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置内容</span></span><br><span class="line">[program:bitcoind]</span><br><span class="line">command=/root/bitcoin/bin/bitcoind -conf=/root/bitcoin/bitcoin.conf -daemon</span><br><span class="line">numprocs=1</span><br><span class="line">directory=/root/bitcoin/</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">stdout_logfile=/root/bitcoin/logs/bitcoind.log</span><br><span class="line">stderr_logfile=/root/bitcoin/logs/bitcoind.error.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置完毕，回到命令行环境后，执行如下：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新配置</span></span><br><span class="line">sudo supervisorctl reread</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">正式生效</span></span><br><span class="line">sudo supervisorctl update</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看状态</span></span><br><span class="line">sudo systemctl status supervisor  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手动启动（可选）</span></span><br><span class="line">sudo supervisorctl start bitcoind</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手动暂停（可选）</span></span><br><span class="line">sudo supervisorctl stop bitcoind</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手动重启（可选）</span></span><br><span class="line">sudo supervisorctl restart bitcoind</span><br></pre></td></tr></table></figure>
<p>注：这里一个问题是，直接使用<code>supervisorctl</code>停止bitcoin，会不会导致数据异常，有待考证。正常情况下，是使用<code>bitcoin-cli</code>停止节点</p>
<h2 id="4-查看日志">4. 查看日志</h2>
<p>目前有两个位置的日志需要留意：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">supervisor的bitcoind控制台日志</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">正常启动后的日志，里面貌似没什么有效日志，就只有一行：Bitcoin Core starting</span></span><br><span class="line">tail -f /root/bitcoin/logs/bitcoind.log</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动异常的日志，各种缘故导致的启动异常，在这里都能看到原因</span></span><br><span class="line">tail -f /root/bitcoin/logs/bitcoind.error.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bitcoin自身的日志文件，可以看到索引同步进度，节点数据同步情况等</span></span><br><span class="line">tail -f /root/bitcoin/data/debug.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以看看数据同步多大了</span></span><br><span class="line">du -h /root/bitcoin/data/</span><br></pre></td></tr></table></figure>
<h2 id="rpc访问">rpc访问</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">账户密码要输对，输错了什么也不返回</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询mininginfo</span> </span><br><span class="line">curl -s -X POST --user rpcUserName:rpcPassword -H &#x27;content-type: text/plain;&#x27; http://127.0.0.1:8332/ --data-binary &#x27;&#123;&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;:&quot;curltest&quot;, &quot;method&quot;: &quot;getmininginfo&quot;, &quot;params&quot;: [] &#125;&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可进一步过滤获取最新高度</span></span><br><span class="line">curl -s -X POST --user rpcUserName:rpcPassword -H &#x27;content-type: text/plain;&#x27; http://127.0.0.1:8332/ --data-binary &#x27;&#123;&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;:&quot;curltest&quot;, &quot;method&quot;: &quot;getmininginfo&quot;, &quot;params&quot;: [] &#125;&#x27; |awk -F &#x27;[:,]&#x27; &#x27;&#123;print $3&#125;&#x27; </span><br></pre></td></tr></table></figure>
<h2 id="5-常用命令">5. 常用命令</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止bitcoin节点</span></span><br><span class="line">bitcoin-cli rpcuser=rpcuser -rpcpassword=rpcpassword stop</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看网络状态：</span></span><br><span class="line">bitcoin-cli rpcuser=rpcuser -rpcpassword=rpcpassword getnetworkinfo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看网络节点：</span></span><br><span class="line">bitcoin-cli rpcuser=rpcuser -rpcpassword=rpcpassword getpeerinfo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看区块链信息：如同步进度、</span></span><br><span class="line">bitcoin-cli rpcuser=rpcuser -rpcpassword=rpcpassword getblockchaininfo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有命令</span></span><br><span class="line">bitcoin-cli help</span><br></pre></td></tr></table></figure>
<h2 id="6-总结">6. 总结</h2>
<p>本文编辑完毕</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Bitcoin</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Bitcoin</tag>
      </tags>
  </entry>
  <entry>
    <title>linux中安装代理clash客户端</title>
    <url>/articles/6598a2e5/</url>
    <content><![CDATA[<p>某些特定场合，总需要用到代理客户端。桌面版的就不说了，网上一搜一大筐。<br>
本文只针对linux命令行环境下，安装代理客户端</p>
<span id="more"></span>
<h2 id="环境">环境</h2>
<ol>
<li>操作系统： ubuntu 22.04 命令行版(server版)</li>
<li>docker docker-compose (强烈建议在容器中部署)</li>
<li>代理客户端：<a href="https://github.com/Dreamacro/clash/releases">clash</a> (自行根据需要下载)</li>
</ol>
<h2 id="步骤">步骤</h2>
<ol>
<li>首先，需要一个配置文件，文件名称叫做<code>config.yaml</code>，具体该文件怎么来，自行解决，这里有很多代理信息。官方有个可以参考的示例配置：<a href="https://dreamacro.github.io/clash/configuration/configuration-reference.html">config.yaml</a>，仅供参考</li>
<li><code>docker-compose.yaml</code>内容：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">clash:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">ghcr.io/dreamacro/clash</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">clash</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config.yaml:/root/.config/clash/config.yaml:ro</span></span><br><span class="line">      <span class="comment"># - ./ui:/ui:ro # dashboard volume</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;7890:7890&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9090:9090&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;7891:7891&quot;</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;bridge&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">ui:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">haishanh/yacd:master</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">clashui</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;81:80&quot;</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;bridge&quot;</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>clash</code>是代理执行程序，而<code>ui</code>是前端页面，用于可视化管理代理。<br>
<code>clash</code>的端口解释：<br>
7890：http代理端口，你需要用代理的程序，需要通过它来转发<br>
7891：socket代理端口，你需要用代理的程序，需要通过它来转发<br>
9090：clash的api接口，用于方便ui的调用</p>
<ol start="3">
<li>启动</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>
<p>浏览器打开ui管理页面<br>
为确保安全，<code>config.yaml</code>中，有一项可以配置密码，远程打开页面时候，可以通过输入密码，来管理你的代理，打开后，根据需要自行配置</p>
</li>
<li>
<p>调用<br>
假设，你需要用到代理的程序和你部署的代理服务是在同一个ubuntu系统中，那可以这样：</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export https_proxy=127.0.0.1:7890</span><br></pre></td></tr></table></figure>
<p>然后就能成功在当前窗口调用了。具体怎么用，你根据自己实际情况来决定</p>
]]></content>
      <categories>
        <category>通用技能</category>
      </categories>
      <tags>
        <tag>通用技能</tag>
      </tags>
  </entry>
  <entry>
    <title>spacemesh标准部署教程</title>
    <url>/articles/c1eac28e/</url>
    <content><![CDATA[<p>话不多说，整理部署运行过程</p>
<span id="more"></span>  
<h2 id="1-环境配置">1. 环境配置</h2>
<ol>
<li>操作系统：推荐ubuntu 22.04 一定用这个版本，别的版本也能跑，但各种毛病合配置，会让你抓狂</li>
<li>显卡：4070、3080等</li>
<li>驱动：ubuntu官方方式直接安装显卡</li>
<li>内存：32G起步</li>
<li>硬盘：除了系统盘。要P多大的盘，根据自己需要考量。最小需要256G。想省成本，可以用机械盘。固态盘主要是扫盘时候效率高，p盘没多大区别</li>
</ol>
<h3 id="1-1-环境说明">1.1 环境说明</h3>
<p>这块踩了很多坑，开始这个项目前，一定要先确保环境没有问题。其实最大的问题，就是显卡驱动。这个要没问题，那基本就都没什么事了。整理了下相关命令，具体如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 新装系统</span></span><br><span class="line">带有独显的设备重装系统，需要明白，ubuntu自带的显卡驱动nouveau可能会导致你无法重装，或者装上无法启动，如果开机有提示这个驱动导致你无法进入系统，那就参考网上的解决方案吧。</span><br><span class="line">我的解决方式是，在重装启动时，按ESC键，当画面让你选择哪种方式启动装系统时，一般选择第一种（不要回车），然后键盘按E，添加一行内容：splash nouveau.modeset=0 ，然后键盘按F10，正常就能进入系统或者安装系统了。</span><br><span class="line">每次开机或者装机，都这样操作。进入系统后，需要将nouveau加入黑名单，具体往上找找吧，大体如下：</span><br><span class="line">sudo vim /etc/modprobe.d/blacklist-nouveau.conf</span><br><span class="line">输入内容：</span><br><span class="line">blacklist nouveau</span><br><span class="line">options nouveau modeset=0</span><br><span class="line">生效：</span><br><span class="line">sudo update-initramfs -u</span><br><span class="line">重启系统：</span><br><span class="line">reboot</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 检测ubuntu驱动并安装</span></span><br><span class="line">apt-get update</span><br><span class="line">ubuntu-drivers devices</span><br><span class="line">选择标记recommand的那个版本（我是这样成功的，你需要根据自己实际情况考量，可前往https://www.nvidia.cn/Download/index.aspx?lang=cn 检查你的卡是否支持）然后安装，比如535：</span><br><span class="line">建议此种方式安装，可以最大限度减少没必要的文件</span><br><span class="line">sudo apt-get install nvidia-driver-535</span><br><span class="line">重启</span><br><span class="line">reboot</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. 检测显卡驱动是否安装成功</span></span><br><span class="line">如果有数据，则驱动安装成功，只是安装成功，但能否满足项目需要，还要看下一步</span><br><span class="line">nvidia-smi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4. 安装clinfo</span></span><br><span class="line">sudo apt install clinfo</span><br><span class="line">执行下方命令检测，如果能够输出你的显卡信息，那你的环境基本就没问题了。这个命令是最关键的一步，我在这里卡了好几天，一直什么数据都不显示。最后发现是有一张显卡有问题，拔掉后就正常了。</span><br><span class="line">clinfo -l</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5. 安装其余依赖（务必安装）</span></span><br><span class="line">sudo apt update &amp;&amp; sudo apt install -y git git-lfs make curl build-essential unzip wget ocl-icd-opencl-dev unzip libudev-dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6. 可选</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">p盘完成后，如果后续在没有显卡的设备，或者没有进行过上述安装的设备中进行扫盘，则需要进行如下安装。该方式主要是针对类似如下案例情况下的。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比如，nfs形式，计算和存储分离，计算设备p完存储设备的盘后，想要用存储设备的cpu扫盘，那存储设备就需要：</span></span><br><span class="line">sudo apt install mesa-opencl-icd</span><br><span class="line">sudo apt-get install clinfo</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>正常情况下，新系统，如上四个步骤就够了。别的诸如cuda、intel什么的，都不需要安装。<br>
如果第4步实在显示不出信息，而第3步又正常，这种时候建议检查下硬件，逐个排查，深刻的教训。</p>
<h3 id="1-2-挂载硬盘">1.2 挂载硬盘</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看空间情况</span></span><br><span class="line">lsblk</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式化硬盘</span></span><br><span class="line">sudo mkfs.ext4  /dev/sdb</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个目录用于挂载</span></span><br><span class="line">sudo mkdir /data</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">硬盘挂载到目录</span></span><br><span class="line">sudo mount /dev/sdb /data</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认情况下，新挂载的硬盘，系统会自动保留5%的空间，为了充分利用这5%空间，可以做如下设置，比如只保留1%：</span></span><br><span class="line">tune2fs -m 0.01 /dev/sdb</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">（可选）这种挂载，系统重启后，就会消失，想要永久挂载，继续如下操作：</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 查看uuid并记录</span></span></span><br><span class="line">blkid /dev/sdb </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 将uuid信息写入文件</span></span></span><br><span class="line">vim /etc/fstab</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 新增内容：</span></span></span><br><span class="line">/dev/disk/by-uuid/&#123;uuid&#125; /data ext4 defaults 0 1</span><br><span class="line"></span><br><span class="line">重启，检查硬盘是否正常</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>
<p>测试磁盘读写速度，这个涉及到你扫盘时候面临的问题，因此，你一定要测速，先心里有个底。<br>
因为扫盘时，要确保你能够在<code>12个小时内扫描结束</code>，为此，你一定要计算好你磁盘读写大小以及你p的文件大小<br>
这篇文章，针对这个，我专门提醒了3次。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装工具</span></span><br><span class="line">sudo apt-get install hdparm</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看磁盘</span></span><br><span class="line">lsblk</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试</span></span><br><span class="line">sudo hdparm -Tt /dev/指定磁盘</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式2 推荐</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装工具</span></span><br><span class="line">apt-get install sysstat</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试 5秒一次</span></span><br><span class="line">iostat -dmt /dev/sdb 5</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式3</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接手动读写几个G文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写</span></span><br><span class="line">time dd if=/dev/zero of=/data/testfile bs=8k count=307200</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">读</span></span><br><span class="line">time dd if=/data/testfile of=/dev/null bs=8k count=307200</span><br></pre></td></tr></table></figure>
<h3 id="1-3-其余命令汇总">1.3 其余命令汇总</h3>
<p>下面👇这里我再将我调试期间用到的命令，都汇总一下，方便以后自己查阅，这些命令没必要看，项目也用不到，除非你想了解了解：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显卡驱动，可前往nvidia官方下载run文件驱动</span></span><br><span class="line">安装驱动</span><br><span class="line">sudo bash xxx.run</span><br><span class="line">卸载驱动</span><br><span class="line">sudo bash xxx.run --uninstall</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提示apply <span class="built_in">command</span> not found，则安装：</span></span><br><span class="line">apt-get install alsa-utils</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前显卡硬件有哪些</span></span><br><span class="line">lspci | grep VGA</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看系统内核</span></span><br><span class="line">ubuntu22.04的默认好像是5.15</span><br><span class="line">uname -r</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看ubuntu的发行版本</span></span><br><span class="line">lsb_release -a</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看apt安装的关于nvidia有哪些</span></span><br><span class="line">apt list --installed | grep nvidia</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找nvidia驱动</span></span><br><span class="line">sudo apt search nvidia-driver</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自动安装显卡驱动</span></span><br><span class="line">这会安装很多东西</span><br><span class="line">sudo ubuntu-drivers autoinstall</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">卸载显卡驱动</span></span><br><span class="line">sudo apt-get --purge remove *nvidia*</span><br><span class="line">sudo apt autoremove</span><br><span class="line">sudo apt autoclean</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">卸载cuda</span></span><br><span class="line">sudo apt-get --purge remove &quot;*cublas*&quot; &quot;cuda*&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果以官方的run方式安装的驱动，则可以用安装包来卸载</span></span><br><span class="line">sudo xx.run --unistall</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其余一些icd支持</span></span><br><span class="line">项目需要的是nvidia-opencl-icd，这个在驱动安装时候，就会自动安装，你也单独安装不了。下面的是我测试期间各种尝试安装的。</span><br><span class="line">最后，你会在/etc/OpenCl/vender/目录中看到各种icd，可以cat看看具体内容</span><br><span class="line"></span><br><span class="line">sudo apt install pocl-opencl-icd</span><br><span class="line">sudo apt install mesa-opencl-icd</span><br><span class="line">sudo apt install ocl-icd-opencl-dev</span><br><span class="line">sudo apt install ocl-icd-libopencl1</span><br><span class="line">sudo apt install opencl-headers</span><br><span class="line">sudo apt install intel-opencl-icd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本机名称变更</span></span><br><span class="line">注意同时更改hosts中的本机名称</span><br><span class="line">hostnamectl set-hostname xxx</span><br></pre></td></tr></table></figure>
<h2 id="2-spacemesh项目文件准备">2. spacemesh项目文件准备</h2>
<p>下面三个程序，是后面命令要用到的，这个需要预先准备好<br>
官方工具最新版下载(当然可以自己编译，只要你有精力)：</p>
<ol>
<li>钱包工具：<a href="https://github.com/spacemeshos/smcli/releases">smcli</a></li>
<li>p盘工具：<a href="https://github.com/spacemeshos/post/releases">postcli</a></li>
<li>节点工具：<a href="https://github.com/spacemeshos/go-spacemesh/releases">spacemesh</a></li>
</ol>
<h2 id="3-创建钱包并记录信息">3. 创建钱包并记录信息</h2>
<p>使用前面准备的<code>smcli</code>程序<br>
这一过程，一定要记录好自己的账户信息，包括账户地址。后续产生的收益全在这里面了。<br>
地址后续的配置要用到</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./smcli wallet create</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">记录复制好钱包地址，后面要用，这里假设钱包地址是：sm1xxxxxxx</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">会显示钱包信息，助记词什么的，还有文件位置都记录好。比如提示的文件位置：xxx/xxx/xxx.json</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以可执行该命令打开文件，获取钱包信息</span></span><br><span class="line">./smcli wallet read xxx/xxx/xxx.json</span><br></pre></td></tr></table></figure>
<h2 id="4-计算p盘需要的数据">4. 计算p盘需要的数据</h2>
<ol>
<li>因为扫盘期间，要确保你能够在<code>12个小时内扫描结束</code>，为此，你一定要计算好你磁盘读写大小以及你p的文件大小，请务必牢记这句话，因为试错成本太高</li>
<li>使用前面准备的<code>postcli</code>程序，这个过程的目的是计算出你总共要生成多少个文件</li>
<li>先说下规则：<br>
<code>SpaceMesh</code>是以<code>numUnits</code>为基本的存储单元，每个<code>numUnits</code>是<code>64G</code>(这个值固定不变)，P好的文件是<code>postdata_xxx.bin</code>格式的文件，文件大小取决于<code>postcli</code>启动时<code>-maxFileSize</code>参数指定的文件大小，默认是<code>4G</code>。</li>
<li>按我的理解，一个<code>bin文件</code>的大小是64的整数倍，检索什么的效率应该会更高。但还需要考虑个人实际情况。比如你p盘完了，要传输或者拷贝文件，太大了反而成为负担。再比如，你多卡p盘时，想更细力度划分各卡p的范围。具体要多大，自己来衡量吧。</li>
<li>根据规则，其实我们只需要更改<code>numUnits</code>和<code>-maxFileSize</code>参数即可，计算出最终需要多少文件，是我们最关心的。</li>
<li>举个例子来解释这个过程：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比如你要p盘1152G（`需要时64的倍数`，最少需要p盘256G），则`numUnits`=1152/64=`18`，就是说，你总共要p出18个单位（注意，不是文件数量）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-maxFileSize默认，即4G，不配置，执行命令</span></span><br><span class="line">./postcli -numUnits 18 -printNumFiles</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时得到结果288，表示按现有参数最终你磁盘会生成288个4G的文件</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-maxFileSize改为32G，需要折算成字节byte，为34359738368，再次执行命令</span></span><br><span class="line">./postcli -numUnits 18 -maxFileSize=34359738368 -printNumFiles</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时得到结果36，表示按现有参数最终你磁盘会生成36个4G的文件，明显比默认值时候，生成的文件小很多</span></span><br></pre></td></tr></table></figure>
<p>如果你打算多显卡p同一个盘，生成文件的数量一定要记录好，具体后续会做进一步讲解。</p>
<h2 id="5-单机p盘">5. 单机p盘</h2>
<p>这个过程分为<code>单机单卡p盘</code>，或者<code>单机多张卡并行p盘</code>。说白了就是，假设你要p个256G，一张卡把256G从头p到尾，还是用多张卡把这256G划分到多张卡上p盘，后者显然效率更高，只要你有条件。<br>
而<code>单机多张卡并行p盘</code>的实现，是在<code>单机单卡p盘</code>的基础上实现的。<br>
因此，我们先讲讲如何进行<code>单机单卡p盘</code>。<br>
<code>注</code>：看懂了<code>单机多张卡并行p盘</code>，那即使显卡不在同一个机器上，也可以用相似方法搞。只是最近传输合并数据会比较麻烦。这个衍生的用法，文中我就不说了，自行探索吧。</p>
<h3 id="5-1-单机单卡p盘">5.1 单机单卡p盘</h3>
<p>使用前面准备的<code>go-spacemesh</code>程序<br>
这个其实很简单，一条命令就够了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./go-spacemesh --config config.mainnet.json --smeshing-start --smeshing-coinbase sm1xxxxxxx --smeshing-opts-numunits 18 -maxFileSize=34359738368 --smeshing-opts-provider 0 --smeshing-opts-datadir /mnt/spacemesh/post_data --data-folder /mnt/spacemesh/node_data</span><br></pre></td></tr></table></figure>
<p>解释下：<br>
<code>--config</code>: 节点配置文件，通过<code>wget https://smapp.spacemesh.network/config.mainnet.json</code> 获取，这个是官方的配置，可视化版本还是程序，都用这同一个配置，看着貌似是创世的配置以及网络节点的配置，具体内容我也没研究；<br>
<code>--smeshing-start</code>: 启动P盘，如果不加此选项，则只同步节点，不会启动P盘，也不会生成<code>postdata_metadata.json</code>；<br>
<code>--smeshing-coinbase</code>: 收益地址，sm1开头，通过smcli创建，就是前面让你记录的地址；<br>
<code>--smeshing-opts-numunits</code>: P盘的单元数量，和前面<code>postcli</code>计算的<code>-numUnits</code>值必须相等；<br>
<code>--smeshing-opts-maxfilesize</code>: 生成一个文件的大小，不能超过该值，用byte；<br>
<code>--smeshing-opts-provider</code>: 指定用显卡还是CPU，P盘时用显卡，参数值为显卡ID0、1、2…，比如你用nvidia卡，nvidia-sim命令，返回结果第一列就是ID；<br>
<code>--smeshing-opts-datadir</code>: P盘文件存储路径；<br>
<code>--data-folder</code>: 节点文件存储路径；</p>
<h3 id="5-2-单机多卡p盘">5.2 单机多卡p盘</h3>
<p>使用前面准备的<code>postcli</code>程序。<br>
这个原理就是：使用你前面计算的文件数量，根据显卡计算能力，把文件划分给不同的卡去p。比如你算出总共能生成10个文件，编号0到9，3张卡。你可以给计算能力强的0号卡分配前5个文件编号，计算适中的1号卡分配3个文件编号，计算最差的2号卡分配2个文件编号。<br>
然后配合节点参数，启动p盘</p>
<h4 id="5-2-1-获取commitmentatxid值">5.2.1 获取commitmentAtxId值</h4>
<p>该值为提交PoET证明的地址<br>
<code>单机单卡p盘</code>启动后，新开一个窗口，执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./grpcurl -plaintext -d &#x27;&#x27; 127.0.0.1:9092 spacemesh.v1.ActivationService.Highest | jq -r &#x27;.atx.id.id&#x27; |  base64 -d | xxd -p -c 32</span><br></pre></td></tr></table></figure>
<p>记录下这个输出值，这个值就是后面会用到的<code>-commitmentAtxId</code>值<br>
此时，就请务必关掉<code>单机单卡p盘</code>运行的程序了</p>
<p><code>注：</code> grpc下载地址：<a href="https://github.com/fullstorydev/grpcurl/releases/download/v1.8.7/grpcurl_1.8.7_linux_x86_64.tar.gz">下载</a></p>
<h4 id="5-2-2-获取id值">5.2.2 获取id值</h4>
<p>这是节点地址<br>
执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /data/post_data/postdata_metadata.json | jq -r &#x27;.NodeId&#x27; |  base64 -d | xxd -p -c 32</span><br></pre></td></tr></table></figure>
<p>关于<code>postdata_metadata.json</code>我解释下，<code>单机单卡p盘</code>启动后，会在启动用的参数<code>--smeshing-opts-datadir</code>中生成该文件，还有另一个<code>key</code>文件<br>
记录下这个输出值，这个值就是后面会用到的<code>-id</code>值<br>
<code>/mnt/spacemesh/post_data/</code>目录只要保留<code>key</code>和<code>--smeshing-opts-datadir</code>文件，其余的建议都删除掉</p>
<h4 id="5-2-3-启动p盘">5.2.3 启动p盘</h4>
<p>获取前面生成的<code>commitmentAtxId</code>和<code>id</code>参数<br>
比如有3张卡，则：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup ./postcli -provider=0 -commitmentAtxId=$&#123;commitmentAtxId&#125; -id=$&#123;id&#125; --smeshing-opts-numunits 18 -maxFileSize=34359738368 -fromFile=0 -toFile=5 -datadir=/mnt/spacemesh/post_data &gt; 0.log &amp;</span><br><span class="line">nohup ./postcli -provider=1 -commitmentAtxId=$&#123;commitmentAtxId&#125; -id=$&#123;id&#125; --smeshing-opts-numunits 18 -maxFileSize=34359738368 -fromFile=6 -toFile=11 -datadir=/mnt/spacemesh/post_data &gt; 1.log &amp;</span><br><span class="line">nohup ./postcli -provider=2 -commitmentAtxId=$&#123;commitmentAtxId&#125; -id=$&#123;id&#125; --smeshing-opts-numunits 18 -maxFileSize=34359738368 -fromFile=12 -toFile=17 -datadir=/mnt/spacemesh/post_data &gt; 2.log &amp;</span><br></pre></td></tr></table></figure>
<p>其中<code>nohup xxx &gt; 0.log</code> 表示后台运行，同时打印出日志，不想要的话，直接撤了就行</p>
<p>其余参数我简单解释下：<br>
<code>--provider</code>: 指定用显卡还是CPU，P盘时用显卡，参数值为显卡ID0、1、2…，比如你用nvidia卡，nvidia-sim命令，返回结果第一列就是ID；<br>
<code>--commitmentAtxId</code>: 提交PoET证明的地址；<br>
<code>--id</code>: 节点id；<br>
<code>--smeshing-opts-numunits</code>: P盘的单元数量，和前面<code>postcli</code>计算的<code>-numUnits</code>值必须相等；<br>
<code>---maxFileSize</code>: 生成一个文件的大小，不能超过该值，用byte。如果不填，默认一个文件大小4GB，即4294967296；<br>
<code>---fromFile</code>: 根据p盘原理，选择从哪个文件编号开始p；<br>
<code>---toFile</code>: 根据p盘原理，选择p到哪个文件编号为止；<br>
<code>---datadir</code>: p的文件存储的位置，同一台机子，不同卡都可以把文件指向同一个目录，如果每张卡指向不同目录，那到时候合并数据时，你得把不同目录中，最小那个<code>Nonce</code>值变更到合并目录中；</p>
<p>如果你每张卡p在了不同目录，合并数据时，需要选择不同目录中最小的那个<code>Nonce</code>值，然后替换合并目录中<code>postdata_metadata.json</code>的Nonce值。<br>
如果每张卡都p在同一目录，就什么也不用操作了，等着p完就行。</p>
<p>为了简化这个计算过程，避免每张卡计算失误，我开发了个脚本<a href="https://github.com/bitxx/spacemesh-utils/blob/main/script/multi_thread_p.sh">单机多卡快速部署脚本</a> ，把该脚本放在和<code>postcli</code>程序同一个目录下，直接执行，按照脚本提示完成操作即可。</p>
<h3 id="5-3-验证">5.3 验证</h3>
<p>如果因为各种意外，导致P盘中断，是可以继续使用相同命令和参数继续P盘的，程序会自动跳过已经P好的盘。如果p完后，不放心盘是否完整，可以使用下面这个命令验证P盘是否正确：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/post/data 表示p盘文件的目录，该目录下包含xxx.json和key</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">0.1表示，只验证0.1%的数据，说白了就是只抽取0.1%的数据去验证，毕竟完整验证是很消耗时间的</span></span><br><span class="line">postcli -verify -datadir /post/data -fraction 0.1</span><br></pre></td></tr></table></figure>
<h3 id="5-4-总结">5.4 总结</h3>
<p>看懂了<code>单机多张卡并行p盘</code>，那即使显卡不在同一个机器上，也可以用相似方法搞。只是传输合并数据会比较麻烦。这个衍生的用法，文中我就不说了，自行探索吧。</p>
<h2 id="6-节点同步">6. 节点同步</h2>
<p>p盘期间，根据我个人经验，建议可以同时启动节点同步，让节点先自行下载同步数据去，要不然等你p完了，还得等待节点同步。<br>
节点同步的目录，一定是你前面p盘那会儿生成的节点目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./go-spacemesh --config config.mainnet.json --data-folder /mnt/spacemesh/node_data</span><br></pre></td></tr></table></figure>
<h2 id="7-扫盘并提交证明">7. 扫盘并提交证明</h2>
<p>这个过程，要确保你能够在<code>12个小时内扫描结束</code>，为此，你一定要计算好你磁盘读写大小以及你p的文件大小</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取cpu编号</span></span><br><span class="line">./postcli -printProviders</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开始扫盘</span></span><br><span class="line">./go-spacemesh --config config.mainnet.json --smeshing-start --smeshing-coinbase sm1xxxxxxx --smeshing-opts-numunits 16 --smeshing-opts-provider 4294967295 --smeshing-opts-datadir /data/post_data --data-folder /data/node_data</span><br></pre></td></tr></table></figure>
<p>执行命令后：<br>
当出现如下信息表示正在扫描文件（不是扫盘），该信息是你启动扫盘后，很快会出现的：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2023-07-23T15:57:24.849+0800	INFO	fb26a.post	initialization: file already initialized	&#123;&quot;node_id&quot;: &quot;fb26a9d2da5626ded24027da14054bf0fbf8886bd7ec4a29d05ee2fdd44edddd&quot;, &quot;module&quot;: &quot;post&quot;, &quot;fileIndex&quot;: 0, &quot;currentNumLabels&quot;: 268435456, &quot;targetNumLabels&quot;: 268435456, &quot;startPosition&quot;: 0&#125;</span><br><span class="line">2023-07-23T15:57:24.849+0800	INFO	fb26a.post	initialization: file already initialized	&#123;&quot;node_id&quot;: &quot;fb26a9d2da5626ded24027da14054bf0fbf8886bd7ec4a29d05ee2fdd44edddd&quot;, &quot;module&quot;: &quot;post&quot;, &quot;fileIndex&quot;: 1, &quot;currentNumLabels&quot;: 268435456, &quot;targetNumLabels&quot;: 268435456, &quot;startPosition&quot;: 268435456&#125;</span><br></pre></td></tr></table></figure>
<p>当出现如下信息，表示开始生成证明文件，该信息是你启动扫盘后，很快会出现的：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2023-07-23T15:57:59.995+0800	INFO	fb26a.post calculating proof of work for nonces 0..144</span><br></pre></td></tr></table></figure>
<p>等待十来二十分钟，检测磁盘读写，表示已经开始扫了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iostat -dmt /dev/sdb 5</span><br></pre></td></tr></table></figure>
<p>当出现如下信息，表示扫描结束，并在<code>post_data</code>目录生成<code>post.bin</code>文件：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2023-07-23T16:07:27.469+0800	INFO	fb26a.post	Found proof for nonce: 110, pow: 54043195528453627 with...</span><br></pre></td></tr></table></figure>
<p>然后就是漫长的等待纪元时间点，链上自动注册，链上自动二次扫描（确保你没舞弊），获取收益，需要历经14天左右。<br>
比如出现如下日志表示开始注册：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2023-08-21T07:00:00.743Z	INFO	c9d89.atxBuilder	atx challenge is ready</span><br></pre></td></tr></table></figure>
<h2 id="参考：">参考：</h2>
<ol>
<li><a href="https://github.com/minerdao/posts/blob/master/spacemesh/cluster-mining-tutorial.md">集群P盘教程</a> <a href="https://github.com/minerdao/posts/blob/master/spacemesh/cluster-mining-tutorial.md">https://github.com/minerdao/posts/blob/master/spacemesh/cluster-mining-tutorial.md</a></li>
<li><a href="https://github.com/spacemeshos/post/tree/develop/cmd/postcli">显卡P盘脚本</a> <a href="https://github.com/minerdao/posts/blob/master/spacemesh/cluster-mining-tutorial.md">https://github.com/minerdao/posts/blob/master/spacemesh/cluster-mining-tutorial.md</a></li>
<li><a href="https://simeononsecurity.ch/other/efficient-spacemesh-mining-multiple-gpus-guide/#linux">多显卡P盘教程</a> <a href="https://simeononsecurity.ch/other/efficient-spacemesh-mining-multiple-gpus-guide/#linux">https://simeononsecurity.ch/other/efficient-spacemesh-mining-multiple-gpus-guide/#linux</a></li>
<li><a href="https://github.com/spacemeshos/gpu-post">GPU post</a> <a href="https://github.com/spacemeshos/gpu-post">https://github.com/spacemeshos/gpu-post</a></li>
</ol>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Spacemesh</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Spacemesh</tag>
      </tags>
  </entry>
  <entry>
    <title>ethstats-以太坊生态网络监控工具</title>
    <url>/articles/f2ecc7b4/</url>
    <content><![CDATA[<p>现在无论ethereum本身、还是L2、L3，其实本质用的都是同一个技术网络实现的。比如你在不同区域部署了opside的网络节点，为了确保持续运行，怎样实时监控每个节点的健康状况，怎样知道哪个节点失联了？<br>
对于普通的开发者，弄一套复杂的运维监控系统，一个是是否有必要？另一个是懂多少运维技术？<br>
为此，本着赠人玫瑰，手有余香的考虑，我这里推出一款工具：<a href="https://github.com/bitxx/ethstats">ethstats</a></p>
<span id="more"></span>
<h2 id="1-概述">1. 概述</h2>
<p><a href="https://github.com/bitxx/ethstats">ethstats</a> 分为客户端和服务端，客户端实时上报节点信息给服务端，服务端根据得到的信息，发送邮件或者前端渲染等等</p>
<p>以下是<a href="https://github.com/bitxx/ethstats">ethstats</a> 目前已有的主要功能</p>
<ol>
<li>每个节点名称不得重复</li>
<li>支持实时上传节点信息</li>
<li>节点异常时，实时邮件反馈。若同一个节点频繁出异常，则一个小时内只发送一份邮件，避免频繁发送造成邮箱上限异常</li>
<li>定时邮件发送节点简报</li>
<li>server和client强稳定性，可持续稳定运行，降低了运维复杂度，差不多就是个守护进程，要是总停止，三天两头去重启服务，很烦人的。</li>
<li>可通过命令行传入参或者通过配置文件启动client、server，不建议同时使用两种方式，选择其中一种即可</li>
<li>本项目没有前端页面，主要是不会用前端语言，也设计不了。。。本项目在server/app/service/api中提供了socket数据出口，只要前端使用socket调用，即可渲染在前端。</li>
<li>前端通过socket的emit可读取：<code>stats 节点信息</code>、<code>latency 延迟</code>、<code>node-ping ping</code>三类数据</li>
</ol>
<h2 id="2-部署服务端">2. 部署服务端</h2>
<p>需要在一台ip稳定的服务器上部署<br>
可以去<a href="https://github.com/bitxx/ethstats/releases">ethstats</a> 直接下载最新版，或者先编译再部署：<br>
编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go mod tidy</span><br><span class="line">cd server</span><br><span class="line">go build -o server ./server.go  当前操作系统编译</span><br><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -a -o server server.go 当前操作系统交叉编译为linux amd版的</span><br></pre></td></tr></table></figure>
<p>部署</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">前往稳定IP的服务器</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用配置文件方式启动，这个需要你编译好配置信息，该配置里面有详细的配置信息解释，代码护着release下载后就可以看到</span></span><br><span class="line">server start -c setting.yml</span><br></pre></td></tr></table></figure>
<p>启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置文件嫌麻烦的话，可以直接命令行方式启动，具体参数可以参考配置文件或者https://github.com/bitxx/ethstats/blob/main/server/cmd/run/start.go</span></span><br><span class="line">./server start --name ethereum-server --secret 123456 --host 0.0.0.0 --port 3000 --email-subject-prefix ethereum --email-host 邮箱服务地址 --email-port 465 --email-username 发件邮箱账户 --email-password 邮箱密钥 --email-from 发件邮箱账户--email-to 收件邮箱账户(多个逗号隔开)</span><br></pre></td></tr></table></figure>
<p>服务端启动成功，等待客户端传入数据。</p>
<h2 id="3-部署客户端">3. 部署客户端</h2>
<p>可以去<a href="https://github.com/bitxx/ethstats/releases">ethstats</a> 直接下载最新版，或者先编译再部署：</p>
<p>编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go mod tidy</span><br><span class="line">cd client</span><br><span class="line">go build -o client ./client.go  当前操作系统编译</span><br><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -a -o client client.go 当前操作系统交叉编译为linux amd版的</span><br></pre></td></tr></table></figure>
<p>部署</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">前往需要监控的节点服务器</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用配置文件方式启动，这个需要你编译好配置信息，该配置里面有详细的配置信息解释，代码护着release下载后就可以看到</span></span><br><span class="line">client start -c setting.yml</span><br></pre></td></tr></table></figure>
<p>启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置文件嫌麻烦的话，可以直接命令行方式启动，具体参数可以参考配置文件或者https://github.com/bitxx/ethstats/blob/main/client/cmd/run/start.go</span></span><br><span class="line">./client start --name test --secret 123456 --server-url 链地址，如：ws://127.0.0.1:30303</span><br></pre></td></tr></table></figure>
<p>客户端启动完毕，它会不停的尝试链接服务端，持续运行</p>
<h2 id="总结">总结</h2>
<p>本文大概讲解了下<a href="https://github.com/bitxx/ethstats">ethstats</a> 的使用方式，具体细节如果还有疑惑的，可以发issue等来进一步予以解释</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>综合</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>ethereum</tag>
        <tag>opside</tag>
      </tags>
  </entry>
  <entry>
    <title>opside简介及部署</title>
    <url>/articles/fc7a5373/</url>
    <content><![CDATA[<p>记录一些Opside的主要信息，以及跟进官方的部署方式和其余信息。大多数内容都能在官方文档找到，我这里主要列一些关键信息。<br>
当前我主要关注的是pos</p>
<span id="more"></span>  
<h2 id="1-简介">1. 简介</h2>
<ol>
<li>Opside是一个三层（three-layer）区块链平台，既兼容EVM同时支持rollup，表现形式为“Base chains &lt; Opside chain &lt; Rollups.”，其中第二层是与EVM兼容且适合Rollup的链，第三层由多个zk-rollups组成。</li>
<li>通俗的说，第三层，一个应用就是一个一条独立的链</li>
<li>PoS + PoW 混合共识机制
<ol>
<li>Opside三层架构中的layer 2和layer 3，共用了一个PoS与PoW融合的共识机制。通过 PoS &amp; PoW的混合共识机制，layer 2和layer 3具有相同的共识层与验证者集合，确保了整个架构的安全性和去中心化。</li>
<li>更为重要的是，layer 3的各个Native Rollup在底层架构上拥有了一个规范化的去中心化解决方案。layer 2定义了一个统一的系统合约，rollup的开发者只需要实现这些规范化的接口，并注册rollup 插槽成为native rollup。给开发者带来的便利是不必关心在底层架构层面layer 2与layer 3如何交互，也不需要维护rollup的全节点和zkp算力。</li>
</ol>
</li>
</ol>
<h3 id="1-1-pos">1.1 Pos</h3>
<h4 id="1-1-1-硬件">1.1.1 硬件</h4>
<p>系统: 64-bit Linux, Mac OS X 10.14+, Windows 10+ 64-bit<br>
CPU: 4+ cores @ 2.8+ GHz<br>
内存: 16GB+ RAM<br>
存储: 最少500G的SSD存储，主网建议2T起步<br>
要成为验证者，需要存入质押25000个IDE，不能多也不能少</p>
<h4 id="1-1-2-规则">1.1.2 规则</h4>
<ol>
<li>规则每6.4分钟，也就是384秒一个纪元，进行一次奖励或惩罚</li>
<li>每12秒出一个块，也就是一天最多可以出7200块。一个验证器每天有7200次机会出块</li>
<li>惩罚：
<ol>
<li>在2/3验证者仍然在线的情况下，个别节点的离线只会有较小的惩罚，目前来看，比如你今天能收益1个IDE，但由于停机一天，就会惩罚1个IDE，从质押中扣除</li>
<li>极端情况下，超过 1/3验证者离线，则会有严重的损失，但这个情况微乎其微，毕竟去中心化</li>
</ol>
</li>
</ol>
<h2 id="2-主要链接">2. 主要链接</h2>
<ol>
<li><a href="https://opside.network/rollup/start">官方第三层rollup平台入口，可申请独立链开发应用</a></li>
<li><a href="https://galxe.com/Opside/campaign/GCpHhUYvox">galxe任务，官方的任务汇总</a> ：<a href="https://galxe.com/Opside/campaign/GCpHhUYvox">https://galxe.com/Opside/campaign/GCpHhUYvox</a></li>
<li><a href="https://tutorial-for-the-tasks-on-galxe.gitbook.io/tutorial-for-the-tasks-on-galxe/">做任务的教程指导</a> ：<a href="https://tutorial-for-the-tasks-on-galxe.gitbook.io/tutorial-for-the-tasks-on-galxe/">https://tutorial-for-the-tasks-on-galxe.gitbook.io/tutorial-for-the-tasks-on-galxe/</a></li>
<li><a href="https://docs.opside.network/">开发者文档</a> : <a href="https://docs.opside.network/">https://docs.opside.network/</a></li>
<li><a href="https://opside.network/validator/deposit">Pos在线质押</a> ：<a href="https://opside.network/validator/deposit">https://opside.network/validator/deposit</a></li>
<li><a href="https://xthrill.xyz/events">xthrill游戏，第三方应用</a> ：<a href="https://xthrill.xyz/events">https://xthrill.xyz/events</a></li>
<li><a href="https://www.era7.io/#/">era7游戏，第三方应用，很火</a> ：<a href="https://www.era7.io/#/">https://www.era7.io/#/</a></li>
<li><a href="https://www.sideswap.finance/#/swap">Sideswap应用，各链之间兑换，全靠它</a>  ：<a href="https://www.sideswap.finance/#/swap">https://www.sideswap.finance/#/swap</a></li>
<li><a href="https://zealy.io/c/sideswap-6411/questboard">Zealy中SideSwap的专属任务</a> ：<a href="https://zealy.io/c/sideswap-6411/questboard">https://zealy.io/c/sideswap-6411/questboard</a></li>
</ol>
<h2 id="3-pos部署">3. pos部署</h2>
<ol>
<li>其实就是部署验证者节点</li>
<li>一个节点需要25000个IDE，具体去哪凑这么多，不在本文考虑范围内</li>
<li>一台机子可以部署多个节点，就是通过官方脚本追加节点，官方建议一台不要超过10个，否则稳定性会受到影响。这里按我观察，主要受限于内存和网络</li>
<li>根据第二点，虽然可以部署多个节点，但是只能共用一个提现账户，因此，这个提现账户一定要守护好</li>
<li>这里我只考虑<code>ubuntu 22.04</code> 的部署方式，别的方式直接参考官方文档吧</li>
<li>25000个IDE一个节点，反复在同一个节点质押没有任何用，白白浪费</li>
</ol>
<h3 id="3-1-部署步骤">3.1 部署步骤</h3>
<p>执行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -c https://pre-alpha-download.opside.network/testnet-auto-install-v3.tar.gz &amp;&amp; tar -C ./ -xzf testnet-auto-install-v3.tar.gz &amp;&amp; chmod +x -R ./testnet-auto-install-v3 &amp;&amp; cd ./testnet-auto-install-v3 &amp;&amp; ./install-ubuntu-1.0.sh</span><br></pre></td></tr></table></figure>
<p>该命令执行后，会出现命令行，主要如下：<br>
如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">你要生成几个节点：</span><br><span class="line">根据你账户余额，看你要生成几个节点，反正一个25000</span><br><span class="line"></span><br><span class="line">Please choose the synchronization mode you need: </span><br><span class="line"> 1. Fast mode &#123;synchronization is fast, recommended, if there is a synchronization error, you can try to switch to normal mode&#125;</span><br><span class="line"> 2. Normal mode &#123;more nodes, more stable, but slower&#125;</span><br><span class="line">Enter index[1]: 默认1，快速同步，新人直接默认就行</span><br><span class="line"></span><br><span class="line">Select the mnemonic import type: </span><br><span class="line"> 1. Create a new mnemonic 创建新账户</span><br><span class="line"> 2. Import an existing mnemonic  导入已有账户助记词</span><br><span class="line">Enter index[1]: 默认1。属于提现账户，创新新的助记词或者导入已有助记词。这个很重要，用于接收Pos产生的收益。即使后续追加多个节点，也只能靠这个账户接收收益。</span><br><span class="line"></span><br><span class="line">Please enter your mnemonic separated by spaces (&quot; &quot;). Note: you only need to enter the first 4 letters of each word if you&#x27;d prefer.:</span><br><span class="line">验证你的提现账户。就是让你输入上面提到的提现账户的助记词，提示说你只要输入前四个助记词，按我说，直接全输就行</span><br><span class="line"></span><br><span class="line">Enter the index (key number) you wish to start generating more keys from. For example, if you&#x27;ve generated 4 keys in the past, you&#x27;d enter 4 here. [0]:</span><br><span class="line">这一步很重要，意思就是，你用上面那个提现账户，创建并成功运行过几个验证者。比如你以前用这个账户生成过3个节点并产生收益，那这里就输入3. 这里解释下是咋回事，因为你生成过3个，但你输0，表示你没生成过，系统在这里生成的前三个节点，就会是你以前的，相当于你又质押在以前节点，而以前节点已经质押了25000个，那你就白质押了。</span><br></pre></td></tr></table></figure>
<p>你会发现本地当前目录多了个文件夹，<code>testnet-auto-install-v3</code>什么的，里面就是运行节点需要的各种文件，有个文件夹<code>validator_keys</code>，里面有<code>deposit_data-xxx.json</code>文件(该文件中有个key，就是每个节点的唯一标记，建议你记录下来，方便后续在区块链浏览器专门查找该节点)，这个就是你新建的质押节点的信息，你执行命令创建几个节点，这里面就记录几个节点信息。<br>
把它拷贝出来，前往  <a href="https://opside.network/validator/deposit">Pos在线质押</a> 按步骤完成质押即可，这个过程傻瓜式操作，我就不再详述了。</p>
<p>完成质押操作后，需要等大概24个小时，然后你去区块链浏览器，用你的提现账户查找，就能发现验证节点信息了。一个提现账户下挂了多少个验证节点，一目了然。等着领取收益就行。</p>
<h2 id="4-pow部署">4. pow部署</h2>
<p>这里我只针对zksync的L2部署GPU版。<br>
分为同步节点和算力节点，你设备足够强的话，可以共用一台机子</p>
<h3 id="4-1-环境安装">4.1 环境安装</h3>
<p>ubuntu 22.04 这个就不说了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 新装系统(根据实际情况，可选)</span></span><br><span class="line">带有独显的设备重装系统，需要明白，ubuntu自带的显卡驱动nouveau可能会导致你无法重装，或者装上无法启动，如果开机有提示这个驱动导致你无法进入系统，那就参考网上的解决方案吧。</span><br><span class="line">我的解决方式是，在重装启动时，按ESC键，当画面让你选择哪种方式启动装系统时，一般选择第一种（不要回车），然后键盘按E，添加一行内容：splash nouveau.modeset=0 ，然后键盘按F10，正常就能进入系统或者安装系统了。</span><br><span class="line">每次开机或者装机，都这样操作。进入系统后，需要将nouveau加入黑名单，具体往上找找吧，大体如下：</span><br><span class="line">sudo vim /etc/modprobe.d/blacklist-nouveau.conf</span><br><span class="line">输入内容：</span><br><span class="line">blacklist nouveau</span><br><span class="line">options nouveau modeset=0</span><br><span class="line">生效：</span><br><span class="line">sudo update-initramfs -u</span><br><span class="line">重启系统：</span><br><span class="line">reboot</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 检测ubuntu驱动并安装</span></span><br><span class="line">apt-get update</span><br><span class="line">ubuntu-drivers devices</span><br><span class="line">选择标记recommand的那个版本（我是这样成功的，你需要根据自己实际情况考量，可前往https://www.nvidia.cn/Download/index.aspx?lang=cn 检查你的卡是否支持）然后安装，比如535：</span><br><span class="line">建议此种方式安装，可以最大限度减少没必要的文件</span><br><span class="line">sudo apt-get install nvidia-driver-535</span><br><span class="line">重启</span><br><span class="line">reboot</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. 检测显卡驱动是否安装成功</span></span><br><span class="line">如果有数据，则驱动安装成功，只是安装成功，但能否满足项目需要，还要看下一步</span><br><span class="line">nvidia-smi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4. 安装clinfo</span></span><br><span class="line">sudo apt install clinfo</span><br><span class="line">执行下方命令检测，如果能够输出你的显卡信息，那你的环境基本就没问题了。这个命令是最关键的一步，我在这里卡了好几天，一直什么数据都不显示。最后发现是有一张显卡有问题，拔掉后就正常了。</span><br><span class="line">clinfo -l</span><br></pre></td></tr></table></figure>
<h3 id="4-2">4.2</h3>
<p>安装节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检测环境，并自动下载缺失依赖</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">网络环境不好，国内网络环境，那就执行后，慢慢等吧，我的是最终都成功下载并安装了</span></span><br><span class="line">wget -c https://pre-alpha-miner-download.opside.network/update/zksync/install-basic-env.sh -O ./install-basic-env.sh &amp;&amp; chmod +x ./install-basic-env.sh &amp;&amp; ./install-basic-env.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">节点安装</span></span><br><span class="line">wget -c https://pre-alpha-miner-download.opside.network/update/zksync/run-external-node.sh -O ./run-external-node.sh &amp;&amp;  chmod +x ./run-external-node.sh &amp;&amp; ./run-external-node.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">按照提示依次输入：地址、私钥、ethereum测试网地址</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这一步我是进行不下去了，连接不上节点</span></span><br></pre></td></tr></table></figure>
<h2 id="5-总结">5. 总结</h2>
<p>本文编辑完毕。pos的部署理解了，还是很容易操作的。等运行起来后，建议多看看官方文档，好好看下奖励惩罚细节</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Opside</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Opside</tag>
      </tags>
  </entry>
  <entry>
    <title>uniswap-v3设计详解</title>
    <url>/articles/a0a6b822/</url>
    <content><![CDATA[<p>v3的设计要复杂太多，直接看源码不现实，一定要先实操，并理解设计的理论。然后再去看源码，会减少很多压力</p>
<span id="more"></span>
<p>v3的设计，网上我翻了很多信息，发现还是这篇文章讲的最好，建议通读一下：</p>
<p><a href="https://zhuanlan.zhihu.com/p/448382469">Uniswap v3 设计详解</a></p>
<p>该文章解释了很多我们关注的疑惑，我就不再班门弄斧了。</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://zhuanlan.zhihu.com/p/625756780">什么是自动化做市商（AMM）？</a></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>DeFi</category>
        <category>Uniswap-V3</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>DeFi</tag>
        <tag>Uniswap-V3</tag>
      </tags>
  </entry>
  <entry>
    <title>sr25519概述和理解</title>
    <url>/articles/5158b3d6/</url>
    <content><![CDATA[<p>最近在搞substrate的sdk时，一直纠结怎样从keystore导入的账户中导出私钥？经过这几天的踩坑和学习，才知道这个是不可能导出的。网上也没找到什么直观的文章来解释，只好通过代码调试来了解。密码学太过深奥，这里我只结合自己的理解，把这个原因和过程记录一下。</p>
<span id="more"></span>
<h2 id="1-简介">1. 简介</h2>
<p>在众多区块链项目中，密钥和keystore是可以相互导出的。但在substrate中使用钱包时，你会发现密钥可以导出keystore，但Keysotre却无法重新获取密钥，这是因为substrate使用了sr25519这样一套密码学规则，它可以生成密钥账户、消息签名等。具体机制我逐步讲解下。</p>
<h2 id="2-sr25519结构">2. sr25519结构</h2>
<p>我抛开密码学专业解释以及一些枯燥的图示，通俗的来说下。sr25519的结构分为三部分：<br>
<code>seed</code>、<code>key</code>、<code>nonce</code></p>
<h3 id="2-1-seed">2.1 seed</h3>
<p>种子数据，32字节。<br>
substrate中的私钥，就是通过它转化出来的。这块会涉及到sr25519更深的结构，但作为非密码学专业的我们，可以先不必去深入了解欸。只需要知道seed即为私钥或者助记词。<br>
seed作为私钥，自然可以生成公钥以及对应的不同networid的地址</p>
<h3 id="2-2-key-nonce">2.2 key、nonce</h3>
<p>key是seed生成的，32字节。<br>
通过对源码的了解，我发现seed通过hash512生成了key，也就是说，这个过程是不可逆的。<code>key无法重新恢复seed（请记住这句话）</code>。<br>
而nonce是生成key时，生成的固定值，32字节。<br>
在sr25519中，使用的是key来签名消息，而不是直接使用seed。</p>
<h2 id="3-keystore">3. keystore</h2>
<p>通过私钥或者助记词，可以导出一个keystore。<br>
这里我直接贴一个keystore结构：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;encoded&quot;</span><span class="punctuation">:</span><span class="string">&quot;mD7nc88uUIpeRG4+mfw5bfZxCTM1Gp8xoCHtAGtC4m0AgAAAAQAAAAgAAAClmfyOli5KEtwM/PgHojaTuD6vsd1XeKEU/ZdlQ1LH/RWEQOd+wXdsA1AyRSi6XseDx6ZZvfr8L07IFY9E2f79ysEcogEmSQ3dU2pVqLulnLYex8Rjkef6Ac52mN4BnGrDuZ5puoe5pN2Qmn9WZ/+OP3tYRKXXnHnTDge389HbdsNpxhXQUJ06+g7WA6NFgclABG2TG1UfMNup52TD&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;pkcs8&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;sr25519&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;scrypt&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;xsalsa20-poly1305&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span><span class="string">&quot;3&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span><span class="string">&quot;5FnTy68oYwMVE8J7VRMczJVyJrTv9U4P5M7YnwWcFy8C8Xck&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;meta&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;genesisHash&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;testM1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;whenCreated&quot;</span><span class="punctuation">:</span><span class="number">1681128297037</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>其实只要关注<code>encoded</code>，它包含了一个账户的Keystore密码、公钥、key、nonce等信息，输入正确的密码，即可解析到：<code>公钥、key、nonce值</code>（解析过程这里就不说了，感觉没必要，字节码按长度规范截取转码等过程），这里你也就会明白keystore中是没有私钥的。<br>
通过公钥，你可以生成不同networkid的地址，<br>
通过key，你可以给消息签名、转账签名等。<br>
结合前文<code>sr25519的结构</code>让你记住的话<code>key无法重新恢复seed</code>，你会明白keystore是无法获取私钥的。<br>
这里记录个信息，从<code>encoded</code>中会导出一个64字节的二进制数据，其中前32字节是key，后32字节是nonce。</p>
<h2 id="4-综述">4. 综述</h2>
<ol>
<li>本文还有很多内容我没有提到，包括助记词或者密钥怎么转换成seed、中间各阶段数据如何解析的等等。这里只是大概讲了下sr25519的规则，对大家有个宏观上的了解，然后有必要了再去进一步研究。对我而言，解决了文章开头提到的最大的疑惑。</li>
<li>按官方解释，substrate选择sr25519的目的是为了能让账户更加安全。不同于常规的账户体系，如果不了解该算法，硬按着常规方式搞，会走不少弯路</li>
<li>sdk源码可供参考，代码位置：<a href="https://github.com/bitxx/my-token">my-token</a>  如果没放出代码来，就是还在搞，最终肯定放出来</li>
<li>最后总结一下：<br>
私钥或者助记词可以导出keystore，但keystore是不可导出私钥或助记词的。</li>
</ol>
]]></content>
      <categories>
        <category>区块链</category>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>sui基础(4)-永久测试网节点部署</title>
    <url>/articles/4e548a66/</url>
    <content><![CDATA[<p>部署全节点、验证人节点</p>
<span id="more"></span>
<h2 id="1-编译">1. 编译</h2>
<p>Macos交叉编译配置参考：<a href="/articles/a6749ab9">MacOS中Rust交叉编译</a></p>
<h3 id="1-1-安装依赖">1.1 安装依赖</h3>
<p>ubuntu 20.04环境依赖安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">依赖安装</span></span><br><span class="line">sudo apt-get update \</span><br><span class="line">&amp;&amp; sudo apt-get install -y --no-install-recommends \</span><br><span class="line">tzdata \</span><br><span class="line">libprotobuf-dev \</span><br><span class="line">ca-certificates \</span><br><span class="line">build-essential \</span><br><span class="line">libssl-dev \</span><br><span class="line">libclang-dev \</span><br><span class="line">pkg-config \</span><br><span class="line">openssl \</span><br><span class="line">protobuf-compiler \</span><br><span class="line">git \</span><br><span class="line">clang \</span><br><span class="line">cmake</span><br></pre></td></tr></table></figure>
<p>macos环境依赖安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装macos默认cli客户端，然后根据需要自行补充安装即可</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-编译节点文件-sui-sui-node">1.2 编译节点文件(sui、sui-node)</h3>
<p>默认我编译了这两个常用的，当然，还有别的比如:<code>validator</code>，根据自己需要，同样方式生成即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载源码</span></span><br><span class="line">git clone https://github.com/MystenLabs/sui.git</span><br><span class="line">cd sui</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要连接或者部署开发网节点，就一定要切换到指定分支，要不然会因为版本不一致而无法连接</span></span><br><span class="line">git checkout testnet </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译，其中sui相当于客户端，sui-node用于部署节点</span></span><br><span class="line">cargo build --release --bin sui</span><br><span class="line">cargo build --release --bin sui-node</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 交叉编译linux，其中sui相当于客户端，sui-node用于部署节点</span></span></span><br><span class="line">TARGET_CC=x86_64-unknown-linux-gnu-gcc  cargo build --release --bin sui --target x86_64-unknown-linux-gnu</span><br><span class="line">TARGET_CC=x86_64-unknown-linux-gnu-gcc  cargo build --release --bin sui-node --target x86_64-unknown-linux-gnu</span><br></pre></td></tr></table></figure>
<h3 id="1-3-编译索引器-sui-indexer">1.3 编译索引器(sui-indexer)</h3>
<p>这个用来加速节点的rpc访问速度，减轻node压力。没有索引器，部分rpc没法使用。建议使用，机器有限时，可部署在和节点相同的机器中。<br>
<code>sui-indexer的编译</code>，由于编译涉及到libpq命令行工具，因此需要在对应的系统上进行编译，不能交叉编译。</p>
<ol>
<li>安装数据库服务<code>postgresql</code>，用于存储索引数据。官方指定用这个数据库，但据我观察，用mysql等等也可以，没试过，有兴趣的可以自行尝试：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get -y install postgresql</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>安装<code>Diesel CLI</code>，rust的一个命令行工具，可以将表脚本等内容，导入到<code>postgresql</code>中，orm方式生成表等。说白了就是数据库脚本迁移工具。因为数据库脚本中有rust的代码，才让用该工具。<br>
需要安装libpcap支持</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ubuntu需要安装libpcap-dev</span></span><br><span class="line">sudo apt install libpq-dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">macos中</span></span><br><span class="line">brew install libpq</span><br><span class="line">export PATH=&quot;/usr/local/opt/libpq/bin:$PATH&quot; &gt;&gt; ~/.bash_profile</span><br><span class="line">export LDFLAGS=&quot;-L/usr/local/opt/libpq/lib&quot;</span><br><span class="line">export CPPFLAGS=&quot;-I/usr/local/opt/libpq/include&quot;</span><br></pre></td></tr></table></figure>
<p>安装diesel</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定postgres，减少安装没必要的依赖(否则mysql什么的都会要求你配置，执行会失败)</span></span><br><span class="line">cargo install diesel_cli --no-default-features --features postgres</span><br></pre></td></tr></table></figure>
<p>编译sui-indexer，由于编译涉及到libpq命令行工具，这个交叉编译会搞的很复杂，因此需要在对应的系统上编译sui-indexer</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo build --release --bin sui-indexer</span><br></pre></td></tr></table></figure>
<h2 id="3-部署开发网节点">3. 部署开发网节点</h2>
<p>sui-node可以用来配置<code>全节点</code>和<code>验证节点</code>，涉及到如下端口号：</p>
<table>
<thead>
<tr>
<th><strong>protocol/port</strong></th>
<th><strong>reachability</strong></th>
<th><strong>purpose</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>TCP/8080</strong></td>
<td>inbound</td>
<td>protocol/transaction interface</td>
</tr>
<tr>
<td><strong>UDP/8081</strong></td>
<td>inbound/outbound</td>
<td>narwhal primary interface</td>
</tr>
<tr>
<td><strong>UDP/8082</strong></td>
<td>inbound/outbound</td>
<td>narwhal primary interface</td>
</tr>
<tr>
<td><strong>TCP/8083</strong></td>
<td>localhost</td>
<td>sui -&gt; narwhal interface</td>
</tr>
<tr>
<td><strong>UDP/8084</strong></td>
<td>inbound/outbound</td>
<td>peer to peer state sync interface</td>
</tr>
<tr>
<td><strong>TCP/8443</strong></td>
<td>outbound</td>
<td>metrics pushing</td>
</tr>
<tr>
<td><strong>TCP/9184</strong></td>
<td>localhost</td>
<td>metrics scraping</td>
</tr>
</tbody>
</table>
<p>一般情况下，需要对外开放端口8080-8084，尤其验证节点，这些端口一定要开放</p>
<h3 id="3-1-全节点启动">3.1 全节点启动</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建目录</span></span><br><span class="line">cd ~</span><br><span class="line">mkdir bin</span><br><span class="line">cd bin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载开发网的创世文件</span></span><br><span class="line">curl -fLJO https://github.com/MystenLabs/sui-genesis/raw/main/devnet/genesis.blob</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在sui项目的根目录中执行如下</span></span><br><span class="line">cp crates/sui-config/data/fullnode-template.yaml fullnode.yaml</span><br><span class="line">mv ./fullnode.yaml ~/bin/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果有需要，修改fullnode.yaml。其实也没啥可配置的，默认就行，顶多改改文件路径或者端口号</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动同步节点</span></span><br><span class="line">cd ~/bin/</span><br><span class="line">./sui-node --config-path fullnode.yaml</span><br></pre></td></tr></table></figure>
<p>节点启动后，会自动进行同步，会有日志信息。日志的一些报错信息不用理会，同步文件不停的在增长，那就铁定一切正常了<br>
耐心等待同步，直到同步结束</p>
<h3 id="3-2-sui-indexer启动-可选">3.2 sui-indexer启动（可选）</h3>
<p>这个就是用来提高rpc的访问速度的，我个人理解，如果需要搞dapp等，频繁交互的话，就部署上这个。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建账户</span></span><br><span class="line">su - postgres</span><br><span class="line">psql</span><br><span class="line">CREATE USER sui WITH PASSWORD &#x27;sui123&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建库</span></span><br><span class="line">diesel setup --database-url=postgres://sui:sui123@localhost:5432/sui</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">迁移db脚本</span></span><br><span class="line">diesel migration run --database-url=postgres://sui:sui123@localhost:5432/sui</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行sui-indexer</span></span><br><span class="line">./sui-indexer --db-url &quot;postgres://sui:sui123@localhost:5432/sui&quot; --rpc-client-url &quot;http://0.0.0.0:9000&quot; --rpc-server-port 9102 --client-metric-port 9180</span><br></pre></td></tr></table></figure>
<h3 id="3-2-1-postgres常规操作">3.2.1. postgres常规操作</h3>
<p>\l --查看所有数据库<br>
\c dbname  --切换数据库<br>
\d --查看当前数据库下所有表<br>
\d test --查看test表定义</p>
<h3 id="3-3-检测节点是否正常同步">3.3 检测节点是否正常同步</h3>
<p>使用如下两种方式检测块高度来判断是否开始同步：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式1</span></span><br><span class="line">curl --location --request POST http://127.0.0.1:9000/ --header &#x27;Content-Type: application/json&#x27; --data-raw &#x27;&#123; &quot;jsonrpc&quot;:&quot;2.0&quot;, &quot;method&quot;:&quot;sui_getTotalTransactionBlocks&quot;,&quot;id&quot;:1&#125;&#x27;; echo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式2</span></span><br><span class="line">curl -q localhost:9184/metrics 2&gt;/dev/null |grep &#x27;^highest_synced_checkpoint&#x27;</span><br></pre></td></tr></table></figure>
<p>反复执行几次，高度若有变化，则说明节点正在正常同步</p>
<h3 id="3-3-1-第一种同步异常的处理方式">3.3.1 第一种同步异常的处理方式</h3>
<p>目前我发现一种情况的解决方式，节点日志提示：<code>Sending fatal alert BadCertificate</code>，并且高度不变，也就是同步异常，此时解决方式是，在<code>fullnode.yml</code>中，加入如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">p2p-config:</span><br><span class="line">  seed-peers:</span><br><span class="line">   - address: &quot;/dns/sui-rpc-pt.testnet-pride.com/udp/8084&quot;</span><br><span class="line">     peer-id: 0b10182585ae4a305721b1823ea5a9c3ce7d6ac4b4a8ce35fe96d9914c8fcb73</span><br><span class="line">   - address: &quot;/dns/sui-rpc-pt2.testnet-pride.com/udp/8084&quot;</span><br><span class="line">     peer-id: bf45f2bd2bbc4c2d53d10c05c96085d4ef18688af04649d6e65e1ebad1716804</span><br><span class="line">   - address: &quot;/dns/sui-rpc-testnet.bartestnet.com/udp/8084&quot;</span><br><span class="line">   - address: &quot;/ip4/38.242.197.20/udp/8080&quot;</span><br><span class="line">   - address: &quot;/ip4/178.18.250.62/udp/8080&quot;</span><br><span class="line">   - address: &quot;/ip4/162.55.84.47/udp/8084&quot;</span><br><span class="line">   - address: &quot;/dns/wave-3.testnet.n1stake.com/udp/8084&quot;</span><br></pre></td></tr></table></figure>
<p>该问题，其实就是无法访问到官方默认的节点，只好自己加入几个公开的别的节点来同步了</p>
<h3 id="3-4-性能指标">3.4 性能指标</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有指标</span></span><br><span class="line">curl -s http://localhost:9184/metrics</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索特定指标：</span></span><br><span class="line">curl http://localhost:9184/metrics | grep &lt;METRIC&gt;</span><br></pre></td></tr></table></figure>
<p>也可以在配置中加入如下内容，将实时指标信息发送到官方位置或者自定义位置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">metrics:</span></span><br><span class="line">  <span class="attr">push-interval-seconds:</span> <span class="number">60</span></span><br><span class="line">  <span class="attr">push-url:</span> <span class="string">https://metrics-proxy.testnet.sui.io:8443/publish/metrics</span></span><br></pre></td></tr></table></figure>
<p><a href="https://metrics.sui.io/public-dashboards/9b841d63c9bf43fe8acec4f0fa991f5e">官方测试网监控</a></p>
<h2 id="5-部署验证节点">5. 部署验证节点</h2>
<p>从我个人测试和文档阅读后的理解，验证节点其实就是在全节点的基础上的进一步配置，它拥有全节点的所有功能和数据，同时提供了验证功能。也就是说，部署验证节点，就没必要再去部署全节点。<br>
当前测试环境，验证节点如下规则：</p>
<ol>
<li>刚开始只能部署成候选人节点</li>
<li>当候选人节点质押达到3000万以上，就有机会成为验证人节点</li>
<li>成为验证人后，质押池需要维持在2000万以上，如果质押低于1500万，会被踢出去</li>
</ol>
<h3 id="5-1-部署过程">5.1 部署过程</h3>
<p>参考官方文档<a href="https://github.com/MystenLabs/sui/blob/main/nre/validator_tool.md">申请验证人</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成必要文件，此时会生成validator.info、</span></span><br><span class="line">sui validator --client.config client.yml make-validator-info &quot;name&quot; &quot;description&quot; &quot;image-url&quot; &quot;project-url&quot; &quot;host-name&quot; &quot;gas_price&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">申请候选人，需要足够的gas-budget，目前测试环境我发现需要设置至少50000000，根据返回提示，不够了就继续往上加</span></span><br><span class="line">sui validator --client.config client.yml become-candidate validator.info --gas-budget 50000000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">质押资金足够后，当前测试网需要3000万，执行申请加入验证集</span></span><br><span class="line">sui validator --client.config join-committee</span><br></pre></td></tr></table></figure>
<p>和前面的全节点部署方式类似，同样使用<code>sui-node</code>二进制文件<br>
配置文件为<code>validator.yml</code>，官方位置<a href="https://github.com/MystenLabs/sui/blob/main/nre/config/validator.yaml">validator</a>，也可从下载的源码的如下方式获取：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp nre/nre/config/validator.yaml validator.yaml</span><br><span class="line">mv ./fullnode.yaml ~/sui/validator/bin/</span><br></pre></td></tr></table></figure>
<p>我对默认的验证文件做了些改动，全部配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 下文讲解这4个key作用，以及如何生成</span></span><br><span class="line"><span class="attr">protocol-key-pair:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">./key-pairs/protocol.key</span></span><br><span class="line"><span class="attr">worker-key-pair:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">./key-pairs/worker.key</span></span><br><span class="line"><span class="attr">account-key-pair:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">./key-pairs/account.key</span></span><br><span class="line"><span class="attr">network-key-pair:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">./key-pairs/network.key</span></span><br><span class="line"><span class="attr">db-path:</span> <span class="string">./db/authorities_db</span></span><br><span class="line"><span class="attr">network-address:</span> <span class="string">/ip4/0.0.0.0/tcp/8080/http</span></span><br><span class="line"><span class="attr">json-rpc-address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:9000</span></span><br><span class="line"><span class="attr">metrics-address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:9184</span></span><br><span class="line"><span class="attr">admin-interface-port:</span> <span class="number">1337</span></span><br><span class="line"><span class="attr">consensus-config:</span></span><br><span class="line">  <span class="attr">address:</span> <span class="string">/ip4/127.0.0.1/tcp/8083/http</span></span><br><span class="line">  <span class="attr">db-path:</span> <span class="string">./db/consensus_db</span></span><br><span class="line">  <span class="attr">internal-worker-address:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">narwhal-config:</span></span><br><span class="line">    <span class="attr">header_num_of_batches_threshold:</span> <span class="number">32</span></span><br><span class="line">    <span class="attr">max_header_num_of_batches:</span> <span class="number">1000</span></span><br><span class="line">    <span class="attr">max_header_delay:</span> <span class="string">2000ms</span></span><br><span class="line">    <span class="attr">gc_depth:</span> <span class="number">50</span></span><br><span class="line">    <span class="attr">sync_retry_delay:</span> <span class="string">5000ms</span></span><br><span class="line">    <span class="attr">sync_retry_nodes:</span> <span class="number">3</span></span><br><span class="line">    <span class="attr">batch_size:</span> <span class="number">500000</span></span><br><span class="line">    <span class="attr">max_batch_delay:</span> <span class="string">100ms</span></span><br><span class="line">    <span class="attr">block_synchronizer:</span></span><br><span class="line">      <span class="attr">range_synchronize_timeout:</span> <span class="string">30000ms</span></span><br><span class="line">      <span class="attr">certificates_synchronize_timeout:</span> <span class="string">30000ms</span></span><br><span class="line">      <span class="attr">payload_synchronize_timeout:</span> <span class="string">30000ms</span></span><br><span class="line">      <span class="attr">payload_availability_timeout:</span> <span class="string">30000ms</span></span><br><span class="line">      <span class="attr">handler_certificate_deliver_timeout:</span> <span class="string">30000ms</span></span><br><span class="line">    <span class="attr">consensus_api_grpc:</span></span><br><span class="line">      <span class="attr">socket_addr:</span> <span class="string">/ip4/127.0.0.1/tcp/44579/http</span></span><br><span class="line">      <span class="attr">get_collections_timeout:</span> <span class="string">5000ms</span></span><br><span class="line">      <span class="attr">remove_collections_timeout:</span> <span class="string">5000ms</span></span><br><span class="line">    <span class="attr">max_concurrent_requests:</span> <span class="number">500000</span></span><br><span class="line">    <span class="attr">prometheus_metrics:</span></span><br><span class="line">      <span class="attr">socket_addr:</span> <span class="string">/ip4/127.0.0.1/tcp/33291/http</span></span><br><span class="line">    <span class="attr">network_admin_server:</span></span><br><span class="line">      <span class="attr">primary_network_admin_server_port:</span> <span class="number">41303</span></span><br><span class="line">      <span class="attr">worker_network_admin_server_base_port:</span> <span class="number">41669</span></span><br><span class="line"><span class="attr">enable-event-processing:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">p2p-config:</span></span><br><span class="line">  <span class="attr">listen-address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:8084</span></span><br><span class="line">  <span class="attr">external-address:</span> <span class="string">/dns/$HOSTNAME/udp/8084</span> <span class="comment"># UPDATE THIS</span></span><br><span class="line">  <span class="attr">anemo-config:</span></span><br><span class="line">    <span class="attr">max-concurrent-connections:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">seed-peers:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">address:</span> <span class="string">&quot;/dns/sui-rpc-pt.testnet-pride.com/udp/8084&quot;</span></span><br><span class="line">     <span class="attr">peer-id:</span> <span class="string">0b10182585ae4a305721b1823ea5a9c3ce7d6ac4b4a8ce35fe96d9914c8fcb73</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">address:</span> <span class="string">&quot;/dns/sui-rpc-pt2.testnet-pride.com/udp/8084&quot;</span></span><br><span class="line">     <span class="attr">peer-id:</span> <span class="string">bf45f2bd2bbc4c2d53d10c05c96085d4ef18688af04649d6e65e1ebad1716804</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">address:</span> <span class="string">&quot;/dns/sui-rpc-testnet.bartestnet.com/udp/8084&quot;</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">address:</span> <span class="string">&quot;/ip4/38.242.197.20/udp/8080&quot;</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">address:</span> <span class="string">&quot;/ip4/178.18.250.62/udp/8080&quot;</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">address:</span> <span class="string">&quot;/ip4/162.55.84.47/udp/8084&quot;</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">address:</span> <span class="string">&quot;/dns/wave-3.testnet.n1stake.com/udp/8084&quot;</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">genesis:</span></span><br><span class="line">  <span class="attr">genesis-file-location:</span> <span class="string">./config/genesis.blob</span></span><br><span class="line"><span class="attr">authority-store-pruning-config:</span></span><br><span class="line">  <span class="attr">num-latest-epoch-dbs-to-retain:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">epoch-db-pruning-period-secs:</span> <span class="number">3600</span></span><br><span class="line">  <span class="attr">num-epochs-to-retain:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">max-checkpoints-in-batch:</span> <span class="number">200</span></span><br><span class="line">  <span class="attr">max-transactions-in-batch:</span> <span class="number">1000</span></span><br><span class="line">  <span class="attr">use-range-deletion:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">end-of-epoch-broadcast-channel-capacity:</span> <span class="number">128</span></span><br><span class="line"><span class="attr">checkpoint-executor-config:</span></span><br><span class="line">  <span class="attr">checkpoint-execution-max-concurrency:</span> <span class="number">200</span></span><br><span class="line">  <span class="attr">local-execution-timeout-sec:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">db-checkpoint-config:</span></span><br><span class="line">  <span class="attr">perform-db-checkpoints-at-epoch-end:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">indirect-objects-threshold:</span> <span class="number">18446744073709551615</span></span><br><span class="line"><span class="comment"># 因为网络受限问题，我把这个注销掉了。它默认会把节点情况发送给官方的监控网站</span></span><br><span class="line"><span class="comment"># metrics:</span></span><br><span class="line"><span class="comment">#  push-interval-seconds: 60</span></span><br><span class="line"><span class="comment">#  push-url: https://metrics-proxy.testnet.sui.io:8443/publish/metrics</span></span><br></pre></td></tr></table></figure>
<p>启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./sui-node --config-path validator.yaml</span><br></pre></td></tr></table></figure>
<h3 id="5-2-生成key文件">5.2 生成key文件</h3>
<p>从上面<code>validator.yml</code>中可以看出，有4个key需要配置：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>key</strong></th>
<th style="text-align:center"><strong>scheme</strong></th>
<th style="text-align:center"><strong>purpose</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>protocol.key</strong></td>
<td style="text-align:center">bls12381</td>
<td style="text-align:center">transactions, narwhal consensus</td>
</tr>
<tr>
<td style="text-align:center"><strong>account.key</strong></td>
<td style="text-align:center">ed25519</td>
<td style="text-align:center">controls assets for staking</td>
</tr>
<tr>
<td style="text-align:center"><strong>network.key</strong></td>
<td style="text-align:center">ed25519</td>
<td style="text-align:center">narwhal primary, sui state sync</td>
</tr>
<tr>
<td style="text-align:center"><strong>worker.key</strong></td>
<td style="text-align:center">ed25519</td>
<td style="text-align:center">validate narwhal workers</td>
</tr>
</tbody>
</table>
<p>目前有两种方式生成这4个key，一个是使用官方命令行工具<code>sui</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成bls12381</span></span><br><span class="line">sui keytool generate bls12381</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成ed25519</span></span><br><span class="line">sui keytool generate ed25519</span><br></pre></td></tr></table></figure>
<p>其中ed25519就是sui钱包账户生成的标准方式，可以互通<br>
另一种方式是使用官方的命令行工具<code>validator</code>，可查阅<a href="https://github.com/MystenLabs/sui/blob/main/nre/validator_tool.md">官方文档</a>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">validator make-validator-info</span><br></pre></td></tr></table></figure>
<h2 id="6-区块链浏览器查询">6. 区块链浏览器查询</h2>
<p><a href="https://explorer.sui.io/">https://explorer.sui.io/</a></p>
<h2 id="7-总结">7. 总结</h2>
<p>本文编辑完毕</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Sui</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Sui</tag>
      </tags>
  </entry>
  <entry>
    <title>polkadot-apps的使用汇总</title>
    <url>/articles/ef694515/</url>
    <content><![CDATA[<p><a href="https://polkadot.js.org/apps">polkadot-app</a> 的细节比较多，这篇文章汇总记录一些常用的使用方式</p>
<span id="more"></span>  
<h2 id="1-安装">1. 安装</h2>
<p>参考：<br>
<a href="/articles/8aab1b7b">substrate基础(2)-polkadot-apps远端访问配置</a></p>
<h2 id="2-账户说明">2. 账户说明</h2>
<ol>
<li>助记词可以导出私钥，私钥可以恢复账户</li>
<li>keystore生的的私钥，和助记词生成的私钥不一样。无法用该私钥正常恢复账户。需要完整的keystore</li>
</ol>
<h2 id="2-查询">2. 查询</h2>
<ol>
<li>同一个私钥，在不同的平行链中，会显示出不同的地址，这是因为地址生成用到的<code>ss58Prefix</code>不一样，具体可以在apps的这里查看：<br>
<code>开发者-链状态-常数-选system-选ss58Prefix</code>，查询即可获取值</li>
</ol>
<h2 id="总结">总结</h2>
<p>本文编辑中</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Substrate</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Substrate</tag>
      </tags>
  </entry>
  <entry>
    <title>MacOS中Rust交叉编译</title>
    <url>/articles/a6749ab9/</url>
    <content><![CDATA[<p>别的环境可以参考macos的交叉编译方式来实现</p>
<span id="more"></span>  
<h2 id="1-简介">1. 简介</h2>
<ol>
<li>命令行下，国内需要设置下科学上网：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export https_proxy=http://127.0.0.1:1087 http_proxy=http://127.0.0.1:1087 all_proxy=socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>目前macos交叉编译rust，一般使用如下两种方式：
<ol>
<li>x86_64-unknown-linux-gnu  更快、生成动态链接库，依赖所在平台安装glibc，<code>实践证明，macos建议使用该方式</code></li>
<li>x86_64-unknown-linux-musl 轻量、无依赖，能运行在任何linux系统。缺点是编译后程序比glibc慢点。<code>实践发现，macos中编译librocksdb-sys会发现很多问题，还是用gnu方式更好点</code></li>
</ol>
</li>
</ol>
<h2 id="2-使用x86-64-unknown-linux-gnu">2. 使用x86_64-unknown-linux-gnu</h2>
<p>macos建议使用该方式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装target</span></span><br><span class="line">rustup target add x86_64-unknown-linux-gnu</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装链接器</span></span><br><span class="line">brew install SergioBenitez/osxct/x86_64-unknown-linux-gnu</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bin链接 根据需要，看是否需要从/usr/local/bin/中<span class="built_in">ln</span>，一般需要x86_64-linux-gnu-g++：</span></span><br><span class="line">ln -s /usr/local/bin/x86_64-unknown-linux-gnu-g++ /usr/local/bin/x86_64-linux-gnu-g++</span><br><span class="line">ln -s /usr/local/bin/x86_64-unknown-linux-gnu-gcc /usr/local/bin/x86_64-linux-gnu-gcc</span><br></pre></td></tr></table></figure>
<p>之后，在<code>./cargo/config.toml</code>中，加入如下内容：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[target.x86_64-unknown-linux-gnu]</span></span><br><span class="line"><span class="attr">linker</span> = <span class="string">&quot;x86_64-unknown-linux-gnu-gcc&quot;</span></span><br></pre></td></tr></table></figure>
<p>之后就可以常规编译项目路：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo build --release --target x86_64-unknown-linux-gnu</span><br></pre></td></tr></table></figure>
<p>如果要是你的程序依赖原生库，需要设置一个环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">TARGET_CC=x86_64-linux-gnu-gcc cargo build --release --target x86_64-unknown-linux-gnu</span><br></pre></td></tr></table></figure>
<h2 id="3-使用x86-64-unknown-linux-musl">3. 使用x86_64-unknown-linux-musl</h2>
<p>macos如果非必要，不建议使用该方式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装target</span></span><br><span class="line">rustup target add x86_64-unknown-linux-musl</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装链接器</span></span><br><span class="line">brew install filosottile/musl-cross/musl-cross</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bin链接  根据需要，从/usr/local/bin/中<span class="built_in">ln</span>，一般需要musl-g++</span></span><br><span class="line">ln -s /usr/local/bin/x86_64-linux-musl-g++ /usr/local/bin/musl-g++</span><br><span class="line">ln -s /usr/local/bin/x86_64-linux-musl-gcc /usr/local/bin/musl-gcc</span><br></pre></td></tr></table></figure>
<p>之后，在<code>./cargo/config.toml</code>中，加入如下内容：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[target.x86_64-unknown-linux-musl]</span></span><br><span class="line"><span class="attr">linker</span> = <span class="string">&quot;x86_64-linux-musl-gcc&quot;</span></span><br></pre></td></tr></table></figure>
<p>之后就可以常规编译项目路：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo build --release --target x86_64-unknown-linux-musl</span><br></pre></td></tr></table></figure>
<p>如果要是你的程序依赖原生库，需要设置一个环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">TARGET_CC=x86_64-linux-musl-gcc cargo build --release --target x86_64-unknown-linux-musl</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>编辑完毕</p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust</category>
      </categories>
      <tags>
        <tag>rust</tag>
        <tag>开发语言</tag>
      </tags>
  </entry>
  <entry>
    <title>sui基础(3)-sui常用RPC记录</title>
    <url>/articles/abfd4559/</url>
    <content><![CDATA[<p>sui 常用的rpc</p>
<span id="more"></span>  
<h2 id="1-说明">1. 说明</h2>
<p>目前官方节点地址：<a href="https://fullnode.devnet.sui.io:443">https://fullnode.devnet.sui.io:443</a></p>
<h2 id="2-发现">2. 发现</h2>
<p>一次性扫描并返回sui所有rpc方法等信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --location --request POST https://fullnode.devnet.sui.io:443 \</span><br><span class="line">--header &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">--data-raw &#x27;&#123; &quot;jsonrpc&quot;:&quot;2.0&quot;, &quot;method&quot;:&quot;rpc.discover&quot;,&quot;id&quot;:1&#125;&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="3-完成一笔交易">3. 完成一笔交易</h2>
<p>创建未签名交易-签名-提交-完成交易</p>
<h3 id="3-1-创建一个未签名的交易-将coin从一个地址转移到另一个地址">3.1 创建一个未签名的交易，将coin从一个地址转移到另一个地址</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --location --request POST $SUI_RPC_HOST \</span><br><span class="line">--header &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">--data-raw &#x27;&#123;</span><br><span class="line">  &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">  &quot;id&quot;: 1,</span><br><span class="line">  &quot;method&quot;: &quot;sui_transferObject&quot;,</span><br><span class="line">  &quot;params&quot;:[</span><br><span class="line">    &quot;&#123;&#123;owner_address&#125;&#125;&quot;,</span><br><span class="line">    &quot;&#123;&#123;object_id&#125;&#125;&quot;,</span><br><span class="line">    &quot;&#123;&#123;gas_object_id&#125;&#125;&quot;,</span><br><span class="line">    &#123;&#123;gas_budget&#125;&#125;,</span><br><span class="line">    &quot;&#123;&#123;to_address&#125;&#125;&quot;],</span><br><span class="line">&#125;&#x27; | json_pp</span><br></pre></td></tr></table></figure>
<p>返回结果如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;jsonrpc&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;result&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tx_bytes&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;VHJhbnNhY3Rpb25EYXRhOjoAAFHe8jecgzoGWyGlZ1sJ2KBFN8aZF7NIkDsM+3X8mrVCa7adg9HnVqUBAAAAAAAAACDOlrjlT0A18D0DqJLTU28ChUfRFtgHprmuOGCHYdv8YVHe8jecgzoGWyGlZ1sJ2KBFN8aZdZnY6h3kyWFtB38Wyg6zjN7KzAcBAAAAAAAAACDxI+LSHrFUxU0G8bPMXhF+46hpchJ22IHlpPv4FgNvGOgDAAAAAAAA=&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>签名交易，获取签名结果</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sui keytool sign --address &lt;owner_address&gt; --data &lt;tx_bytes&gt;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>rpc提交，完成交易</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --location --request POST $SUI_RPC_HOST \</span><br><span class="line">--header &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">--data-raw &#x27;&#123;</span><br><span class="line">  &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">  &quot;id&quot;: 1,</span><br><span class="line">  &quot;method&quot;: &quot;sui_executeTransactionSerializedSig&quot;,</span><br><span class="line">  &quot;params&quot;: [</span><br><span class="line">    &quot;&#123;&#123;tx_bytes&#125;&#125;&quot;,</span><br><span class="line">    &quot;&#123;&#123;signature&#125;&#125;&quot;,</span><br><span class="line">    &quot;&#123;&#123;request_type&#125;&#125;&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;&#x27; | json_pp</span><br></pre></td></tr></table></figure>
<h2 id="3-总结">3. 总结</h2>
<p>本文编辑完毕</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Sui</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Sui</tag>
      </tags>
  </entry>
  <entry>
    <title>sui基础(2)-sui命令行工具</title>
    <url>/articles/9274b609/</url>
    <content><![CDATA[<p>sui 命令行工具的常用命令汇总</p>
<span id="more"></span>  
<h2 id="1-综合">1. 综合</h2>
<p>主要是作为客户端连接网络节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本地第一次执行，会引导创建客户端网络信息</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成客户端配置，用来和网络节点（如测试网）连接会默认产生yml，提供节点地址</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开发网：https://fullnode.devnet.sui.io:443</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试网：https://fullnode.testnet.sui.io:443</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认位置：/Users/ld/.sui/sui_config/client.yaml</span></span><br><span class="line">sui client</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自定义配置位置</span></span><br><span class="line">sui client --client.config ~/sui/bin/validator/client/client.yml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">快速配置，会快速生成客户端配置、账户以及节点等信息，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里我们需要用到的是客户端配置以及账户</span></span><br><span class="line">sui genesis</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">读取默认账户</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若是自定义配置，必须在client之后加上--client.config</span> </span><br><span class="line">sui client active-address</span><br><span class="line">sui client --client.config ~/sui/bin/validator/client/client.yml active-address</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看网络配置，有哪几种网络</span></span><br><span class="line">sui client envs</span><br><span class="line">sui client --client.config ~/sui/bin/validator/client/client.yml envs</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换网络</span></span><br><span class="line">sui client switch --env 网络名称(envs中提供)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加一个新的网络</span></span><br><span class="line">sui client new-env --alias &lt;ALIAS&gt; --rpc &lt;RPC&gt;</span><br></pre></td></tr></table></figure>
<h2 id="2-常用命令">2. 常用命令</h2>
<ol>
<li>交互式命令入口</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">交互式控制台方式，同样可以连接网络</span></span><br><span class="line">sui console</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认配置在/Users/ld/.sui/sui_config/client.yaml，可以使用如下方式覆盖默认配置</span></span><br><span class="line">sui console --client.config /workspace/config-files</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>查看地址列表</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sui client addresses</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>查看当前默认账户</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sui client active-address</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>切换默认地址</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sui client switch --address  xxx</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>查看gas</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看默认账户的gas</span></span><br><span class="line">sui client gas</span><br><span class="line">sui client --client.config ~/sui/bin/validator/client/client.yml gas</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看指定账户的gas</span></span><br><span class="line">sui client gas 地址</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>生成地址<br>
24个单词的助记词<br>
可选择：ed25519、secp256k1、secp256r1</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sui client new-address Secp256k1</span><br></pre></td></tr></table></figure>
<p>可以手动编辑client.yaml，将已存在的账户加入到其中<br>
7. 查看账户拥有的对象</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认账户查看</span></span><br><span class="line">sui client objects</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定账户查看</span></span><br><span class="line">sui client objects 地址</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>查看一个对象的详细信息</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sui client object &lt;ID&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用json格式查看</span></span><br><span class="line">sui client object &lt;ID&gt; --json</span><br></pre></td></tr></table></figure>
<ol start="9">
<li>将当前账户的一个对象转移给另一个账户</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gas-budget 是gas上限</span></span><br><span class="line">sui client transfer --to 接收地址 --object-id 当前对象号 --gas-budget 1000</span><br></pre></td></tr></table></figure>
<ol start="10">
<li>创建一个nft</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建默认nft</span></span><br><span class="line">sui client create-example-nft</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自定义创建nft</span></span><br><span class="line">sui client create-example-nft --url=https://user-images.githubusercontent.com/76067158/166136286-c60fe70e-b982-4813-932a-0414d0f55cfb.png --description=&quot;The greatest chef in the world&quot; --name=&quot;Greatest Chef&quot;</span><br></pre></td></tr></table></figure>
<h2 id="3-coin的合并与拆分">3. Coin的合并与拆分</h2>
<ol>
<li>合并Coin，至少需要3个Object，其中两个用来合并，另一个用来支付gas</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看指定账户拥有哪些对象</span></span><br><span class="line">sui client objects 账户地址</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">合并coin</span></span><br><span class="line">sui client merge-coin --primary-coin 第一个object --coin-to-merge 第二个object --gas-budget gas预算值(猜测：会根据值选一个合适的Object拆分来支付gas，或者合并多个小Object来支付gas)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">合并示例：</span></span><br><span class="line">sui client merge-coin --primary-coin 0x33e3e1d64f76b71a80ec4f332f4d1a6742c537f2bb32473b01b1dcb1caac9427 --coin-to-merge 0x11af4b844ff94b3fbef6e36b518da3ad4c5856fa686464524a876b463d129760 --gas-budget 1000</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>拆分Coin，至少需要2个Object，一个用来拆分，另一个用来支付gas</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同样先查看指定账户拥有哪些对象</span></span><br><span class="line">sui client objects 账户地址</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拆分coin</span></span><br><span class="line">sui client split-coin --coin-id 要拆分的Object --amounts 拆分值1 拆分值2 拆分值3 --gas-budget gas预算值</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">合并示例：</span></span><br><span class="line">sui client split-coin --coin-id 0x11af4b844ff94b3fbef6e36b518da3ad4c5856fa686464524a876b463d129760 --amounts 1000 5000 3000 --gas-budget 1000</span><br></pre></td></tr></table></figure>
<h2 id="4-genesis自定义初始化配置">4. genesis自定义初始化配置</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sui genesis --config 自定义配置路径</span><br></pre></td></tr></table></figure>
<p>自定义配置模板如下<code>gensis.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">validator_config_info:</span> <span class="string">~</span></span><br><span class="line"><span class="attr">committee_size:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">accounts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">gas_objects:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">object_id:</span> <span class="string">&quot;0x33e3e1d64f76b71a80ec4f332f4d1a6742c537f2bb32473b01b1dcb1caac9427&quot;</span></span><br><span class="line">        <span class="attr">gas_value:</span> <span class="number">100000</span></span><br><span class="line">    <span class="attr">gas_object_ranges:</span> []</span><br><span class="line"><span class="attr">move_packages:</span> [<span class="string">&quot;&lt;Paths to custom move packages&gt;&quot;</span>]</span><br><span class="line"><span class="attr">sui_framework_lib_path:</span> <span class="string">~</span></span><br><span class="line"><span class="attr">move_framework_lib_path:</span> <span class="string">~</span></span><br></pre></td></tr></table></figure>
<h2 id="5-账户规则">5. 账户规则</h2>
<ol>
<li>默认生成的keystore中，是一个私钥base64的集合列表</li>
<li>使用<code>sui keytool generate ed25519</code>生成的<code>xxx.key</code>其中是一个base64密钥</li>
<li>使用<code>sui keytool unpack base64私钥</code>可解析成成一个账户文件<code>xxx.key</code>，其中包含地址、keypair、key scheme等信息</li>
</ol>
<h2 id="3-总结">3. 总结</h2>
<p>本文编辑完毕</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Sui</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Sui</tag>
      </tags>
  </entry>
  <entry>
    <title>sui基础(1)-开发网连接和部署</title>
    <url>/articles/24d64513/</url>
    <content><![CDATA[<p>本地编译好的命令行，连接开发网、部署全节点。<br>
开发网不支持部署验证节点，该过程由官方提供的4个验证节点来维护</p>
<span id="more"></span>
<h2 id="1-编译">1. 编译</h2>
<p>Macos交叉编译配置参考：<a href="/articles/a6749ab9">MacOS中Rust交叉编译</a><br>
ubuntu 20.04环境依赖安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">依赖安装</span></span><br><span class="line">sudo apt-get update \</span><br><span class="line">&amp;&amp; sudo apt-get install -y --no-install-recommends \</span><br><span class="line">tzdata \</span><br><span class="line">libprotobuf-dev \</span><br><span class="line">ca-certificates \</span><br><span class="line">build-essential \</span><br><span class="line">libssl-dev \</span><br><span class="line">libclang-dev \</span><br><span class="line">pkg-config \</span><br><span class="line">openssl \</span><br><span class="line">protobuf-compiler \</span><br><span class="line">git \</span><br><span class="line">clang \</span><br><span class="line">cmake</span><br></pre></td></tr></table></figure>
<p>编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载源码</span></span><br><span class="line">git clone https://github.com/MystenLabs/sui.git</span><br><span class="line">cd sui</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要连接或者部署开发网节点，就一定要切换到指定分支，要不然会因为版本不一致而无法连接</span></span><br><span class="line">git checkout devnet </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sui命令行客户端 通用工具编译</span></span><br><span class="line">cargo build --release --bin sui</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 交叉编译linux</span></span></span><br><span class="line">TARGET_CC=x86_64-unknown-linux-gnu-gcc  cargo build --release --bin sui-node --target x86_64-unknown-linux-gnu</span><br><span class="line">TARGET_CC=x86_64-unknown-linux-gnu-gcc  cargo build --release --bin sui --target x86_64-unknown-linux-gnu</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sui-node 节点编译</span></span><br><span class="line">cargo build --release --bin-node sui</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 交叉编译linux</span></span></span><br><span class="line">TARGET_CC=x86_64-unknown-linux-gnu-gcc  cargo build --release --bin-node sui --target x86_64-unknown-linux-gnu</span><br></pre></td></tr></table></figure>
<h2 id="2-sui客户端连接开发网">2. sui客户端连接开发网</h2>
<p>进编译好的<code>target/release</code>中，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本地第一次执行，会引导创建客户端网络信息</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成客户端配置，用来和网络节点（如测试网）连接会默认产生yml，提供节点地址</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开发网：https://fullnode.devnet.sui.io:443</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认位置：/Users/ld/.sui/sui_config/client.yaml</span></span><br><span class="line">sui client</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">快速配置，会快速生成客户端配置、账户以及节点等信息，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里我们需要用到的是客户端配置以及账户</span></span><br><span class="line">sui genesis</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">读取默认账户</span></span><br><span class="line">sui client active-address</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看网络配置，有哪几种网络</span></span><br><span class="line">sui client envs</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换网络</span></span><br><span class="line">sui client switch --env 网络名称(envs中提供)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加一个新的网络</span></span><br><span class="line">sui client new-env --alias &lt;ALIAS&gt; --rpc &lt;RPC&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-客户端应用">2.1 客户端应用</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建nft</span></span><br><span class="line">./sui client create-example-nft</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自定义创建nft</span></span><br><span class="line">sui client create-example-nft --url=https://user-images.githubusercontent.com/76067158/166136286-c60fe70e-b982-4813-932a-0414d0f55cfb.png --description=&quot;The greatest chef in the world&quot; --name=&quot;Greatest Chef&quot;</span><br></pre></td></tr></table></figure>
<h2 id="3-部署开发网节点">3. 部署开发网节点</h2>
<p>sui-node可以用来配置<code>全节点</code>和<code>验证节点</code>，涉及到如下端口号：</p>
<table>
<thead>
<tr>
<th><strong>protocol/port</strong></th>
<th><strong>reachability</strong></th>
<th><strong>purpose</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>TCP/8080</strong></td>
<td>inbound</td>
<td>protocol/transaction interface</td>
</tr>
<tr>
<td><strong>UDP/8081</strong></td>
<td>inbound/outbound</td>
<td>narwhal primary interface</td>
</tr>
<tr>
<td><strong>UDP/8082</strong></td>
<td>inbound/outbound</td>
<td>narwhal primary interface</td>
</tr>
<tr>
<td><strong>TCP/8083</strong></td>
<td>localhost</td>
<td>sui -&gt; narwhal interface</td>
</tr>
<tr>
<td><strong>UDP/8084</strong></td>
<td>inbound/outbound</td>
<td>peer to peer state sync interface</td>
</tr>
<tr>
<td><strong>TCP/8443</strong></td>
<td>outbound</td>
<td>metrics pushing</td>
</tr>
<tr>
<td><strong>TCP/9184</strong></td>
<td>localhost</td>
<td>metrics scraping</td>
</tr>
</tbody>
</table>
<p>一般情况下，需要对外开放端口8080-8084，尤其验证节点，这些端口一定要开放<br>
开发网中，官方默认提供了4个验证节点，开发网中，用户无法自行部署验证节点</p>
<p>目前开发网只能部署全节点，全节点可以用来rpc调用等等，获取数据会方便很多</p>
<h3 id="3-1-全节点启动">3.1 全节点启动</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建目录</span></span><br><span class="line">cd ~</span><br><span class="line">mkdir bin</span><br><span class="line">cd bin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载开发网的创世文件</span></span><br><span class="line">curl -fLJO https://github.com/MystenLabs/sui-genesis/raw/main/devnet/genesis.blob</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在sui项目的根目录中执行如下</span></span><br><span class="line">cp crates/sui-config/data/fullnode-template.yaml fullnode.yaml</span><br><span class="line">mv ./fullnode.yaml ~/bin/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果有需要，修改fullnode.yaml。其实也没啥可配置的，默认就行，顶多改改文件路径或者端口号</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动同步节点</span></span><br><span class="line">cd ~/bin/</span><br><span class="line">./sui-node --config-path fullnode.yaml</span><br></pre></td></tr></table></figure>
<p>节点启动后，会自动进行同步，会有如下日志信息，刚开始我以为是同步失败了，但发现，节点文件正在越变越大，那就耐心等着就行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2023-03-23T02:54:36.559288Z  INFO sui_node: Sui Node version: 0.27.1-157ac7203</span><br><span class="line">2023-03-23T02:54:36.559315Z  INFO sui_node: Supported protocol versions: Some(SupportedProtocolVersions &#123; min: ProtocolVersion(1), max: ProtocolVersion(1) &#125;)</span><br><span class="line">2023-03-23T02:54:36.559329Z  INFO sui_node: Started Prometheus HTTP endpoint at 0.0.0.0:9184</span><br><span class="line">2023-03-23T02:54:36.559390Z  INFO sui_node::admin: starting admin server filter=info address=127.0.0.1:1337</span><br><span class="line">2023-03-23T02:54:36.559430Z  INFO sui_node: Initializing sui-node listening on /dns/localhost/tcp/8080/http node=k#a84a1626b846e996c30145ffd0e26dd2c246f8dc7ca24279442341fac1b8024126db429fa4c5a7a466ca3f1989c6790712c5afa60a92d5c80bdec326d0b23626a123acc217fda5a35bc72c933db84fd84cc42d6cd1c553abdf09159327e19c93</span><br><span class="line">2023-03-23T02:54:37.579203Z  INFO sui_core::authority::authority_store_pruner: Starting object pruning service with num_versions_to_retain=5    </span><br><span class="line">2023-03-23T02:54:39.021935Z  INFO sui_storage::event_store::sql: Created/opened SQLite EventStore on disk db_path=&quot;suidb/events.db&quot;</span><br><span class="line">2023-03-23T02:54:39.022091Z  INFO sui_storage::event_store::sql: SQLite events table is initialized with query &quot;CREATE TABLE IF NOT EXISTS events(timestamp INTEGER NOT NULL, seq_num INTEGER, event_num INTEGER, tx_digest BLOB, event_type INTEGER, package_id BLOB, module_name TEXT, function TEXT, object_type TEXT, object_id BLOB, fields TEXT, move_event_name TEXT, contents BLOB, sender BLOB, recipient TEXT);&quot;</span><br><span class="line">2023-03-23T02:54:39.022635Z  INFO sui_storage::event_store::sql: Index is ready column=&quot;seq_num&quot;</span><br><span class="line">2023-03-23T02:54:39.022745Z  INFO sui_storage::event_store::sql: Index is ready column=&quot;event_num&quot;</span><br><span class="line">2023-03-23T02:54:39.022821Z  INFO sui_storage::event_store::sql: Index is ready column=&quot;timestamp&quot;</span><br><span class="line">2023-03-23T02:54:39.022916Z  INFO sui_storage::event_store::sql: Index is ready column=&quot;tx_digest&quot;</span><br><span class="line">2023-03-23T02:54:39.023002Z  INFO sui_storage::event_store::sql: Index is ready column=&quot;event_type&quot;</span><br><span class="line">2023-03-23T02:54:39.023108Z  INFO sui_storage::event_store::sql: Index is ready column=&quot;package_id&quot;</span><br><span class="line">2023-03-23T02:54:39.023188Z  INFO sui_storage::event_store::sql: Index is ready column=&quot;module_name&quot;</span><br><span class="line">2023-03-23T02:54:39.023267Z  INFO sui_storage::event_store::sql: Index is ready column=&quot;sender&quot;</span><br><span class="line">2023-03-23T02:54:39.023348Z  INFO sui_storage::event_store::sql: Index is ready column=&quot;recipient&quot;</span><br><span class="line">2023-03-23T02:54:39.023410Z  INFO sui_storage::event_store::sql: Index is ready column=&quot;object_id&quot;</span><br><span class="line">2023-03-23T02:54:39.023487Z  INFO sui_storage::event_store::sql: Index is ready column=&quot;object_type&quot;</span><br><span class="line">2023-03-23T02:54:39.023569Z  INFO sui_storage::event_store::sql: Index is ready column=&quot;move_event_name&quot;</span><br><span class="line">2023-03-23T02:54:39.024385Z  INFO sui_node: P2p network started on 0.0.0.0:8080</span><br><span class="line">2023-03-23T02:54:39.024425Z  INFO sui_core::authority: current protocol version is now ProtocolVersion(1)</span><br><span class="line">2023-03-23T02:54:39.024432Z  INFO sui_core::authority: supported versions are: SupportedProtocolVersions &#123; min: ProtocolVersion(1), max: ProtocolVersion(1) &#125;</span><br><span class="line">2023-03-23T02:54:39.024433Z  INFO sui_network::discovery: Discovery started</span><br><span class="line">2023-03-23T02:54:39.024442Z  INFO sui_network::state_sync: State-Synchronizer started</span><br><span class="line">2023-03-23T02:54:39.024445Z  INFO narwhal_network::connectivity: Spawning future narwhal/network/src/connectivity.rs:ConnectionMonitor</span><br><span class="line">2023-03-23T02:54:39.024448Z  INFO connection-manager&#123;peer=17f9e4fb&#125;: anemo::network::connection_manager: ConnectionManager started</span><br><span class="line">2023-03-23T02:54:39.025748Z  INFO sui_storage::event_store::sql: Running SQLite WAL truncation...</span><br><span class="line">2023-03-23T02:54:39.025764Z  INFO sui_storage::event_store::sql: Acquired query_lock for write after 20.552µs</span><br><span class="line">2023-03-23T02:54:39.028451Z  INFO sui_core::execution_driver: Starting pending certificates execution process.</span><br><span class="line">2023-03-23T02:54:39.028502Z  INFO sui_core::authority::authority_per_epoch_store_pruner: Starting pruning of epoch tables    </span><br><span class="line">2023-03-23T02:54:39.028620Z  INFO sui_core::authority::authority_per_epoch_store_pruner: Finished pruning old epoch databases. Pruned 0 dbs    </span><br><span class="line">2023-03-23T02:54:39.031022Z  INFO sui_storage::event_store::sql: force_wal_truncation result: SqliteQueryResult &#123; changes: 0, last_insert_rowid: 0 &#125;</span><br><span class="line">2023-03-23T02:54:39.031032Z  INFO sui_storage::event_store::sql: SQLite WAL truncation finished</span><br><span class="line">2023-03-23T02:54:39.112452Z  INFO sui_json_rpc: acl=Const(&quot;*&quot;)</span><br><span class="line">2023-03-23T02:54:39.112672Z  INFO sui_json_rpc: Sui JSON-RPC server listening on 0.0.0.0:9000 local_addr=0.0.0.0:9000</span><br><span class="line">2023-03-23T02:54:39.112681Z  INFO sui_json_rpc: Available JSON-RPC methods : [&quot;sui_moveCall&quot;, &quot;sui_getCoinMetadata&quot;, &quot;sui_getDynamicFieldObject&quot;, &quot;sui_getObjectsOwnedByAddress&quot;, &quot;sui_getCheckpointContentsByDigest&quot;, &quot;sui_transferObject&quot;, &quot;sui_payAllSui&quot;, &quot;sui_getCommitteeInfo&quot;, &quot;sui_unsubscribeEvent&quot;, &quot;sui_tblsSignRandomnessObject&quot;, &quot;sui_getCheckpointContents&quot;, &quot;sui_mergeCoins&quot;, &quot;sui_executeTransaction&quot;, &quot;sui_getCheckpointSummaryByDigest&quot;, &quot;sui_getEvents&quot;, &quot;sui_getObject&quot;, &quot;sui_getTransactionsInRange&quot;, &quot;sui_getCoins&quot;, &quot;sui_executeTransactionSerializedSig&quot;, &quot;sui_getSuiSystemState&quot;, &quot;sui_getAllBalances&quot;, &quot;sui_paySui&quot;, &quot;sui_subscribeEvent&quot;, &quot;sui_getDynamicFields&quot;, &quot;sui_getRawObject&quot;, &quot;sui_splitCoin&quot;, &quot;sui_getNormalizedMoveFunction&quot;, &quot;sui_getReferenceGasPrice&quot;, &quot;sui_submitTransaction&quot;, &quot;sui_getTransaction&quot;, &quot;sui_requestWithdrawDelegation&quot;, &quot;sui_getLatestCheckpointSequenceNumber&quot;, &quot;sui_getTotalTransactionNumber&quot;, &quot;sui_getBalance&quot;, &quot;sui_devInspectTransaction&quot;, &quot;sui_getTransactionAuthSigners&quot;, &quot;sui_getMoveFunctionArgTypes&quot;, &quot;sui_getCheckpointSummary&quot;, &quot;sui_pay&quot;, &quot;sui_requestAddDelegation&quot;, &quot;sui_transferSui&quot;, &quot;sui_batchTransaction&quot;, &quot;sui_dryRunTransaction&quot;, &quot;sui_getDelegatedStakes&quot;, &quot;sui_splitCoinEqual&quot;, &quot;sui_getValidators&quot;, &quot;sui_getNormalizedMoveModule&quot;, &quot;sui_getAllCoins&quot;, &quot;sui_getTotalSupply&quot;, &quot;sui_requestSwitchDelegation&quot;, &quot;sui_getNormalizedMoveModulesByPackage&quot;, &quot;sui_tryGetPastObject&quot;, &quot;rpc.discover&quot;, &quot;sui_getTransactions&quot;, &quot;sui_getNormalizedMoveStruct&quot;, &quot;sui_publish&quot;]</span><br><span class="line">2023-03-23T02:54:39.112719Z  INFO sui_node: SuiNode started!</span><br><span class="line">2023-03-23T02:54:39.871650Z  WARN request&#123;route=/sui.Discovery/GetKnownPeers remote_peer_id=5c32e280 direction=outbound&#125;: anemo_tower::trace::on_failure: response failed error=Error: connection lost latency=0 ms</span><br><span class="line">2023-03-23T02:54:39.872188Z  WARN request&#123;route=/sui.StateSync/GetCheckpointSummary remote_peer_id=5c32e280 direction=outbound&#125;: anemo_tower::trace::on_failure: response failed error=Error: closed latency=0 ms</span><br><span class="line">2023-03-23T02:54:39.872420Z  WARN request&#123;route=/sui.Discovery/GetKnownPeers remote_peer_id=3ed98f54 direction=outbound&#125;: anemo_tower::trace::on_failure: response failed error=Error: connection lost latency=16 ms</span><br><span class="line">2023-03-23T02:54:39.872518Z  WARN request&#123;route=/sui.StateSync/GetCheckpointSummary remote_peer_id=3ed98f54 direction=outbound&#125;: anemo_tower::trace::on_failure: response failed error=Error: connection lost latency=16 ms</span><br><span class="line">2023-03-23T02:54:40.465267Z  WARN request&#123;route=/sui.StateSync/GetCheckpointSummary remote_peer_id=bb3db619 direction=outbound&#125;: anemo_tower::trace::on_failure: response failed error=Error: connection lost latency=305 ms</span><br><span class="line">2023-03-23T02:54:40.465267Z  WARN request&#123;route=/sui.Discovery/GetKnownPeers remote_peer_id=bb3db619 direction=outbound&#125;: anemo_tower::trace::on_failure: response failed error=Error: connection lost latency=609 ms</span><br><span class="line">2023-03-23T02:55:26.495975Z  INFO execute_checkpoint&#123;seq=3670 epoch=1&#125;: sui_core::authority::authority_per_epoch_store: transaction write conflict detected, sleeping delay=41ms retries=1</span><br><span class="line">2023-03-23T03:04:39.238043Z  INFO execute_checkpoint&#123;seq=8364 epoch=1&#125;: sui_core::authority::authority_per_epoch_store: transaction write conflict detected, sleeping delay=29ms retries=1</span><br></pre></td></tr></table></figure>
<p>等待同步，直到同步结束</p>
<h3 id="2-2-区块链浏览器查询">2.2 区块链浏览器查询</h3>
<p><a href="https://explorer.sui.io/">https://explorer.sui.io/</a></p>
<h2 id="5-总结">5. 总结</h2>
<p>本文编辑完毕</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Sui</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Sui</tag>
      </tags>
  </entry>
  <entry>
    <title>solidity教程(2)-高级</title>
    <url>/articles/3f51919a/</url>
    <content><![CDATA[<p>solidity教程-高级，基于<code>8.0</code>版本</p>
<span id="more"></span>
<h2 id="1-概述">1. 概述</h2>
<ol>
<li>私有变量比公开变量节省gas</li>
</ol>
<h2 id="2-两个合约之间的调用">2. 两个合约之间的调用</h2>
<h3 id="2-1-一个项目中两个合约通过引用实现">2.1 一个项目中两个合约通过引用实现</h3>
<p>两个合约各自发布，然后通过地址调用不同合约，下方是<code>CallTestContract</code>调用<code>TestContract</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.3;</span><br><span class="line"></span><br><span class="line">contract CallTestContract&#123;</span><br><span class="line">    function setX(TestContract _test,uint _x) external&#123;</span><br><span class="line">        _test.setX(_x);</span><br><span class="line">    &#125;</span><br><span class="line">    function getX(address _test) external view returns (uint)&#123;</span><br><span class="line">        return TestContract(_test).getX();</span><br><span class="line">    &#125;</span><br><span class="line">    function setXandSendEther(address _test,uint _x) external payable&#123;</span><br><span class="line">        TestContract(_test).setXandReceiveEther&#123;value: msg.value&#125;(_x);</span><br><span class="line">    &#125;</span><br><span class="line">    function getXandValue(address _test) external view returns (uint x, uint value)&#123;</span><br><span class="line">        (x, value) = TestContract(_test).getXandValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TestContract&#123;</span><br><span class="line">    uint public x;</span><br><span class="line">    uint public value = 123;</span><br><span class="line">    function setX(uint _x) external&#123;</span><br><span class="line">        x = _x;</span><br><span class="line">    &#125;</span><br><span class="line">    function getX() external view returns (uint)&#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">    function setXandReceiveEther(uint _x) external payable&#123;</span><br><span class="line">        x = _x;</span><br><span class="line">        value = msg.value;</span><br><span class="line">    &#125;</span><br><span class="line">    function getXandValue() external view returns (uint,uint)&#123;</span><br><span class="line">        return(x,value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-两个项目中两个合约通过接口实现">2.2 两个项目中两个合约通过接口实现</h3>
<p>知道要调用的合约，抽象出其中的接口，传入要调用的合约地址<br>
先单独部署Counter合约</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.3;</span><br><span class="line">contract Counter&#123;</span><br><span class="line">    uint public count;</span><br><span class="line">    function inc() external&#123;</span><br><span class="line">        count += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    function dec() external&#123;</span><br><span class="line">        count -= 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再部署带有接口的合约，用来间接调用Counter合约</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.3;</span><br><span class="line">interface ICounter&#123;</span><br><span class="line">    function count() external view returns (uint);</span><br><span class="line">    function inc() external;</span><br><span class="line">&#125;</span><br><span class="line">contract CallTestContract&#123;</span><br><span class="line">    uint public count;</span><br><span class="line">    function examples(address _counter) external &#123;</span><br><span class="line">        ICounter(_counter).inc();</span><br><span class="line">        count = ICounter(_counter).count();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-使用call调用不同合约">2.3 使用call调用不同合约</h3>
<p>先发布<code>TestCall</code>合约，再发布<code>Call</code>合约；<br>
用<code>Call</code>合约通过地址和call调用<code>TestCall</code>合约</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.3;</span><br><span class="line">contract TestCall&#123;</span><br><span class="line">    string public message;</span><br><span class="line">    uint public x;</span><br><span class="line">    event Log(string message);</span><br><span class="line">    //调用不存在的合约，会触发该方法</span><br><span class="line">    fallback() external payable&#123;</span><br><span class="line">        emit Log(&quot;fallback was called&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    function foo(string memory _message,uint _x) external payable returns(bool,uint)&#123;</span><br><span class="line">        message = _message;</span><br><span class="line">        x = _x;</span><br><span class="line">        return (true,999);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Call&#123;</span><br><span class="line">    bytes public data;</span><br><span class="line">    function callFoo(address _test) external payable&#123;</span><br><span class="line">        (bool success,bytes memory _data)=_test.call&#123;value:111,gas:5000&#125;(</span><br><span class="line">            abi.encodeWithSignature(</span><br><span class="line">                &quot;foo(string,uint256)&quot;,&quot;call foo&quot;,123</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">        require(success,&quot;call failed&quot;);</span><br><span class="line">        data = _data; </span><br><span class="line">    &#125;</span><br><span class="line">    //调用不存在的合约</span><br><span class="line">    function callDoesNotExit(address _test) external&#123;</span><br><span class="line">        (bool success,)=_test.call&#123;value:111,gas:5000&#125;(abi.encodeWithSignature(&quot;doesNotExist()&quot;));</span><br><span class="line">        require(success,&quot;call failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-通过委托delegatecall调用不同合约">2.4 通过委托delegatecall调用不同合约</h3>
<p>适用于升级合约。<br>
<code>DelegateCall合约</code>通过delegatecall只是借用了<code>TestDelegateCall合约</code>中的逻辑，并没有改变<code>TestDelegateCall合约</code>中任何参数值。<br>
被调用的<code>TestDelegateCall合约</code>，参数变量结构一定要与<code>DelegateCall合约</code>的一致，否则调用会出现问题。（当然，在相同结构的情况下，在被调用的<code>TestDelegateCall合约</code>之后追加内容是可以的，但还是不建议，以防出了问题找不到原因）</p>
<p>另外，通过委托调用，msg.sender会始终为调用人的地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.3;</span><br><span class="line"></span><br><span class="line">contract TestDelegateCall&#123;</span><br><span class="line">    uint public num;</span><br><span class="line">    address public sender;</span><br><span class="line">    uint public value;</span><br><span class="line">    function setVars(uint _num) external payable&#123;</span><br><span class="line">        num = _num;</span><br><span class="line">        sender = msg.sender;</span><br><span class="line">        value = msg.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract DelegateCall&#123;</span><br><span class="line">    uint public num;</span><br><span class="line">    address public sender;</span><br><span class="line">    uint public value;</span><br><span class="line">    //通过delegatecall调用TestDelegateCall，只会修改了当前合约DelegateCall的变量值，但不会修改TestDelegateCall中num的值</span><br><span class="line">    //也就是说，通过delegatecall只是借用了TestDelegateCall中的逻辑，并没有改变其中任何值</span><br><span class="line">    //此种方式，需要TestDelegateCall中的结构和变量参数需要与DelegateCall中的保持一致。</span><br><span class="line">    function setVars(address _test,uint _num) external payable&#123;</span><br><span class="line">       (bool success,bytes memory data) = _test.delegatecall(abi.encodeWithSelector(TestDelegateCall.setVars.selector,_num));</span><br><span class="line">       require(success,&quot;delegatecall failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-通过工厂模式调用合约">2.5 通过工厂模式调用合约</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.3;</span><br><span class="line">contract Account&#123;</span><br><span class="line">    address public bank;</span><br><span class="line">    address public owner;</span><br><span class="line">    constructor(address _owner) payable&#123;</span><br><span class="line">        bank = msg.sender;</span><br><span class="line">        owner = _owner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract AccountFactory&#123;</span><br><span class="line">    Account[] public accounts;</span><br><span class="line">    function createAccount(address _owner) external payable&#123;</span><br><span class="line">        Account account = new Account&#123;value: 111&#125;(_owner);</span><br><span class="line">        accounts.push(account);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-调用库合约">2.6 调用库合约</h3>
<p>用于节约代码量<br>
涉及到<code>using AContract for type</code>的使用，该功能可以将<code>AContract库合约</code>中的方法赋予给<code>type数据类型</code>使用，提高使用效率</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.3;</span><br><span class="line">library Math&#123;</span><br><span class="line">    function max(uint x, uint y) internal pure returns (uint)&#123;</span><br><span class="line">        return x &gt;= y ? x : y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract Test&#123;</span><br><span class="line">    function testMax(uint x, uint y) external pure returns (uint)&#123;</span><br><span class="line">        return Math.max(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">library ArrayLib&#123;</span><br><span class="line">    function find(uint[] storage arr, uint x) internal view returns (uint)&#123;</span><br><span class="line">        for(uint i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">            if (arr[i]==x)&#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        revert(&quot;not found&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract TestArray&#123;</span><br><span class="line">    using ArrayLib for uint[];  //将库合约中的方法赋予给了uint[]</span><br><span class="line">    uint[] public arr = [3,2,1];</span><br><span class="line">    function testFind() external view returns (uint i)&#123;</span><br><span class="line">        return arr.find(2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-哈希运算和验证签名">3. 哈希运算和验证签名</h2>
<h2 id="3-1-hash生成">3.1 hash生成</h2>
<p>这个注意encodePacked和encode的区别：<br>
encodePacked压缩了结果，容易造成hash碰撞，因此使用它对两个字符串进行hash时，最好在两个字符串之间加入一个数字。<br>
<code>注：</code>关于哈希碰撞，<code>aa aaa</code>的压缩和<code>a aaaa</code>的压缩使用encodePacked的压缩结果是一样的，造成了碰撞</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.3;</span><br><span class="line"></span><br><span class="line">//通常用于签名或者获取特定Id时，会用到hash</span><br><span class="line">//合约中，hash值是个32位定长的bytes</span><br><span class="line">contract HashFunc&#123;</span><br><span class="line">    //encodePacked打包会压缩</span><br><span class="line">    function hash(string memory text,uint num,address addr) external pure returns (bytes32)&#123; </span><br><span class="line">        //正常签名，一般需要三个参数，按如下格式传入</span><br><span class="line">        //中间加入num，是为了隔开text和addr，防止因encodePacked压缩结果造成的hash碰撞</span><br><span class="line">        return keccak256(abi.encodePacked(text,num,addr));</span><br><span class="line">    &#125;</span><br><span class="line">    //不压缩结果，返回不定长,会补0</span><br><span class="line">    function encode(string memory text0,string memory text1) external pure returns (bytes memory)&#123;</span><br><span class="line">        return abi.encode(text0,text1);</span><br><span class="line">    &#125;</span><br><span class="line">    //压缩结果，会去掉0，容易产生hash碰撞</span><br><span class="line">    function encodePacked(string memory text0,string memory text1) external pure returns (bytes memory)&#123;</span><br><span class="line">        return abi.encodePacked(text0,text1);</span><br><span class="line">    &#125;</span><br><span class="line">    //直接使用encodePacked生成的hash，容易发生碰撞。解决方式：</span><br><span class="line">    //1. 使用encode，但gas消耗会多</span><br><span class="line">    //2. 依旧使用encodePacked，但在text0和text1之间加一个数字num参数，相当于使用三个参数生成hash</span><br><span class="line">    function collision(string memory text0,string memory text1) external pure returns (bytes32)&#123;</span><br><span class="line">        return keccak256(abi.encodePacked(text0,text1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-验证签名">3.2 验证签名</h3>
<p>签名流程：</p>
<ol>
<li>将消息签名</li>
<li>将签名后的消息进行hash</li>
<li>将签名并且hash后的消息和私钥进行签名 该行为是链下操作</li>
<li>ecrecover(hash(message),signature)==signer 恢复签名。ecrecover通过hash后的消息和链下签名恢复地址，检查地址是否为期望地址</li>
</ol>
<p>以下为用于验证签名的合约(链下签名自行实现)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.3;</span><br><span class="line">/*</span><br><span class="line">签名流程：</span><br><span class="line">1. 将消息签名</span><br><span class="line">2. 将签名后的消息进行hash</span><br><span class="line">3. 将签名并且hash后的消息和私钥进行签名 该行为是链下操作</span><br><span class="line">4. ecrecover(hash(message),signature)==signer 恢复签名。ecrecover通过hash后的消息和链下签名恢复地址，检查地址是否为期望地址</span><br><span class="line">*/</span><br><span class="line">contract VerifySig&#123;</span><br><span class="line">    //传入：</span><br><span class="line">    //签名人地址</span><br><span class="line">    //消息，这里一个字符串</span><br><span class="line">    //链下签名</span><br><span class="line">    function verify(address _signer,string memory _message,bytes memory _sig) external pure returns(bool)&#123;</span><br><span class="line">        //两次hash是为了提高安全性，有第三方认为，一次签名容易被破解</span><br><span class="line">        bytes32 messageHash = getMessageHash(_message);</span><br><span class="line">        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);</span><br><span class="line">        return recover(ethSignedMessageHash,_sig) == _signer;</span><br><span class="line">    &#125;</span><br><span class="line">    function getMessageHash(string memory _message) public pure returns (bytes32)&#123;</span><br><span class="line">        return keccak256(abi.encodePacked(_message));</span><br><span class="line">    &#125;</span><br><span class="line">    function getEthSignedMessageHash(bytes32 _messageHash) public pure returns (bytes32)&#123;</span><br><span class="line">        return keccak256(abi.encodePacked(&quot;\x19Ethereum Singed Message:\n32&quot;,_messageHash));</span><br><span class="line">    &#125;</span><br><span class="line">    function recover(bytes32 _ethSignedMessageHash,bytes memory _sig) public pure returns (address)&#123;</span><br><span class="line">        (bytes32 r,bytes32 s, uint8 v) = _split(_sig);</span><br><span class="line">        return ecrecover(_ethSignedMessageHash,v,r,s);</span><br><span class="line">    &#125;</span><br><span class="line">    //_sig总共65位，其中：</span><br><span class="line">    //r 32位</span><br><span class="line">    //s 32位</span><br><span class="line">    //v 1位</span><br><span class="line">    function _split(bytes memory _sig) internal pure returns(bytes32 r,bytes32 s,uint8 v)&#123;</span><br><span class="line">        require(_sig.length == 65,&quot;invalid signature length&quot;);</span><br><span class="line">        assembly&#123;</span><br><span class="line">        //汇编中，前32位不取</span><br><span class="line">            r := mload(add(_sig,32)) //跳过32位后，取32位</span><br><span class="line">            s := mload(add(_sig,64)) //跳过64位后，取32位</span><br><span class="line">            v := byte(0,mload(add(_sig,96))) //跳过96位后，取剩余的</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-合约自毁">4. 合约自毁</h2>
<p><code>selfdestruct(payable(msg.sender));</code>，其中<code>msg.sender</code>是只接收eth的地址，有两个作用：</p>
<ol>
<li>删除合约，就是自毁</li>
<li>自毁同时，强制发送eth到指定地址，也就是为了安全，强制转移走eth</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.3;</span><br><span class="line">contract Kill&#123;</span><br><span class="line">    constructor() payable&#123;&#125;</span><br><span class="line">    function kill() external&#123;</span><br><span class="line">        //msg.sender表示，合约只要自毁，就会强制把当前合约剩余的eth转移给msg.sender</span><br><span class="line">        selfdestruct(payable(msg.sender));</span><br><span class="line">    &#125;</span><br><span class="line">    //用于测试该合约是否被销毁</span><br><span class="line">    function testCall() external pure returns(uint)&#123;</span><br><span class="line">        return 123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract Helper &#123;</span><br><span class="line">     function getBalance() external view returns (uint)&#123;</span><br><span class="line">         return address(this).balance;</span><br><span class="line">     &#125;</span><br><span class="line">     //会自毁的同时，将Kill合约剩余的eth强制转移给Helper合约</span><br><span class="line">     function kill(Kill _kill) external&#123;</span><br><span class="line">         _kill.kill();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-函数签名-底层逻辑">5. 函数签名-底层逻辑</h2>
<p>本质意思是，hash的固定前4个字节是用来标记方法名称的，通过该方式来区分不同的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.3;</span><br><span class="line"></span><br><span class="line">contract FunctionSelector&#123;</span><br><span class="line">    //可以获取方法的选择器，即头部hash，固定获取头部4字节</span><br><span class="line">    //传入 &quot;transfer(address,uint256)&quot;</span><br><span class="line">    //可得到结果：0xa9059cbb   与下面Receiver合约中的Log结果一致</span><br><span class="line">    function getSelector(string calldata _func) external pure returns (bytes4)&#123;</span><br><span class="line">        return bytes4(keccak256(bytes(_func)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Receiver&#123;</span><br><span class="line">    event Log(bytes data);</span><br><span class="line">    function transfer(address _to,uint _amount) external&#123;</span><br><span class="line">        emit Log(msg.data);</span><br><span class="line">        //虚拟机中，事件会打印如下信息：</span><br><span class="line">        //0xa9059cbb0000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc4000000000000000000000000000000000000000000000000000000000000000b</span><br><span class="line">        //将该信息拆分为三部分：</span><br><span class="line">        //0xa9059cbb  表示函数选择器，即代表transfer函数，固定占有4个字节</span><br><span class="line">        //0000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc  //第一个参数</span><br><span class="line">        //4000000000000000000000000000000000000000000000000000000000000000b  //第二个参数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-通过合约部署合约-create2">6. 通过合约部署合约-create2</h2>
<p>注意和通过合约调用合约进行区分。该方式是直接通过合约部署新的合约。</p>
<h3 id="6-1-通过new部署合约">6.1 通过new部署合约</h3>
<p>可以方便随时部署，<br>
缺点是：每次new在不同的链上存储位置进行部署</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.3;</span><br><span class="line"></span><br><span class="line">contract DeployWithCreate2&#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    constructor(address _owner)&#123;</span><br><span class="line">        owner = _owner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Create2Factory&#123;</span><br><span class="line">    event Deploy(address addr);</span><br><span class="line">    function deploy() external&#123;</span><br><span class="line">        DeployWithCreate2 _contract = new DeployWithCreate2(msg.sender);</span><br><span class="line">        emit Deploy(address(_contract));  //获取到部署的合约地址</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-通过create2部署合约">6.2 通过create2部署合约</h3>
<p>低版本中，需要通过内联，显式调用create2来部署合约。但8.0后简化了逻辑。具体看如下。<br>
借用了salt进行部署，只要salt不变，则表示链上该位置不能重复部署。除非该位置的合约被销毁了。<br>
简单说，只要salt不变，则合约地址不变。<br>
其中会涉及到个<code>bytecode</code>，这是机器码，也就是合约编译后的完整结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.3;</span><br><span class="line">contract DeployWithCreate2&#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    constructor(address _owner)&#123;</span><br><span class="line">        owner = _owner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//工厂合约</span><br><span class="line">contract Create2Factory&#123;</span><br><span class="line">    event Deploy(address addr);</span><br><span class="line">    function deploy(uint _salt) external&#123;</span><br><span class="line">        DeployWithCreate2 _contract = new DeployWithCreate2&#123;</span><br><span class="line">            salt: bytes32(_salt)</span><br><span class="line">        &#125;(msg.sender);</span><br><span class="line">        emit Deploy(address(_contract));  //获取到部署的合约地址</span><br><span class="line">    &#125;</span><br><span class="line">    //用于计算合约地址</span><br><span class="line">    //bytecode是要部署的合约的机器码（该机器码其实）</span><br><span class="line">    function getAddress(bytes memory bytecode,uint _salt) public view returns(address)&#123;</span><br><span class="line">        bytes32 hash = keccak256(</span><br><span class="line">            abi.encodePacked(</span><br><span class="line">                //四个参数：固定的0xff、合约地址、salt、机器码</span><br><span class="line">                bytes1(0xff), address(this), _salt, keccak256(bytecode)</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">        return address(uint160(uint(hash)));</span><br><span class="line">   &#125;</span><br><span class="line">   //获取机器码，机器码相当于是要部署的合约编译后的完整内容</span><br><span class="line">   //传入合约初始化时需要的参数</span><br><span class="line">   function getBytecode(address _owner) public pure returns(bytes memory)&#123;</span><br><span class="line">       bytes memory bytecode = type(DeployWithCreate2).creationCode;</span><br><span class="line">       return abi.encodePacked(bytecode,abi.encode(_owner));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-多重调用">7. 多重调用</h2>
<h3 id="7-1-基本的multi-call">7.1 基本的Multi Call</h3>
<ol>
<li>是指把对一个或者多个合约的多次调用打包整合在一个交易中，然后再去调用合约，优点：<br>
比如前端短时间需要对合约几十次调用，而一个链的rpc节点又限制了调用次数，比如20秒限制只能调用一次。此时，如果能把多次调用整合成一次调用，可以提高效率。</li>
<li>因为链上的延迟，多次调用，获取到的链上的结果可能有所不同，比如获取块高度。打包后调用，将会获取到同一个块的结果。</li>
</ol>
<p>使用该方式的不足之处是，被调用<code>合约TestMultiCall</code>的<code>msg.sender</code>表示的是<code>合约MultiCall</code>的地址，并不是调用<code>合约MultiCall</code>的真实用户的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.3;</span><br><span class="line">contract TestMultiCall&#123;</span><br><span class="line">    function func1() external view returns (uint,uint)&#123;</span><br><span class="line">        return (1,block.timestamp);</span><br><span class="line">    &#125;</span><br><span class="line">    function func2() external view returns (uint,uint)&#123;</span><br><span class="line">        return (2,block.timestamp);</span><br><span class="line">    &#125;</span><br><span class="line">    function getData1() external pure returns (bytes memory)&#123;</span><br><span class="line">        //获取选择器</span><br><span class="line">        //等价于：abi.encodeWithSignature(&quot;func1()&quot;)</span><br><span class="line">        return abi.encodeWithSelector(this.func1.selector);</span><br><span class="line">    &#125;</span><br><span class="line">    function getData2() external pure returns (bytes memory)&#123;</span><br><span class="line">        return abi.encodeWithSelector(this.func2.selector);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract MultiCall&#123;</span><br><span class="line">    //data 表示编码后的要调用的方法和内容，该数据可以通过链下计算获取，或者合约中实现该计算</span><br><span class="line">    //比如上面TestMultiCall的func1()方法，转换成data后，即可通过multiCall来调用</span><br><span class="line">    function multiCall(address[] calldata targets,bytes[] calldata data) external view returns(bytes[] memory)&#123;</span><br><span class="line">        require(targets.length == data.length,&quot;target length != data length&quot;);</span><br><span class="line">        bytes[] memory results = new bytes[](data.length);</span><br><span class="line">        for (uint i;i&lt;targets.length;i++)&#123;</span><br><span class="line">            //需要用staticcall，而不是call。是因为call可能会产生动态写入，与multiCall的view属性不一致</span><br><span class="line">            //result结果是abi编码返回的</span><br><span class="line">            (bool success,bytes memory result) = targets[i].staticcall(data[i]);</span><br><span class="line">            require(success,&quot;call failed&quot;);</span><br><span class="line">            results[i] = result; //记录返回结果</span><br><span class="line">        &#125;</span><br><span class="line">        return results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-2-多重委托调用multi-delegate-call">7.2 多重委托调用Multi Delegate Call</h3>
<p>为了解决上面的<code>Multi Call</code>的不足之处：被调用合约的<code>msg.sender</code>表示的是上一个合约的地址，并不是进行调用的用户的地址。<br>
通过委托调用，msg.sender在不同合约中会始终表示的是调用人的真是地址。<br>
缺点是：</p>
<ol>
<li>委托合约和业务合约，都需要是在同一个项目中。继承关系，可以看下方代码</li>
<li>警告：<code>不建议在多重委托调用中接收处理代币逻辑</code>。比如，只传入一笔token，但重复调用3次转账，会凭空出来两笔token。如果非要在多重委托调用中进行代币业务处理，那业务逻辑一定要规划好。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.3;</span><br><span class="line">contract MultiDelegatecall&#123;</span><br><span class="line">    error DelegatecallFailed();</span><br><span class="line">    function multiDelegatecall(bytes[] calldata data) external payable returns(bytes[] memory results)&#123;</span><br><span class="line">        results = new bytes[](data.length);</span><br><span class="line">        for (uint i;i&lt;data.length;i++)&#123;</span><br><span class="line">            (bool ok,bytes memory res) = address(this).delegatecall(data[i]);</span><br><span class="line">            if (!ok)&#123;</span><br><span class="line">                revert DelegatecallFailed();</span><br><span class="line">            &#125;</span><br><span class="line">            results[i] = res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract TestMultiDelegatecall is MultiDelegatecall&#123;</span><br><span class="line">    event Log(address caller, string func, uint i);</span><br><span class="line">    function func1(uint x, uint y) external&#123;</span><br><span class="line">        emit Log(msg.sender,&quot;func1&quot;, x+y);</span><br><span class="line">    &#125;</span><br><span class="line">    function func2() external returns (uint)&#123;</span><br><span class="line">        emit Log(msg.sender,&quot;func2&quot;,2);</span><br><span class="line">        return 111; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract Helper &#123;</span><br><span class="line">    function getFunc1Data(uint x, uint y) external pure returns (bytes memory)&#123;</span><br><span class="line">        return abi.encodeWithSelector(TestMultiDelegatecall.func1.selector,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    function getFunc2Data() external pure returns (bytes memory)&#123;</span><br><span class="line">        return abi.encodeWithSelector(TestMultiDelegatecall.func2.selector);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-abi编码和解码">8. ABI编码和解码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.3;</span><br><span class="line">contract AbiDecode&#123;</span><br><span class="line">    struct MyStruct&#123;</span><br><span class="line">        string name;</span><br><span class="line">        uint[2] nums;</span><br><span class="line">    &#125;</span><br><span class="line">    function encode(</span><br><span class="line">        uint x, </span><br><span class="line">        address addr,</span><br><span class="line">        uint[] calldata arr,</span><br><span class="line">        MyStruct calldata myStruct</span><br><span class="line">    ) external pure returns(bytes memory) &#123;</span><br><span class="line">        return abi.encode(x,addr,arr,myStruct);</span><br><span class="line">    &#125;</span><br><span class="line">    function decode(bytes calldata data) external pure returns(</span><br><span class="line">        uint x, </span><br><span class="line">        address addr,</span><br><span class="line">        uint[] memory arr,</span><br><span class="line">        MyStruct memory myStruct</span><br><span class="line">    ) &#123;</span><br><span class="line">        (x,addr,arr,myStruct) = abi.decode(data,(uint,address,uint[],MyStruct));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-gas优化">9. gas优化</h2>
<p>当然，如果能通过evm内联汇编来优化是更好，但可读性低。折中后，在现有代码逻辑中优化会更稳妥一些。<br>
通过案例来观察优化细节：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.3;</span><br><span class="line"></span><br><span class="line">contract GasGolf&#123;</span><br><span class="line">    /*</span><br><span class="line">    初始gas：50992</span><br><span class="line">    第一次优化：将memory 改为calldata  gas消耗：49163</span><br><span class="line">    第二次优化，引入_total内存变量，降低原先循环更新total频率，即降低写入storage频率  gas消耗：48952</span><br><span class="line">    第三次优化，短路。将两个判断直接写入if语句中，第一个判断失败就不会执行第二个判断。   gas消耗：48634</span><br><span class="line">    第四次优化，将i+=1改为++i  gas消耗：48244</span><br><span class="line">    第五次优化，缓存数组长度    gas消耗：48209</span><br><span class="line">    第六次优化，将数组元素提前拷贝到内存中 gas消耗：48047</span><br><span class="line">    */</span><br><span class="line">    uint public total;</span><br><span class="line">    </span><br><span class="line">    //输入参数：[1,2,3,4,5,100]</span><br><span class="line">    function sumIfEvenAndLessThan99(uint[] calldata nums) external&#123;</span><br><span class="line">        uint _total = total;</span><br><span class="line">        uint len = nums.length;</span><br><span class="line">        for (uint i=0;i&lt;len;++i)&#123;</span><br><span class="line">            uint num = nums[i];</span><br><span class="line">            if (num%2 ==0 &amp;&amp; num&lt;99)&#123;</span><br><span class="line">                _total += num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        total = _total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-综合案例-时间锁合约">12. 综合案例-时间锁合约</h2>
<p>队列中交易，只有到了指定时间，才能手动触发</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line">contract TimeLock&#123;</span><br><span class="line">    error NotOwnerError();</span><br><span class="line">    error AlreadyQueuedError(bytes32 txId);</span><br><span class="line">    error TimestampNotInRangeError(uint blockTimestamp,uint timestamp);</span><br><span class="line">    error NotQueuedError(bytes32 txId);</span><br><span class="line">    error TimestampNotPassedError(uint blockTimestamp,uint timestamp);</span><br><span class="line">    error TimestampExpiredError(uint blockTimestamp,uint expireAt);</span><br><span class="line">    error TxFailedError();</span><br><span class="line"></span><br><span class="line">    event Queue(bytes32 indexed txId, address indexed target,uint value,string func,bytes data,uint _timestamp);</span><br><span class="line">    event Execute(bytes32 indexed txId, address indexed target,uint value,string func,bytes data,uint _timestamp);</span><br><span class="line">    event Cancel(bytes32 indexed txId);</span><br><span class="line">    uint public constant MIN_DELAY = 10; //秒</span><br><span class="line">    uint public constant MAX_DELAY = 1000;</span><br><span class="line">    uint public constant GRACE_PERIOD = 1000;</span><br><span class="line">    address public owner;</span><br><span class="line">    mapping(bytes32=&gt;bool) public queued;</span><br><span class="line"></span><br><span class="line">    constructor()&#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    receive() external payable&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    modifier onlyOwner()&#123;</span><br><span class="line">        if (msg.sender != owner)&#123;</span><br><span class="line">            revert NotOwnerError();</span><br><span class="line">        &#125;</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getTxId(address _target,uint _value,string calldata _func,bytes calldata _data,uint _timestamp) public pure returns (bytes32 txId)&#123;</span><br><span class="line">        return keccak256(abi.encode(_target,_value,_func,_data,_timestamp));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //_target：目标合约地址</span><br><span class="line">    //_value：数值,</span><br><span class="line">    //_func：要执行的方法名称</span><br><span class="line">    //_data：要操作的具体数据</span><br><span class="line">    //_timestamp：时间戳</span><br><span class="line">    function queue(address _target,uint _value,string calldata _func,bytes calldata _data,uint _timestamp) external onlyOwner&#123;</span><br><span class="line">        //当前交易id</span><br><span class="line">        bytes32 txId = getTxId(_target,_value,_func,_data,_timestamp);</span><br><span class="line">        //检查id是否存在</span><br><span class="line">        if (queued[txId])&#123;</span><br><span class="line">            revert AlreadyQueuedError(txId);</span><br><span class="line">        &#125;</span><br><span class="line">        //检查交易时间戳，即交易要执行的时间，单位秒</span><br><span class="line">        if(_timestamp&lt;block.timestamp+MIN_DELAY || _timestamp&gt;block.timestamp+MAX_DELAY)&#123;</span><br><span class="line">            revert TimestampNotInRangeError(block.timestamp,_timestamp);</span><br><span class="line">        &#125;</span><br><span class="line">        queued[txId] = true;</span><br><span class="line">        emit Queue(txId,_target,_value,_func,_data,_timestamp);</span><br><span class="line">    &#125;</span><br><span class="line">    function execute(address _target,uint _value,string calldata _func,bytes calldata _data,uint _timestamp) external payable onlyOwner returns(bytes memory)&#123;</span><br><span class="line">        //当前交易id</span><br><span class="line">        bytes32 txId = getTxId(_target,_value,_func,_data,_timestamp);</span><br><span class="line">        //检查txid是否有效</span><br><span class="line">        if (queued[txId])&#123;</span><br><span class="line">            revert NotQueuedError(txId);</span><br><span class="line">        &#125;</span><br><span class="line">        //检查时间戳 block.timestamp &gt;_timestamp</span><br><span class="line">        if(block.timestamp&lt;_timestamp)&#123;</span><br><span class="line">            revert TimestampNotPassedError(block.timestamp,_timestamp);</span><br><span class="line">        &#125;</span><br><span class="line">        if(block.timestamp&gt;_timestamp+GRACE_PERIOD)&#123;  //超时1000秒依旧可以执行</span><br><span class="line">            revert TimestampExpiredError(block.timestamp,_timestamp+GRACE_PERIOD);</span><br><span class="line">        &#125;</span><br><span class="line">        //队列中删除交易</span><br><span class="line">        queued[txId] = false;</span><br><span class="line">        //执行</span><br><span class="line">        bytes memory data;</span><br><span class="line">        if (bytes(_func).length&gt;0)&#123;</span><br><span class="line">            data = abi.encodePacked(bytes4(keccak256(bytes(_func))),_data);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            data = _data;</span><br><span class="line">        &#125;</span><br><span class="line">        (bool ok,bytes memory res) = _target.call&#123;value:_value&#125;(data);</span><br><span class="line">        if(!ok)&#123;</span><br><span class="line">            revert TxFailedError();</span><br><span class="line">        &#125;</span><br><span class="line">        emit Execute(txId,_target,_value,_func,_data,_timestamp);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function cancel(bytes32 _txId) external onlyOwner&#123;</span><br><span class="line">        if (!queued[_txId])&#123;</span><br><span class="line">            revert NotQueuedError(_txId);</span><br><span class="line">        &#125;</span><br><span class="line">        queued[_txId] = false;</span><br><span class="line">        emit Cancel(_txId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TestTimeLock&#123;</span><br><span class="line">    address public timeLock;</span><br><span class="line">    constructor(address _timeLock)&#123;</span><br><span class="line">        timeLock = _timeLock;</span><br><span class="line">    &#125;</span><br><span class="line">    function test() external&#123;</span><br><span class="line">        require(msg.sender == timeLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getTimestamp() external view returns(uint)&#123;</span><br><span class="line">        return block.timestamp +100;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-合约安全">13. 合约安全</h2>
<ol>
<li>防重入攻击，比如攻击者利用fallback()反复攻击获取资产。解决方案：
<ol>
<li>先变更状态，再执行操作。比如，先改变余额，再执行转账</li>
<li>利用重入锁：</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool internal locked;</span><br><span class="line">modifier noReentrant()&#123;</span><br><span class="line">    require(!locked,&quot;No re-entrancy&quot;);</span><br><span class="line">    locked = true;</span><br><span class="line">    _;</span><br><span class="line">    locked = false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>数学溢出攻击<br>
为防止上溢或下溢，需要使用安全数学库进行操作，<code>openZepplin</code>有提供</li>
</ol>
<h2 id="12-总结">12. 总结</h2>
<p>本文编辑完毕</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>solidity</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>solidity v8.0新增特性</title>
    <url>/articles/cf5190ad/</url>
    <content><![CDATA[<p>solidity v8.0新增特性，建议完整学了基础之后再来看本文。</p>
<span id="more"></span>
<h2 id="1-安全数学">1. 安全数学</h2>
<p>也就是说从v8.0后，不再需要使用第三方SafeMath库，默认运算时，若溢出，会检测结果并报错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8;</span><br><span class="line"></span><br><span class="line">contract SafeMath&#123;</span><br><span class="line">    //负数时，会返回报错：call to SafeMath.testUnderflow errored: VM error: revert.</span><br><span class="line">    function testUnderflow() public pure returns(uint)&#123;</span><br><span class="line">        uint x=0;</span><br><span class="line">        x--;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //负数时，会返回uint的最大值</span><br><span class="line">    function testUncheckedUnderflow() public pure returns(uint)&#123;</span><br><span class="line">        uint x=0;</span><br><span class="line">        unchecked &#123; x--; &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-自定义错误">2. 自定义错误</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8;</span><br><span class="line"></span><br><span class="line">contract VendingMachine&#123;</span><br><span class="line">    address payable owner = payable(msg.sender);</span><br><span class="line">    //原先使用方式，通过字符串返回错误信息，字符串越长，gas消耗越大</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        if (msg.sender != owner)&#123;</span><br><span class="line">            revert(&quot;error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        owner.transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //通过方法定义error，当遇到异常，可以详细的抛出异常位置，参数等信息</span><br><span class="line">    error Unauthorized(address caller);</span><br><span class="line">    function withdraw2() public &#123;</span><br><span class="line">        if (msg.sender != owner)&#123;</span><br><span class="line">            revert Unauthorized(msg.sender);</span><br><span class="line">        &#125;</span><br><span class="line">        owner.transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-函数在合约之外">3. 函数在合约之外</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8;</span><br><span class="line"></span><br><span class="line">function helper(uint x) pure returns (uint)&#123;</span><br><span class="line">        return x * 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TestHelper &#123;</span><br><span class="line">    function test() external pure returns (uint)&#123;</span><br><span class="line">        return helper(123);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-引用合约并起别名">4. 引用合约并起别名</h2>
<p>很多语言中都有该特性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8;</span><br><span class="line">import &#123; Unauthorized, helper as h1&#125; from &quot;./Sol.sol&quot;;</span><br><span class="line"></span><br><span class="line">function helper(uint x) pure returns (uint)&#123;</span><br><span class="line">        return x * 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Import &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-create2">5. create2</h2>
<p>通过salt来获取合约地址，<code>只要使用salt和new就会自动使用create2地址</code>，具体细节，可以看solidity入门教程中的讲解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8;</span><br><span class="line"></span><br><span class="line">contract D&#123;</span><br><span class="line">    uint public x;</span><br><span class="line">    constructor(uint a) &#123;</span><br><span class="line">        x = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Create2&#123;</span><br><span class="line">    // 1. 先通过getBytes32获取salt</span><br><span class="line">    function getBytes32(uint salt) external pure returns (bytes32)&#123;</span><br><span class="line">        return bytes32(salt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2. 通过getAddress传入salt 和 参数，得到D合约的地址</span><br><span class="line">    function getAddress(bytes32 salt, uint arg) external view returns (address)&#123;</span><br><span class="line">        address addr = address(uint160(uint(keccak256(abi.encodePacked(</span><br><span class="line">            bytes1(0xff),</span><br><span class="line">            address(this),</span><br><span class="line">            salt,</span><br><span class="line">            keccak256(abi.encodePacked(</span><br><span class="line">                type(D).creationCode,</span><br><span class="line">                arg</span><br><span class="line">            ))</span><br><span class="line">        )))));</span><br><span class="line">        return addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //通过发布合约获取</span><br><span class="line">    address public deployedAddr;</span><br><span class="line"></span><br><span class="line">    // 3. 正常发布合约方式获取合约地址，该地址与getAddress得到的地址是一样的</span><br><span class="line">    // 4. 也就是说，新版这里，只要使用salt和new就会自动使用create2地址</span><br><span class="line">    function createDSalted(bytes32 salt,uint arg) public &#123;</span><br><span class="line">        D d = new D&#123;salt:salt&#125;(arg);</span><br><span class="line">        deployedAddr = address(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-总结">6. 总结</h2>
<p>本文编辑完毕</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>solidity</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>solidity教程(1)-基础和进阶</title>
    <url>/articles/4337926c/</url>
    <content><![CDATA[<p>solidity教程-基础和进阶，基于<code>8.0</code>版本</p>
<span id="more"></span>
<h2 id="1-概述">1. 概述</h2>
<p><a href="https://remix.ethereum.org">在线合约编辑器Remix</a></p>
<h3 id="1-1-区块链上问题">1.1 区块链上问题</h3>
<ol>
<li>产生随机数：
<ol>
<li>通常是拿来做抽奖用途，但在区块链上，如果要大家都能达成公式，就代表每个节点都要能够做出完全一致的随机数</li>
<li>于是要如何设计出<code>有特定产生模式+异地完全一致+不能被预测到</code>的随机数就是个大问题</li>
</ol>
</li>
<li>数据存储
<ol>
<li>存储在区块链上的数据，需要能让每个节点都验证到，因此至少专门存储数据的节点会需要把这些数据永久的记录下来</li>
<li>运行节点的人很难有无限的硬盘，把大量的数据都存储下来</li>
<li>存储成本直接转嫁给使用者，导致数据存储会很贵</li>
</ol>
</li>
</ol>
<h3 id="1-2-合约结构">1.2 合约结构</h3>
<img src="/articles/4337926c/1.png" class="" title="合约结构">
<p>关键字：pragma<br>
用来声明编译指示，通常为开发编译器选项使用，如：</p>
<ol>
<li>版本声明：pragma solidity ^0.8.17   //^表示大于等于（但不得大于等于0.9.0），也可以用 = 限制固定版本</li>
<li>ABI编解码版本声明(ABI CoderPragma)
<ol>
<li>pragma abicoder v2;</li>
<li>平常不会特别声明</li>
</ol>
</li>
<li>实验性编译指示(Experimental Pragma):
<ol>
<li>pragma experimental ABIEncoderV2;
<ol>
<li>V2版本的ABI编解码器</li>
<li>在0.7.4后被正式使用： pragma abicoder v2</li>
</ol>
</li>
<li>pragma experimental SMTChecker;
<ol>
<li>格式检查</li>
<li>能通过分析找出更多关于安全性的警告<br>
最基本的一个合约：</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line">contract ContractName &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-版权声明">1.3 版权声明</h3>
<ol>
<li>Solidity在0.6.8版加入了版权声明的警告机制，编译器会警告开发者</li>
<li>SPDX全名：The Software Package Data Exchange</li>
<li>根据自己的需要选择版权，去这里查找：<a href="https://spdx.org/licenses">版权列表</a></li>
<li>使用方式类似如此：<code>// SPDX-License-Identifier: MIT</code></li>
</ol>
<h3 id="1-4-helloworld">1.4 helloworld</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.7;</span><br><span class="line">contract HelloWorld &#123;</span><br><span class="line">   string public myString = &quot;hello world&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-基础">2. 基础</h2>
<h3 id="2-1-类型和值">2.1 类型和值</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line">contract ValueTypes&#123;</span><br><span class="line">    bool public b = true;</span><br><span class="line"></span><br><span class="line">    // uint正整数，默认uint256 0 to 2**256 - 1</span><br><span class="line">    // uint8 0 to 2**8 - 1</span><br><span class="line">    // uint16 0 to 2**16 -1</span><br><span class="line">    uint public u = 123; </span><br><span class="line"></span><br><span class="line">    // int，有符号，默认int256 -2**255 to 2**255 - 1</span><br><span class="line">    // uint128 -2**127 to 2**127 - 1</span><br><span class="line">    int public i = -123; </span><br><span class="line">    int public minInt = type(int).min;</span><br><span class="line">    int public maxInt = type(int).max;</span><br><span class="line"></span><br><span class="line">    //地址：16进制数字 </span><br><span class="line">    address public addr = &quot;0xE5e69B292170459a4e4CC77f94491681fF1f1636&quot;</span><br><span class="line"></span><br><span class="line">    //32位 64个16进制</span><br><span class="line">    bytes32 public b32 = &quot;0xf83bf40815929b2448b230d51fa2eaa5b8ccffd87691db7e62bf817b2cbb56ad&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-函数简介-可见范围">2.2 函数简介&amp;可见范围</h3>
<p>可见范围-external：表示外部函数，只能暴露给外部调用<br>
可见范围-public：可以外部调用，也可以合约内部调用<br>
可见范围-private：只在合约内部可见<br>
可见范围-internal：合约内部以及被继承的子合约可见</p>
<p>pure：这个函数不对链上有任何读写操作，也就是只能有局部变量（方法执行完毕，会被释放）<br>
view：不可链上写入数据，可以读取链上变量<br>
immutable: 合约发布时，仅可赋值一次(可在构造函数中赋值，也可全局赋值)，之后就不可变更，可节省gas</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line">contract FunctionIntro&#123;</span><br><span class="line"></span><br><span class="line">   //读取全局变量</span><br><span class="line">   function globalVars() external view reutrns(address,uint,uint)&#123;</span><br><span class="line">      address sender = msg.sender;</span><br><span class="line">      uint timestamp =  block.timestamp;</span><br><span class="line">      uint blockNum = block.number;</span><br><span class="line">      return (sender,timestamp,blockNum);</span><br><span class="line">   &#125;</span><br><span class="line">     </span><br><span class="line">   function add(uint x,uint y) external pure returns (uint)&#123;</span><br><span class="line">      return x + y;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   function sub(uint x,uint y) external pure returns (uint)&#123;</span><br><span class="line">      return x - y;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   //函数返回</span><br><span class="line">   function returnMany1() public pure returns (uint,bool)&#123;</span><br><span class="line">      return (1,true);</span><br><span class="line">   &#125;</span><br><span class="line">   function returnMany2() public pure returns (uint x,bool b)&#123;</span><br><span class="line">      return (1,true);</span><br><span class="line">   &#125;</span><br><span class="line">   function returnMany3() public pure returns (uint x,bool b)&#123;</span><br><span class="line">      x = 1;</span><br><span class="line">      b = true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //函数调用返回值，若不需要某返回值，则直接逗号，节省gas</span><br><span class="line">   function destructingAssigments() public pure&#123;</span><br><span class="line">      (uint x, bool b) = returnMany1();</span><br><span class="line">      (, bool b2) = returnMany2();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-状态变量-局部变量-常量-不可变量及默认值">2.3 状态变量、局部变量、常量、不可变量及默认值</h3>
<p><code>写入函数读取常量或状态变量时，需要消耗gas</code>；定义为常量，可以减少gas消耗。<br>
bool默认：false<br>
uint、int默认：0<br>
address默认：0x0000000000000000000000000000000000000000   40个0<br>
bytes32默认：0x0000000000000000000000000000000000000000000000000000000000000000 64个0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line">contract StateVariables&#123;</span><br><span class="line">    //链上记录变量，状态变量</span><br><span class="line">    uint public i;</span><br><span class="line">    bool public b;</span><br><span class="line">    address public myAddress;</span><br><span class="line">   </span><br><span class="line">   //常量</span><br><span class="line">   address public immutable owner = msg.sender;  //immutable 仅合约发布时可赋值一次</span><br><span class="line">   address public constant MY_ADDRESS=&quot;0xE5e69B292170459a4e4CC77f94491681fF1f1636&quot;;</span><br><span class="line">   uint public constant MY_UINT=123;</span><br><span class="line"></span><br><span class="line">    function foo() external&#123;</span><br><span class="line">       //局部变量</span><br><span class="line">       // 虚拟机内存，方法执行完，会被释放</span><br><span class="line">       uint x = 123;</span><br><span class="line">       bool f = false;</span><br><span class="line">       x += 456;</span><br><span class="line">       f = true;</span><br><span class="line"></span><br><span class="line">       // 链上，会改变链的状态</span><br><span class="line">       i = 123;</span><br><span class="line">       b = true;</span><br><span class="line">       myAddress = address(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-结构-循环-报错控制">2.4 结构、循环、报错控制</h3>
<ol>
<li>if else语法和别的语言一样，包括三元运算符</li>
<li>for while语法和别的语言一样，类似java，</li>
<li>报错控制：require、revert、assert
<ol>
<li>如果没有写入错误返回信息，如果表达式失败，则会全部退还gas</li>
<li>如果一定要返回错误信息，可以用自定义报错，就是自定义方法报错(v8.0特性)</li>
<li>区别：
<ol>
<li>require对比Revert，复杂时候用revert(如for、if语句中)，一般用require(方法开头)，两者一样都会向剩余的gas费返还给调用者</li>
<li>assert()语句的失败报错，会烧掉所有的gas，尽量少用。意味着发生了代码层面的错误事件，很大可能是合约中有一个bug需要修复。</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line">contract Err&#123;</span><br><span class="line">    function testRequire(uint _i) public pure&#123;</span><br><span class="line">        require(_i&lt;=10,&quot;i&gt;10&quot;);  //有表达式，表达式为真才能运行后续代码</span><br><span class="line">        //other code</span><br><span class="line">    &#125;</span><br><span class="line">    function testRevert(uint _i) public pure&#123;</span><br><span class="line">        if(i&gt;10)&#123;</span><br><span class="line">            revert(&quot;i&gt;10&quot;); //没有表达式</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    uint public num = 123;</span><br><span class="line">    function testAssert(uint _i) public pure&#123;</span><br><span class="line">        assert(num = 123); //断言，不包含报错信息，只会抛出异常</span><br><span class="line">    &#125;      </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-函数修改器modifier">2.5 函数修改器modifier</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line">contract Err&#123;</span><br><span class="line">    bool public paused;</span><br><span class="line">    uint public count;</span><br><span class="line"></span><br><span class="line">    function setPause(bool _paused) external&#123;</span><br><span class="line">        paused = _paused;</span><br><span class="line">    &#125;</span><br><span class="line">    modifier whenNotPaused()&#123;</span><br><span class="line">        require(!paused,&quot;paused&quot;);</span><br><span class="line">        _; //类似占位符，使用该修改器的方法的代码被调用的位置</span><br><span class="line">    &#125;</span><br><span class="line">    function inc() external whenNotPaused&#123;</span><br><span class="line">        count +=1;</span><br><span class="line">    &#125;</span><br><span class="line">    function dec() external whenNotPaused&#123;</span><br><span class="line">        count -=1;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    //带有参数的修改器</span><br><span class="line">    modifier cap(uint _x)&#123;</span><br><span class="line">        require(_x &lt;100,&quot;x&gt;=100&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    function incBy(uint _x) external cap(_x)&#123;</span><br><span class="line">        count += _x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //三明治式的修改器</span><br><span class="line">    modifier sandwich()&#123;</span><br><span class="line">        count +=10;</span><br><span class="line">        _;</span><br><span class="line">        count *=2;</span><br><span class="line">    &#125;</span><br><span class="line">    function foo() external sandwich&#123;</span><br><span class="line">        count +=1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-构造函数">2.6 构造函数</h3>
<p>只有合约发布时，会执行一次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line">contract Constructor&#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    uint public x;</span><br><span class="line"></span><br><span class="line">    constructor(uint _x)&#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        x = _x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-7-数组">2.7 数组</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line">contract Array&#123;</span><br><span class="line">   uint[] public nums = [1, 2, 3];</span><br><span class="line">   uint[3] public numsFixed = [4, 5, 6];</span><br><span class="line">   uint[] public arr;</span><br><span class="line"></span><br><span class="line">   function examples() external&#123;</span><br><span class="line">      nums.push(4); //新增</span><br><span class="line">      uint x = nums[1]; //访问</span><br><span class="line">      nums[2] = 777; //修改</span><br><span class="line">      delete nums[1]; //删除数字，该删除不会减小数组长度，会将指定索引位置的值变更为默认值0</span><br><span class="line">      nums.pop();  //队列推出，数组长队会变小</span><br><span class="line">      uint len = nums.length;</span><br><span class="line"></span><br><span class="line">      //内存中创建数组，内存中必须固定长度</span><br><span class="line">      uint[] memory a = new uint[](5);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //全部返回数组，需要方法使用memory来返回</span><br><span class="line">   function returnArray() external view returns (uint[] memory)&#123;</span><br><span class="line">      return nums;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //数组中删除指定元素-方式一，比较浪费gas</span><br><span class="line">   function remove(uint _index) public &#123;</span><br><span class="line">      require(_index &lt; arr.length,&quot;index out of bound&quot;);</span><br><span class="line">      for (uint i=_index;i&lt;arr.length-1;i++)&#123;</span><br><span class="line">         arr[i] = arr[i+1];</span><br><span class="line">      &#125;</span><br><span class="line">      arr.pop();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //数组中删除指定元素-方式二，节省gas，但会打乱数组顺序</span><br><span class="line">   function remove2(uint _index) public&#123;</span><br><span class="line">      arr[_index] = arr[arr.length-1];</span><br><span class="line">      arr.pop();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-8-映射">2.8 映射</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line"></span><br><span class="line">contract Mapping&#123;</span><br><span class="line">    mapping(address =&gt; uint) public balances;</span><br><span class="line">    mapping(address =&gt; bool) public inserted;</span><br><span class="line">    address[] public keys;</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; bool)) public isFriend;</span><br><span class="line"></span><br><span class="line">    function examples() external&#123;</span><br><span class="line">        balances[msg.sender] = 123;</span><br><span class="line">        uint bal = balances[msg.sender];</span><br><span class="line">        uint bal2 = balances[address(1)]; //若不存在，则返回0x0000...</span><br><span class="line"></span><br><span class="line">        balances[msg.sender] += 456;</span><br><span class="line">        delete balances[msg.sender]; //删除数据，其实是将该key对应的值设置为默认值，并不是真正的删除</span><br><span class="line"></span><br><span class="line">        isFriend[msg.sender][address(this)] = true;</span><br><span class="line">    &#125;</span><br><span class="line">    function set(address _key,uint _val) external&#123;</span><br><span class="line">        balances[_key] = _val;</span><br><span class="line">        if (!inserted[_key])&#123;</span><br><span class="line">            inserted[_key] = true;</span><br><span class="line">            keys.push(_key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function getSize() external view returns (uint)&#123;</span><br><span class="line">        return keys.length;</span><br><span class="line">    &#125;</span><br><span class="line">    function first() external view returns (uint)&#123;</span><br><span class="line">        return balances[keys[0]];</span><br><span class="line">    &#125;</span><br><span class="line">    function last() external view returns (uint)&#123;</span><br><span class="line">        return balances[keys[keys.length - 1]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function set(uint _i) external view returns (uint)&#123;</span><br><span class="line">        return balances[keys[_i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-9-结构体-枚举">2.9 结构体、枚举</h3>
<p>结构体：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line">contract Structs&#123;</span><br><span class="line">    struct Car&#123;</span><br><span class="line">        string model;</span><br><span class="line">        uint year;</span><br><span class="line">        address owner;</span><br><span class="line">    &#125;</span><br><span class="line">    Car public car;</span><br><span class="line">    Car[] public cars;</span><br><span class="line">    mapping(address =&gt; Car[]) public carsByOwner;</span><br><span class="line">    </span><br><span class="line">    function examples() external&#123;</span><br><span class="line">        // 标记为内存，修改不会变更链上状态，方法执行后，会被释放</span><br><span class="line">        Car memory toyota = Car(&quot;Toyota&quot;,1990,msg.sender);</span><br><span class="line">        Car memory lanbo = Car(&#123;model:&quot;Lamborghini&quot;, year:1980, owner:msg.sender&#125;);</span><br><span class="line">        Car memory tesla;</span><br><span class="line">        tesla.model = &quot;Tesla&quot;;</span><br><span class="line">        tesla.year = 2010;</span><br><span class="line">        tesla.owner = msg.sender;</span><br><span class="line">        cars.push(Car(&quot;Ferrari&quot;,2020,msg.sender)); </span><br><span class="line"></span><br><span class="line">        //标记为存储，可以修改掉cars[0]在链上的数据</span><br><span class="line">        Car storage _car = cars[0];</span><br><span class="line">        _car.year = 1999;</span><br><span class="line">        delete _car.owner;</span><br><span class="line">        delete cars[1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举：<br>
默认值是枚举清单中的第一个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line">contract Enum&#123;</span><br><span class="line">    enum Status&#123;</span><br><span class="line">        None,</span><br><span class="line">        Pending,</span><br><span class="line">        Shipped,</span><br><span class="line">        Completed,</span><br><span class="line">        Rejected,</span><br><span class="line">        Canceled</span><br><span class="line">    &#125;</span><br><span class="line">    Status public status;</span><br><span class="line">    struct Order&#123;</span><br><span class="line">        address buyer;</span><br><span class="line">        Status status;</span><br><span class="line">    &#125;</span><br><span class="line">    Order[] public orders;</span><br><span class="line">    function get() view external returns (Status)&#123;</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br><span class="line">    function set(Status _status) external&#123;</span><br><span class="line">        status = _status;</span><br><span class="line">    &#125;</span><br><span class="line">    function ship() external&#123;</span><br><span class="line">        status = Status.Shipped;</span><br><span class="line">    &#125;</span><br><span class="line">    function reset() external&#123;</span><br><span class="line">        delete status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-进阶">3. 进阶</h2>
<h3 id="3-1-存储">3.1 存储</h3>
<p>存储分为：<br>
storage 链上存储<br>
memory 内存存储<br>
calldata 类似于memory。低配版memory，可以用于节省gas，因此使用受限：只能用于external函数的输入参数，是不可变的，不能被覆盖和更改。<br>
<code>注</code>：函数外部声明的变量默认储存在storage里，函数内部声明的变量默认储存在memory里</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line"></span><br><span class="line">contract DataLocations &#123;</span><br><span class="line">    struct MyStruct&#123;</span><br><span class="line">        uint foo;</span><br><span class="line">        string text;</span><br><span class="line">    &#125;</span><br><span class="line">    mapping(address =&gt; MyStruct) public myStructs;</span><br><span class="line">   </span><br><span class="line">   //输入参数，也可使用calldata，尽量优先使用calldata，节省gas</span><br><span class="line">    function examples(uint[] memory y, string memory s) external returns (uint[] memory)&#123;</span><br><span class="line">        myStructs[msg.sender] = MyStruct(&#123;foo:123,text:&quot;bar&quot;&#125;);</span><br><span class="line">        MyStruct storage myStruct = myStructs[msg.sender];</span><br><span class="line">        myStruct.text = &quot;foo&quot;;</span><br><span class="line">        MyStruct memory readOnly = myStructs[msg.sender];</span><br><span class="line">        readOnly.foo = 456;</span><br><span class="line"></span><br><span class="line">        uint[] memory memArr = new uint[](3);</span><br><span class="line">        memArr[0] = 234;</span><br><span class="line">        return memArr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-事件">3.2 事件</h3>
<p>只要有状态变更，也就是只要有写操作，就应该有event事件<br>
事件相比较于状态变量，更节省gas，使用更清晰：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line">contract Event &#123;</span><br><span class="line">    event Log(string message,uint val);</span><br><span class="line">    //带有索引的事件，方便链下查询</span><br><span class="line">    //一个事件中，最多只能定义3个索引变量</span><br><span class="line">    event IndexedLog(address indexed sender, uint val);</span><br><span class="line">    //事件是写入方法</span><br><span class="line">    function example() external&#123;</span><br><span class="line">        emit Log(&quot;foo&quot;, 1234);</span><br><span class="line">        emit IndexedLog(msg.sender,789);</span><br><span class="line">    &#125;</span><br><span class="line">    event Message(address indexed _from,address indexed _to, string message);</span><br><span class="line"></span><br><span class="line">    function sendMessage(address _to, string calldata message) external&#123;</span><br><span class="line">        emit Message(msg.sender,_to,message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-继承">3.3 继承</h3>
<h4 id="3-3-1-普通继承">3.3.1 普通继承</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line">// virtual表示该方法可以被重写</span><br><span class="line">contract A &#123;</span><br><span class="line">    function foo() public pure virtual returns (string memory)&#123;</span><br><span class="line">        return &quot;A&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    function bar() public pure virtual returns (string memory)&#123;</span><br><span class="line">        return &quot;A&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    function baz() public pure returns (string memory)&#123;</span><br><span class="line">        return &quot;A&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// override表示该方法是重写了父合约中的方法</span><br><span class="line">contract B is A&#123;</span><br><span class="line">    function foo() public pure override returns (string memory)&#123;</span><br><span class="line">        return &quot;B&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    //已经重写的合约，想要被子合约重写，仍旧需要标记virtual</span><br><span class="line">    function bar() public pure virtual override returns (string memory)&#123;</span><br><span class="line">        return &quot;B&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract C is B&#123;</span><br><span class="line">    function bar() public pure override returns (string memory)&#123;</span><br><span class="line">        return &quot;C&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-2-线性继承">3.3.2 线性继承</h4>
<p>继承涉及到多线继承，即Y继承X，Z继承X和Y。则Z实现继承是，依据基础合约优先，派生合约靠后的原则：Z is X,Y。如果不按该规则，编译会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line"></span><br><span class="line">// virtual表示该方法可以被重写</span><br><span class="line">contract X &#123;</span><br><span class="line">    function foo() public pure virtual returns (string memory)&#123;</span><br><span class="line">        return &quot;X&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    function bar() public pure virtual returns (string memory)&#123;</span><br><span class="line">        return &quot;X&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function x() public pure returns (string memory)&#123;</span><br><span class="line">        return &quot;X&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// override表示该方法是重写了父合约中的方法</span><br><span class="line">contract Y is X&#123;</span><br><span class="line">    function foo() public pure virtual override returns (string memory)&#123;</span><br><span class="line">        return &quot;Y&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    //已经重写的合约，想要被子合约重写，仍旧需要标记virtual</span><br><span class="line">    function bar() public pure virtual override returns (string memory)&#123;</span><br><span class="line">        return &quot;Y&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    function y() public pure returns (string memory)&#123;</span><br><span class="line">        return &quot;Y&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//一定要先继承X，后继承Y，否则编译报错</span><br><span class="line">contract Z is X, Y&#123;</span><br><span class="line">    function foo() public pure override(X,Y) returns (string memory)&#123;</span><br><span class="line">        return &quot;Z&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    //已经重写的合约，想要被子合约重写，仍旧需要标记virtual</span><br><span class="line">    function bar() public pure override(X,Y) returns (string memory)&#123;</span><br><span class="line">        return &quot;Z&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-3-多个继承合约结构体初始化">3.3.3 多个继承合约结构体初始化</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line"></span><br><span class="line">contract S &#123;</span><br><span class="line">    string public name;</span><br><span class="line">    constructor(string memory _name)&#123;</span><br><span class="line">        name = _name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract T&#123;</span><br><span class="line">    string public text;</span><br><span class="line">    constructor(string memory _text)&#123;</span><br><span class="line">        text = _text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//构造函数初始化的顺序是，按照从父到子的顺序进行的</span><br><span class="line"></span><br><span class="line">// 父合约初始化-方式1</span><br><span class="line">contract U is S(&quot;s&quot;),T(&quot;t&quot;) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 父合约初始化-方式2</span><br><span class="line">contract V is S,T &#123;</span><br><span class="line">    constructor(string memory _name,string memory _text) S(_name) T(_text)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 父合约初始化-方式3</span><br><span class="line">contract VV is S(&quot;s&quot;),T &#123;</span><br><span class="line">    constructor(string memory _text) T(_text)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-4-调用父级合约">3.3.4 调用父级合约</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line">contract E &#123;</span><br><span class="line">    event Log(string message);</span><br><span class="line"></span><br><span class="line">    function foo() public virtual&#123;</span><br><span class="line">        emit Log(&quot;E.foo&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    function bar() public virtual &#123;</span><br><span class="line">        emit Log(&quot;E.bar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract F is E&#123;</span><br><span class="line">    function foo() public virtual override &#123;</span><br><span class="line">        emit Log(&quot;F.foo&quot;);</span><br><span class="line">        E.foo();</span><br><span class="line">    &#125;</span><br><span class="line">    function bar() public virtual override &#123;</span><br><span class="line">        emit Log(&quot;F.bar&quot;);</span><br><span class="line">        super.bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract G is E&#123;</span><br><span class="line">    function foo() public virtual override&#123;</span><br><span class="line">        emit Log(&quot;G.foo&quot;);</span><br><span class="line">        E.foo();</span><br><span class="line">    &#125;</span><br><span class="line">    function bar() public virtual override&#123;</span><br><span class="line">        emit Log(&quot;G.bar&quot;);</span><br><span class="line">        super.bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract H is F,G&#123;</span><br><span class="line">    function foo() public override(F,G)&#123;</span><br><span class="line">        F.foo();</span><br><span class="line">    &#125;</span><br><span class="line">    function bar() public override(F,G)&#123;</span><br><span class="line">        super.bar(); //F和G合约的bar都会被执行</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-支付eth-回退函数-发送eth">3.4 支付ETH、回退函数、发送ETH</h3>
<h4 id="3-4-1-支付">3.4.1 支付</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line"></span><br><span class="line">contract Payable &#123;</span><br><span class="line">    address payable public owner;  //加上payable属性，则该地址支持eth支付</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        owner = payable(msg.sender);  //被包含在payable中，才能赋值</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit() external payable&#123;&#125;  //方法标记后，该方法可以接收处理eth</span><br><span class="line"></span><br><span class="line">    function getBalance() external view returns(uint)&#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-4-2-回退-receive-和fallback">3.4.2 回退–receive()和fallback()</h4>
<p>receive()：<br>
功能：通过合约接收和转发以太币<br>
特点：<br>
(1) 一个合约至多含有一个receive()函数<br>
(2) 没有function关键字<br>
(3) 必须含有payable关键字<br>
(4) 没有参数，没有返回值<br>
(5) 可见性必须声明为external<br>
(6) 允许使用modifier修改器<br>
(7) 该函数通过.send()和.transfer()转发以太币<br>
(8) 若想要让你的contract(即合约账户)接收以太币，在未定义fallback() external payable{}函数时，需实现receive()函数<br>
(9) 在gasLimit允许范围内可执行复杂操作</p>
<p>fallback()：<br>
功能：当合约中没有任何匹配的函数可调用时，调用fallback()函数<br>
特点：<br>
(1) 一个合约至多含有一个fallback()函数<br>
(2) 没有function关键字<br>
(3) payable关键字是可选项，取决于该函数是否需要接收以太币，智能合约接收到eth，并且有payable关键词，就会触发该方法<br>
(4) 该函数可代替receive()函数以实现合约接受转发以太币的功能<br>
(5) 可见性必须声明为external<br>
(6) 允许使用modifier修改器<br>
(7) 在gasLimit允许范围内可执行复杂操作</p>
<p><code>注：</code> function() public payable {} 等价于fallback()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line">/*</span><br><span class="line">  fallback() or receive()?</span><br><span class="line">      Ether is send to contract</span><br><span class="line">                 |</span><br><span class="line">          is msg.data empty?  是否传入了额外数据</span><br><span class="line">                 / \</span><br><span class="line">               yes  no</span><br><span class="line">                /    \</span><br><span class="line">  receive() exists?  fallback()   一个合约中最多只能有一个receive()，如果不存在，则自动调用fallback()</span><br><span class="line">             / \</span><br><span class="line">           yes  no</span><br><span class="line">           /     \</span><br><span class="line">     receive()   fallback()</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">contract Fallback &#123;</span><br><span class="line">    event Log(string func, address sender, uint value, bytes data);</span><br><span class="line"></span><br><span class="line">    //fallback的第一种使用方式，不存在的方法的调用后，然后就会触发该方法的回调</span><br><span class="line">    fallback() external payable&#123;</span><br><span class="line">        emit Log(&quot;fallback&quot;,msg.sender,msg.value,msg.data);</span><br><span class="line">    &#125;</span><br><span class="line">    //fallback的第二种使用方式</span><br><span class="line">    fallback (bytes calldata input) external [payable] returns (bytes memory output)&#123;</span><br><span class="line">        emit Log(&quot;fallback second&quot;,msg.sender,msg.value,msg.data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //只接收eth  </span><br><span class="line">    receive() external payable&#123;</span><br><span class="line">        emit Log(&quot;receive&quot;,msg.sender,msg.value,&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-4-2-发送eth">3.4.2 发送ETH</h4>
<p>三种方法：<br>
transfer 返回revert()，只会消耗2300个gas<br>
send  返回bool，只会消耗2300个gas<br>
call  返回bool和data，会发出去所有gas，供后续逻辑消耗</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line">//发送者合约</span><br><span class="line">contract SendEth &#123;</span><br><span class="line">    constructor() payable&#123;&#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable&#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 发送eth，只会带有2300gas，如果发生异常，只会报出revert()</span><br><span class="line">    function sendViaTransfer(address payable _to) external payable&#123;</span><br><span class="line">        _to.transfer(123);</span><br><span class="line">    &#125;</span><br><span class="line">    // 会返回判断</span><br><span class="line">    function sendViaSend(address payable _to) external payable&#123;</span><br><span class="line">        bool send = _to.send(123);</span><br><span class="line">        require(send,&quot;send failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    function sendViaCall(address payable _to) external payable&#123;</span><br><span class="line">        (bool success,) = _to.call&#123;value: 123&#125;(&quot;&quot;); //其中(&quot;&quot;)表示要发送的数据</span><br><span class="line">        require(success,&quot;call failed&quot;);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//接收者合约</span><br><span class="line">contract EthReceiver&#123;</span><br><span class="line">    event Log(uint amount,uint gas);</span><br><span class="line">    receive() external payable&#123;</span><br><span class="line">        emit Log(msg.value, gasleft());  //剩余的gas</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-总结">4. 总结</h2>
<p>本文编辑完毕</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>solidity</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>uniswap-v2部署过程</title>
    <url>/articles/3b89cd2c/</url>
    <content><![CDATA[<p>uniswap-v2的前端以及合约代码均已不再更新，但官方项目中比较零散，为了能更直观的部署，我将所有代码均整合到如下项目中，只需要看该项目即可<a href="https://github.com/bitxx/uniswap-v2">uniswap-v2</a> ,本文也是基于该项目进行讲解的。</p>
<span id="more"></span>
<h2 id="1-概述">1. 概述</h2>
<ol>
<li>本文基于<code>Goerli</code>测试网进行部署，主网部署方式也基本一致，可参考。</li>
<li>本项目<a href="https://github.com/bitxx/uniswap-v2">uniswap-v2</a> 的目录结构大体如下：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">etherscan：将合约整合成一个文件并上传etherscan进行验证</span><br><span class="line">frontnd：存放前端代码，用于和合约进行交互</span><br><span class="line">hardhat：其中存放着4个合约项目。uniswap-factory表示工厂合约、uniswap-router表示路由合约、WETH9顾名思义的协议合约、用于方便调试的ERC20合约</span><br><span class="line">hardhat中的文件token.json是用于uniswap的token列表</span><br></pre></td></tr></table></figure>
<p>在hardhat中，需要先做如下操作生成配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp hardhat.config.js.backup hardhat.config.js</span><br></pre></td></tr></table></figure>
<p>然后在<code>hardhat.config.js</code>，编辑如下两个字段<br>
<code>INFURA_API_KEY</code>：表示在infura申请的<code>goerli</code>的key<br>
<code>ACCOUNT_PRIVATE_KEY</code>: 你账户的私钥，其中需要有测试环境的<code>ETH</code>，获取方式这里不讲解<br>
下文的部署均默认已完成上述操作。</p>
<h2 id="2-合约发布">2. 合约发布</h2>
<ol>
<li>添加依赖</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ./uniswap-v2/hardhat</span><br><span class="line">npm install --force</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>先发布<code>WETH</code>合约</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx hardhat --network goerli run scripts/deploy_1_weth9.js -h</span><br></pre></td></tr></table></figure>
<p>获取合约地址：<code>WETHAddress</code></p>
<p><code>备注</code>：官方不同网络已经提供了相应的WETH合约，如果不想按上面发布该合约，可以直接从链上调用：<br>
主网WETH9地址：<code>0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2</code><br>
GÖRLI测试网WETH9地址：<code>0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6</code></p>
<ol start="3">
<li>接着发布<code>factory</code>工厂合约<br>
<code>./script/deploy_2_factory.js.js</code>中，修改第30行，把<code>deploy中的地址</code>改为你自己账户的地址，然后：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx hardhat --network goerli run scripts/deploy_2_factory.js </span><br></pre></td></tr></table></figure>
<p>获取合约地址：<code>FactoryAddress</code><br>
获取code(上传合约后，在etherscan中查看，或者自己代码调出)：<code>INIT_CODE_PAIR_HASH</code></p>
<ol start="4">
<li>发布<code>router</code>路由合约<br>
在<code>./contract/router/libraries/UniswapV2Library.sol</code>的第26行，更改<code>hex</code>中的内容为上面获取到的<code>INIT_CODE_PAIR_HASH</code>，前缀不用<code>0x</code>。<br>
接着在<code>./script/deploy_3_router.js</code>中，修改第30行，把<code>deploy中的地址</code>改为你自己账户的地址以及上面<code>WETH9</code>的合约地址<code>WETHAddress</code>。<br>
然后：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx hardhat --network goerli run scripts/deploy_3_router.js</span><br></pre></td></tr></table></figure>
<p>获取合约地址：<code>RouterAddress</code></p>
<ol start="5">
<li>最后发布两个erc20合约，Token分别为<code>AAA</code>、<code>BBB</code><br>
修改<code>Token.sol</code>结构体中的token名称和标识，然后即可发布不同的token</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx hardhat --network goerli run scripts/deploy_4_erc20.js</span><br></pre></td></tr></table></figure>
<p>获取AAA Token合约地址：<code>AAAAddress</code><br>
获取BBB Token合约地址：<code>BBBAddress</code></p>
<ol start="6">
<li>至此，合约发布完毕<br>
我已根据上述操作发布的合约地址如下（Goerli测试网）：
<ol>
<li><a href="https://goerli.etherscan.io/address/0xFe33eC9960E430608030e92860264B486Ae99Ef2">WETH9地址</a> ：0xFe33eC9960E430608030e92860264B486Ae99Ef2</li>
<li><a href="https://goerli.etherscan.io/address/0x08b99e6b892da793b3da07db14d83c86337d5b1c">UniswapV2Factory合约地址</a> ：0x08b99e6b892da793b3da07db14d83c86337d5b1c</li>
<li><a href="https://goerli.etherscan.io/address/0x4A566ba09a8628d2a3BC7132f6F9F1D3Fe8Aca61">UniswapV2Router02合约地址</a> ：0x4A566ba09a8628d2a3BC7132f6F9F1D3Fe8Aca61</li>
<li><a href="https://goerli.etherscan.io/token/0x41466d52a90dFa935463c38B7D477059D5B04093">AAA Token</a> ：0x41466d52a90dFa935463c38B7D477059D5B04093</li>
<li><a href="https://goerli.etherscan.io/token/0xC180BA5FD897781f5764c1B079e21Be2a77855Ee">BBB Token</a> ：0xC180BA5FD897781f5764c1B079e21Be2a77855Ee</li>
</ol>
</li>
</ol>
<p>另外，UniswapV2Factory的<code>INIT_CODE_PAIR_HASH</code> = 0x6ea2252a145d03633feebbade3509ebd120dbe9d50dbf6bd343c366dc155dc67</p>
<h2 id="3-发布前端">3. 发布前端</h2>
<ol>
<li>下载依赖</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd frontend</span><br><span class="line">yarn</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>官方提供了Goerli测试网的合约地址等信息，可以直接用。当然，如果自行发布了uniswap v2合约，需要根据上文生成的合约地址对前端项目作如下改动：</p>
<ol>
<li>修改 frontend/src/constants/index.ts 文件中 ROUTER_ADDRESS 的值为 <code>RouterAddress</code></li>
<li>修改 frontend/src/state/swap/hooks.ts文件中 BAD_RECIPIENT_ADDRESSES 数组的值为 [<code>FactoryAddress</code>, , $<code>RouterAddress</code>]，数组第2个为空，这是早期的Router合约，目前也不用。</li>
<li><code>frontend/node_modules/@uniswap/sdk/dist/sdk.cjs.development.js</code>、<code>uniswap-interface/node_modules/@uniswap/sdk/dist/sdk.esm.js </code>、<code>uniswap-interface/node_modules/@uniswap/sdk/dist/sdk.cjs.production.min.js</code>、<code>frontend/node_modules/@uniswap/sdk/dist/constants.d.ts</code>这四个文件中：
<ol>
<li>FACTORY_ADDRESS 若存在，则改为 <code>FactoryAddress</code></li>
<li>INIT_CODE_HASH 若存在，则改为 <code>INIT_CODE_PAIR_HASH</code></li>
<li>若存在全局变量 WETH，则将其中<code>key</code>为<code>GÖRLI</code>的 Token 类型的地址修改为<code>WETHAddress</code>。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>启动</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本地启动</span></span><br><span class="line">yarn start</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若要发布，可进行编译</span></span><br><span class="line">yarn build</span><br></pre></td></tr></table></figure>
<p>本地浏览器打开：<code>http://localhost:3000</code> 即可进行交互体验</p>
<h2 id="4-添加token列表">4. 添加Token列表</h2>
<p><code>./frontend/src/constants/lists.ts</code>中的<code>DEFAULT_LIST_OF_LISTS</code>有一些默认Token列表，但要想进行<code>AAA</code>和<code>BBB</code>的swap，或者说要想自己控制swap自己的别的Token，就需要自己创建一个列表，该列表可以直接从前端页面上添加。<br>
但是你会发现只能添加url，因此该列表上传到某个服务器，再把url添加进去即可。<br>
该列表是一个json格式，完整的基于<code>AAA</code>和<code>BBB</code>，如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">   <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Test Tokens List&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;major&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;minor&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;patch&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">   <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;logoURI&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://www.bitxx.top/images/my_head-touch-icon-next.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2022-11-24 00:00:00.000+00:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;tokens&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;chainId&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x41466d52a90dFa935463c38B7D477059D5B04093&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;AAA Token&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;symbol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;AAA&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;decimals&quot;</span><span class="punctuation">:</span> <span class="number">18</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;logoURI&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://www.bitxx.top/images/aaa.png&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;chainId&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0xC180BA5FD897781f5764c1B079e21Be2a77855Ee&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;BBB Token&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;symbol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;BBB&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;decimals&quot;</span><span class="punctuation">:</span> <span class="number">18</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;logoURI&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://www.bitxx.top/images/bbb.png&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">   <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>我添加到gist上：<a href="https://gist.githubusercontent.com/bitxx/53780a04750e640b6e5171090b7707ac/raw/d77990cd7a69f7bf559dda874d9e401b747fa6a8/token.json">https://gist.githubusercontent.com/bitxx/53780a04750e640b6e5171090b7707ac/raw/d77990cd7a69f7bf559dda874d9e401b747fa6a8/token.json</a><br>
然后回到前端页面，加入上面的链接，即可进行swap等uniswapv2行为</p>
<h2 id="4-总结">4. 总结</h2>
<p>本文编辑完毕</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>DeFi</category>
        <category>Uniswap-V2</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Uniswap-V2</tag>
        <tag>DeFi</tag>
      </tags>
  </entry>
  <entry>
    <title>hardhat的部署以及基本使用</title>
    <url>/articles/8a4955c1/</url>
    <content><![CDATA[<p>本文主要讲解hardhat的部署以及基本使用，hardhat是solidity合约开发框架，跟truffle类似，但据说貌似比truffle更好用，因此来试试看。</p>
<span id="more"></span>
<h2 id="1-部署">1. 部署</h2>
<p><a href="https://nodejs.org/en">官网安装nodejs环境</a><br>
如果使用idea，则在该IDE中安装插件<code>hardhat</code><br>
以下命令方式安装，这里提供参考：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ubuntu</span></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install curl git</span><br><span class="line">curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -</span><br><span class="line">sudo apt-get install -y nodejs</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">macos</span></span><br><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash</span><br><span class="line">nvm install 20</span><br><span class="line">nvm use 20</span><br><span class="line">nvm alias default 20</span><br><span class="line">npm install npm --global # Upgrade npm to the latest version</span><br></pre></td></tr></table></figure>
<h2 id="2-创建一个项目">2. 创建一个项目</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用npm创建</span></span><br><span class="line">mkdir hardhat-tutorial</span><br><span class="line">cd hardhat-tutorial</span><br><span class="line">npm init</span><br><span class="line">npm install --save-dev hardhat</span><br><span class="line">npx hardhat init  # 按照提示，本文选择了：Create an empty hardhat.config.js</span><br><span class="line">npm install --save-dev @nomicfoundation/hardhat-toolbox  # 安装一款hardhat默认使用的插件，方便合约开发</span><br></pre></td></tr></table></figure>
<p>此时，需要在根目录的<code>hardhat.config.js</code>文件中，头部加入如下内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;@nomicfoundation/hardhat-toolbox&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="3-编写并编译一个合约">3. 编写并编译一个合约</h2>
<p>上面的根目录中，创建固定的<code>contracts</code>目录，在其中创建一个<code>Token.sol</code>文件，其中内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 该合约很简单，其中的逻辑这里就不讲解了</span><br><span class="line">//SPDX-License-Identifier: UNLICENSED</span><br><span class="line"></span><br><span class="line">// Solidity files have to start with this pragma.</span><br><span class="line">// It will be used by the Solidity compiler to validate its version.</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// This is the main building block for smart contracts.</span><br><span class="line">contract Token &#123;</span><br><span class="line">    // Some string type variables to identify the token.</span><br><span class="line">    string public name = &quot;My Hardhat Token&quot;;</span><br><span class="line">    string public symbol = &quot;MHT&quot;;</span><br><span class="line"></span><br><span class="line">    // The fixed amount of tokens, stored in an unsigned integer type variable.</span><br><span class="line">    uint256 public totalSupply = 1000000;</span><br><span class="line"></span><br><span class="line">    // An address type variable is used to store ethereum accounts.</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    // A mapping is a key/value map. Here we store each account&#x27;s balance.</span><br><span class="line">    mapping(address =&gt; uint256) balances;</span><br><span class="line"></span><br><span class="line">    // The Transfer event helps off-chain applications understand</span><br><span class="line">    // what happens within your contract.</span><br><span class="line">    event Transfer(address indexed _from, address indexed _to, uint256 _value);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Contract initialization.</span><br><span class="line">     */</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        // The totalSupply is assigned to the transaction sender, which is the</span><br><span class="line">        // account that is deploying the contract.</span><br><span class="line">        balances[msg.sender] = totalSupply;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * A function to transfer tokens.</span><br><span class="line">     *</span><br><span class="line">     * The `external` modifier makes a function *only* callable from *outside*</span><br><span class="line">     * the contract.</span><br><span class="line">     */</span><br><span class="line">    function transfer(address to, uint256 amount) external &#123;</span><br><span class="line">        // Check if the transaction sender has enough tokens.</span><br><span class="line">        // If `require`&#x27;s first argument evaluates to `false` then the</span><br><span class="line">        // transaction will revert.</span><br><span class="line">        require(balances[msg.sender] &gt;= amount, &quot;Not enough tokens&quot;);</span><br><span class="line"></span><br><span class="line">        // Transfer the amount.</span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">        balances[to] += amount;</span><br><span class="line"></span><br><span class="line">        // Notify off-chain applications of the transfer.</span><br><span class="line">        emit Transfer(msg.sender, to, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Read only function to retrieve the token balance of a given account.</span><br><span class="line">     *</span><br><span class="line">     * The `view` modifier indicates that it doesn&#x27;t modify the contract&#x27;s</span><br><span class="line">     * state, which allows us to call it without executing a transaction.</span><br><span class="line">     */</span><br><span class="line">    function balanceOf(address account) external view returns (uint256) &#123;</span><br><span class="line">        return balances[account];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着回到项目根目录，编译合约：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx hardhat compile</span><br></pre></td></tr></table></figure>
<h2 id="4-测试合约">4. 测试合约</h2>
<p>回到项目根目录，创建新的固定目录<code>test</code>，并在其中创建文件<code>Token.js</code>，内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This is an example test file. Hardhat will run every *.js file in `test/`,</span></span><br><span class="line"><span class="comment">// so feel free to add new ones.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Hardhat tests are normally written with Mocha and Chai.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// We import Chai to use its asserting functions here.</span></span><br><span class="line"><span class="keyword">const</span> &#123; expect &#125; = <span class="built_in">require</span>(<span class="string">&quot;chai&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// We use `loadFixture` to share common setups (or fixtures) between tests.</span></span><br><span class="line"><span class="comment">// Using this simplifies your tests and makes them run faster, by taking</span></span><br><span class="line"><span class="comment">// advantage of Hardhat Network&#x27;s snapshot functionality.</span></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  loadFixture,</span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">&quot;@nomicfoundation/hardhat-toolbox/network-helpers&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// `describe` is a Mocha function that allows you to organize your tests.</span></span><br><span class="line"><span class="comment">// Having your tests organized makes debugging them easier. All Mocha</span></span><br><span class="line"><span class="comment">// functions are available in the global scope.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// `describe` receives the name of a section of your test suite, and a</span></span><br><span class="line"><span class="comment">// callback. The callback must define the tests of that section. This callback</span></span><br><span class="line"><span class="comment">// can&#x27;t be an async function.</span></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&quot;Token contract&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// We define a fixture to reuse the same setup in every test. We use</span></span><br><span class="line">  <span class="comment">// loadFixture to run this setup once, snapshot that state, and reset Hardhat</span></span><br><span class="line">  <span class="comment">// Network to that snapshot in every test.</span></span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">deployTokenFixture</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// Get the Signers here.</span></span><br><span class="line">    <span class="keyword">const</span> [owner, addr1, addr2] = <span class="keyword">await</span> ethers.<span class="title function_">getSigners</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// To deploy our contract, we just have to call ethers.deployContract and await</span></span><br><span class="line">    <span class="comment">// its waitForDeployment() method, which happens once its transaction has been</span></span><br><span class="line">    <span class="comment">// mined.</span></span><br><span class="line">    <span class="keyword">const</span> hardhatToken = <span class="keyword">await</span> ethers.<span class="title function_">deployContract</span>(<span class="string">&quot;Token&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> hardhatToken.<span class="title function_">waitForDeployment</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fixtures can return anything you consider useful for your tests</span></span><br><span class="line">    <span class="keyword">return</span> &#123; hardhatToken, owner, addr1, addr2 &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// You can nest describe calls to create subsections.</span></span><br><span class="line">  <span class="title function_">describe</span>(<span class="string">&quot;Deployment&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// `it` is another Mocha function. This is the one you use to define each</span></span><br><span class="line">    <span class="comment">// of your tests. It receives the test name, and a callback function.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If the callback function is async, Mocha will `await` it.</span></span><br><span class="line">    <span class="title function_">it</span>(<span class="string">&quot;Should set the right owner&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// We use loadFixture to setup our environment, and then assert that</span></span><br><span class="line">      <span class="comment">// things went well</span></span><br><span class="line">      <span class="keyword">const</span> &#123; hardhatToken, owner &#125; = <span class="keyword">await</span> <span class="title function_">loadFixture</span>(deployTokenFixture);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// `expect` receives a value and wraps it in an assertion object. These</span></span><br><span class="line">      <span class="comment">// objects have a lot of utility methods to assert values.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// This test expects the owner variable stored in the contract to be</span></span><br><span class="line">      <span class="comment">// equal to our Signer&#x27;s owner.</span></span><br><span class="line">      <span class="title function_">expect</span>(<span class="keyword">await</span> hardhatToken.<span class="title function_">owner</span>()).<span class="property">to</span>.<span class="title function_">equal</span>(owner.<span class="property">address</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">it</span>(<span class="string">&quot;Should assign the total supply of tokens to the owner&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; hardhatToken, owner &#125; = <span class="keyword">await</span> <span class="title function_">loadFixture</span>(deployTokenFixture);</span><br><span class="line">      <span class="keyword">const</span> ownerBalance = <span class="keyword">await</span> hardhatToken.<span class="title function_">balanceOf</span>(owner.<span class="property">address</span>);</span><br><span class="line">      <span class="title function_">expect</span>(<span class="keyword">await</span> hardhatToken.<span class="title function_">totalSupply</span>()).<span class="property">to</span>.<span class="title function_">equal</span>(ownerBalance);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">describe</span>(<span class="string">&quot;Transactions&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">it</span>(<span class="string">&quot;Should transfer tokens between accounts&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; hardhatToken, owner, addr1, addr2 &#125; = <span class="keyword">await</span> <span class="title function_">loadFixture</span>(</span><br><span class="line">        deployTokenFixture</span><br><span class="line">      );</span><br><span class="line">      <span class="comment">// Transfer 50 tokens from owner to addr1</span></span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">expect</span>(</span><br><span class="line">        hardhatToken.<span class="title function_">transfer</span>(addr1.<span class="property">address</span>, <span class="number">50</span>)</span><br><span class="line">      ).<span class="property">to</span>.<span class="title function_">changeTokenBalances</span>(hardhatToken, [owner, addr1], [-<span class="number">50</span>, <span class="number">50</span>]);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Transfer 50 tokens from addr1 to addr2</span></span><br><span class="line">      <span class="comment">// We use .connect(signer) to send a transaction from another account</span></span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">expect</span>(</span><br><span class="line">        hardhatToken.<span class="title function_">connect</span>(addr1).<span class="title function_">transfer</span>(addr2.<span class="property">address</span>, <span class="number">50</span>)</span><br><span class="line">      ).<span class="property">to</span>.<span class="title function_">changeTokenBalances</span>(hardhatToken, [addr1, addr2], [-<span class="number">50</span>, <span class="number">50</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">it</span>(<span class="string">&quot;Should emit Transfer events&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; hardhatToken, owner, addr1, addr2 &#125; = <span class="keyword">await</span> <span class="title function_">loadFixture</span>(</span><br><span class="line">        deployTokenFixture</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Transfer 50 tokens from owner to addr1</span></span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">expect</span>(hardhatToken.<span class="title function_">transfer</span>(addr1.<span class="property">address</span>, <span class="number">50</span>))</span><br><span class="line">        .<span class="property">to</span>.<span class="title function_">emit</span>(hardhatToken, <span class="string">&quot;Transfer&quot;</span>)</span><br><span class="line">        .<span class="title function_">withArgs</span>(owner.<span class="property">address</span>, addr1.<span class="property">address</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Transfer 50 tokens from addr1 to addr2</span></span><br><span class="line">      <span class="comment">// We use .connect(signer) to send a transaction from another account</span></span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">expect</span>(hardhatToken.<span class="title function_">connect</span>(addr1).<span class="title function_">transfer</span>(addr2.<span class="property">address</span>, <span class="number">50</span>))</span><br><span class="line">        .<span class="property">to</span>.<span class="title function_">emit</span>(hardhatToken, <span class="string">&quot;Transfer&quot;</span>)</span><br><span class="line">        .<span class="title function_">withArgs</span>(addr1.<span class="property">address</span>, addr2.<span class="property">address</span>, <span class="number">50</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">it</span>(<span class="string">&quot;Should fail if sender doesn&#x27;t have enough tokens&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; hardhatToken, owner, addr1 &#125; = <span class="keyword">await</span> <span class="title function_">loadFixture</span>(</span><br><span class="line">        deployTokenFixture</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">const</span> initialOwnerBalance = <span class="keyword">await</span> hardhatToken.<span class="title function_">balanceOf</span>(owner.<span class="property">address</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Try to send 1 token from addr1 (0 tokens) to owner.</span></span><br><span class="line">      <span class="comment">// `require` will evaluate false and revert the transaction.</span></span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">expect</span>(</span><br><span class="line">        hardhatToken.<span class="title function_">connect</span>(addr1).<span class="title function_">transfer</span>(owner.<span class="property">address</span>, <span class="number">1</span>)</span><br><span class="line">      ).<span class="property">to</span>.<span class="property">be</span>.<span class="title function_">revertedWith</span>(<span class="string">&quot;Not enough tokens&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Owner balance shouldn&#x27;t have changed.</span></span><br><span class="line">      <span class="title function_">expect</span>(<span class="keyword">await</span> hardhatToken.<span class="title function_">balanceOf</span>(owner.<span class="property">address</span>)).<span class="property">to</span>.<span class="title function_">equal</span>(</span><br><span class="line">        initialOwnerBalance</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>执行测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx hardhat test</span><br></pre></td></tr></table></figure>
<h2 id="在hardhat-network中进行调试">在Hardhat Network中进行调试</h2>
<p>在<code>Hardhat Network</code>中，可以通过hardhat内置的log打印来调试合约<br>
如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.9;</span><br><span class="line"></span><br><span class="line">import &quot;hardhat/console.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function transfer(address to, uint256 amount) external &#123;</span><br><span class="line">    require(balances[msg.sender] &gt;= amount, &quot;Not enough tokens&quot;);</span><br><span class="line"></span><br><span class="line">    console.log(</span><br><span class="line">        &quot;Transferring from %s to %s %s tokens&quot;,</span><br><span class="line">        msg.sender,</span><br><span class="line">        to,</span><br><span class="line">        amount</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    balances[msg.sender] -= amount;</span><br><span class="line">    balances[to] += amount;</span><br><span class="line"></span><br><span class="line">    emit Transfer(msg.sender, to, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-合约发布">5. 合约发布</h2>
<p>就是将合约发布在公开测试网或者主网。<br>
在项目根目录创建固定目录<code>scripts</code>，在其中创建文件<code>deploy.js</code>，编辑发布信息，如下作为参考：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [deployer] = <span class="keyword">await</span> ethers.<span class="title function_">getSigners</span>();</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Deploying contracts with the account:&quot;</span>, deployer.<span class="property">address</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> token = <span class="keyword">await</span> ethers.<span class="title function_">deployContract</span>(<span class="string">&quot;Token&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Token address:&quot;</span>, <span class="keyword">await</span> token.<span class="title function_">getAddress</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">main</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> process.<span class="title function_">exit</span>(<span class="number">0</span>))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">    process.<span class="title function_">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>使用如下命令进行发布：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt;network-name&gt; 为指定网络的名称，如果不使用--network，则是在Hardhat Network中进行发布（内置网络，其实就知识模拟发布）</span></span><br><span class="line">npx hardhat run scripts/deploy.js --network &lt;network-name&gt;</span><br></pre></td></tr></table></figure>
<p>当然，如果要发布在测试网或者主网，还需要在<code>hardhat.config.js</code>中进行配置，这里假设配置Goerli网：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;@nomicfoundation/hardhat-toolbox&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Go to https://infura.io, sign up, create a new API key</span></span><br><span class="line"><span class="comment">// in its dashboard, and replace &quot;KEY&quot; with it</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">INFURA_API_KEY</span> = <span class="string">&quot;KEY&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace this private key with your Sepolia account private key</span></span><br><span class="line"><span class="comment">// To export your private key from Coinbase Wallet, go to</span></span><br><span class="line"><span class="comment">// Settings &gt; Developer Settings &gt; Show private key</span></span><br><span class="line"><span class="comment">// To export your private key from Metamask, open Metamask and</span></span><br><span class="line"><span class="comment">// go to Account Details &gt; Export Private Key</span></span><br><span class="line"><span class="comment">// Beware: NEVER put real Ether into testing accounts</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">SEPOLIA_PRIVATE_KEY</span> = <span class="string">&quot;YOUR SEPOLIA PRIVATE KEY&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">solidity</span>: <span class="string">&quot;0.8.19&quot;</span>,</span><br><span class="line">  <span class="attr">networks</span>: &#123;</span><br><span class="line">    <span class="attr">sepolia</span>: &#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">`https://sepolia.infura.io/v3/<span class="subst">$&#123;INFURA_API_KEY&#125;</span>`</span>,</span><br><span class="line">      <span class="attr">accounts</span>: [<span class="variable constant_">SEPOLIA_PRIVATE_KEY</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此时可以如下发布：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx hardhat run scripts/deploy.js --network sepolia</span><br></pre></td></tr></table></figure>
<p>备注：<br>
sepolia获取测试币渠道：<br>
<a href="https://www.infura.io/faucet/sepolia">渠道1-infura</a>  目前只发现这个渠道领取方便点，每24个小时能领取0.5个</p>
<h2 id="6-可参考项目">6. 可参考项目</h2>
<p>官方提供了一个样本项目来提供开发者参考：<br>
<a href="https://github.com/NomicFoundation/hardhat-boilerplate">hardhat-boilerplate</a><br>
具体使用方法这里就不讲解了，自行参考项目中的文档，或者参考这里：<a href="https://hardhat.org/tutorial/boilerplate-project">hardhat-boilerplate部署方式</a></p>
<h2 id="7-总结">7. 总结</h2>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://hardhat.org/tutorial">hardhat官方文档</a></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>hardhat</category>
      </categories>
      <tags>
        <tag>hardhat</tag>
        <tag>智能合约</tag>
      </tags>
  </entry>
  <entry>
    <title>uniswap-v2实现过程分析</title>
    <url>/articles/e04fabc2/</url>
    <content><![CDATA[<p>uniswap v2的实现流程分为<a href="https://github.com/Uniswap/v2-core">uniswapv2-core</a> 以及<a href="https://github.com/Uniswap/v2-periphery">uniswap-v2-periphery</a> 。这两部分内容相对独立，第一部分是uniswapv2的实现核心，第二部分是外围合约，一般称为路由合约，前端通过该外围合约来与核心合约进行交互。</p>
<span id="more"></span>
<h2 id="1-概述">1. 概述</h2>
<ol>
<li><a href="https://github.com/Uniswap/v2-periphery">uniswap-v2-periphery</a> 作为外围合约，只是用来接收前端请求，做简单的数据处理后，转发给底层合约执行。逻辑很简单，自行查阅即可。
<ol>
<li>该项目中，主要关注这两个文件：<code>UniswapV2Router02.sol</code>和<code>UniswapV2Library.sol</code>，别的文件主要是用于兼容早期合约的，无需关注。
<ol>
<li><code>UniswapV2Library.sol</code>：工具库，可以从<a href="https://github.com/Uniswap/v2-core">v2-core</a> 中读取并封装一些关键信息</li>
<li><code>UniswapV2Router02.sol</code>：路由合约，用于衔接<a href="https://github.com/Uniswap/v2-core">v2-core</a> 是与用户进行交互的入口，主要提供了添加流动性、移除流动性和兑换的系列接口，并提供了几个查询接口。属于该项目的最重要的一个文件</li>
</ol>
</li>
</ol>
</li>
<li><a href="https://github.com/Uniswap/v2-core">uniswapv2-core</a> 是uniswap v2的底层核心合约：
<ol>
<li>协议费和手续费区分
<ol>
<li>协议费：表示平台抽成，需要手动在合约中开启，每次mint或burn后会触发</li>
<li>手续费：每次swap，会保留的千分之三的交易费用。用户burn时，可以根据自己的份额连同该手续费提走。</li>
</ol>
</li>
<li>主要分为以下几个部分：
<ol>
<li>池子初始化：<code>createPair</code></li>
<li>增加池子流动性：<code>mint</code></li>
<li>减少池子流动性：<code>burn</code></li>
<li>交换：<code>swap</code>，也就是在满足x * y=k的情况下，如何从池子中获取其中一种token</li>
<li>同步更新资产：<code>sync</code>，用于将池子账户的两种资产数量与池子合约中参数标记的数量保持一致</li>
<li>从池子中提走多余的资产：<code>skim</code>，就是池子账户上两种资产数量如果大于池子合约中参数标记的两种资产数量，那就将多余的资产提取出来</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="2-概念解释">2. 概念解释</h2>
<p>uniswap v2中涉及到的一些概念</p>
<h3 id="2-1-恒定乘积做市模型-cpmm">2.1 恒定乘积做市模型(CPMM)</h3>
<p>Uniswap-v2 使用了恒定乘积做市模型来实现自动化做市商。其计算步骤如下：</p>
<ol>
<li>甲在 Uniswap-v2 上提供了 1000 个 TokenA 和 100 个 TokenB 作为流动池，计乘数 Kab = 1000 * 100 = 100000</li>
<li>乙想要在 Uniswap-v2 上使用 100 个 TokenA 兑换 TokenB，那么 Uniswap-v2 会首先计算交易后流动池会有 1000 + 100 = 1100 个 TokenA；为了维持 Kab 的不变，就需要 TokenB 的数量减少为 100000/1100 = 90.909… 。因此，Uniswap-v2 会给乙兑换出100 - 90.909 = 9.091 个 TokenB 。</li>
<li>乙成功地使用 100 个 TokenA 在 Uniswap-v2 上兑换了 9.091 个 TokenB。可以预见的是，根据这套算法，乙需要兑换的 TokenA 越多，平均每个 TokenA 能兑换的 TokenB 就会越少。这就产生了滑点的概念。<br>
<code>简化公式</code>：(TokenA余额 + 你出售的TokenA)*(TokenB余额 - 你获得的TokenB) = 常数K</li>
</ol>
<h3 id="2-2-滑点">2.2 滑点</h3>
<p>滑点一般指预设成交价位与真实成交价位的偏差。恒定乘积AMM中同样存在滑点，一旦发生交易，池中资产的储备发生变化，资产实际的交易执行价就会发生变化，产生滑点。交易额越大，滑点越大，交易者的损失就越大。<br>
根据恒定乘积，当用dx个x兑换dy个y时（忽略手续费），有：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">x * y = k </span><br><span class="line">(x + dx)(y - dy) = k</span><br></pre></td></tr></table></figure>
<p>可得，兑换量：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">dy = (y * dx)/(x + dx)</span><br></pre></td></tr></table></figure>
<p>则在实际兑换中，y相对x的单价为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">dx / dy = (x + dx) / y</span><br></pre></td></tr></table></figure>
<p>而兑换前，池中的y单价为x/y，那么y单价的滑点就产生了：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">p = (dx / dy) - (x/y) = dx / y</span><br></pre></td></tr></table></figure>
<p>当然，这里总结出的滑点计算还只是通过AMM机制所算出的理论滑点，实际上滑点还会受很多因素影响，比如网络延时、区块确认等等。</p>
<h3 id="2-3-无常损失">2.3 无常损失</h3>
<p>无常损失的发生与AMM的机制有关，例如当BTC的价格为50 USDT时，假设用户A向流动性池中添加10 BTC与 500 USDT，此时用户A的总资产价值1000USDT。假设此时流动性池中总的流动性为100 BTC与 5000 USDT, 用户A占总流动性池的10%。<br>
若BTC的价格上涨为 200 USDT，则根据恒定常数自动做市商的机制，总流动性池中资产的量变为50 BTC与10,000 USDT，若此时用户A撤出流动性，因为此前用户A提供的流动性占总流动性池的10%，则用户A成功取出 5 BTC与 1000 USDT，此时用户A的资产价值为2000 USDT(不计手续费收入)。<br>
但若用户A不向流动性池提供流动性，而是单纯持有则用户A的资产应该价值 10*200 + 500 =2500 USDT，中间的损失为500USDT ，提供流动性与单纯持有之间相较产生的损失称为无常损失。无常损失的大小只与提供流动性时币对的价格(P0)与撤出流动性时币对价格(P1)的比值(P1/P0)有关。<br>
但是用户可以通过提供流动性赚取交易的手续费，一定程度上可以弥补价格波动带来的无常损失。</p>
<h2 id="3-通过案例理解交易和手续费的计算过程">3. 通过案例理解交易和手续费的计算过程</h2>
<p>HelloSwap是一个独立的Uniswap交易所，它与其他交易所没有互联，该交易所的手续费比例为0.3.%，返还0.25%给LP，剩余0.05%给开发团队即协议抽成ϕ=1/6，有个资源池为LAM-MUT代币对，假设该资源池的持有者只有一个用户名称为Tom，如下图所示，即Tom占有LAM-MUT资源池的比例为100%，他初始添加流动性的比例为LAM:MUT = 4000:1000，分2次通过售出100LAM来买入MUT，请问Tom每次交易接收到的MUT是多少？Tom移除LAM-MUT 100%的流动性时，返回给Tom的LP手续费（UNI的个数）是多少？</p>
<img src="/articles/e04fabc2/1.png" class="" title="uniswap v2 交易信息">
<h3 id="3-1-每次接收到mut的计算过程">3.1 每次接收到MUT的计算过程</h3>
<p><code>售出100LAM第1次后</code>：<br>
Tom接收到的MUT为：1000-4000000/(4100-100<em>0.003)=24.3188526<br>
MUT流动量：4000000/(4100-100</em>0.003)=975.6811474<br>
<code>注</code>：4000000为当前x和y各自的流动性相乘；1000为售出LAM前，池中MUT的流动量；100为当前售出的LAM数量；4100为售出LAM后，LAM在池中的流动量；0.003为总的手续费比例</p>
<p><code>售出100LAM第2次后</code>：<br>
计算结果，与第1次的计算方式一模一样</p>
<p>想要补充说明的是，手续费是从你要出售的token中按比例0.003扣除的。计算手续费的合约代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">uint amount0In = balance0 &gt; _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;</span><br><span class="line">uint amount1In = balance1 &gt; _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;</span><br><span class="line">require(amount0In &gt; 0 || amount1In &gt; 0, &#x27;UniswapV2: INSUFFICIENT_INPUT_AMOUNT&#x27;);</span><br><span class="line">&#123; // scope for reserve&#123;0,1&#125;Adjusted, avoids stack too deep errors</span><br><span class="line">uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));  //减去手续费的数额，手续费是池子剩余余额的0.3%</span><br><span class="line">uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));</span><br><span class="line">require(balance0Adjusted.mul(balance1Adjusted) &gt;= uint(_reserve0).mul(_reserve1).mul(1000**2), &#x27;UniswapV2: K&#x27;); //x*y=k，交易后的k要不小于交易前的k</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可知，<code>swap</code>时，并没有把手续费分发给管理员或者搭建池子的人。而是保留在了池子中。具体的手续费计算，需要关注<code>_mintFee</code>方法，里面涉及到一系列的公式，比较复杂。下面章节中详细解释</p>
<h3 id="3-2-每次接收到mut后手续费的计算">3.2 每次接收到MUT后手续费的计算</h3>
<p>图中可知，0.003的手续费，最终分配给了<code>协议费账户(uni官方)</code>和<code>LP手续费账户(追加流动性用户)</code>。需要说明：</p>
<ol>
<li>每次swap，总手续费都会累加，并不分发（不分发是因为swap调用频次高，若每次都分发，gas扛不住。真正的分发都放在了<code>mint</code>或<code>burn</code>中，低频方法）</li>
<li><code>mint</code>或<code>burn</code>时，都会执行<code>_mintFee</code>方法，通过一系列的数学计算，将属于官方的手续费（LP）转移至官方指定账户。</li>
<li><code>mint</code>时，也就是客户追加了流动性。此时根据客户追加的各token比例，折算出对应的LP给到客户账户(此LP中包系统给的手续费，就是从累加的总手续费按相同比例折算的)。</li>
<li>这会儿的手续费是LP代币，分别在各自账户上。需要折现时，将LP转入合约账户，然后合约操作<code>burn</code>时，会将LP按比例折合成对应的两种token，分发给<code>burn</code>指定的账户。</li>
</ol>
<p><code>_mintFee</code>会划转1/6手续费(LP)到官方账户，先看看该方法代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) &#123;</span><br><span class="line">    address feeTo = IUniswapV2Factory(factory).feeTo();  //查看有没有设置手续费账户</span><br><span class="line">    feeOn = feeTo != address(0);</span><br><span class="line">    uint _kLast = kLast; // gas savings</span><br><span class="line">    if (feeOn) &#123;</span><br><span class="line">        if (_kLast != 0) &#123;</span><br><span class="line">            uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));</span><br><span class="line">            uint rootKLast = Math.sqrt(_kLast);</span><br><span class="line">            if (rootK &gt; rootKLast) &#123;</span><br><span class="line">                uint numerator = totalSupply.mul(rootK.sub(rootKLast));</span><br><span class="line">                uint denominator = rootK.mul(5).add(rootKLast);</span><br><span class="line">                uint liquidity = numerator / denominator;</span><br><span class="line">                if (liquidity &gt; 0) _mint(feeTo, liquidity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (_kLast != 0) &#123;</span><br><span class="line">        kLast = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mint 的数量 为什么是 (rootK - rootKLast)/(5 倍 rootK + 1 倍 rootKLast) 而不是 (rootK - rootKLast)/6 倍 rootKLast ? 通过下图, 看看要增发多少 lp, 使得 lp 分到的财富刚好是增量的 1/6:</p>
<img src="/articles/e04fabc2/2.png" class="" title="模拟计算手续费">
<p>如上图所示, 为了得到新增财富的 1/6, 需要增发的 lp 应该满足:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">lp/lp_supply = (∆/6) / [(∆5/6) + rootKLast ]</span><br></pre></td></tr></table></figure>
<p>这里 <code>∆ = rootK - rootKLast</code> 解出 ：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">lp = lp_supply * ∆ / (5rootK + rootKLast)</span><br></pre></td></tr></table></figure>
<p>与源代码的计算方法一致, 证实了 Uniswap 收取的协议手续费就是总手续费的 1/6.</p>
<p>需要知道每次池子LP的总量，图中没有提供，但思路基本一致。直接套用上面理论即可计算出官方手续费。网上还有另一种方式计算手续费，根据白皮书公式给的，看着有点绕，有兴趣可以看看：<a href="https://blog.csdn.net/sanqima/article/details/109667469">Uniswap V2里的手续费换算</a></p>
<h2 id="6-价格预言机">6. 价格预言机</h2>
<p>这个没有具体去研究，只记录下，在<code>_update</code>方法，会更新累积价格，用于具体的预言机计算，有兴趣的可以去研究下：<br>
price0CumulativeLast和price1CumulativeLast的价格累加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// update reserves and, on the first call per block, price accumulators</span><br><span class="line">function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 时间戳是uint256,只需要保留最低的32位即可，但不可直接强转。</span><br><span class="line">    uint32 blockTimestamp = uint32(block.timestamp % 2**32);</span><br><span class="line">    uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired</span><br><span class="line">    if (timeElapsed &gt; 0 &amp;&amp; _reserve0 != 0 &amp;&amp; _reserve1 != 0) &#123;</span><br><span class="line">        // 计算时间加权的累计价格，256位中，前112位用来存整数，后112位用来存小数，多的32位用来存溢出的值</span><br><span class="line">        // * never overflows, and + overflow is desired</span><br><span class="line">        price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;</span><br><span class="line">        price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    blockTimestampLast = blockTimestamp;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-uniswap-v2缺点">5. uniswap v2缺点</h2>
<ol>
<li>资金利用率低</li>
<li>用户承担无常损失的高风险</li>
<li>用户得到的手续费低</li>
<li>因此，出来了<code>uniswap v3</code></li>
</ol>
<p>关于<code>资金利用率</code>的问题，这里解释下：<br>
假设 ETH/DAI 交易对的实时价格为 1500 DAI/ETH，交易对的流动性池中共有资金：4500 DAI 和 3 ETH，根据 x⋅y=k，可以算出池内的 k 值：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">k= 4500×3 = 13500</span><br></pre></td></tr></table></figure>
<p>假设 x 表示 DAI，y 表示 ETH，即初始阶段 <code>x1=4500 , y1=3</code>，当价格下降到 1300 DAI/ETH 时：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">x2⋅y2=13500</span><br><span class="line">x2 / y2=1300</span><br><span class="line"></span><br><span class="line"># 得到：</span><br><span class="line">x2=4192.54</span><br><span class="line">y2=3.22</span><br></pre></td></tr></table></figure>
<p>资金利用率为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Δx = x1 - x2 </span><br><span class="line">Δx / x1 = 6.84%</span><br></pre></td></tr></table></figure>
<p>同样的计算方式，当价格变为 2200 DAI/ETH 时，资金利用率约为 <code>21.45%</code>.<br>
也就是说，在大部分的时间内池子中的资金利用与低于 25%. 这个问题对于稳定币池来说更加严重。</p>
<p>通俗来说，池子只是消耗了<code>Δx</code>资金，如果价格不会跌破1300，则剩下的x2资金永远不会用到，理论上讲，理想状态下，池子里只需要有<code>Δx</code>资金量就够了</p>
<p>因为资金使用率是v2最大的一个问题，如果不理解上面说的，这里再进一步解释下：</p>
<img src="/articles/e04fabc2/3.png" class="" title="uniswap v2 资金使用率">
<p>上图为资金池中的<code>x/y</code>(这比值其实表示两种币的币价，x对y的价格)的量变化曲线。资金池中的当前价格在c点，并且假设会在a价格点和b价格点之间波动。从c点向a点滑动，消耗最大<code>y_real</code>，从c点向b点滑动，消耗最大为<code>x_real</code>。也就是说，当前价格c点，在a点和b点之间震荡的话，最大只需要消耗<code>x_real</code>和<code>y_real</code>。理论上只要提供<code>x_real</code>和<code>y_real</code>就足够了。而事实上，如上图所示，在价格c点，分别提供了大于<code>x_real</code>和<code>y_real</code>的x和y。明显可以看出，<code>x-x_real</code>和<code>y-y_real</code>的资金在这种情况下是永远用不上的，也就称为闲置资金。<br>
在这种情况下，资金利用率为<code>x_real/x</code>或者<code>y_real/y</code>。如果价格波动非常小的话，资金利用率是非常低的。</p>
<h2 id="4-总结">4. 总结</h2>
<p>按我对源码的解读，核心内容，一个是计算兑换收益，一个是计算手续费。<br>
技术上，一个是结构分层设计，一个是为了节省gas消耗，而设计的手续费的分发实现。<br>
想要更好的理解uniswap v2，测试环境部署一个，然后来来回回反复操作理解吧。</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>DeFi</category>
        <category>Uniswap-V2</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Uniswap-V2</tag>
        <tag>DeFi</tag>
      </tags>
  </entry>
  <entry>
    <title>ink合约-psp37</title>
    <url>/articles/af47b345/</url>
    <content><![CDATA[<p>psp是ink合约生态参考erc标准制定的，psp37协议类似于erc1155。本文使用开源框架<a href="https://github.com/Supercolony-net/openbrush-contracts">openbrush-contracts</a>来讲解，该框架汇总并实现了ink中的主要应用协议，减少了自行开发的风险，同时减少了开发复杂度。</p>
<span id="more"></span>
<h2 id="1-概述">1. 概述</h2>
<p>psp37中，包含有4大扩展，可根据需要选择：</p>
<ol>
<li>psp37Batch：批处理转账</li>
<li>psp37Burnable：销毁token</li>
<li>psp37Enumerable：提高合约中token的可访问性</li>
<li>psp37Metadata：用于存储元数据，如symbol、name、uri等</li>
<li>psp37Mintable：生成新的token</li>
</ol>
<h2 id="2-协议说明">2. 协议说明</h2>
<h3 id="1-psp37基础方法">1. psp37基础方法</h3>
<ol>
<li>
<p>psp37::totalSupply(id)<br>
作用：<br>
获取指定id的总数量<br>
参数说明：<br>
id：指定id</p>
</li>
<li>
<p>psp37::balanceOf(ownerAccountId, id)<br>
作用：<br>
获取<code>账户A</code>指定id的数量<br>
参数说明：<br>
ownerAccountId：账户A<br>
id：指定id</p>
</li>
<li>
<p>psp37::allowance(ownerAccountId, operatorAccountId, id)<br>
作用：<br>
查看<code>账户A</code>授权给<code>账户B</code>指定id的可用数额还有多少<br>
参数说明：<br>
ownerAccountId：账户A<br>
operatorAccountId：账户B<br>
id：指定id</p>
</li>
<li>
<p>psp37::transfer(toAccountId, id, balance, data)<br>
作用：<br>
当前caller账户，将指定id的部分数额交易给<code>账户A</code><br>
参数说明：<br>
toAccountId：账户A<br>
id：指定id<br>
balance：要转账的数额<br>
data：附属信息，如备注等内容</p>
</li>
<li>
<p>psp37::transferFrom(fromAccountId, toAccountId, id, balance, data)<br>
作用：<br>
从<code>账户A</code>转账指定id的部分余额给<code>账户B</code><br>
参数说明：<br>
fromAccountId：账户A<br>
toAccountId：账户B<br>
id：指定id<br>
balance：要转账的余额<br>
data：附属信息，如备注等内容<br>
<code>备注</code>：该行为只能给合约管理员使用</p>
</li>
<li>
<p>psp37::approve(operatorAccountId, id, balance)<br>
作用：<br>
caller账户授权给<code>账户A</code>的指定id数额<br>
参数说明：<br>
operatorAccountId：账户A<br>
id：指定id<br>
balance：授权数额</p>
</li>
</ol>
<h3 id="2-psp37batch扩展方法">2. psp37Batch扩展方法</h3>
<ol>
<li>
<p>psp37Batch::batchTransfer(toAccountId, idsAndBalance, data)<br>
作用：<br>
caller账户批量转账id集合对应的数额给<code>账户A</code><br>
参数说明：<br>
toAccountId：账户A<br>
idsAndBalance：批量集合要转账的id及对应的数额<br>
data：附属信息，如备注等内容</p>
</li>
<li>
<p>psp37Batch::batchTransferFrom(fromAccountId, toAccountId, idsAndBalance, data)<br>
作用：<br>
<code>账户A</code>批量转账id集合对应的数额给<code>账户B</code><br>
参数说明：<br>
fromAccountId：账户A<br>
toAccountId：账户B<br>
idsAndBalance：批量集合要转账的id及对应的数额<br>
data：附属信息，如备注等内容</p>
</li>
</ol>
<h3 id="3-psp37burnable扩展方法">3. psp37Burnable扩展方法</h3>
<ol>
<li>psp37Burnable::burn(fromAccountId, idsAndBalance)<br>
作用：<br>
销毁<code>账户A</code>的集合id的对应指定余额<br>
参数说明：<br>
fromAccountId：账户A<br>
idsAndBalance：批量集合要销毁的id及对应的数额</li>
</ol>
<h3 id="4-psp37enumerable扩展方法">4. psp37Enumerable扩展方法</h3>
<ol>
<li>
<p>psp37Enumerable::ownersTokenByIndex(accountId, index)<br>
作用：<br>
返回<code>账户A</code>的索引号X拥有的id<br>
参数说明：<br>
ccountId: 账户A<br>
index：索引号X</p>
</li>
<li>
<p>psp37Enumerable::tokenByIndex(index)<br>
作用：<br>
返回索引号X拥有的id<br>
参数说明：<br>
index：索引号X</p>
</li>
</ol>
<p><code>说明</code>：按我理解，一个账户下的索引不能相同；而不同账户的索引，有可能相同</p>
<h3 id="5-psp37metadata扩展方法">5. psp37Metadata扩展方法</h3>
<ol>
<li>psp37Metadata::getAttribute(id,key)<br>
作用：<br>
根据id和key，获取参数<br>
参数说明：<br>
id：键1<br>
key：键2</li>
</ol>
<h3 id="6-psp37mintable扩展方法">6. psp37Mintable扩展方法</h3>
<ol>
<li>psp37Mintable::mint(accountId,idsAndBalance)<br>
作用：<br>
为<code>账户A</code>为集合id铸造指定的数额<br>
参数说明：<br>
accountId：账户A<br>
idsAndBalance：批量集合要铸造的id及对应的数额</li>
</ol>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://github.com/Supercolony-net/openbrush-contracts">openbrush-contracts合约开源框架</a><br>
[2] <a href="https://docs.openbrush.io/">openbrush-contracts文档</a><br>
[3] <a href="https://eips.ethereum.org/EIPS/eip-1155">EIP1155: Multi Token Standard</a></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Substrate</category>
        <category>ink合约</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>ink</tag>
      </tags>
  </entry>
  <entry>
    <title>ink合约-psp22</title>
    <url>/articles/c636768b/</url>
    <content><![CDATA[<p>psp是ink合约生态参考erc标准制定的，psp22协议类似于erc20。本文使用开源框架<a href="https://github.com/Supercolony-net/openbrush-contracts">openbrush-contracts</a>来讲解，该框架汇总并实现了ink中的主要应用协议，减少了自行开发的风险，同时减少了开发复杂度。</p>
<span id="more"></span>
<h2 id="1-概述">1. 概述</h2>
<p>psp22中，包含有4大扩展，可根据需要选择：</p>
<ol>
<li>psp22Burnable：销毁token</li>
<li>psp22Capped：新增token总上限，说白了就是用于mint增发</li>
<li>psp22Metadata：用于存储元数据，如symbol、name、uri等</li>
<li>psp22Mintable：生成新的token</li>
<li>psp22Wrapper：质押挖矿</li>
</ol>
<h2 id="2-协议说明">2. 协议说明</h2>
<h3 id="1-psp22基础方法">1. psp22基础方法</h3>
<ol>
<li>
<p>psp22::totalSupply()<br>
作用：<br>
获取总供应量<br>
参数说明：<br>
无</p>
</li>
<li>
<p>psp22::balanceOf(ownerAccountId)<br>
作用：<br>
获取<code>账户A</code>的余额<br>
参数说明：<br>
ownerAccountId：账户A</p>
</li>
<li>
<p>psp22::allowance(ownerAccountId, spenderAccountId)<br>
作用：<br>
查看<code>账户A</code>授权给<code>账户B</code>的可用余额还有多少<br>
参数说明：<br>
ownerAccountId：账户A<br>
spenderAccountId：账户B</p>
</li>
<li>
<p>psp22::transfer(toAccountId, balance, data)<br>
作用：<br>
当前caller账户，将指定balance交易给<code>账户A</code><br>
参数说明：<br>
toAccountId：账户A<br>
balance：要转账的余额<br>
data：附属信息，如备注等内容</p>
</li>
<li>
<p>psp22::transferFrom(fromAccountId, toAccountId, balance, data)<br>
作用：<br>
从账户A转账余额给账户B<br>
参数说明：<br>
fromAccountId：账户A<br>
toAccountId：账户B<br>
balance：要转账的余额<br>
data：附属信息，如备注等内容<br>
<code>备注</code>：该行为只能给合约管理员使用</p>
</li>
<li>
<p>psp22::approve(spenderAccountId,balance)<br>
作用：<br>
caller账户授权给<code>账户A</code>指定余额<br>
参数说明：<br>
spenderAccountId：账户A<br>
balance：授权指定余额</p>
</li>
<li>
<p>psp22::increaseAllowance(spenderAccountId,balance)<br>
作用：<br>
caller账户给<code>账户A</code>新增授权余额<br>
参数说明：<br>
spenderAccountId：账户A<br>
balance：新增的授权余额</p>
</li>
<li>
<p>psp22::decreaseAllowance(spenderAccountId,balance)<br>
作用：<br>
caller账户给<code>账户A</code>降低授权余额<br>
参数说明：<br>
spenderAccountId：账户A<br>
balance：降低的授权余额</p>
</li>
</ol>
<h3 id="2-psp22burnable扩展方法">2. psp22Burnable扩展方法</h3>
<ol>
<li>psp22Burnable::burn(accountId, balance)<br>
作用：<br>
销毁<code>账户A</code>的指定余额<br>
参数说明：<br>
accountId：账户A<br>
balance：指定余额</li>
</ol>
<h3 id="3-psp22capped扩展方法">3. psp22Capped扩展方法</h3>
<ol>
<li>psp22Capped::cap()<br>
作用：<br>
获取总容量<br>
参数说明：<br>
无</li>
</ol>
<h3 id="4-psp22metadata扩展方法">4. psp22Metadata扩展方法</h3>
<ol>
<li>
<p>psp22Metadata::tokenName()<br>
作用：<br>
获取token名称<br>
参数说明：<br>
无</p>
</li>
<li>
<p>psp22Metadata::tokenSymbol()<br>
作用：<br>
获取token标识<br>
参数说明：<br>
无</p>
</li>
<li>
<p>psp22Metadata::tokenDecimals()<br>
作用：<br>
获取token精确度<br>
参数说明：<br>
无</p>
</li>
</ol>
<h3 id="5-psp22mintable扩展方法">5. psp22Mintable扩展方法</h3>
<ol>
<li>psp22Mintable::mint(accountId,balance)<br>
作用：<br>
为<code>账户A</code>铸造指定数量的token<br>
参数说明：<br>
accountId：账户A<br>
balance：成果铸造的数额</li>
</ol>
<h3 id="6-psp22wrapper扩展方法">6. psp22Wrapper扩展方法</h3>
<h4 id="6-1-概述">6.1 概述</h4>
<p>简单来说，就是质押挖矿。质押一定数量的<code>链token</code>，然后获取一定数量的合约币</p>
<h4 id="6-2-方法说明">6.2 方法说明</h4>
<ol>
<li>
<p>psp22Wrapper::depositFor(accountId,balance)<br>
作用：<br>
caller账户质押指定数量的token，挖到的收益，转给<code>账户A</code><br>
参数说明：<br>
accountId：账户A<br>
balance：质押的token</p>
</li>
<li>
<p>psp22Wrapper::withdrawTo(accountId,balance)<br>
作用：<br>
提取质押的token到<code>账户A</code><br>
参数说明：<br>
accountId：账户A<br>
balance：要提取的质押的token</p>
</li>
</ol>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://github.com/Supercolony-net/openbrush-contracts">openbrush-contracts合约开源框架</a><br>
[2] <a href="https://docs.openbrush.io/">openbrush-contracts文档</a><br>
[3] <a href="https://eips.ethereum.org/EIPS/eip-20">EIP-20: Token Standard</a></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Substrate</category>
        <category>ink合约</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>ink</tag>
      </tags>
  </entry>
  <entry>
    <title>ink合约-psp34</title>
    <url>/articles/364ee2ff/</url>
    <content><![CDATA[<p>psp是ink合约生态参考erc标准制定的，psp34协议类似于erc721。本文使用开源框架<a href="https://github.com/Supercolony-net/openbrush-contracts">openbrush-contracts</a>来讲解，该框架汇总并实现了ink中的主要应用协议，减少了自行开发的风险，同时减少了开发复杂度。</p>
<span id="more"></span>
<h2 id="1-概述">1. 概述</h2>
<p>psp34中，包含有4大扩展，可根据需要选择：</p>
<ol>
<li>psp34Burnable：销毁token</li>
<li>psp34Mintable：生成新的token</li>
<li>psp34Enumerable：提高合约中token的可访问性</li>
<li>psp34Metadata：用于存储元数据，如symbol、name、uri等</li>
</ol>
<h2 id="2-协议说明">2. 协议说明</h2>
<h3 id="1-psp34基础方法">1. psp34基础方法</h3>
<ol>
<li>
<p>psp34::allowance(ownerAccountId, operatorAccountId, tokenId)<br>
作用：<br>
查看<code>账户A</code>是否将某token的操作权限授权给<code>账户B</code><br>
参数说明：<br>
ownerAccountId：账户A<br>
operatorAccountId：账户B<br>
tokenId：要授权的token编号</p>
</li>
<li>
<p>psp34::ownerOf(tokenId)<br>
作用：<br>
指定的token是属于哪个用户的<br>
参数说明：<br>
tokenId：指定的token编号</p>
</li>
<li>
<p>psp34::approve(operatorAccountId, tokenId, approved)<br>
作用：<br>
当前账户A，将指定token授权或者取消授权<code>账户B</code><br>
参数说明：<br>
operatorAccountId：账户B<br>
tokenId：要授权或取消授权的token编号<br>
approved：是否授权<br>
<code>安全问题</code>：将token授权给账户B，归属权仍然在原账户A，如果账户B将该token转账给账户C，则归属权就变成账户C了，因此该授权要注意。</p>
</li>
<li>
<p>psp34::transfer(toAccountId, tokenId, data: Vec<u8>)<br>
作用：<br>
当前账户A，将指定token交易给<code>账户B</code><br>
参数说明：<br>
toAccountId：账户B<br>
tokenId：要交易的token编号<br>
data：附属信息，如备注等内容</p>
</li>
<li>
<p>psp34::collectionId()<br>
作用：<br>
获取当前合约ID<br>
参数说明：<br>
无参数</p>
</li>
<li>
<p>psp34::totalSupply()<br>
作用：<br>
获取token总供应量<br>
参数说明：<br>
无参数</p>
</li>
<li>
<p>psp34::balanceOf(ownerAccountId)<br>
作用：<br>
指定账户拥有的token数量<br>
参数说明：<br>
ownerAccountId:指定账户</p>
</li>
</ol>
<h3 id="2-psp34burnable扩展方法">2. psp34Burnable扩展方法</h3>
<ol>
<li>psp34Burnable::burn(accountId, tokenId)<br>
作用：<br>
销毁账户A指定的token<br>
参数说明：<br>
accountId：账户A<br>
tokenId：token编号<br>
备注：这个需要合约管理人可以操作</li>
</ol>
<h3 id="3-psp34mintable扩展方法">3. psp34Mintable扩展方法</h3>
<ol>
<li>psp34Mintable::mint(accountId, tokenId)<br>
作用：<br>
为<code>账户A</code>mint指定编号的token<br>
参数说明：<br>
accountId：账户A<br>
tokenId：token编号</li>
</ol>
<h3 id="4-psp34enumerable扩展方法">4. psp34Enumerable扩展方法</h3>
<ol>
<li>
<p>psp34Enumerable::ownersTokenByIndex(accountId, index)<br>
作用：<br>
返回账户A的索引号X拥有的所有token<br>
参数说明：<br>
accountId: 账户<br>
index：索引号X。一个用户不同索引号，可以挂不同token</p>
</li>
<li>
<p>psp34Enumerable::tokenByIndex(index)<br>
作用：<br>
返回索引号X拥有的所有token<br>
参数说明：<br>
index：索引号X</p>
</li>
</ol>
<p><code>说明</code>：按我理解，一个账户下的索引不能相同；而不同账户的索引，有可能相同</p>
<h3 id="5-psp34metadata扩展方法">5. psp34Metadata扩展方法</h3>
<ol>
<li>psp34Metadata::getAttribute(id,key)<br>
作用：<br>
根据id和key，获取参数<br>
参数说明：<br>
id：键1<br>
key：键2</li>
</ol>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://github.com/Supercolony-net/openbrush-contracts">openbrush-contracts合约开源框架</a><br>
[2] <a href="https://docs.openbrush.io/">openbrush-contracts文档</a><br>
[3] <a href="https://blog.csdn.net/watson2017/article/details/122178880">ERC-721详解</a><br>
[4] <a href="https://eips.ethereum.org/EIPS/eip-721">EIP721: Non-Fungible Token Standard</a></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Substrate</category>
        <category>ink合约</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>ink</tag>
      </tags>
  </entry>
  <entry>
    <title>ink合约-主要协议汇总(1)</title>
    <url>/articles/9fc0f7cc/</url>
    <content><![CDATA[<p>对标以太坊的一些应用协议，方便辅助ink!合约的实现。这些协议均已在<a href="https://github.com/Supercolony-net/openbrush-contracts">openbrush-contracts</a> 中实现</p>
<span id="more"></span>
<h2 id="1-概述">1. 概述</h2>
<ol>
<li>Ownerable：权限，主要是针对超级管理员的行为管理</li>
<li>AccessControl：账户角色控制，链上角色管理。满足通过角色控制方法的需要。</li>
<li>PaymentSplitter：用来实现给某一个群体进行<code>链token</code>支付</li>
<li>Pausable：可控制全局暂停或启动</li>
<li>TimelockController：时间锁</li>
<li>Proxy：用于更新合约的协议</li>
<li>Diamond：用于更新合约的另一种协议，可以同时集成多种合约和指定方法</li>
<li>ReentrancyGuard：防止调用合约的重入攻击</li>
<li>Flashmint：闪电贷-贷款放贷方以及贷款接收方</li>
</ol>
<h2 id="2-协议说明">2. 协议说明</h2>
<h3 id="1-ownerable协议">1. Ownerable协议</h3>
<ol>
<li>
<p>ownable::owner()<br>
作用：<br>
获取当前合约管理人地址<br>
参数说明：<br>
无参数</p>
</li>
<li>
<p>ownable::transferOwnership(newOwnerAccountId)<br>
作用：<br>
变更合约账户所有权<br>
参数说明：<br>
newOwnerAccountId：新的管理账户ID</p>
</li>
<li>
<p>ownable::renounceOwnership()<br>
作用：<br>
放弃合约所有权<br>
参数说明：<br>
无</p>
</li>
</ol>
<h3 id="2-accesscontrol协议">2. AccessControl协议</h3>
<p>备注：默认role=0表示内置管理员账户</p>
<ol>
<li>
<p>accessControl::hasRole(roleType，accountId)<br>
作用：<br>
指定<code>账户A</code>是否设置了指定<code>角色R</code><br>
参数说明：<br>
roleType：指定角色R<br>
accountId：指定账户A</p>
</li>
<li>
<p>accessControl::getRoleAdmin(roleType)<br>
作用：<br>
获取指定role的上级管理员角色<br>
参数说明：<br>
roleType：指定role</p>
</li>
<li>
<p>accessControl::grantRole(roleType,accountId)<br>
作用：<br>
为指定<code>账户A</code>设置<code>角色R</code>，拥有角色的人，才可以使用该方法，安全起见，该方法需要做严格检测，<code>可以为一个账户设置多个不同角色</code><br>
参数说明：<br>
roleType：指定角色R<br>
accountId：指定账户A<br>
注：该方法要么仅可初始化调用，要么对外开放时，限制只有ownerable或者admin可用</p>
</li>
<li>
<p>accessControl::revokeRole(roleType,accountId)<br>
作用：<br>
撤销<code>账户A</code>的<code>角色R</code>，拥有角色的人，才可以使用该方法，安全起见，该方法需要做严格检测<br>
参数说明：<br>
roleType：指定角色R<br>
accountId：指定账户A</p>
</li>
<li>
<p>accessControl::renounceRole(roleType,accountId)<br>
作用：<br>
撤销当前账户的角色，主要是由于自己账号导致合约危险时，可快速撤销自己的<code>角色R</code>。<br>
参数说明：<br>
roleType：指定角色R<br>
accountId：当前正在操作该方法的账户（caller）</p>
</li>
</ol>
<h3 id="3-pausable协议">3. Pausable协议</h3>
<p>备注：可控制全局暂停或启动，如使用<code>#[openbrush::modifiers(when_not_paused)]</code>则只有暂停时才能调用该宏之后的方法</p>
<ol>
<li>
<p>pausable::pause()<br>
作用：<br>
暂停<br>
参数说明：<br>
无</p>
</li>
<li>
<p>pausable::unpause()<br>
作用：<br>
取消暂停<br>
参数说明：<br>
无</p>
</li>
<li>
<p>pausable::changeState()<br>
作用：<br>
变更状态<br>
参数说明：<br>
无</p>
</li>
</ol>
<h3 id="4-paymentsplitter协议">4. PaymentSplitter协议</h3>
<h4 id="4-1-功能说明">4.1 功能说明</h4>
<p>caller用来实现给某一个群体进行<code>链token</code>支付（合约初始化时，传入多个账户以及对应的份额，根据所占有的份额比例进行分配<code>链token</code>）。合约构建时需要指定payees（即支付的所有对象），以及shares（即每个payee的支付份额）。支付使用pull的形式，即payee地址需要自己调用release函数来获得支付：</p>
<ol>
<li>需要先通过<code>receive</code>方法将<code>链token</code>充值到合约中，可以重复多次充入</li>
<li>使用<code>release</code>方法将合约中的<code>链token</code>按合约初始化时账户的分配比例进行支付，为防止理解错误，这里做详细解释
<ol>
<li>假如<code>receive</code>了3次，分别是：10、20、30，同时假设账户A份额所占比例为20%，则对账户A调用<code>release</code>后，账户A可一次性获得token数量为：2+4+6=12个</li>
<li>假如<code>receive</code>了1次，充入10，同时假设账户A份额所占比例为20%，则对账户A调用<code>release</code>后，账户A可一次性获得token数量为：2个；然后继续<code>receive</code>了2次，分别充入20，30，则对账户A调用<code>release</code>后，账户A可一次性获得token数量为：4+6=10个；也就是说，第一次充入的不再参与分配，最终账户A依旧拿到12个</li>
</ol>
</li>
<li>注意，份额不是token数量，只是用于区分所有账户中，不同账户分别占有多少比例，用于后续按比例分配token</li>
</ol>
<h4 id="4-2-涉及方法">4.2 涉及方法</h4>
<ol>
<li>
<p>paymentSplitter::totalShares()<br>
作用：<br>
获取所有用户要支付的份额<br>
参数说明：<br>
无</p>
</li>
<li>
<p>paymentSplitter::totalReleased()<br>
作用：<br>
所有已经分配出去的<code>链token</code>数量<br>
参数说明：<br>
无</p>
</li>
<li>
<p>paymentSplitter::shares(accountId)<br>
作用：<br>
获取<code>账户A</code>应该所占有的份额<br>
参数说明：<br>
accountId：账户A</p>
</li>
<li>
<p>paymentSplitter::released(accountId)<br>
作用：<br>
查看<code>账户A</code>已接收到多少<code>链token</code><br>
参数说明：<br>
accountId：账户A</p>
</li>
<li>
<p>paymentSplitter::payee(index)<br>
作用：<br>
根据集合（一般合约初始化会传入一个数据集合，其中包含账户和份额）索引号获取当前索引号对应的账户地址<br>
参数说明：<br>
index：索引号</p>
</li>
<li>
<p>paymentSplitter::receive()<br>
作用：<br>
使用caller将<code>链token</code>传入合约账户<br>
参数说明：<br>
无</p>
</li>
<li>
<p>paymentSplitter::release(accountId)<br>
作用：<br>
caller根据<code>账户A</code>份额所占有的比例，将合约中的token一次性支付给<code>账户A</code><br>
参数说明：<br>
accountId：账户A</p>
</li>
</ol>
<h3 id="5-timelockcontroller协议">5. TimelockController协议</h3>
<h4 id="5-1-功能说明">5.1 功能说明</h4>
<ol>
<li>TimelockController是一个被提议者和执行者管理的代理。它能确保操作被延迟。这种延迟可以确保用户对智能合约的操作被审计或检查。</li>
<li>默认情况下，TimelockController已部署的地址通过时间同步获得管理员权限。这个角色授权指派到提议者、执行者或其他管理员。</li>
<li>TimelockController配置中指派至少一个提议者和一个执行者。可以在构造时执行，也可以稍后通过任何管理员角色指定。这些角色不是独占的，意味着一个账户可以同时有两个角色。</li>
<li>可以合约初始化时，传入：minDelay（最小延迟时间）、proposers（提议者）、executors（执行者）</li>
<li><code>需要依赖AccessControl扩展</code>，该扩展在上文已经介绍过了，本节只讲解<code>TimelockController</code></li>
<li>大体逻辑：一笔待交易数据生成一个id，叫做活动ID，给活动设置时间，然后启动执行等。</li>
</ol>
<h4 id="5-2-涉及方法">5.2 涉及方法</h4>
<ol>
<li>
<p>timelockController::isOperation(OperationId)<br>
作用：<br>
根据活动ID检查该交易执行设置的时间是否大于0，若大于0则是一个正常的活动<br>
参数说明：<br>
OperationId：活动ID</p>
</li>
<li>
<p>timelockController::isOperationPending(OperationId)<br>
作用：<br>
根据活动ID检查交易是否在pending状态，若该交易执行设置的时间大于1，则该活动pending状态<br>
参数说明：<br>
OperationId：活动ID</p>
</li>
<li>
<p>timelockController::isOperationReady(OperationId)<br>
作用：<br>
根据活动ID检查交易是否在ready状态，若该交易执行设置的时间大于等于当前块时间，则该活动ready状态<br>
参数说明：<br>
OperationId：活动ID</p>
</li>
<li>
<p>timelockController::isOperationDone(OperationId)<br>
作用：<br>
根据活动ID检查交易是否执行完毕，若为1则表示执行完毕。注：活动执行完毕后，该活动的执行时间会被设置为1。<br>
参数说明：<br>
OperationId：活动ID</p>
</li>
<li>
<p>timelockController::getTimestamp(OperationId)<br>
作用：<br>
获取要执行活动的时间<br>
参数说明：<br>
OperationId：活动ID</p>
</li>
<li>
<p>timelockController::getMinDelay()<br>
作用：<br>
获取最小延迟时间<br>
参数说明：<br>
无</p>
</li>
<li>
<p>timelockController::hashOperation(transaction,predecessor,salt)<br>
作用：<br>
将一笔待执行的交易信息生成一个hash值，也就是活动ID<br>
参数说明：<br>
transaction：一笔交易信息<br>
predecessor：未知，也是生成hash必要的<br>
salt：生成hash的参数</p>
</li>
<li>
<p>timelockController::hashOperationBatch(transactions,predecessor,salt)<br>
作用：<br>
将多笔待执行的交易信息对应生成多个hash值，也就是对应多个活动ID<br>
参数说明：<br>
transactions：批量交易信息<br>
predecessor：未知，也是生成hash必要的<br>
salt：生成hash的参数<br>
<code>注</code>：参数用于实时生成活动ID</p>
</li>
<li>
<p>timelockController::schedule(transaction,predecessor,salt,delay)<br>
作用：<br>
为要执行的一笔交易定时，也就是设置日程<br>
参数说明：<br>
transaction：一笔交易信息<br>
predecessor：未知，也是生成hash必要的<br>
salt：生成hash的参数<br>
delay：设置延迟时间，要比minDelay大<br>
<code>注</code>：参数用于实时生成活动ID</p>
</li>
<li>
<p>timelockController::scheduleBatch(transactions,predecessor,salt,delay)<br>
作用：<br>
为要执行的批量交易定时，也就是设置日程，进入pending状态<br>
参数说明：<br>
transactions：批量交易信息<br>
predecessor：未知，也是生成hash必要的<br>
salt：生成hash的参数<br>
delay：设置延迟时间，要比minDelay大<br>
<code>注</code>：参数用于实时生成活动ID</p>
</li>
<li>
<p>timelockController::cancel(OperationId)<br>
作用：<br>
取消要执行的交易，该交易必须在pending状态<br>
参数说明：<br>
OperationId：由交易生成的ID</p>
</li>
<li>
<p>timelockController::execute(transaction,predecessor,salt)<br>
作用：<br>
执行一笔pending状态的交易<br>
参数说明：<br>
transaction：交易数据<br>
predecessor：未知，也是生成hash必要的<br>
salt：生成hash的参数<br>
<code>注</code>：参数用于实时生成活动ID</p>
</li>
<li>
<p>timelockController::executeBatch(transactions,predecessor,salt)<br>
作用：<br>
批量执行pending状态的交易<br>
参数说明：<br>
transactions：批量交易数据<br>
predecessor：未知，也是生成hash必要的<br>
salt：生成hash的参数<br>
<code>注</code>：参数用于实时生成活动ID</p>
</li>
<li>
<p>timelockController::updateDelay(newDelay)<br>
作用：<br>
更新最小延迟时间。内部提供的默认方法中，只有合约自身的账户（不是创建合约的账户）可以调用该方法，可防止外部合约攻击。<br>
参数说明：<br>
newDelay：更新最小延迟时间</p>
</li>
</ol>
<h3 id="6-proxy协议">6. Proxy协议</h3>
<p>可升级的合约，入口为proxy的合约地址，通过来回切换proxy合约的abi以及业务合约的abi，来升级合约。<br>
可以确保数据不丢失，也不用迁移。<br>
每个合约文件都必须传到链上，proxy的changeDelegateCode传入需要执行的合约hash，然后传入abi，才能正常执行代理合约</p>
<h4 id="6-1-使用说明">6.1 使用说明</h4>
<p>需要在polkadot-app中使用：<br>
Steps I followed:</p>
<ol>
<li>upload and deploy psp22_upgradeable contract ( contract-to-be-proxied v1)</li>
<li>upload and deploy proxy with code hash from step1 as constructor argument (one could set it using the proxy’s method as well)</li>
<li>use a “Add existing contract” button to swap Proxy’s ABI (input proxy’s address + contract-to-be-proxied v1 address)</li>
<li>boom - it works</li>
</ol>
<p>To upgrade contract:</p>
<ol>
<li>upload new code</li>
<li>change proxy’s ABI via “Add an existing contract” button</li>
<li>use change_delegate_code (or sth like that) to enter new contract’s code hash</li>
<li>change proxy’s ABI again via “Add an existing contract” button</li>
<li>boom it works</li>
</ol>
<h4 id="6-2-方法说明">6.2 方法说明</h4>
<ol>
<li>
<p>proxy::getDelegateCode()<br>
作用：<br>
获取当前代理合约码<br>
参数说明：<br>
无</p>
</li>
<li>
<p>proxy::changeDelegateCode(newCodeHash)<br>
作用：<br>
修改代理合约码<br>
参数说明：<br>
newCodeHash：新的合约码</p>
</li>
</ol>
<h3 id="7-diamond协议">7. Diamond协议</h3>
<h4 id="7-1-概述">7.1 概述</h4>
<p>diamondCut函数是用来合约升级的函数，可以增加，替代和删除钻石合约里的任意函数 。它接收一个bytes[]类型的参数输入，指明修改内部映射表所需要的方法-钻石面对。比如，调用diamondCut函数可以一次性在一个交易里增加2个新函数，替换3个函数并且删除4个函数。同时diamondCut函数可以触发事件，记录所有的增加，替换和删除。</p>
<p>放大镜（The Loupe）是用来查询钻石合约的内部状况。钻石合约提供4个函数来提供钻石合约当前存储的函数和钻石面。这些函数被统称为放大镜。所有的钻石合约都必须实现这些函数</p>
<p>一个钻石面：可以理解成是一个合约</p>
<h4 id="7-2-方法说明">7.2 方法说明</h4>
<ol>
<li>
<p>diamond::diamondCut (cuts, init)<br>
作用：<br>
增加，替代和删除钻石合约里的任意函数<br>
参数说明：<br>
cuts：FacetCut集合，一个FacetCut（钻石面）中，包含有一个合约hash，以及多个selector(即方法对应的编号，可以在metadata.json中找到)<br>
init：可以初始化<code>cuts</code>中传入的合约的方法</p>
</li>
<li>
<p>diamondLoupe::facets()<br>
作用：<br>
返回所有的钻石面的结构，就是<code>FacetCut</code>集合<br>
参数说明：<br>
无</p>
</li>
<li>
<p>diamondLoupe::facetFunctionSelectors(facet)<br>
作用：<br>
返回指定钻石面（合约）的方法<br>
参数说明：<br>
facet：指定的钻石面hash值（即合约的hash值）</p>
</li>
<li>
<p>diamondLoupe::facetCodeHashes()<br>
作用：<br>
返回所有钻石面的地址，即所有合约的地址<br>
参数说明：<br>
无</p>
</li>
<li>
<p>diamondLoupe::facetCodeHash(selector)<br>
作用：<br>
返回selector所对应的钻石面的hash，即对应合约的hash<br>
参数说明：<br>
selector：合约中对应的一个方法的编号</p>
</li>
</ol>
<h3 id="8-reentrancyguard协议">8. ReentrancyGuard协议</h3>
<h4 id="8-1-概述">8.1 概述</h4>
<p>重入攻击是由于智能合约调用了外部不安全合约，或者对外发送以太币，使得合约的外部调用能够被劫持，导致合约内的方法被外部合约递归调用<br>
形成重入攻击有如下条件：</p>
<ol>
<li>调用了外部不安全合约</li>
<li>使用了不安全的转账方式，未进行gas限制。</li>
<li>状态变量修改在合约交互之后</li>
</ol>
<p>用openbrush的话来说，就是防止合约直接或者间接的调用自身。不允许被标记<code>non_reentrant</code>的方法去调用另一个被标记<code>non_reentrant</code>的方法</p>
<h4 id="8-2-方法说明">8.2 方法说明</h4>
<p>其实只是宏注解，在需要防止重入攻击的方法上面加上<code>#[openbrush::modifiers(non_reentrant)]</code></p>
<h3 id="9-flashmint闪电贷协议">9. Flashmint闪电贷协议</h3>
<p>分为贷款放贷方和贷款发起方，<code>看着不怎么好用</code>。就是快速交换资产。要在一个块中完成交易，也就是短时间内完成交易。<br>
闪电贷是一种关于 DeFi无抵押贷款的新思路，所有操作都在一笔交易（一个区块）中完成，它允许借款人无需抵押资产即可实现借贷（但需支付额外较少费用）<br>
<code>备注</code>：虽然这里记录了闪电贷的主要方法，但我还是没看懂怎么个用法，暂时先不管了，后续理解了，再详细描述</p>
<h4 id="9-1-贷款放贷方须实现">9.1 贷款放贷方须实现</h4>
<ol>
<li>
<p>flashLender::flashloan(receiverAccountId, tokenAccountId, balance)<br>
作用：<br>
<code>账户A</code>从<code>账户B</code>闪电贷指定余额，该函数必须包括对FlashBorrower(贷款接收方)合约中onFlashLoan()的回调。<br>
参数说明：<br>
receiverAccountId：账户A<br>
tokenAccountId：账户B<br>
balance：借贷指定余额</p>
</li>
<li>
<p>flashLender::maxFlashloan(tokenAccountId)<br>
作用：<br>
<code>账户A</code>最大可借贷数量。返回对应<code>账户A</code>可闪电贷的最大数量，如果对应<code>账户A</code>不支持闪电贷，那么返回0<br>
参数说明：<br>
tokenAccountId：账户A</p>
</li>
<li>
<p>flashLender::flashFee(tokenAccountId, balance)<br>
作用：<br>
<code>账户A</code>闪电贷金额所需要收取的手续费，<code>该方法调用后，方可放行贷款</code><br>
参数说明：<br>
tokenAccountId：账户A<br>
balance：贷款金额</p>
</li>
</ol>
<h4 id="9-2-贷款接收方须实现">9.2 贷款接收方须实现</h4>
<ol>
<li>flashBorrower::onFlashloan(initiatorAccountId,tokenAccountId,amountBalance,feeBalance,data)<br>
作用：贷款发起方发起借贷，使用<code>账户A</code>从<code>账户B</code>借贷指定余额amountBalance，约定还款时额外支付利息feeBalance<br>
参数说明：<br>
initiatorAccountId：账户A<br>
tokenAccountId：账户B<br>
amountBalance：借贷余额<br>
feeBalance：总利息<br>
data：额外数据（类似备注）</li>
</ol>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://github.com/Supercolony-net/openbrush-contracts">openbrush-contracts合约开源框架</a><br>
[2] <a href="https://docs.openbrush.io/">openbrush-contracts文档</a><br>
[4] <a href="https://blog.csdn.net/Linxiaoyu2022/article/details/125776328">从The Saudis NFT事件浅析EIP-2535钻石协议</a><br>
[5] <a href="https://www.jianshu.com/p/7268962320af">钻石标准–Diamond Standard</a><br>
[6] <a href="https://blog.csdn.net/jaychois/article/details/125809274">智能合约安全之重入攻击浅析</a><br>
[7] <a href="https://eips.ethereum.org/EIPS/eip-3156">EIP-3156: Flash Loans</a><br>
[8] <a href="https://zhuanlan.zhihu.com/p/458010233">去中心化金融(DeFi)和闪电贷(Flash Loan)</a></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Substrate</category>
        <category>ink合约</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>ink</tag>
      </tags>
  </entry>
  <entry>
    <title>phala关于质押衰减计算模型提议</title>
    <url>/articles/ecb6d3eb/</url>
    <content><![CDATA[<p>phala关于质押衰减计算模型提议</p>
<span id="more"></span>  
<h2 id="概述">概述</h2>
<p>随着PHA价格的大幅波动，现有质押池机制下，高成本成了矿工不得不面对的问题，进而产生的高风险也阻止了矿工扩张的意愿。<br>
为此，从长远考虑，本文针对<code>worker设备</code>在收益不减的情况下质押衰减，给出如下提议，欢迎大家讨论。</p>
<h2 id="模型">模型</h2>
<ol>
<li>增加纬度系数：质押周期(天数) <code>cycleDays</code>、掉线质押保持天数<code>keepDays</code><br>
说明：
<ol>
<li>如果worker每连续<code>cycleDays</code>天均是mining，则可按下方公式进行质押衰减，收益不减
<ol>
<li>衰减的质押在当前worker中设置一字段，标记为累计可衰减数额，矿工可手动将该数额一次性claim到质押池free中。</li>
</ol>
</li>
<li>如果worker出现异常
<ol>
<li><code>cycleDays</code>重置为0，等待worker恢复mining后按上文执行。</li>
<li>同时开始计数worker异常天数<code>keepDays</code>，若<code>keepDays</code>时间内worker恢复正常，则依旧使用衰减后的质押产生高收益；否则按照官方当前质押经济模型来产生收益。</li>
</ol>
</li>
<li>若新增质押，则worker质押模型重置为官方当前质押经济模型，然后再按规则进行衰减</li>
</ol>
</li>
<li>公式</li>
</ol>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>k</mi><msub><mi>e</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub><mo>=</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>k</mi><msub><mi>e</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub><mo>−</mo><mfrac><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>k</mi><msub><mi>e</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub><mo>−</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>k</mi><msub><mi>e</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><mi>α</mi></mfrac><mspace width="1em"/><mspace width="1em"/><mi>s</mi><mi>t</mi><mi>a</mi><mi>k</mi><msub><mi>e</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub><mo>−</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>k</mi><msub><mi>e</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>≥</mo><mi>α</mi><mo separator="true">,</mo><mi>α</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">stake_{new} = stake_{old} -  \frac{stake_{old}-stake_{min}}{\alpha} \quad\quad  stake_{old}-stake_{min} \ge \alpha , \alpha \gt 1 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p>其中：<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>k</mi><msub><mi>e</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">stake_{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ：表示当前worker更新衰减后的质押值<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>k</mi><msub><mi>e</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">stake_{old}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ：表示当前worker实际已质押值<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>k</mi><msub><mi>e</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">stake_{min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ：表示当前worker最小质押值<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span> ：衰减系数，可控制衰减速度，须大于1，社区可讨论设置</p>
<p>具体公式优势，下文继续详解</p>
<h2 id="事例说明">事例说明</h2>
<p>假设当前worker质押17000，最小质押3000，衰减系数分别设置为：2,3,4<br>
符合衰减条件后，假设进行4次衰减，按公式不同系数衰减结果如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">系数为2</span><br><span class="line">第一次衰减后worker质押：10000</span><br><span class="line">第二次衰减后worker质押：6500</span><br><span class="line">第三次衰减后worker质押：4750</span><br><span class="line">第四次衰减后worker质押：3875</span><br><span class="line"></span><br><span class="line">系数为4</span><br><span class="line">第一次衰减后worker质押：13500</span><br><span class="line">第二次衰减后worker质押：10875</span><br><span class="line">第三次衰减后worker质押：8906.25</span><br><span class="line">第四次衰减后worker质押：7429.6875</span><br><span class="line"></span><br><span class="line">系数为6</span><br><span class="line">第一次衰减后worker质押：14666.66</span><br><span class="line">第二次衰减后worker质押：12722.21</span><br><span class="line">第三次衰减后worker质押：11101.84</span><br><span class="line">第四次衰减后worker质押：9751.53</span><br></pre></td></tr></table></figure>
<p>从中可看出，系数越大，worker的质押衰减越慢，也就是每次释放出来的质押越少。直到达到公式边际条件后，停止衰减。</p>
<h2 id="优势">优势</h2>
<p>本文提议的主要优势如下：</p>
<ol>
<li>新增设备：衰减出来的质押，矿工可以用来新增worker节点，提升云计算规模</li>
<li>提升流转率：质押币的流转速率改变，有益于市场换手，</li>
<li>筛选长期价值生态支持厂商，</li>
<li>促进应用生态建设，提升应用场景，</li>
</ol>
<h2 id="同步至plala论坛">同步至plala论坛</h2>
<p><a href="https://forum.phala.network/t/topic/3669">phala关于质押衰减计算模型提议</a></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Phala</category>
        <category>经济模型</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Phala</tag>
        <tag>经济模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Phat合约-案例汇总</title>
    <url>/articles/c7adec45/</url>
    <content><![CDATA[<p>汇总截止当前时间，已经公布的一些开源Phat合约案例</p>
<span id="more"></span>  
<h2 id="1-概述">1. 概述</h2>
<p><a href="https://phat.phala.network/">Phat合约发布入口</a><br>
<a href="https://wiki.phala.network/en-us/build/general/intro/">Phat合约文档</a><br>
<a href="https://use.ink/">ink!合约文档</a><br>
<a href="https://goerli-faucet.pk910.de/">Goerli测试网领取eth</a> Phat可以实现web3相关功能，测试环境需要该测试币</p>
<h2 id="2-phat案例汇总">2. Phat案例汇总</h2>
<ol>
<li><a href="https://github.com/christopherfkk/fat-contract-s3-sync">fat-contract-s3-sync</a><br>
演示Phat实现存储服务，与主流存储协议，如Amazon、Arweave/Filecoin through 4everland, Storj, Filebase等</li>
<li><a href="https://github.com/christopherfkk/clinical-trial-data-smart-contract">clinical-trial-data-smart-contract</a><br>
使用Phat保存临床实验数据（新冠数据）</li>
<li><a href="https://github.com/Phala-Network/oracle-workshop">oracle-workshop</a><br>
官方提供的预言机</li>
<li><a href="https://github.com/Phala-Network/fat-contract-examples">fat-contract-examples</a><br>
官方提供的多个Phat案例，里面有大量的案例</li>
<li><a href="https://github.com/www222fff/oracle-workshop/tree/master/eth_holder">eth_holder</a><br>
使用Phat管理eth</li>
<li><a href="https://github.com/shelvenzhou/secret-file">secret-file</a><br>
使用phat加密文件</li>
<li><a href="https://github.com/Phala-Network/fat-contract-workshop">fat-contract-workshop</a><br>
官方提供，演示Http请求，案例借用了<code>Github Attestation</code></li>
<li><a href="https://github.com/HashWarlock/phat-contract-examples/tree/master/examples/roshambo">roshambo</a><br>
游戏案例-石头、剪刀、布</li>
<li><a href="https://github.com/marlowl/ink-voter-contract">ink-voter-contract</a><br>
Phat黑客马拉松比赛项目-投票案例</li>
<li><a href="https://github.com/Soptq/fat-p2fa">fat-p2fa</a><br>
Phat黑客马拉松比赛项目-安全多签</li>
<li><a href="https://github.com/tenheadedlion/phat-nft">phat-nft</a><br>
管理NFT所有权</li>
<li><a href="https://github.com/Phala-Network/awesome-phat-contracts">awesome-phat-contracts</a><br>
官方汇总phat相关内容的入口</li>
</ol>
<h2 id="3-总结">3. 总结</h2>
<p>本文编辑中</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Phala</category>
        <category>Phat</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Phala</tag>
        <tag>Phat</tag>
      </tags>
  </entry>
  <entry>
    <title>khala-parachain源码解析(1)-runtime相关依赖汇总</title>
    <url>/articles/384c2963/</url>
    <content><![CDATA[<p>再三考虑，还是先看下khala-parachain的源码，一个是想通过代码层了解khala的业务运行机制，另一个也是通过该项目，真正了解一个基于substrate的项目是如何实现的。</p>
<span id="more"></span>  
<h2 id="1-概述">1. 概述</h2>
<ol>
<li><a href="https://github.com/Phala-Network/khala-parachain">khala-parachain</a> 项目是负责pha的节点部分，用来同步数据以及上层应用的实现（入质押池的实现，委员会、质押人等逻辑）。<br>
具体的mining逻辑不在该项目中，暂不考虑这部分内容。</li>
<li>该项目也是基于<a href="https://github.com/substrate-developer-hub/substrate-node-template">substrate-node-template</a> 模板来实现的，用的比较早的模板，但整体内容基本一致</li>
<li>runtime模块中，集成了各个需要的依赖，也是项目运行的核心部分</li>
<li>本文主要讲解runtime中使用到了哪些依赖（如pallet等），通过该内容，对<a href="https://github.com/Phala-Network/khala-parachain">khala-parachain</a> 的整体结构有个全局的了解，以这个作为切入点，也是一个比较好的选择</li>
</ol>
<h2 id="2-依赖讲解">2. 依赖讲解</h2>
<p>项目的<code>runtime</code>目录中，有<code>khala</code>、<code>phala</code>、<code>rhala</code>等等。这里我们主要关注<code>khala</code>，也就是文件<code>runtime/khala/src/lib.rs</code>。<br>
该文件中，集成了所需要的各个pallet，包括自定义的、substrate内置的、以及引用的第三方的。<br>
具体用到了哪些依赖，也可以前往：<code>runtime/khala/Cargo.toml</code>的<code>[dependencies]</code>查看</p>
<h3 id="2-1-substrate相关依赖">2.1 substrate相关依赖</h3>
<ol>
<li>
<p><a href="https://paritytech.github.io/substrate/master/sp_std/index.html">sp-std</a><br>
宏：<br>
if_std：只有std启用的时候，才能使用该代码块<br>
map：创建一个map<br>
vec：创建一个vec</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/sp_api/index.html">sp-api</a><br>
宏：<br>
decl_runtime_apis：用于声明api traits<br>
impl_runtime_apis：用于实现api traits</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/sp_io/index.html">sp-io</a></p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/sp_version/index.html">sp-version</a><br>
宏：<br>
create_apis_vec：创建api声明的集合<br>
create_runtime_str：用于创建<code>RuntimeString</code>常量<br>
runtime_version：用作接受运行库的版本声明并生成具有等效内容的自定义WebAssembly节的属性。</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/sp_runtime/index.html">sp-runtime</a><br>
宏：<br>
bounded_btree_map：从给定的数据创建btree map<br>
bounded_vec：从给定的数据创建btree vec<br>
impl_opaque_keys：实现<code>OpaqueKeys</code>来描述数据结构<br>
parameter_types：用于创建实现了<code>Get</code> trait的类型</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/sp_core/index.html">sp-core</a><br>
宏：</p>
<ul>
<li>map：初始化key value</li>
<li>RuntimeDebug：调试运行时</li>
</ul>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/sp_session/index.html">sp-session</a><br>
session核心</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/sp_offchain/index.html">sp-offchain</a><br>
用于支持链下操作</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/sp_block_builder/index.html">sp-block-builder</a><br>
块构建</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/sc_transaction_pool/index.html">sp-transaction-pool</a><br>
交易池的实现</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/sp_inherents/index.html">sp-inherents</a><br>
固有的外在性是内在地添加到每个块中的外在性。但是，由运行时实现决定是要求每个块的固有函数还是使其可选。固有函数主要用于将数据从块生产者传递到运行时。因此，固有项需要一些在客户端运行的部分和一些在运行时端运行的部分。构造固有项时，固有项所需的任何数据都将作为固有数据从客户端传递到运行时。</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/sp_consensus_aura/index.html">sp-consensus-aura</a><br>
aura底层</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/frame_support/index.html">frame-support</a><br>
该依赖提供了许多重要的声明、derive、attribute-like、function-like等<br>
如下几个重要宏需要掌握：</p>
<ul>
<li>construct_runtime! 用于从已实现的pallet中构造其运行时</li>
<li>match_types! 用于创建实现了<code>Contains</code> trait的类型，类似于<code>matches!</code></li>
<li>parameter_types!  用于创建实现了<code>Get</code> trait的类型</li>
</ul>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/frame_executive/index.html">frame-executive</a><br>
通过在运行时将传入的函数调用发送到适当的托盘来编排它们。</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/frame_system/index.html">frame-system</a><br>
官方解释的看不懂，简单说就是pallet的底层，运行时的根基。其中也包含了一些重要的crate，如：sp_core、sp_runtime等</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/frame_system_rpc_runtime_api/index.html">frame-system-rpc-runtime-api</a><br>
此 API 应由要使用添加系统访问方法的自定义 RPC 扩展的节点的运行时导入和实现。</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/frame_system_benchmarking/index.html">frame-system-benchmarking</a></p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/frame_benchmarking/index.html">frame-benchmarking</a><br>
具体说不来，总之是用于runtime测试</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/frame_try_runtime/index.html">frame-try-runtime</a><br>
用于测试运行时升级的执行。</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/pallet_aura/index.html">pallet-aura</a><br>
aura共识，用于创建块</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/pallet_authorship/index.html">pallet-authorship</a><br>
跟踪当前签名块以及最近的uncles块</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/pallet_session/index.html">pallet-session</a><br>
允许验证器管理其会话密钥，提供更改会话长度的功能，并处理会话轮换。</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/pallet_balances/index.html">pallet-balances</a><br>
提供处理帐户和余额的功能。</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/pallet_randomness_collective_flip/index.html">pallet-randomness-collective-flip</a><br>
提供可在测试中使用的随机函数，并基于前81个块的块散列生成低影响随机值。建议主要在测试等低安全性情况下使用此托盘作为随机性来源（不建议生产环境使用）。</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/pallet_timestamp/index.html">pallet-timestamp</a><br>
提供获取和设置链上时间的功能。</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/pallet_transaction_payment/index.html">pallet-transaction-payment</a> 和 <a href="">pallet-transaction-payment-rpc-runtime-api</a><br>
提供计算调度前交易费用的基本逻辑，以及对应的api</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/pallet_utility/index.html">pallet-utility</a><br>
无状态托盘，带有用于调度管理的助手，无需重新验证。</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/pallet_multisig/index.html">pallet-multisig</a><br>
启用多重签名</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/pallet_proxy/index.html">pallet-proxy</a><br>
允许帐户向其他帐户授予从其签名的来源调度呼叫类型的权限。</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/pallet_scheduler/index.html">pallet-scheduler</a><br>
显示调度调度在指定的块编号或指定的时间段发生的功能。这些调度可以命名或匿名，也可以取消。</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/pallet_collective/index.html">pallet-collective</a><br>
允许一组帐户ID通过来自特定来源的调度来表达他们的集体感受。</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/pallet_membership/index.html">pallet-membership</a><br>
允许控制一组AccountId的成员身份，这对于管理集体成员身份很有用。</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/pallet_treasury/index.html">pallet-treasury</a><br>
提供可由系统中的利益相关者管理的资金储备，以及从该储备中提出支出建议的结构。</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/pallet_bounties/index.html">pallet-bounties</a><br>
管理完成指定工作或实现指定目标的奖励。用于奖励<br>
该pallet需要依赖<a href="https://paritytech.github.io/substrate/master/pallet_treasury/index.html">pallet-treasury</a></p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/pallet_child_bounties/index.html">pallet-child-bounties</a><br>
奖励可以拆分成更小的，需要依赖<a href="https://paritytech.github.io/substrate/master/pallet_treasury/index.html">pallet-treasury</a> 和 <a href="https://paritytech.github.io/substrate/master/pallet_bounties/index.html">pallet-bounties</a></p>
</li>
<li>
<p>pallet-lottery<br>
配置tickets，使网络参与者能够购买tickets。</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/pallet_vesting/index.html">pallet-vesting</a><br>
在帐户的锁定余额上放置线性曲线。该模块确保有一个锁定机制，以防止余额因交易费支付以外的任何原因低于未行权金额。</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/pallet_identity/index.html">pallet-identity</a><br>
启用允许从指定来源添加多个注册器的联合命名系统。登记员可以设定提供身份验证服务的费用。</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/pallet_democracy/index.html">pallet-democracy</a><br>
提供一个民主系统，用于处理一般利益相关者投票的管理。</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/pallet_elections_phragmen/index.html">pallet-elections-phragmen</a><br>
提供基于<a href="https://wiki.polkadot.network/docs/en/learn-phragmen">phragmen</a> 模型的选举</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/pallet_tips/index.html">pallet-tips</a><br>
小费，该pallet依赖于<a href="https://paritytech.github.io/substrate/master/pallet_treasury/index.html">pallet-treasury</a></p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/pallet_preimage/index.html">pallet-preimage</a><br>
允许用户和运行时在链上存储哈希的preimage。其他pallet可用于存储和管理大字节 Blob。</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/pallet_assets/index.html">pallet-assets</a><br>
提供用于处理可替代资产的简单而安全的方法。这个应该是nft用到<br>
一个简单、安全的模块，用于处理可替代资产。<br>
资产模块提供固定供应的可替代资产类别的资产管理功能，包括：<br>
资产发行（铸币）<br>
资产转让<br>
资产冻结<br>
资产销毁（焚烧）<br>
委托资产转让（“批准API”）</p>
</li>
<li>
<p><a href="https://paritytech.github.io/substrate/master/pallet_uniques/index.html">pallet-uniques</a><br>
一个简单、安全的模块，用于处理不可替代的内容。</p>
</li>
</ol>
<h3 id="2-2-cumulus相关依赖">2.2 cumulus相关依赖</h3>
<p><a href="https://github.com/paritytech/cumulus">cumulus</a> 项目：</p>
<ol>
<li>接口文档：<a href="https://paritytech.github.io/cumulus/cumulus_client_collator/index.html">cumulus-doc</a></li>
<li>Cumulus是 Substrate 的扩展，它可以轻松地将任何 Substrate 构建的运行时变成与 Polkadot 兼容的平行链。</li>
<li>Cumulus Consensus 是遵循 Polkadot 中继链（即平行链）的 Substrate 共识引擎。这会在内部运行一个 Polkadot 节点，并指示客户端和同步算法遵循、最终确定和视为正确的链。</li>
</ol>
<h4 id="2-2-1-依赖">2.2.1 依赖</h4>
<ol>
<li>
<p><a href="https://paritytech.github.io/cumulus/pallet_collator_selection/index.html">pallet-collator-selection</a><br>
用于管理平行链中的整理器的pallet。“整理器选择”托盘管理平行链的归类器。排序规则不是一项安全活动，并且此托盘不实现任何博弈论机制来满足所选集合的BFT安全假设。<br>
整理器：平行链块生产者。</p>
</li>
<li>
<p><a href="https://paritytech.github.io/cumulus/cumulus_pallet_aura_ext/index.html">cumulus-pallet-aura-ext</a><br>
aura的扩展，该pallet扩展了基板AuRa托盘，使其与平行链兼容。</p>
</li>
<li>
<p><a href="https://paritytech.github.io/cumulus/cumulus_pallet_parachain_system/index.html">cumulus-pallet-parachain-system</a><br>
底层，包括：<br>
引入平行链验证数据<br>
引入传入的向下和横向消息并分派它们<br>
与中继链协调升级<br>
平行链输出的通信，例如发送的消息，升级信号等。</p>
</li>
<li>
<p><a href="https://paritytech.github.io/cumulus/cumulus_pallet_session_benchmarking/index.html">cumulus-pallet-session-benchmarking</a><br>
测试</p>
</li>
<li>
<p><a href="https://paritytech.github.io/cumulus/cumulus_primitives_core/index.html">cumulus-primitives-core</a><br>
核心</p>
</li>
<li>
<p><a href="https://paritytech.github.io/cumulus/cumulus_primitives_timestamp/index.html">cumulus-primitives-timestamp</a><br>
提供应在平行链的验证阶段使用的固有数据提供程序。它将用于创建固有数据，并将用于检查平行链块内的固有物（在本例中为固有时间戳）。由于我们无法访问运行时中的任何时钟，因此时间戳始终作为运行时的固有时间传递。为了在验证块时检查这一点，我们将使用中继链插槽。由于中继链插槽是从时间戳派生的，因此我们可以通过将其与插槽持续时间混合来轻松地将其转换回时间戳。通过将中继链槽派生的时间戳与时间戳进行比较，我们可以确保平行链时间戳是合理的。</p>
</li>
<li>
<p><a href="https://paritytech.github.io/cumulus/cumulus_primitives_utility/index.html">cumulus-primitives-utility</a></p>
</li>
<li>
<p><a href="https://paritytech.github.io/cumulus/cumulus_pallet_dmp_queue/index.html">cumulus-pallet-dmp-queue</a></p>
</li>
<li>
<p><a href="https://paritytech.github.io/cumulus/cumulus_pallet_xcmp_queue/index.html">cumulus-pallet-xcmp-queue</a></p>
</li>
<li>
<p><a href="https://paritytech.github.io/cumulus/cumulus_pallet_xcm/index.html">cumulus-pallet-xcm</a></p>
</li>
</ol>
<h3 id="2-3-polkadot相关依赖">2.3 polkadot相关依赖</h3>
<ol>
<li>
<p><a href="https://paritytech.github.io/polkadot/doc/polkadot_parachain/index.html">polkadot-parachain</a><br>
波卡平行链所需要的依赖，定义用于创建或验证平行链的基元类型。</p>
</li>
<li>
<p><a href="https://paritytech.github.io/polkadot/doc/polkadot_runtime_common/index.html">polkadot-runtime-common</a><br>
runtime代码</p>
</li>
<li>
<p><a href="https://paritytech.github.io/polkadot/doc/xcm/index.html">xcm</a><br>
跨共识消息格式数据结构。</p>
</li>
<li>
<p><a href="https://paritytech.github.io/polkadot/doc/xcm_builder/index.html">xcm-builder</a><br>
用户配置xcm的类型和帮助</p>
</li>
<li>
<p><a href="https://paritytech.github.io/polkadot/doc/xcm_executor/index.html">xcm-executor</a><br>
用于配置执行程序的各种trait</p>
</li>
<li>
<p><a href="https://paritytech.github.io/polkadot/doc/pallet_xcm/index.html">pallet-xcm</a><br>
用于处理 XCM 消息的 pallet</p>
</li>
</ol>
<h3 id="2-4-rmrk相关依赖">2.4 rmrk相关依赖</h3>
<p>rmrk为波卡生态的元宇宙NFT解决方案：</p>
<ol>
<li>
<p><a href="">pallet-rmrk-core</a></p>
</li>
<li>
<p><a href="">pallet-rmrk-equip</a></p>
</li>
<li>
<p><a href="">pallet-rmrk-market</a></p>
</li>
<li>
<p><a href="">rmrk-traits</a></p>
</li>
<li>
<p><a href="">pallet-rmrk-rpc-runtime-api</a></p>
</li>
</ol>
<h3 id="2-5-自定义的pallet等依赖">2.5 自定义的pallet等依赖</h3>
<ol>
<li>
<p><a href="">assets-registry</a></p>
</li>
<li>
<p><a href="">pallet-parachain-info</a></p>
</li>
<li>
<p><a href="">phala-pallets</a></p>
</li>
<li>
<p><a href="">pallet-mq-runtime-api</a></p>
</li>
<li>
<p><a href="">subbridge-pallets</a></p>
</li>
<li>
<p><a href="">pallet-phala-world</a></p>
</li>
</ol>
<h2 id="3-总结">3. 总结</h2>
<p>本文编辑完毕</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Phala</category>
        <category>khala-parachain源码解析</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Phala</tag>
      </tags>
  </entry>
  <entry>
    <title>pallet进阶(12)-benchmarking</title>
    <url>/articles/12cad6be/</url>
    <content><![CDATA[<p>benchmarking应该都很熟悉，性能测试，同时该测试可以为pallet的公共方法提供权重值</p>
<span id="more"></span>
<h2 id="1-概述">1. 概述</h2>
<ol>
<li>编写benchmarking分两种情况：
<ol>
<li>对函数进行性能测试时需要的构造条件不会涉及到本pallet以外的其它pallet；</li>
<li>在对函数进行性能测试时需要先使用其它的pallet构造测试的先决条件。</li>
</ol>
</li>
</ol>
<h2 id="2-编写pallet业务代码">2. 编写pallet业务代码</h2>
<p>在lib.rs中：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![cfg_attr(not(feature = <span class="string">&quot;std&quot;</span>), no_std)]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> mock;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(feature = <span class="string">&quot;runtime-benchmarks&quot;</span>)]</span></span><br><span class="line"><span class="keyword">mod</span> benchmarking;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> weights;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> weights::WeightInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> pallet::*;</span><br><span class="line"><span class="meta">#[frame_support::pallet]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> pallet &#123;</span><br><span class="line">	<span class="keyword">use</span> codec::Codec;</span><br><span class="line">	<span class="keyword">use</span> frame_support::&#123;</span><br><span class="line">		pallet_prelude::*, sp_runtime::traits::AtLeast32BitUnsigned, sp_std::fmt::<span class="built_in">Debug</span>,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">use</span> frame_system::pallet_prelude::*;</span><br><span class="line">	<span class="keyword">use</span> scale_info::prelude::vec::<span class="type">Vec</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">use</span> crate::WeightInfo;</span><br><span class="line">	<span class="keyword">use</span> sp_io::hashing::&#123;blake2_128, twox_128&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="meta">#[pallet::pallet]</span></span><br><span class="line">	<span class="meta">#[pallet::generate_store(pub(super) trait Store)]</span></span><br><span class="line">	<span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Pallet</span>&lt;T&gt;(_);</span><br><span class="line"></span><br><span class="line">	<span class="meta">#[pallet::config]</span></span><br><span class="line">	<span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Config</span>: frame_system::Config &#123;</span><br><span class="line">		<span class="keyword">type</span> <span class="title class_">Event</span>: <span class="built_in">From</span>&lt;Event&lt;<span class="keyword">Self</span>&gt;&gt; + IsType&lt;&lt;<span class="keyword">Self</span> <span class="keyword">as</span> frame_system::Config&gt;::Event&gt;;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//声明StudentNumber类型</span></span><br><span class="line">		<span class="keyword">type</span> <span class="title class_">StudentNumberType</span>: Member</span><br><span class="line">			+ Parameter</span><br><span class="line">			+ AtLeast32BitUnsigned</span><br><span class="line">			+ Codec</span><br><span class="line">			+ <span class="built_in">From</span>&lt;<span class="type">u32</span>&gt;</span><br><span class="line">			+ <span class="built_in">Into</span>&lt;<span class="type">u32</span>&gt;</span><br><span class="line">			+ <span class="built_in">Copy</span></span><br><span class="line">			+ <span class="built_in">Debug</span></span><br><span class="line">			+ <span class="built_in">Default</span></span><br><span class="line">			+ MaxEncodedLen</span><br><span class="line">			+ MaybeSerializeDeserialize;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//声明StudentName类型</span></span><br><span class="line">		<span class="keyword">type</span> <span class="title class_">StudentNameType</span>: Parameter</span><br><span class="line">			+ Member</span><br><span class="line">			+ AtLeast32BitUnsigned</span><br><span class="line">			+ Codec</span><br><span class="line">			+ <span class="built_in">Default</span></span><br><span class="line">			+ <span class="built_in">From</span>&lt;<span class="type">u128</span>&gt;</span><br><span class="line">			+ <span class="built_in">Into</span>&lt;<span class="type">u128</span>&gt;</span><br><span class="line">			+ <span class="built_in">Copy</span></span><br><span class="line">			+ MaxEncodedLen</span><br><span class="line">			+ MaybeSerializeDeserialize</span><br><span class="line">			+ <span class="built_in">Debug</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">type</span> <span class="title class_">WeightInfo</span>: WeightInfo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4. Runtime Storage</span></span><br><span class="line">	<span class="comment">// 用storageMap存储学生信息，（key， value）分别对应的是学号和姓名.</span></span><br><span class="line">	<span class="meta">#[pallet::storage]</span></span><br><span class="line">	<span class="meta">#[pallet::getter(fn students_info)]</span></span><br><span class="line">	<span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">StudentsInfo</span>&lt;T: Config&gt; =</span><br><span class="line">		StorageMap&lt;_, Blake2_128Concat, T::StudentNumberType, T::StudentNameType, ValueQuery&gt;;</span><br><span class="line">   </span><br><span class="line">	<span class="meta">#[pallet::event]</span></span><br><span class="line">	<span class="meta">#[pallet::generate_deposit(pub(super) fn deposit_event)]</span></span><br><span class="line">	<span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Event</span>&lt;T: Config&gt; &#123;</span><br><span class="line">		<span class="title function_ invoke__">SetStudentInfo</span>(T::StudentNumberType, T::StudentNameType),</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	<span class="meta">#[pallet::error]</span></span><br><span class="line">	<span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Error</span>&lt;T&gt; &#123;</span><br><span class="line">		<span class="comment">// 相同学号的只允许设置一次名字</span></span><br><span class="line">		SetStudentsInfoDuplicate,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">#[pallet::call]</span></span><br><span class="line">	<span class="keyword">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; &#123;</span><br><span class="line">		<span class="meta">#[pallet::weight(&lt;T as Config&gt;::WeightInfo::set_student_info((*student_number).into() ))]</span></span><br><span class="line">		<span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_student_info</span>(origin: OriginFor&lt;T&gt;, student_number: T::StudentNumberType, student_name: T::StudentNameType, ) <span class="punctuation">-&gt;</span> DispatchResultWithPostInfo &#123;</span><br><span class="line">			<span class="title function_ invoke__">ensure_signed</span>(origin)?;</span><br><span class="line">			<span class="keyword">if</span> StudentsInfo::&lt;T&gt;::<span class="title function_ invoke__">contains_key</span>(student_number) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(Error::&lt;T&gt;::SetStudentsInfoDuplicate.<span class="title function_ invoke__">into</span>())</span><br><span class="line">			&#125;</span><br><span class="line">			StudentsInfo::&lt;T&gt;::<span class="title function_ invoke__">insert</span>(&amp;student_number, &amp;student_name);</span><br><span class="line">			<span class="keyword">Self</span>::<span class="title function_ invoke__">deposit_event</span>(Event::<span class="title function_ invoke__">SetStudentInfo</span>(student_number, student_name));</span><br><span class="line">			<span class="keyword">Self</span>::<span class="title function_ invoke__">generate_key</span>();</span><br><span class="line">			<span class="title function_ invoke__">Ok</span>(().<span class="title function_ invoke__">into</span>())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; &#123;</span><br><span class="line">		<span class="keyword">fn</span> <span class="title function_">generate_key</span>() &#123;</span><br><span class="line">			<span class="comment">// let key1 = twox_128(b&quot;Balances&quot;.to_vec().as_slice());</span></span><br><span class="line">			<span class="keyword">let</span> <span class="variable">key1</span> = <span class="title function_ invoke__">twox_128</span>(<span class="string">b&quot;Balances&quot;</span>);</span><br><span class="line">			<span class="keyword">let</span> <span class="variable">key2</span> = <span class="title function_ invoke__">twox_128</span>(<span class="string">b&quot;FreeBalance&quot;</span>);</span><br><span class="line">			<span class="keyword">let</span> <span class="variable">key3</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">blake2_128_concat</span>(</span><br><span class="line">				<span class="string">b&quot;0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d&quot;</span>,</span><br><span class="line">			);</span><br><span class="line">			log::info!(target: <span class="string">&quot;use-benchmarking&quot;</span>, <span class="string">&quot;------------ ============================, key1 = &#123;:?&#125;, key2 = &#123;:?&#125;, key3 = &#123;:?&#125;&quot;</span>, key1, key2, key3);</span><br><span class="line">			<span class="keyword">let</span> <span class="variable">a</span> = <span class="string">&quot;5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY&quot;</span>.<span class="title function_ invoke__">as_bytes</span>().<span class="title function_ invoke__">to_vec</span>();</span><br><span class="line">			a.<span class="title function_ invoke__">using_encoded</span>(|<span class="keyword">ref</span> slice| &#123;</span><br><span class="line">				log::info!(target: <span class="string">&quot;use-benchmarking&quot;</span>, <span class="string">&quot;------------ ============================, code = &#123;:?&#125;&quot;</span>, slice);</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">fn</span> <span class="title function_">blake2_128_concat</span>(d: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; &#123;</span><br><span class="line">			<span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="title function_ invoke__">blake2_128</span>(d).<span class="title function_ invoke__">to_vec</span>();</span><br><span class="line">			v.<span class="title function_ invoke__">extend_from_slice</span>(d);</span><br><span class="line">			v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-编写mock代码">3. 编写mock代码</h2>
<p><a href="http://mock.rs">mock.rs</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">crate</span> <span class="keyword">as</span> pallet_use_benchmarking;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> frame_support::traits::&#123;ConstU16, ConstU64&#125;;</span><br><span class="line"><span class="keyword">use</span> frame_system <span class="keyword">as</span> system;</span><br><span class="line"><span class="keyword">use</span> sp_core::H256;</span><br><span class="line"><span class="keyword">use</span> sp_runtime::&#123;</span><br><span class="line">	testing::Header,</span><br><span class="line">	traits::&#123;BlakeTwo256, IdentityLookup&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UncheckedExtrinsic</span> = frame_system::mocking::MockUncheckedExtrinsic&lt;Test&gt;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Block</span> = frame_system::mocking::MockBlock&lt;Test&gt;;</span><br><span class="line"></span><br><span class="line">frame_support::construct_runtime!(</span><br><span class="line">	<span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Test</span> <span class="keyword">where</span></span><br><span class="line">		Block = Block,</span><br><span class="line">		NodeBlock = Block,</span><br><span class="line">		UncheckedExtrinsic = UncheckedExtrinsic,</span><br><span class="line">	&#123;</span><br><span class="line">		System: frame_system,</span><br><span class="line">		UseBenchmarkingDemo: pallet_use_benchmarking,</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">system</span>::Config <span class="keyword">for</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">BaseCallFilter</span> = frame_support::traits::Everything;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">BlockWeights</span> = ();</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">BlockLength</span> = ();</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">DbWeight</span> = ();</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">Origin</span> = Origin;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">Call</span> = Call;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">Index</span> = <span class="type">u64</span>;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">BlockNumber</span> = <span class="type">u64</span>;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">Hash</span> = H256;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">Hashing</span> = BlakeTwo256;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">AccountId</span> = <span class="type">u64</span>;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">Lookup</span> = IdentityLookup&lt;<span class="keyword">Self</span>::AccountId&gt;;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">Header</span> = Header;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">Event</span> = Event;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">BlockHashCount</span> = ConstU64&lt;<span class="number">250</span>&gt;;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">Version</span> = ();</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">PalletInfo</span> = PalletInfo;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">AccountData</span> = ();</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">OnNewAccount</span> = ();</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">OnKilledAccount</span> = ();</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">SystemWeightInfo</span> = ();</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">SS58Prefix</span> = ConstU16&lt;<span class="number">42</span>&gt;;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">OnSetCode</span> = ();</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">MaxConsumers</span> = frame_support::traits::ConstU32&lt;<span class="number">16</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">pallet_use_benchmarking</span>::Config <span class="keyword">for</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">Event</span> = Event;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">StudentNumberType</span> = <span class="type">u32</span>;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">StudentNameType</span> = <span class="type">u128</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> frame_support::pallet_prelude::GenesisBuild;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new_test_ext</span>() <span class="punctuation">-&gt;</span> sp_io::TestExternalities &#123;</span><br><span class="line">	system::GenesisConfig::<span class="title function_ invoke__">default</span>().build_storage::&lt;Test&gt;().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">into</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-编写benchmarking">4. 编写benchmarking</h2>
<p>编写benchmarking的目的主要是为调度函数生成对应的权重计算函数，对应到本例子中就主要是use-benchmarking的set_student_info函数生成对应的权重计算函数。<br>
编写benchmark以宏benchmarks!包含，里面的内容主要分三部分，做的事情分别是准备条件、调用调度函数、对执行结果验证。对于第一步，其实就是对我们调度函数中的变量进行赋值，<br>
<a href="http://benchmarking.rs">benchmarking.rs</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[allow(unused)]</span></span><br><span class="line"><span class="keyword">use</span> crate::Pal<span class="keyword">let</span> <span class="variable">as</span> UseBenchmarkingDemo;</span><br><span class="line"><span class="keyword">use</span> frame_benchmarking::&#123;benchmarks, whitelisted_caller&#125;;</span><br><span class="line"><span class="keyword">use</span> frame_system::RawOrigin;</span><br><span class="line"></span><br><span class="line">benchmarks! &#123;</span><br><span class="line">	set_student_info &#123;</span><br><span class="line">		<span class="keyword">let</span> <span class="variable">s</span> <span class="keyword">in</span> <span class="number">0</span> .. <span class="number">100</span>;</span><br><span class="line">		<span class="keyword">let</span> <span class="variable">caller</span>: T::AccountId = <span class="title function_ invoke__">whitelisted_caller</span>();</span><br><span class="line">	&#125;:&#123;</span><br><span class="line">		<span class="keyword">let</span> <span class="variable">_</span> = UseBenchmarkingDemo::&lt;T&gt;::<span class="title function_ invoke__">set_student_info</span>(RawOrigin::<span class="title function_ invoke__">Signed</span>(caller).<span class="title function_ invoke__">into</span>(), s.<span class="title function_ invoke__">into</span>(), <span class="built_in">Default</span>::<span class="title function_ invoke__">default</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	verify &#123;</span><br><span class="line">		<span class="built_in">assert_eq!</span>(&lt;StudentsInfo&lt;T&gt;&gt;::get::&lt;&lt;T <span class="keyword">as</span> pallet::Config&gt;::StudentNumberType&gt;(s.<span class="title function_ invoke__">into</span>()), <span class="built_in">Default</span>::<span class="title function_ invoke__">default</span>());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	impl_benchmark_test_suite!(UseBenchmarkingDemo, crate::mock::<span class="title function_ invoke__">new_test_ext</span>(), crate::mock::Test);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-添加到runtime中">5. 添加到runtime中</h2>
<p>添加依赖.pallet/runtime/Cargo.toml：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="comment">#...</span></span><br><span class="line"><span class="attr">pallet-use-benchmarking</span> = &#123; version = <span class="string">&quot;4.0.0-dev&quot;</span>, default-features = <span class="literal">false</span>, path = <span class="string">&quot;../pallets/use-benchmarking&quot;</span> &#125;</span><br><span class="line"><span class="comment">#...</span></span><br><span class="line"></span><br><span class="line"><span class="section">[features]</span></span><br><span class="line"><span class="attr">default</span> = [<span class="string">&quot;std&quot;</span>]</span><br><span class="line"><span class="attr">std</span> = [</span><br><span class="line">  <span class="comment">#...</span></span><br><span class="line">  <span class="string">&quot;pallet-use-benchmarking/std&quot;</span>,</span><br><span class="line">  <span class="comment">#...</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="attr">runtime-benchmarks</span> = [</span><br><span class="line">  <span class="comment">#...</span></span><br><span class="line">  <span class="string">&quot;pallet-use-benchmarking/runtime-benchmarks&quot;</span>,</span><br><span class="line">  <span class="comment">#...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>然后就是将use-benchmarking添加到runtime中，在runtime/src/lib.rs：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">pallet_use_benchmarking</span>::Config <span class="keyword">for</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Event</span> = Event;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">StudentNumberType</span> = <span class="type">u32</span>;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">StudentNameType</span> = <span class="type">u128</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">construct_runtime!(</span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Runtime</span> <span class="keyword">where</span></span><br><span class="line">    Block = Block,</span><br><span class="line">    NodeBlock = opaque::Block,</span><br><span class="line">    UncheckedExtrinsic = UncheckedExtrinsic</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//添加下面这行</span></span><br><span class="line">    UseBenchmarkingDemo: pallet_use_benchmarking,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>将use-benchmarking pallet添加到对应的benchmark宏中，在runtime/src/lib.rs：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#[cfg(feature = <span class="string">&quot;runtime-benchmarks&quot;</span>)]</span></span><br><span class="line"><span class="keyword">mod</span> benches &#123;</span><br><span class="line">  define_benchmarks!(</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//这行为添加的代码</span></span><br><span class="line">    [pallet_use_benchmarking, UseBenchmarkingDemo]</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-编译-生成weights-rs文件">6. 编译&amp;生成weights.rs文件</h2>
<p>编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要带上--features runtime-benchmarks</span></span><br><span class="line">cargo build --features runtime-benchmarks</span><br></pre></td></tr></table></figure>
<p>拷贝模板：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir .maintain</span><br><span class="line">cd .maintain</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">此处的substrate同官方的repo仓库</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">从substrate的repo中拷贝模板放到我们的substrate-node-template目录下</span></span><br><span class="line">cp substrate/.maintain/frame-weight-template.hbs .</span><br></pre></td></tr></table></figure>
<p>生成weights文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./target/debug/node-template benchmark --chain dev \</span><br><span class="line">  --execution wasm --wasm-execution compiled \</span><br><span class="line">  --pallet pallet_use_benchmarking \</span><br><span class="line">  --extrinsic &quot;*&quot; --steps 20 --repeat 10 \</span><br><span class="line">  --output ./pallets/use-benchmarking/src/weights.rs \</span><br><span class="line">  --template ./.maintain/frame-weight-template.hbs</span><br></pre></td></tr></table></figure>
<p>执行完后就会在./pallets/use-benchmarking/src/目录下生成对应的weights.rs文件。<br>
至此，生成了weights.rs文件，但是这仅仅只是生成，还需要把生成的权重函数用到pallet中</p>
<h2 id="7-将生成的权重函数应用到pallet中">7. 将生成的权重函数应用到pallet中</h2>
<p>首先需要在pallet的Cargo.toml中添加如下：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">#添加下面这行</span></span><br><span class="line"><span class="attr">sp-std</span> = &#123; default-features = <span class="literal">false</span>, </span><br><span class="line">  <span class="attr">version</span> = <span class="string">&quot;4.0.0&quot;</span>, </span><br><span class="line">  <span class="attr">git</span> = <span class="string">&quot;https://github.com/paritytech/substrate.git&quot;</span>, </span><br><span class="line">  <span class="attr">branch</span> = <span class="string">&quot;polkadot-v0.9.28&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="section">[features]</span></span><br><span class="line"><span class="attr">default</span> = [<span class="string">&quot;std&quot;</span>]</span><br><span class="line"><span class="attr">std</span> = [</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">#添加下面这行</span></span><br><span class="line">  <span class="string">&quot;sp-std/std&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>接着在pallet的lib.rs中：<br>
将<code>#[pallet::weight(100)]</code>改为<code>#[pallet::weight(&lt;T as Config&gt;::WeightInfo::set_student_info((*student_number).into() ))]</code><br>
最后，还需要回到runtime/src/lib.rs文件，修改pallet_use_benchmarking的配置，如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">pallet_use_benchmarking</span>::Config <span class="keyword">for</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//添加这一行</span></span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">WeightInfo</span> = pallet_use_benchmarking::weights::SubstrateWeight&lt;Runtime&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新编译，pallet的对应的权重就会在新的执行文件中生效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo build</span><br></pre></td></tr></table></figure>
<h2 id="8-总结">8. 总结</h2>
<p>本文编辑完毕</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Substrate</category>
        <category>pallet进阶</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Substrate</tag>
      </tags>
  </entry>
  <entry>
    <title>pallet进阶(11)-test</title>
    <url>/articles/3af740ea/</url>
    <content><![CDATA[<p>只是为了测试一个方法，每次总编译项目，慢又麻烦。因此，能够灵活的编写测试用例非常重要</p>
<span id="more"></span>
<h2 id="1-pallet">1. pallet</h2>
<p>这里就不展示了，找个精简的模板搞就行</p>
<h2 id="2-编写mock-runtime">2. 编写mock runtime</h2>
<p>mock runtime是进行pallet测试时需要提供的runtime，用于在测试环境中为pallet的函数提供必要的运行环境。<a href="http://xn--palletsrcmock-x40uy68b16szm4azlb521mftxbga94um46pzxlc61e.rs">在需要测试的pallet的src目录下创建mock.rs</a>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">crate</span> <span class="keyword">as</span> pallet_use_test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> frame_support::traits::&#123;ConstU16, ConstU64&#125;;</span><br><span class="line"><span class="keyword">use</span> frame_system <span class="keyword">as</span> system;</span><br><span class="line"><span class="keyword">use</span> sp_core::H256;</span><br><span class="line"><span class="keyword">use</span> sp_runtime::&#123;</span><br><span class="line">	testing::Header,</span><br><span class="line">	traits::&#123;BlakeTwo256, IdentityLookup&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UncheckedExtrinsic</span> = frame_system::mocking::MockUncheckedExtrinsic&lt;Test&gt;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Block</span> = frame_system::mocking::MockBlock&lt;Test&gt;;</span><br><span class="line"></span><br><span class="line">frame_support::construct_runtime!(</span><br><span class="line">	<span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Test</span> <span class="keyword">where</span></span><br><span class="line">		Block = Block,</span><br><span class="line">		NodeBlock = Block,</span><br><span class="line">		UncheckedExtrinsic = UncheckedExtrinsic,&#123;</span><br><span class="line">		System: frame_system,</span><br><span class="line">		UseTestDemo: pallet_use_test,</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">system</span>::Config <span class="keyword">for</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">BaseCallFilter</span> = frame_support::traits::Everything;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">BlockWeights</span> = ();</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">BlockLength</span> = ();</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">DbWeight</span> = ();</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">Origin</span> = Origin;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">Call</span> = Call;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">Index</span> = <span class="type">u64</span>;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">BlockNumber</span> = <span class="type">u64</span>;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">Hash</span> = H256;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">Hashing</span> = BlakeTwo256;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">AccountId</span> = <span class="type">u64</span>;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">Lookup</span> = IdentityLookup&lt;<span class="keyword">Self</span>::AccountId&gt;;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">Header</span> = Header;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">Event</span> = Event;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">BlockHashCount</span> = ConstU64&lt;<span class="number">250</span>&gt;;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">Version</span> = ();</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">PalletInfo</span> = PalletInfo;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">AccountData</span> = ();</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">OnNewAccount</span> = ();</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">OnKilledAccount</span> = ();</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">SystemWeightInfo</span> = ();</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">SS58Prefix</span> = ConstU16&lt;<span class="number">42</span>&gt;;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">OnSetCode</span> = ();</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">MaxConsumers</span> = frame_support::traits::ConstU32&lt;<span class="number">16</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">pallet_use_test</span>::Config <span class="keyword">for</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">Event</span> = Event;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">ClassType</span> = <span class="type">u32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> frame_support::pallet_prelude::GenesisBuild;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此处需要结合`设置genesisconfig`考虑</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new_test_ext</span>() <span class="punctuation">-&gt;</span> sp_io::TestExternalities &#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">storage</span> = system::GenesisConfig::<span class="title function_ invoke__">default</span>().build_storage::&lt;Test&gt;().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">into</span>();</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">config</span>: pallet_use_test::GenesisConfig&lt;Test&gt; = pallet_use_test::GenesisConfig &#123; class: <span class="number">2</span> &#125;;</span><br><span class="line">	config.<span class="title function_ invoke__">assimilate_storage</span>(&amp;<span class="keyword">mut</span> storage).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">	storage.<span class="title function_ invoke__">into</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出，写mock runtime的方式基本上和在runtime/src/lib.rs中加载pallet的写法基本是一样的，只不过在mock runtime中，只加载需要测试的必要的pallet就可以了。另外在配置pallet的时候也只需要能满足测试使用就可以了，而不用配置实际的类型。</p>
<h2 id="3-设置genesisconfig">3. 设置genesisconfig</h2>
<p>在上面的代码中，还创建了一个new_test_ext函数，这个函数中，为测试需要的一些pallet进行初始配置，此处只需要为System进行默认的配置，在实际的测试情况中，往往需要为被测试的pallet以及相关的pallet提供一些初始设置。现在，这里的pallet-use-test还没有genesisConfig。</p>
<p>下面为pallet-use-test添加genesisConfig，在pallet的use-test/src/lib.rs中添加代码如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此处一定要test导出</span></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> mock;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[pallet::genesis_config]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">GenesisConfig</span>&lt;T: Config&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> class: T::ClassType,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(feature = <span class="string">&quot;std&quot;</span>)]</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Config&gt; <span class="built_in">Default</span> <span class="keyword">for</span> <span class="title class_">GenesisConfig</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">default</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">      <span class="keyword">Self</span> &#123; class: <span class="built_in">Default</span>::<span class="title function_ invoke__">default</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[pallet::genesis_build]</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Config&gt; GenesisBuild&lt;T&gt; <span class="keyword">for</span> <span class="title class_">GenesisConfig</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">build</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">      Class::&lt;T&gt;::<span class="title function_ invoke__">put</span>(<span class="keyword">self</span>.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面代码中，为pallet添加了默认的class，而这个配置在实际使用中，需要在chainspec文件里面配置上此值（配置chainspec涉及到node/src/chainspec.rs和chainspec的json文件）。</p>
<h2 id="4-编写测试函数">4. 编写测试函数</h2>
<p>mock runtime准备好后就可以写测试函数了，在use-test/src目录下创建一个tests.rs的文件，添加测试函数的代码</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> super::pallet::Class;</span><br><span class="line"><span class="keyword">use</span> crate::mock::*;</span><br><span class="line"><span class="keyword">use</span> frame_support::&#123;assert_noop, assert_ok&#125;;</span><br><span class="line"><span class="keyword">use</span> sp_runtime::traits::BadOrigin;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test_set_class_info</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">new_test_ext</span>().<span class="title function_ invoke__">execute_with</span>(|| &#123;</span><br><span class="line">        assert_noop!(UseTestDemo::<span class="title function_ invoke__">set_class_info</span>(Origin::<span class="title function_ invoke__">signed</span>(<span class="number">1</span>), <span class="number">42</span>), BadOrigin);</span><br><span class="line">        assert_ok!(UseTestDemo::<span class="title function_ invoke__">set_class_info</span>(Origin::<span class="title function_ invoke__">root</span>(), <span class="number">42</span>));</span><br><span class="line">        <span class="built_in">assert_eq!</span>(Class::&lt;Test&gt;::<span class="title function_ invoke__">get</span>(), <span class="number">42</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在测试函数中调用pallet的函数，方式如下: 在mock runtime中定义的模块名字::函数名字（函数参数）<br>
在测试函数中使用pallet的存储，方式如下:</p>
<ol>
<li>导出pallet中存储，如上面例子中使用use super::pallet::Class; 导出存储Class；</li>
<li>像正常在pallet中使用存储一样使用。</li>
</ol>
<h2 id="5-运行测试">5. 运行测试</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo test</span><br></pre></td></tr></table></figure>
<h2 id="6-总结">6. 总结</h2>
<p>本文编辑完毕</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Substrate</category>
        <category>pallet进阶</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Substrate</tag>
      </tags>
  </entry>
  <entry>
    <title>pallet进阶(10)-自定义RPC接口</title>
    <url>/articles/e509665e/</url>
    <content><![CDATA[<p>自定义RPC接口</p>
<span id="more"></span>
<h2 id="1-pallet内容">1. pallet内容</h2>
<p>其中实现一个rpc的功能函数</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![cfg_attr(not(feature = <span class="string">&quot;std&quot;</span>), no_std)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> pallet::*;</span><br><span class="line"><span class="meta">#[frame_support::pallet]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> pallet &#123;</span><br><span class="line">	<span class="keyword">use</span> frame_support::pallet_prelude::*;</span><br><span class="line">	<span class="keyword">use</span> frame_system::pallet_prelude::*;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">#[pallet::pallet]</span></span><br><span class="line">	<span class="meta">#[pallet::generate_store(pub(super) trait Store)]</span></span><br><span class="line">	<span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Pallet</span>&lt;T&gt;(_);</span><br><span class="line">    </span><br><span class="line">	<span class="meta">#[pallet::config]</span></span><br><span class="line">	<span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Config</span>: frame_system::Config &#123;</span><br><span class="line">		<span class="keyword">type</span> <span class="title class_">Event</span>: <span class="built_in">From</span>&lt;Event&lt;<span class="keyword">Self</span>&gt;&gt; + IsType&lt;&lt;<span class="keyword">Self</span> <span class="keyword">as</span> frame_system::Config&gt;::Event&gt;;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">#[pallet::storage]</span></span><br><span class="line">	<span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">Proofs</span>&lt;T: Config&gt; = StorageMap&lt;_, Blake2_128Concat, <span class="type">u32</span>, <span class="type">u128</span>&gt;;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">#[pallet::event]</span></span><br><span class="line">	<span class="meta">#[pallet::generate_deposit(pub(super) fn deposit_event)]</span></span><br><span class="line">	<span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Event</span>&lt;T: Config&gt; &#123;</span><br><span class="line">		<span class="title function_ invoke__">ClaimCreated</span>(<span class="type">u32</span>, <span class="type">u128</span>),</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">#[pallet::call]</span></span><br><span class="line">	<span class="keyword">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; &#123;</span><br><span class="line">		<span class="meta">#[pallet::weight(0)]</span></span><br><span class="line">		<span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">create_claim</span>(origin: OriginFor&lt;T&gt;, id: <span class="type">u32</span>, claim: <span class="type">u128</span>, ) <span class="punctuation">-&gt;</span> DispatchResultWithPostInfo &#123;</span><br><span class="line">			<span class="title function_ invoke__">ensure_signed</span>(origin)?;</span><br><span class="line">			Proofs::&lt;T&gt;::<span class="title function_ invoke__">insert</span>(&amp;id, &amp;claim);</span><br><span class="line">			<span class="keyword">Self</span>::<span class="title function_ invoke__">deposit_event</span>(Event::<span class="title function_ invoke__">ClaimCreated</span>(id, claim));</span><br><span class="line">			<span class="title function_ invoke__">Ok</span>(().<span class="title function_ invoke__">into</span>())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; &#123;</span><br><span class="line">        <span class="comment">//重点：供rpc调用，功能函数</span></span><br><span class="line">		<span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">rpc_method</span>(v: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> v &gt; <span class="number">100</span> &#123;</span><br><span class="line">				<span class="literal">true</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-在-rpc-runtime-api-目录定义runtime中的rpc接口">2. 在./rpc/runtime-api/目录定义runtime中的rpc接口</h2>
<p>Cargo.toml内容：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;use-rpc-runtime-api&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;4.0.0-dev&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[package.metadata.docs.rs]</span></span><br><span class="line"><span class="attr">targets</span> = [<span class="string">&quot;x86_64-unknown-linux-gnu&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">sp-api</span> = &#123; default-features = <span class="literal">false</span>, version = <span class="string">&quot;4.0.0-dev&quot;</span>, git = <span class="string">&quot;https://github.com/paritytech/substrate.git&quot;</span>, branch = <span class="string">&quot;polkadot-v0.9.28&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="section">[features]</span></span><br><span class="line"><span class="attr">default</span> = [<span class="string">&quot;std&quot;</span>]</span><br><span class="line"><span class="attr">std</span> = [</span><br><span class="line">	<span class="string">&quot;sp-api/std&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>src/lib.rs中定义：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![cfg_attr(not(feature = <span class="string">&quot;std&quot;</span>), no_std)]</span></span><br><span class="line">sp_api::decl_runtime_apis! &#123;</span><br><span class="line">    <span class="comment">//定义接口</span></span><br><span class="line">	<span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">MyRpcRuntimeApi</span> &#123;</span><br><span class="line">		<span class="keyword">fn</span> <span class="title function_">rpc_method</span>(v: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-在-rpc-目录定义rpc接口">3. 在./rpc/目录定义rpc接口</h2>
<p>在Cargo.toml中：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;pallet-rpc&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;4.0.0-dev&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[package.metadata.docs.rs]</span></span><br><span class="line"><span class="attr">targets</span> = [<span class="string">&quot;x86_64-unknown-linux-gnu&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">jsonrpc-core</span> = <span class="string">&quot;18.0.0&quot;</span></span><br><span class="line"><span class="attr">jsonrpc-core-client</span> = <span class="string">&quot;18.0.0&quot;</span></span><br><span class="line"><span class="attr">jsonrpc-derive</span> = <span class="string">&quot;18.0.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sp-runtime</span> = &#123; default-features = <span class="literal">false</span>, version = <span class="string">&quot;6.0.0&quot;</span>, git = <span class="string">&quot;https://github.com/paritytech/substrate.git&quot;</span>, branch = <span class="string">&quot;polkadot-v0.9.28&quot;</span> &#125;</span><br><span class="line"><span class="attr">sp-api</span> = &#123; default-features = <span class="literal">false</span>, version = <span class="string">&quot;4.0.0-dev&quot;</span>, git = <span class="string">&quot;https://github.com/paritytech/substrate.git&quot;</span>, branch = <span class="string">&quot;polkadot-v0.9.28&quot;</span> &#125;</span><br><span class="line"><span class="attr">sp-blockchain</span> = &#123; default-features = <span class="literal">false</span>, version = <span class="string">&quot;4.0.0-dev&quot;</span>, git = <span class="string">&quot;https://github.com/paritytech/substrate.git&quot;</span>, branch = <span class="string">&quot;polkadot-v0.9.28&quot;</span> &#125;</span><br><span class="line"><span class="attr">use-rpc-runtime-api</span> = &#123; version = <span class="string">&quot;4.0.0-dev&quot;</span>, default-features = <span class="literal">false</span>, path = <span class="string">&quot;./runtime-api&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="section">[dev-dependencies]</span></span><br><span class="line"><span class="attr">serde_json</span> = <span class="string">&quot;1.0.74&quot;</span></span><br></pre></td></tr></table></figure>
<p>在src/lib.rs中实现rpc：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::gen_client::Client <span class="keyword">as</span> UseRpcClient;</span><br><span class="line"><span class="keyword">use</span> jsonrpc_core::&#123;Error <span class="keyword">as</span> RpcError, ErrorCode, <span class="type">Result</span>&#125;;</span><br><span class="line"><span class="keyword">use</span> jsonrpc_derive::rpc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> sp_api::ProvideRuntimeApi;</span><br><span class="line"><span class="keyword">use</span> sp_blockchain::HeaderBackend;</span><br><span class="line"><span class="keyword">use</span> sp_runtime::&#123;generic::BlockId, traits::Block <span class="keyword">as</span> BlockT&#125;;</span><br><span class="line"><span class="keyword">use</span> use_rpc_runtime_api::MyRpcRuntimeApi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">UseRpc</span>&lt;C, B&gt; &#123;</span><br><span class="line">	client: Arc&lt;C&gt;,</span><br><span class="line">	_marker: std::marker::PhantomData&lt;B&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;C, B&gt; UseRpc&lt;C, B&gt; &#123;</span><br><span class="line">	<span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(client: Arc&lt;C&gt;) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">		<span class="keyword">Self</span> &#123; client, _marker: <span class="built_in">Default</span>::<span class="title function_ invoke__">default</span>() &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[rpc]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">MyRpcApi</span>&lt;BlockHash&gt; &#123;</span><br><span class="line">	<span class="meta">#[rpc(name = <span class="string">&quot;my_rpc_method&quot;</span>)]</span></span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">rpc_method</span>(&amp;<span class="keyword">self</span>, v: <span class="type">u32</span>, at: <span class="type">Option</span>&lt;BlockHash&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">bool</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;C, Block&gt; MyRpcApi&lt;&lt;Block <span class="keyword">as</span> BlockT&gt;::Hash&gt; <span class="keyword">for</span> <span class="title class_">UseRpc</span>&lt;C, Block&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">	Block: BlockT,</span><br><span class="line">	C: <span class="built_in">Send</span> + <span class="built_in">Sync</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">	C: ProvideRuntimeApi&lt;Block&gt;,</span><br><span class="line">	C: HeaderBackend&lt;Block&gt;,</span><br><span class="line">	C::Api: MyRpcRuntimeApi&lt;Block&gt;, &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">rpc_method</span>(&amp;<span class="keyword">self</span>, v: <span class="type">u32</span>, at: <span class="type">Option</span>&lt;&lt;Block <span class="keyword">as</span> BlockT&gt;::Hash&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">bool</span>&gt; &#123;</span><br><span class="line">		<span class="keyword">let</span> <span class="variable">api</span> = <span class="keyword">self</span>.client.<span class="title function_ invoke__">runtime_api</span>();</span><br><span class="line">		<span class="keyword">let</span> <span class="variable">at</span> = BlockId::<span class="title function_ invoke__">hash</span>(at.<span class="title function_ invoke__">unwrap_or_else</span>(|| <span class="keyword">self</span>.client.<span class="title function_ invoke__">info</span>().best_hash));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">let</span> <span class="variable">runtime_api_result</span> = api.<span class="title function_ invoke__">rpc_method</span>(&amp;at, v);</span><br><span class="line">		runtime_api_result.<span class="title function_ invoke__">map_err</span>(|e| RpcError &#123;</span><br><span class="line">			code: ErrorCode::<span class="title function_ invoke__">ServerError</span>(<span class="number">9876</span>),</span><br><span class="line">			message: <span class="string">&quot;Something wrong&quot;</span>.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">			data: <span class="title function_ invoke__">Some</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, e).<span class="title function_ invoke__">into</span>()),</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-在项目的runtime中引入rpc">4. 在项目的runtime中引入rpc</h2>
<p>在runtime/Cargo.toml中添加依赖：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="comment">#...</span></span><br><span class="line"><span class="attr">use-rpc-runtime-api</span> = &#123; version = <span class="string">&quot;1.0.0&quot;</span>, path = <span class="string">&quot;../pallets/use-rpc/runtime-api&quot;</span> &#125;</span><br><span class="line"><span class="comment">#...</span></span><br><span class="line"></span><br><span class="line"><span class="section">[features]</span></span><br><span class="line"><span class="attr">default</span> = [<span class="string">&quot;std&quot;</span>]</span><br><span class="line"><span class="attr">std</span> = [</span><br><span class="line">   <span class="comment">#...</span></span><br><span class="line">   <span class="string">&quot;use-rpc-runtime-api/std&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>在runtime/src/lib.rs中添加：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">impl_runtime_apis! &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">impl</span> <span class="title class_">use_rpc_runtime_api</span>::MyRpcRuntimeApi&lt;Block&gt; <span class="keyword">for</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">rpc_method</span>(v: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">       UseRpc::<span class="title function_ invoke__">rpc_method</span>(v)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-node中添加对应rpc">5. node中添加对应rpc</h2>
<p>在node/Cargo.toml中添加如下依赖</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pallet-rpc</span> = &#123; version = <span class="string">&quot;1.0.0&quot;</span>, path = <span class="string">&quot;../pallets/use-rpc/rpc&quot;</span>&#125;</span><br><span class="line"><span class="attr">use-rpc-runtime-api</span> = &#123; version = <span class="string">&quot;1.0.0&quot;</span>, path = <span class="string">&quot;../pallets/use-rpc/runtime-api&quot;</span> &#125;</span><br></pre></td></tr></table></figure>
<p>node/src/rpc.rs中添加如下</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">create_full</span>&lt;C, P&gt;(deps: FullDeps&lt;C, P&gt;) <span class="punctuation">-&gt;</span> jsonrpc_core::IoHandler&lt;sc_rpc::Metadata&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">  C: ProvideRuntimeApi&lt;Block&gt;,</span><br><span class="line">  C: HeaderBackend&lt;Block&gt; + HeaderMetadata&lt;Block, Error = BlockChainError&gt; + <span class="symbol">&#x27;static</span>,</span><br><span class="line">  C: <span class="built_in">Send</span> + <span class="built_in">Sync</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">  C::Api: substrate_frame_rpc_system::AccountNonceApi&lt;Block, AccountId, Index&gt;,</span><br><span class="line">  C::Api: pallet_transaction_payment_rpc::TransactionPaymentRuntimeApi&lt;Block, Balance&gt;,</span><br><span class="line">  <span class="comment">// 添加此行</span></span><br><span class="line">  C::Api: use_rpc_runtime_api::MyRpcRuntimeApi&lt;Block&gt;,</span><br><span class="line">  C::Api: BlockBuilder&lt;Block&gt;,</span><br><span class="line">  P: TransactionPool + <span class="symbol">&#x27;static</span>,</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">use</span> pallet_transaction_payment_rpc::&#123;TransactionPayment, TransactionPaymentApi&#125;;</span><br><span class="line">  <span class="keyword">use</span> substrate_frame_rpc_system::&#123;FullSystem, SystemApi&#125;;</span><br><span class="line">  <span class="comment">// 添加这一行</span></span><br><span class="line">  <span class="keyword">use</span> pallet_rpc::&#123;MyRpcApi, UseRpc&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">io</span> = jsonrpc_core::IoHandler::<span class="title function_ invoke__">default</span>();</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">FullDeps</span> &#123; client, pool, deny_unsafe &#125; = deps;</span><br><span class="line"></span><br><span class="line">  io.<span class="title function_ invoke__">extend_with</span>(SystemApi::<span class="title function_ invoke__">to_delegate</span>(FullSystem::<span class="title function_ invoke__">new</span>(client.<span class="title function_ invoke__">clone</span>(), pool, deny_unsafe)));</span><br><span class="line">        ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//添加这一行</span></span><br><span class="line">  io.<span class="title function_ invoke__">extend_with</span>(MyRpcApi::<span class="title function_ invoke__">to_delegate</span>(UseRpc::<span class="title function_ invoke__">new</span>(client.<span class="title function_ invoke__">clone</span>())));</span><br><span class="line"></span><br><span class="line">  io</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-运行">6. 运行</h2>
<p>运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./target/debug/node-template --dev</span><br></pre></td></tr></table></figure>
<p>调用rpc接口：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl http://localhost:9933 -H &quot;Content-Type:application/json;charset=utf-8&quot; -d   &#x27;&#123;</span><br><span class="line">     &quot;jsonrpc&quot;:&quot;2.0&quot;,</span><br><span class="line">      &quot;id&quot;:1,</span><br><span class="line">      &quot;method&quot;:&quot;my_rpc_method&quot;,</span><br><span class="line">      &quot;params&quot;: [1]</span><br><span class="line">    &#125;&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="7-总结">7. 总结</h2>
<p>本文编辑完毕</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Substrate</category>
        <category>pallet进阶</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Substrate</tag>
      </tags>
  </entry>
  <entry>
    <title>pallet进阶(9)-offchain index</title>
    <url>/articles/1352adf3/</url>
    <content><![CDATA[<p>链下索引，提供的是在链上操作链下存储的方式。</p>
<span id="more"></span>
<h2 id="概述">概述</h2>
<p>注意区分链下存储和链下索引：<br>
链下存储：所有的使用都是在链下进行的（准确的说是在ocw中进行的）<br>
链下索引：链上操作链下存储的方式</p>
<h2 id="案例">案例</h2>
<p>本示例的具体功能就是提供一个调度函数，在该调度函数中通过offchain_index设置链下存储，然后在ocw中将该链下存储的值打印出来。<br>
pallet的lib.rs代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#![cfg_attr(not(feature = <span class="string">&quot;std&quot;</span>), no_std)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> pallet::*;</span><br><span class="line"><span class="meta">#[frame_support::pallet]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> pallet &#123;</span><br><span class="line">  <span class="keyword">use</span> frame_support::pallet_prelude::*;</span><br><span class="line">  <span class="keyword">use</span> frame_system::pallet_prelude::*;</span><br><span class="line">  <span class="keyword">use</span> scale_info::prelude::vec::<span class="type">Vec</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">use</span> sp_runtime::offchain::storage::StorageValueRef;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#[pallet::pallet]</span></span><br><span class="line">  <span class="meta">#[pallet::generate_store(pub(super) trait Store)]</span></span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Pallet</span>&lt;T&gt;(_);</span><br><span class="line"></span><br><span class="line">  <span class="meta">#[pallet::config]</span></span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Config</span>: frame_system::Config &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#[pallet::hooks]</span></span><br><span class="line">  <span class="keyword">impl</span>&lt;T: Config&gt; Hooks&lt;BlockNumberFor&lt;T&gt;&gt; <span class="keyword">for</span> <span class="title class_">Pallet</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">offchain_worker</span>(_block_number: T::BlockNumber) &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Ok</span>(some_number) = <span class="keyword">Self</span>::<span class="title function_ invoke__">get_local_storage</span>() &#123;</span><br><span class="line">        log::info!(target:<span class="string">&quot;offchain-index-demo&quot;</span>, <span class="string">&quot;1. Offchain-index, some_number ======================== &#123;:?&#125;&quot;</span>, some_number);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log::info!(target:<span class="string">&quot;offchain-index-demo&quot;</span>, <span class="string">&quot;2. Offchain-index, no number in storage ==================== &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#[pallet::call]</span></span><br><span class="line">  <span class="keyword">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">#[pallet::weight(0)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_local_storage</span>(</span><br><span class="line">      origin: OriginFor&lt;T&gt;,</span><br><span class="line">      some_number: <span class="type">u32</span>,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> DispatchResultWithPostInfo &#123;</span><br><span class="line">      <span class="title function_ invoke__">ensure_signed</span>(origin)?;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">Self</span>::<span class="title function_ invoke__">set_local_storage_with_offchain_index</span>(some_number);</span><br><span class="line">      <span class="title function_ invoke__">Ok</span>(().<span class="title function_ invoke__">into</span>())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">derived_key</span>() <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; &#123;</span><br><span class="line">      <span class="string">b&quot;offchain-index-demo::value&quot;</span>.<span class="title function_ invoke__">encode</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重点1：看这里，这里是通过offchain_index将值设置到链下存储，请注意key的值</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_local_storage_with_offchain_index</span>(some_number: <span class="type">u32</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> <span class="variable">key</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">derived_key</span>();</span><br><span class="line">      sp_io::offchain_index::<span class="title function_ invoke__">set</span>(&amp;key, some_number.<span class="title function_ invoke__">encode</span>().<span class="title function_ invoke__">as_slice</span>());</span><br><span class="line">      log::info!(target:<span class="string">&quot;offchain-index-demo&quot;</span>, <span class="string">&quot;set some_number ======================== &#123;:?&#125;&quot;</span>, some_number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重点2：看这里，这里是从对应的链下存储读取，请注意key的值</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_local_storage</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">u32</span>, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> <span class="variable">key</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">derived_key</span>();</span><br><span class="line">      <span class="keyword">let</span> <span class="variable">some_number_storage</span> = StorageValueRef::<span class="title function_ invoke__">persistent</span>(&amp;key);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Ok</span>(<span class="title function_ invoke__">Some</span>(number)) = some_number_storage.get::&lt;<span class="type">u32</span>&gt;() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(number)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(<span class="string">&quot;No number in storage.&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行">运行</h2>
<p>启动节点时，需要加上<code>--enable-offchain-indexing=true</code>才能开启索引功能：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">./target/debug/node-template --dev --enable-offchain-indexing=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Substrate</category>
        <category>pallet进阶</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Substrate</tag>
      </tags>
  </entry>
  <entry>
    <title>pallet进阶(8)-offchain storage</title>
    <url>/articles/dea3a0dc/</url>
    <content><![CDATA[<p>链下存储<br>
顾名思义，链下存储不保存在链上，而是保存在节点本地的。</p>
<span id="more"></span>
<h2 id="1-案例1-链下存储基本操作">1. 案例1-链下存储基本操作</h2>
<p>在ocw中使用StorageValueRef<br>
pallet的lib.rs中</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#![cfg_attr(not(feature = <span class="string">&quot;std&quot;</span>), no_std)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> pallet::*;</span><br><span class="line"><span class="meta">#[frame_support::pallet]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> pallet &#123;</span><br><span class="line">  <span class="keyword">use</span> frame_support::pallet_prelude::*;</span><br><span class="line">  <span class="keyword">use</span> frame_system::pallet_prelude::*;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">use</span> sp_runtime::offchain::storage::&#123;</span><br><span class="line">    MutateStorageError, StorageRetrievalError, StorageValueRef,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#[pallet::pallet]</span></span><br><span class="line">  <span class="meta">#[pallet::generate_store(pub(super) trait Store)]</span></span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Pallet</span>&lt;T&gt;(_);</span><br><span class="line"></span><br><span class="line">  <span class="meta">#[pallet::config]</span></span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Config</span>: frame_system::Config &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#[pallet::hooks]</span></span><br><span class="line">  <span class="keyword">impl</span>&lt;T: Config&gt; Hooks&lt;BlockNumberFor&lt;T&gt;&gt; <span class="keyword">for</span> <span class="title class_">Pallet</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">offchain_worker</span>(block_number: T::BlockNumber) &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">Self</span>::<span class="title function_ invoke__">should_print</span>() &#123;</span><br><span class="line">        log::info!(target:<span class="string">&quot;offchain-storage&quot;</span>, <span class="string">&quot;1. Block number: &#123;:?&#125;, should print +++++++++++++++++++++++++++ &quot;</span>, block_number);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log::info!(target:<span class="string">&quot;offchain-storage&quot;</span>, <span class="string">&quot;2. Block number: &#123;:?&#125;, Should not print +++++++++++++++++++++++++++ &quot;</span>, block_number);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//内部方法  </span></span><br><span class="line">  <span class="keyword">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">should_print</span>() <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> LAST_VALUE: () = ();</span><br><span class="line">      <span class="comment">//重点看这里</span></span><br><span class="line">      <span class="keyword">let</span> <span class="variable">val</span> = StorageValueRef::<span class="title function_ invoke__">persistent</span>(<span class="string">b&quot;ocw-demo::last_value&quot;</span>);</span><br><span class="line">      <span class="keyword">let</span> <span class="variable">res</span> = val.<span class="title function_ invoke__">mutate</span>(</span><br><span class="line">          |last_flag: <span class="type">Result</span>&lt;<span class="type">Option</span>&lt;<span class="type">bool</span>&gt;, StorageRetrievalError&gt;| <span class="keyword">match</span> last_flag &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">Some</span>(flag)) =&gt; <span class="title function_ invoke__">Ok</span>(!flag),</span><br><span class="line">            _ =&gt; <span class="title function_ invoke__">Ok</span>(<span class="literal">true</span>),</span><br><span class="line">          &#125;,</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">      <span class="keyword">match</span> res &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(flag) =&gt; flag,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(MutateStorageError::<span class="title function_ invoke__">ValueFunctionFailed</span>(LAST_VALUE)) =&gt; <span class="literal">false</span>,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(MutateStorageError::<span class="title function_ invoke__">ConcurrentModification</span>(_)) =&gt; <span class="literal">false</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关引入和编译后，即可正常运行</p>
<h2 id="2-在ocw中使用local-storage-set-get">2. 在ocw中使用local_storage_set/get</h2>
<p>手动通过rpc对storage demo::flag设置为true，然后在代码中查看此存储的值，然后再将此值写到另外一个存储demo::result中</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![cfg_attr(not(feature = <span class="string">&quot;std&quot;</span>), no_std)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> pallet::*;</span><br><span class="line"><span class="meta">#[frame_support::pallet]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> pallet &#123;</span><br><span class="line">  <span class="keyword">use</span> frame_support::pallet_prelude::*;</span><br><span class="line">  <span class="keyword">use</span> frame_system::pallet_prelude::*;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">crate</span> alloc;</span><br><span class="line">  <span class="keyword">use</span> alloc::string::&#123;<span class="type">String</span>, <span class="built_in">ToString</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#[pallet::pallet]</span></span><br><span class="line">  <span class="meta">#[pallet::generate_store(pub(super) trait Store)]</span></span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Pallet</span>&lt;T&gt;(_);</span><br><span class="line"></span><br><span class="line">  <span class="meta">#[pallet::config]</span></span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Config</span>: frame_system::Config &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#[pallet::hooks]</span></span><br><span class="line">  <span class="keyword">impl</span>&lt;T: Config&gt; Hooks&lt;BlockNumberFor&lt;T&gt;&gt; <span class="keyword">for</span> <span class="title class_">Pallet</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">offchain_worker</span>(block_number: T::BlockNumber) &#123;</span><br><span class="line">      <span class="keyword">let</span> <span class="variable">flag</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">should_print</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> flag &#123;</span><br><span class="line">        log::info!(target:<span class="string">&quot;offchain-storage2222&quot;</span>, <span class="string">&quot;1. Offchain-storage2, block number: &#123;:?&#125;, should print +++++++++++ &quot;</span>, block_number);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log::info!(target:<span class="string">&quot;offchain-storage2222&quot;</span>, <span class="string">&quot;2. Offchain-storage2, block number: &#123;:?&#125;, Should not print +++++++++++ &quot;</span>, block_number);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">Self</span>::<span class="title function_ invoke__">set_result</span>(flag);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">should_print</span>() <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> <span class="variable">kind</span> = sp_core::offchain::StorageKind::PERSISTENT;</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(flag) = sp_io::offchain::<span class="title function_ invoke__">local_storage_get</span>(kind, <span class="string">b&quot;demo::flag&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ret</span> = <span class="keyword">match</span> <span class="type">String</span>::<span class="title function_ invoke__">from_utf8</span>(flag) &#123;</span><br><span class="line">          <span class="title function_ invoke__">Ok</span>(v) =&gt; v.<span class="title function_ invoke__">eq</span>(&amp;<span class="string">&quot;true&quot;</span>),</span><br><span class="line">          <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="literal">false</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        ret</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_result</span>(flag: <span class="type">bool</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> <span class="variable">kind</span> = sp_core::offchain::StorageKind::PERSISTENT;</span><br><span class="line">      <span class="keyword">let</span> <span class="variable">value</span> = <span class="keyword">match</span> flag &#123;</span><br><span class="line">        <span class="literal">true</span> =&gt; <span class="string">&quot;true&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        <span class="literal">false</span> =&gt; <span class="string">&quot;false&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">      &#125;;</span><br><span class="line">      sp_io::offchain::<span class="title function_ invoke__">local_storage_set</span>(kind, <span class="string">b&quot;demo::result&quot;</span>, value.<span class="title function_ invoke__">as_bytes</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Substrate</category>
        <category>pallet进阶</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Substrate</tag>
      </tags>
  </entry>
  <entry>
    <title>pallet进阶(6)-offchain-worker</title>
    <url>/articles/5b3ac830/</url>
    <content><![CDATA[<p>offchain worker，链下工作者。</p>
<span id="more"></span>
<h2 id="1-概述">1. 概述</h2>
<ol>
<li><code>offchain worker</code> 可以提交签名交易、未签名交易、具有签名负载的未签名交易(即内容签名的未签名交易)等功能。</li>
<li>一个block import结束之后开始执行offchain worker</li>
<li><code>ocw</code>即为<code>offchain worker</code>的缩写</li>
</ol>
<h2 id="2-提交签名交易">2. 提交签名交易</h2>
<p>表示用自己的私钥签名的文件或内容，标明归属权</p>
<h3 id="2-1-在pallet中添加代码">2.1 在pallet中添加代码</h3>
<p>pallet的lib.rs中：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![cfg_attr(not(feature = <span class="string">&quot;std&quot;</span>), no_std)]</span></span><br><span class="line"><span class="comment">//=========================</span></span><br><span class="line"><span class="comment">//需要关注的第一部分，引入相关密码学工具</span></span><br><span class="line"><span class="comment">// 这部分主要是用来在offchain worker提交签名交易时的签名的子模块。在实际的开发中，这部分基本上是固定的写法。在substrate中支持ed25519和sr25519，我们此处使用的是sr29915作为例子。其中KEY_TYPE是offchain worker签名时检索key使用的类型，由开发者指定，我们这里指定为“demo”。</span></span><br><span class="line"><span class="comment">//=========================</span></span><br><span class="line"><span class="keyword">use</span> sp_core::crypto::KeyTypeId;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> KEY_TYPE: KeyTypeId = <span class="title function_ invoke__">KeyTypeId</span>(*<span class="string">b&quot;demo&quot;</span>);</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> crypto &#123;</span><br><span class="line">  <span class="keyword">use</span> super::KEY_TYPE;</span><br><span class="line">  <span class="keyword">use</span> sp_runtime::app_crypto::&#123;app_crypto, sr25519&#125;;</span><br><span class="line">  app_crypto!(sr25519, KEY_TYPE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">AuthorityId</span> = crypto::Public;</span><br><span class="line"><span class="comment">//==========================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> pallet::*;</span><br><span class="line"><span class="meta">#[frame_support::pallet]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> pallet &#123;</span><br><span class="line">  <span class="keyword">use</span> frame_support::pallet_prelude::*;</span><br><span class="line">  <span class="keyword">use</span> frame_system::pallet_prelude::*;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">use</span> frame_system::offchain::&#123;</span><br><span class="line">    AppCrypto, CreateSignedTransaction, SendSignedTransaction, Signer,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#[pallet::pallet]</span></span><br><span class="line">  <span class="meta">#[pallet::generate_store(pub(super) trait Store)]</span></span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Pallet</span>&lt;T&gt;(_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//=========================</span></span><br><span class="line">  <span class="comment">//需要关注的第二部分，需要实现签名配置</span></span><br><span class="line">  <span class="comment">//config需要继承 CreateSignedTransaction；</span></span><br><span class="line">  <span class="comment">//需要定义类型type AuthorityId: AppCrypto&lt;Self::Public, Self::Signature&gt;;</span></span><br><span class="line">  <span class="meta">#[pallet::config]</span></span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Config</span>: frame_system::Config + CreateSignedTransaction&lt;Call&lt;<span class="keyword">Self</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">AuthorityId</span>: AppCrypto&lt;<span class="keyword">Self</span>::Public, <span class="keyword">Self</span>::Signature&gt;;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Event</span>: <span class="built_in">From</span>&lt;Event&lt;<span class="keyword">Self</span>&gt;&gt; + IsType&lt;&lt;<span class="keyword">Self</span> <span class="keyword">as</span> frame_system::Config&gt;::Event&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//=========================</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">#[pallet::storage]</span></span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">SomeInfo</span>&lt;T: Config&gt; = StorageMap&lt;_, Blake2_128Concat, <span class="type">u64</span>, <span class="type">u64</span>, ValueQuery&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#[pallet::event]</span></span><br><span class="line">  <span class="meta">#[pallet::generate_deposit(pub(super) fn deposit_event)]</span></span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Event</span>&lt;T: Config&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">SetSomeInfo</span>(<span class="type">u64</span>, <span class="type">u64</span>),</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#[pallet::error]</span></span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Error</span>&lt;T&gt; &#123;</span><br><span class="line">    OffchainSignedTxError,</span><br><span class="line">    NoAcctForSigning,</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//=========================</span></span><br><span class="line">  <span class="comment">//需要关注的第三部分 钩子函数中，加入链下函数，该offchain_worker函数会在一个块import成功后调用</span></span><br><span class="line">  <span class="comment">//调用offchain worker是在钩子函数中实现。这里重点要提一下的是代码注释标注3.1的部分，在offchain worker中调用交易的方式是这样，</span></span><br><span class="line">  <span class="comment">//=========================</span></span><br><span class="line">  <span class="meta">#[pallet::hooks]</span></span><br><span class="line">  <span class="keyword">impl</span>&lt;T: Config&gt; Hooks&lt;BlockNumberFor&lt;T&gt;&gt; <span class="keyword">for</span> <span class="title class_">Pallet</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">offchain_worker</span>(block_number: T::BlockNumber) &#123;</span><br><span class="line">      log::info!(target: <span class="string">&quot;ocw&quot;</span>, <span class="string">&quot;before offchain_worker set storage: &#123;:?&#125;&quot;</span>, block_number);</span><br><span class="line">      <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">offchain_signed_tx</span>(block_number);</span><br><span class="line">      log::info!(target: <span class="string">&quot;ocw&quot;</span>, <span class="string">&quot;after offchain_worker set storage: &#123;:?&#125;&quot;</span>, block_number);</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = result &#123;</span><br><span class="line">        log::error!(target:<span class="string">&quot;ocw&quot;</span>, <span class="string">&quot;offchain_worker error: &#123;:?&#125;&quot;</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#[pallet::call]</span></span><br><span class="line">  <span class="keyword">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">#[pallet::weight(0)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">submit_something_signed</span>(origin: OriginFor&lt;T&gt;, number: <span class="type">u64</span>, ) <span class="punctuation">-&gt;</span> DispatchResultWithPostInfo &#123;</span><br><span class="line">      log::info!(target:<span class="string">&quot;ocw&quot;</span>, <span class="string">&quot;11111 +++++++++++++++++++ &quot;</span>);</span><br><span class="line">      <span class="title function_ invoke__">ensure_signed</span>(origin)?;</span><br><span class="line">      <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">cnt</span>: <span class="type">u64</span> = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> number &gt; <span class="number">0</span> &#123;</span><br><span class="line">        cnt = number;</span><br><span class="line">      &#125;</span><br><span class="line">      log::info!(target:<span class="string">&quot;ocw&quot;</span>, <span class="string">&quot;+++++++++++++++++++ offchain_worker set storage: &#123;:?&#125;, cnt: &#123;:?&#125;&quot;</span>, number, cnt);</span><br><span class="line">      SomeInfo::&lt;T&gt;::<span class="title function_ invoke__">insert</span>(&amp;number, cnt);</span><br><span class="line">      <span class="keyword">Self</span>::<span class="title function_ invoke__">deposit_event</span>(Event::<span class="title function_ invoke__">SetSomeInfo</span>(number, cnt));</span><br><span class="line">      <span class="title function_ invoke__">Ok</span>(().<span class="title function_ invoke__">into</span>())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这是属于内部方法</span></span><br><span class="line">  <span class="keyword">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">offchain_signed_tx</span>(block_number: T::BlockNumber) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&lt;T&gt;&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> <span class="variable">signer</span> = Signer::&lt;T, T::AuthorityId&gt;::<span class="title function_ invoke__">any_account</span>();</span><br><span class="line">      log::info!(target:<span class="string">&quot;ocw&quot;</span>, <span class="string">&quot;+++++++++++++++++++, can sign: &#123;:?&#125;&quot;</span>, signer.<span class="title function_ invoke__">can_sign</span>());</span><br><span class="line">      <span class="keyword">let</span> <span class="variable">number</span>: <span class="type">u64</span> = block_number.<span class="title function_ invoke__">try_into</span>().<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="comment">//需要关注的3.1</span></span><br><span class="line">      <span class="keyword">let</span> <span class="variable">result</span> = signer.<span class="title function_ invoke__">send_signed_transaction</span>(|_acct| Call::submit_something_signed &#123; number &#125;);</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>((_acc, res)) = result &#123;</span><br><span class="line">        <span class="keyword">if</span> res.<span class="title function_ invoke__">is_err</span>() &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(&lt;Error&lt;T&gt;&gt;::OffchainSignedTxError)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(&lt;Error&lt;T&gt;&gt;::NoLocalAcctForSigning)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-在runtime中添加相关代码">2.2 在runtime中添加相关代码</h3>
<p>runtime/src/lib.rs中</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;LocalCall&gt; frame_system::offchain::CreateSignedTransaction&lt;LocalCall&gt; <span class="keyword">for</span> <span class="title class_">Runtime</span></span><br><span class="line"><span class="keyword">where</span> Call: <span class="built_in">From</span>&lt;LocalCall&gt;, &#123;</span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">create_transaction</span>&lt;C: frame_system::offchain::AppCrypto&lt;<span class="keyword">Self</span>::Public, <span class="keyword">Self</span>::Signature&gt;&gt;(</span><br><span class="line">    call: Call,</span><br><span class="line">    public: &lt;Signature <span class="keyword">as</span> sp_runtime::traits::Verify&gt;::Signer,</span><br><span class="line">    account: AccountId,</span><br><span class="line">    nonce: Index, ) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;(Call, &lt;UncheckedExtrinsic <span class="keyword">as</span> sp_runtime::traits::Extrinsic&gt;::SignaturePayload)&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tip</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// take the biggest period possible.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">period</span> = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">    <span class="comment">// BlockHashCount::get().checked_next_power_of_two().map(|c| c / 2).unwrap_or(2) as u64;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">current_block</span> = System::<span class="title function_ invoke__">block_number</span>()</span><br><span class="line">      .saturated_into::&lt;<span class="type">u64</span>&gt;()</span><br><span class="line">      <span class="comment">// The `System::block_number` is initialized with `n+1`,</span></span><br><span class="line">      <span class="comment">// so the actual block number is `n`.</span></span><br><span class="line">      .<span class="title function_ invoke__">saturating_sub</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">era</span> = Era::<span class="title function_ invoke__">mortal</span>(period, current_block);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">extra</span> = (</span><br><span class="line">      frame_system::CheckNonZeroSender::&lt;Runtime&gt;::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">      frame_system::CheckSpecVersion::&lt;Runtime&gt;::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">      frame_system::CheckTxVersion::&lt;Runtime&gt;::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">      frame_system::CheckGenesis::&lt;Runtime&gt;::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">      frame_system::CheckEra::&lt;Runtime&gt;::<span class="title function_ invoke__">from</span>(era),</span><br><span class="line">      frame_system::CheckNonce::&lt;Runtime&gt;::<span class="title function_ invoke__">from</span>(nonce),</span><br><span class="line">      frame_system::CheckWeight::&lt;Runtime&gt;::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">      pallet_transaction_payment::ChargeTransactionPayment::&lt;Runtime&gt;::<span class="title function_ invoke__">from</span>(tip),</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">raw_payload</span> = SignedPayload::<span class="title function_ invoke__">new</span>(call, extra)</span><br><span class="line">      .<span class="title function_ invoke__">map_err</span>(|e| &#123;</span><br><span class="line">        log::warn!(<span class="string">&quot;Unable to create signed payload: &#123;:?&#125;&quot;</span>, e);</span><br><span class="line">      &#125;).<span class="title function_ invoke__">ok</span>()?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">signature</span> = raw_payload.<span class="title function_ invoke__">using_encoded</span>(|payload| C::<span class="title function_ invoke__">sign</span>(payload, public))?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">address</span> = &lt;<span class="keyword">Self</span> <span class="keyword">as</span> frame_system::Config&gt;::Lookup::<span class="title function_ invoke__">unlookup</span>(account);</span><br><span class="line">    <span class="keyword">let</span> (call, extra, _) = raw_payload.<span class="title function_ invoke__">deconstruct</span>();</span><br><span class="line">    <span class="title function_ invoke__">Some</span>((call, (address, signature.<span class="title function_ invoke__">into</span>(), extra)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">frame_system</span>::offchain::SigningTypes <span class="keyword">for</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Public</span> = &lt;Signature <span class="keyword">as</span> sp_runtime::traits::Verify&gt;::Signer;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Signature</span> = Signature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;C&gt; frame_system::offchain::SendTransactionTypes&lt;C&gt; <span class="keyword">for</span> <span class="title class_">Runtime</span></span><br><span class="line"><span class="keyword">where</span> Call: <span class="built_in">From</span>&lt;C&gt;, &#123;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">OverarchingCall</span> = Call;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Extrinsic</span> = UncheckedExtrinsic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在大多数情况下直接这样使用就好了。下面还需要为runtime添加pallet_ocw_sigtx::Config：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MyAuthorityId</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">frame_system</span>::offchain::AppCrypto&lt;&lt;Signature <span class="keyword">as</span> Verify&gt;::Signer, Signature&gt; <span class="keyword">for</span> <span class="title class_">MyAuthorityId</span> &#123;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">RuntimeAppPublic</span> = pallet_ocw_sigtx::crypto::Public;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">GenericSignature</span> = sp_core::sr25519::Signature;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">GenericPublic</span> = sp_core::sr25519::Public;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">pallet_ocw_sigtx</span>::Config <span class="keyword">for</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">AuthorityId</span> = MyAuthorityId;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Event</span> = Event;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">construct_runtime!(</span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Runtime</span> <span class="keyword">where</span></span><br><span class="line">    Block = Block,</span><br><span class="line">    NodeBlock = opaque::Block,</span><br><span class="line">    UncheckedExtrinsic = UncheckedExtrinsic&#123;</span><br><span class="line">    System: frame_system,</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    OcwSigtx: pallet_ocw_sigtx,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-提交未签名交易">3. 提交未签名交易</h2>
<h3 id="3-1-在pallet中添加offchain-worker">3.1 在pallet中添加offchain worker</h3>
<ol>
<li>修改Config配置</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[pallet::config]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Config</span>: frame_system::Config + SendTransactionTypes&lt;Call&lt;<span class="keyword">Self</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>实现具体的未签名调度函数<br>
也就是公共函数</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[pallet::weight(0)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">submit_something_unsigned</span>(origin: OriginFor&lt;T&gt;, number: <span class="type">u64</span>, ) <span class="punctuation">-&gt;</span> DispatchResultWithPostInfo &#123;</span><br><span class="line">  <span class="title function_ invoke__">ensure_none</span>(origin)?;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">cnt</span>: <span class="type">u64</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> number &gt; <span class="number">0</span> &#123;</span><br><span class="line">    cnt = number;</span><br><span class="line">  &#125;</span><br><span class="line">  log::info!(target:<span class="string">&quot;ocw&quot;</span>, <span class="string">&quot;unsigned +++++++++++++++++++ offchain_worker set storage: &#123;:?&#125;, cnt: &#123;:?&#125;&quot;</span>, number, cnt);</span><br><span class="line">  SomeInfo::&lt;T&gt;::<span class="title function_ invoke__">insert</span>(&amp;number, cnt);</span><br><span class="line">  <span class="keyword">Self</span>::<span class="title function_ invoke__">deposit_event</span>(Event::<span class="title function_ invoke__">UnsignedPutSetSomeInfo</span>(number, cnt));</span><br><span class="line">  <span class="title function_ invoke__">Ok</span>(().<span class="title function_ invoke__">into</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在offchain worker中调用未签名交易函数<br>
钩子函数中调用</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[pallet::hooks]</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Config&gt; Hooks&lt;BlockNumberFor&lt;T&gt;&gt; <span class="keyword">for</span> <span class="title class_">Pallet</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">offchain_worker</span>(block_number: T::BlockNumber) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">number</span>: <span class="type">u64</span> = block_number.<span class="title function_ invoke__">try_into</span>().<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">//下面为具体的调用未签名交易的方式</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">call</span> = Call::submit_something_unsigned &#123; number &#125;;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = SubmitTransaction::&lt;T, Call&lt;T&gt;&gt;::<span class="title function_ invoke__">submit_unsigned_transaction</span>(call.<span class="title function_ invoke__">into</span>())</span><br><span class="line">      .<span class="title function_ invoke__">map_err</span>(|_| &lt;Error&lt;T&gt;&gt;::OffchainUnsignedTxError) &#123;</span><br><span class="line">    log::error!(target:<span class="string">&quot;ocw&quot;</span>, <span class="string">&quot;offchain_worker submit unsigned tx error: &#123;:?&#125;&quot;</span>, e);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    log::info!(target:<span class="string">&quot;ocw&quot;</span>, <span class="string">&quot;offchain_worker submit unsigned tx success&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>实现未签名交易验证的trait</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[pallet::validate_unsigned]</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Config&gt; ValidateUnsigned <span class="keyword">for</span> <span class="title class_">Pallet</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Call</span> = Call&lt;T&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">validate_unsigned</span>(_source: TransactionSource, call: &amp;<span class="keyword">Self</span>::Call) <span class="punctuation">-&gt;</span> TransactionValidity &#123;</span><br><span class="line">       <span class="comment">//Call冒号后面就是具体的提交未签名交易的函数，</span></span><br><span class="line">       <span class="comment">//需要对此交易进行验证</span></span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Call</span>::submit_something_unsigned &#123; number: _ &#125; = call &#123;</span><br><span class="line">        ValidTransaction::<span class="title function_ invoke__">with_tag_prefix</span>(<span class="string">&quot;OcwUnsigtx&quot;</span>)</span><br><span class="line">          .<span class="title function_ invoke__">priority</span>(TransactionPriority::<span class="title function_ invoke__">max_value</span>())</span><br><span class="line">          .<span class="title function_ invoke__">longevity</span>(<span class="number">5</span>)</span><br><span class="line">          .<span class="title function_ invoke__">propagate</span>(<span class="literal">false</span>)</span><br><span class="line">          .<span class="title function_ invoke__">build</span>()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        InvalidTransaction::Call.<span class="title function_ invoke__">into</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="3-2-在runtime中添加相关代码">3.2 在runtime中添加相关代码</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">pallet_ocw_unsigtx</span>::Config <span class="keyword">for</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Event</span> = Event;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">construct_runtime!(</span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Runtime</span> <span class="keyword">where</span></span><br><span class="line">    Block = Block,</span><br><span class="line">    NodeBlock = opaque::Block,</span><br><span class="line">    UncheckedExtrinsic = UncheckedExtrinsic</span><br><span class="line">  &#123;</span><br><span class="line">    System: frame_system,</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    OcwUnSigtx: pallet_ocw_unsigtx,</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="4-具有签名负载的未签名交易">4. 具有签名负载的未签名交易</h2>
<p>和<code>提交未签名交易</code>的方式类似，需要时再细查</p>
<h2 id="5-应用：在ocw中发送http请求">5. 应用：在ocw中发送http请求</h2>
<p>这部分的功能非常简单，就是发送请求https://min-api.cryptocompare.com/data/price?fsym=BTC&amp;tsyms=USD 来获取btc价格</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内部方法</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">parse_price</span>(price_str: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">u32</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">val</span> = lite_json::<span class="title function_ invoke__">parse_json</span>(price_str);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">price</span> = <span class="keyword">match</span> val.<span class="title function_ invoke__">ok</span>()? &#123;</span><br><span class="line">            JsonValue::<span class="title function_ invoke__">Object</span>(obj) =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> (_, v) =</span><br><span class="line">                    obj.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">find</span>(|(k, _)| k.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">copied</span>().<span class="title function_ invoke__">eq</span>(<span class="string">&quot;USD&quot;</span>.<span class="title function_ invoke__">chars</span>()))?;</span><br><span class="line">                <span class="keyword">match</span> v &#123;</span><br><span class="line">                    JsonValue::<span class="title function_ invoke__">Number</span>(number) =&gt; number,</span><br><span class="line">                    _ =&gt; <span class="keyword">return</span> <span class="literal">None</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            _ =&gt; <span class="keyword">return</span> <span class="literal">None</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">exp</span> = price.fraction_length.<span class="title function_ invoke__">saturating_sub</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(price.integer <span class="keyword">as</span> <span class="type">u32</span> * <span class="number">100</span> + (price.fraction / <span class="number">10_u64</span>.<span class="title function_ invoke__">pow</span>(exp)) <span class="keyword">as</span> <span class="type">u32</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fetch_price</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">u32</span>, http::Error&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">deadline</span> = sp_io::offchain::<span class="title function_ invoke__">timestamp</span>().<span class="title function_ invoke__">add</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">2_000</span>));</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">request</span> = http::Request::<span class="title function_ invoke__">get</span>(</span><br><span class="line">            <span class="string">&quot;https://min-api.cryptocompare.com/data/price?fsym=BTC&amp;tsyms=USD&quot;</span>,</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pending</span> = request.<span class="title function_ invoke__">deadline</span>(deadline).<span class="title function_ invoke__">send</span>().<span class="title function_ invoke__">map_err</span>(|_| http::Error::IoError)?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">response</span> =</span><br><span class="line">            pending.<span class="title function_ invoke__">try_wait</span>(deadline).<span class="title function_ invoke__">map_err</span>(|_| http::Error::DeadlineReached)??;</span><br><span class="line">        <span class="keyword">if</span> response.code != <span class="number">200</span> &#123;</span><br><span class="line">            log::warn!(<span class="string">&quot;Unexpected status code: &#123;&#125;&quot;</span>, response.code);</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(http::Error::Unknown)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">body</span> = response.<span class="title function_ invoke__">body</span>().collect::&lt;<span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;&gt;();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">body_str</span> = sp_std::<span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(&amp;body).<span class="title function_ invoke__">map_err</span>(|_| &#123;</span><br><span class="line">            log::warn!(<span class="string">&quot;No UTF8 body&quot;</span>);</span><br><span class="line">            http::Error::Unknown</span><br><span class="line">        &#125;)?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">price</span> = <span class="keyword">match</span> <span class="keyword">Self</span>::<span class="title function_ invoke__">parse_price</span>(body_str) &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(price) =&gt; <span class="title function_ invoke__">Ok</span>(price),</span><br><span class="line">            <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                log::warn!(<span class="string">&quot;Unable to extract price from the response: &#123;:?&#125;&quot;</span>, body_str);</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(http::Error::Unknown)</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;?;</span><br><span class="line">        log::warn!(<span class="string">&quot;Got price: &#123;&#125; cents&quot;</span>, price);</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(price)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>钩子函数调用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[pallet::hooks]</span></span><br><span class="line">  <span class="keyword">impl</span>&lt;T: Config&gt; Hooks&lt;BlockNumberFor&lt;T&gt;&gt; <span class="keyword">for</span> <span class="title class_">Pallet</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">offchain_worker</span>(_block_number: T::BlockNumber) &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Ok</span>(data) = <span class="keyword">Self</span>::<span class="title function_ invoke__">fetch_price</span>() &#123;</span><br><span class="line">        log::info!(target:<span class="string">&quot;offchain-index-demo&quot;</span>, <span class="string">&quot;1. get price, price ======================== &#123;:?&#125;&quot;</span>, data);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log::info!(target:<span class="string">&quot;offchain-index-demo&quot;</span>, <span class="string">&quot;2. get price failed ==================== &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Substrate</category>
        <category>pallet进阶</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Substrate</tag>
      </tags>
  </entry>
  <entry>
    <title>pallet进阶(6)-调试</title>
    <url>/articles/10dc8319/</url>
    <content><![CDATA[<p>pallet的调试</p>
<span id="more"></span>
<h2 id="1-概述">1. 概述</h2>
<p>在pallet开发时主要有以下几种调试方式：</p>
<ol>
<li>logging uilities</li>
<li>printable trait</li>
<li>print函数</li>
<li>if_std</li>
</ol>
<h2 id="2-logging-uilities">2. logging uilities</h2>
<p>加入依赖：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">log</span> = &#123; version = <span class="string">&quot;0.4.14&quot;</span>, default-features = <span class="literal">false</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="section">[features]</span></span><br><span class="line"><span class="attr">default</span> = [<span class="string">&quot;std&quot;</span>]</span><br><span class="line"><span class="attr">std</span> = [</span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  <span class="string">&quot;log/std&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>在pallet中，需要打印的地方，直接使用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">log::info!(<span class="string">&quot;|||||||||||||||||||||| called by &#123;:?&#125;&quot;</span>, who);</span><br></pre></td></tr></table></figure>
<h2 id="3-printable-trait">3. printable trait</h2>
<p>需要为需要打印的类型实现printable trait，这里为Error类型实现对应的trait，然后再进行打印，需要修改代码如下：</p>
<p>pallet的lib.rs中：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> sp_runtime::traits::Printable;</span><br><span class="line"><span class="keyword">use</span> sp_runtime::print;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[pallet::error]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Error</span>&lt;T&gt; &#123;</span><br><span class="line">    NoneValue,</span><br><span class="line">    StorageOverflow,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Config&gt; Printable <span class="keyword">for</span> <span class="title class_">Error</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            Error::NoneValue =&gt; <span class="string">&quot;Invalid Value&quot;</span>.<span class="title function_ invoke__">print</span>(),</span><br><span class="line">            Error::StorageOverflow =&gt; <span class="string">&quot;++++++++++++++++++++++++++ Value Exceeded and Overflowed&quot;</span>.<span class="title function_ invoke__">print</span>(),</span><br><span class="line">            _ =&gt; <span class="string">&quot;Invalid Error Case&quot;</span>.<span class="title function_ invoke__">print</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在需要打印的地方，直接调用：</span></span><br><span class="line"><span class="title function_ invoke__">print</span>(Error::&lt;T&gt;::NoneValue);</span><br></pre></td></tr></table></figure>
<h2 id="4-print函数">4. print函数</h2>
<p>直接使用print进行打印</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> sp_runtime::print;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">print</span>(<span class="string">&quot;After storing my_val&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="5-if-std">5. if_std</h2>
<p>没用过，暂不考虑</p>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Substrate</category>
        <category>pallet进阶</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Substrate</tag>
      </tags>
  </entry>
  <entry>
    <title>substrate进阶(5)-不同pallet之间的使用</title>
    <url>/articles/90c002dd/</url>
    <content><![CDATA[<p>不同pallet之间的使用</p>
<span id="more"></span>
<h2 id="1-概述">1. 概述</h2>
<p>多个pallet之间的调用，主要有以下几种情况：</p>
<ol>
<li>调用现有的pallet：即在pallet的config中定义类型，然后runtime中使用时指定这个类型为frame中指定某个现成的pallet；</li>
<li>调用自定义的pallet：即在pallet的config中定义类型，然后runtime中使用时指定这个类型为frame中指定某个自定义的pallet；</li>
<li>封装和扩展现有的pallet。</li>
</ol>
<h2 id="2-调用现有的pallet">2. 调用现有的pallet</h2>
<p>runtime/lib.rs中:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义：</span></span><br><span class="line">construct_runtime!() &#123;</span><br><span class="line">  Balances: pallet_balances,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对应Config中直接引入：</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">pallet_contracts</span>::Config <span class="keyword">for</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Currency</span> = Balances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-调用自定义的pallet">3. 调用自定义的pallet</h2>
<p>通过案例来说明：<code>pallet2</code>调用<code>pallet1</code>：</p>
<ol>
<li>pallet1作为被调用者，先实现：<br>
先定义一个<code>trait.rs</code>文件：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">StorageInterface</span>&#123;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Value</span>;</span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">get_param</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Value;</span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">set_param</span>(v: <span class="keyword">Self</span>::Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lib.rs中内容：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![cfg_attr(not(feature = <span class="string">&quot;std&quot;</span>), no_std)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> pallet::*;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> traits::StorageInterface;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> traits;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[frame_support::pallet]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> pallet &#123;</span><br><span class="line">  <span class="keyword">use</span> codec::Codec;</span><br><span class="line">  <span class="keyword">use</span> frame_support::&#123;</span><br><span class="line">    pallet_prelude::*, </span><br><span class="line">    sp_runtime::traits::AtLeast32BitUnsigned, </span><br><span class="line">    sp_std::fmt::<span class="built_in">Debug</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">use</span> frame_system::pallet_prelude::*;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#[pallet::pallet]</span></span><br><span class="line">  <span class="meta">#[pallet::generate_store(pub(super) trait Store)]</span></span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Pallet</span>&lt;T&gt;(_);</span><br><span class="line"></span><br><span class="line">  <span class="meta">#[pallet::config]</span></span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Config</span>: frame_system::Config &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Event</span>: <span class="built_in">From</span>&lt;Event&lt;<span class="keyword">Self</span>&gt;&gt; </span><br><span class="line">      + IsType&lt;&lt;<span class="keyword">Self</span> <span class="keyword">as</span> frame_system::Config&gt;::Event&gt;;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Value</span>: Member</span><br><span class="line">      + Parameter</span><br><span class="line">      + AtLeast32BitUnsigned</span><br><span class="line">      + Codec</span><br><span class="line">      + <span class="built_in">From</span>&lt;<span class="type">u32</span>&gt;</span><br><span class="line">      + <span class="built_in">Into</span>&lt;<span class="type">u32</span>&gt;</span><br><span class="line">      + <span class="built_in">Copy</span></span><br><span class="line">      + <span class="built_in">Debug</span></span><br><span class="line">      + <span class="built_in">Default</span></span><br><span class="line">      + MaxEncodedLen</span><br><span class="line">      + MaybeSerializeDeserialize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#[pallet::storage]</span></span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">MyValue</span>&lt;T: Config&gt; = </span><br><span class="line">       StorageValue&lt;_, T::Value, ValueQuery&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#[pallet::event]</span></span><br><span class="line">  <span class="meta">#[pallet::generate_deposit(pub(super) fn deposit_event)]</span></span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Event</span>&lt;T: Config&gt; &#123;</span><br><span class="line">    FunctionCall,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#[pallet::call]</span></span><br><span class="line">  <span class="keyword">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">#[pallet::weight(0)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">my_function</span>(</span><br><span class="line">      origin: OriginFor&lt;T&gt;,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> DispatchResultWithPostInfo &#123;</span><br><span class="line">      <span class="title function_ invoke__">ensure_signed</span>(origin)?;</span><br><span class="line">      log::info!(target: <span class="string">&quot;storage pallet1&quot;</span>, <span class="string">&quot;my function!&quot;</span>);</span><br><span class="line">      <span class="keyword">Self</span>::<span class="title function_ invoke__">deposit_event</span>(Event::FunctionCall);</span><br><span class="line">      <span class="title function_ invoke__">Ok</span>(().<span class="title function_ invoke__">into</span>())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意此处：我们为pallet实现了前面定义的trait StorageInterface.</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Config&gt; StorageInterface <span class="keyword">for</span> <span class="title class_">Pallet</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Value</span> = T::Value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">get_param</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Value &#123;</span><br><span class="line">    MyValue::&lt;T&gt;::<span class="title function_ invoke__">get</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">set_param</span>(v: <span class="keyword">Self</span>::Value) &#123;</span><br><span class="line">    MyValue::&lt;T&gt;::<span class="title function_ invoke__">put</span>(v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>pallet1做为调用者：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![cfg_attr(not(feature = <span class="string">&quot;std&quot;</span>), no_std)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> pallet::*;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[frame_support::pallet]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> pallet &#123;</span><br><span class="line">  <span class="keyword">use</span> codec::Codec;</span><br><span class="line">  <span class="keyword">use</span> frame_support::&#123;</span><br><span class="line">    pallet_prelude::*, </span><br><span class="line">    sp_runtime::traits::AtLeast32BitUnsigned, </span><br><span class="line">    sp_std::fmt::<span class="built_in">Debug</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">use</span> frame_system::pallet_prelude::*;</span><br><span class="line">  <span class="comment">//引入pallet1中定义的trait</span></span><br><span class="line">  <span class="keyword">use</span> pallet1::traits::StorageInterface;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#[pallet::pallet]</span></span><br><span class="line">  <span class="meta">#[pallet::generate_store(pub(super) trait Store)]</span></span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Pallet</span>&lt;T&gt;(_);</span><br><span class="line"></span><br><span class="line">  <span class="meta">#[pallet::config]</span></span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Config</span>: frame_system::Config &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Event</span>: <span class="built_in">From</span>&lt;Event&lt;<span class="keyword">Self</span>&gt;&gt; </span><br><span class="line">      + IsType&lt;&lt;<span class="keyword">Self</span> <span class="keyword">as</span> frame_system::Config&gt;::Event&gt;;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Value</span>: Member</span><br><span class="line">      + Parameter</span><br><span class="line">      + AtLeast32BitUnsigned</span><br><span class="line">      + Codec</span><br><span class="line">      + <span class="built_in">From</span>&lt;<span class="type">u32</span>&gt;</span><br><span class="line">      + <span class="built_in">Into</span>&lt;<span class="type">u32</span>&gt;</span><br><span class="line">      + <span class="built_in">Copy</span></span><br><span class="line">      + <span class="built_in">Debug</span></span><br><span class="line">      + <span class="built_in">Default</span></span><br><span class="line">      + MaxEncodedLen</span><br><span class="line">      + MaybeSerializeDeserialize;</span><br><span class="line">    <span class="comment">//定义了MyStorage类型，要求其实现trait StorageInterface</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">MyStorage</span>: StorageInterface&lt;Value = <span class="keyword">Self</span>::Value&gt;; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#[pallet::event]</span></span><br><span class="line">  <span class="meta">#[pallet::generate_deposit(pub(super) fn deposit_event)]</span></span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Event</span>&lt;T: Config&gt; &#123;</span><br><span class="line">    StoreEvent,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#[pallet::call]</span></span><br><span class="line">  <span class="keyword">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">#[pallet::weight(0)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">storage_value</span>(</span><br><span class="line">      origin: OriginFor&lt;T&gt;,</span><br><span class="line">      value: T::Value, </span><br><span class="line">    ) <span class="punctuation">-&gt;</span> DispatchResultWithPostInfo &#123;</span><br><span class="line">      <span class="title function_ invoke__">ensure_signed</span>(origin)?;</span><br><span class="line"></span><br><span class="line">      T::MyStorage::<span class="title function_ invoke__">set_param</span>(value);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//使用trait StorageInterface中的函数</span></span><br><span class="line">      <span class="keyword">let</span> <span class="variable">v</span> = T::MyStorage::<span class="title function_ invoke__">get_param</span>();</span><br><span class="line">      log::info!(target: <span class="string">&quot;pallet1&quot;</span>, </span><br><span class="line">           <span class="string">&quot;Value get from storage is: &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">      <span class="keyword">Self</span>::<span class="title function_ invoke__">deposit_event</span>(Event::StoreEvent);</span><br><span class="line">      <span class="title function_ invoke__">Ok</span>(().<span class="title function_ invoke__">into</span>())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在runtime/src/lib.rs中加入相关引用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加下面4行</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">pallet2</span>::Config <span class="keyword">for</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Event</span> = Event;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Value</span> = <span class="type">u32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加下面5行</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">pallet2</span>::Config <span class="keyword">for</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Event</span> = Event;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Value</span> = <span class="type">u32</span>;</span><br><span class="line">  <span class="comment">//调用pallet2  </span></span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">MyStorage</span> = Pallet2; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">construct_runtime!(</span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Runtime</span> <span class="keyword">where</span></span><br><span class="line">    Block = Block,</span><br><span class="line">    NodeBlock = opaque::Block,</span><br><span class="line">    UncheckedExtrinsic = UncheckedExtrinsic</span><br><span class="line">  &#123;</span><br><span class="line">    System: frame_system,</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//添加下面两行</span></span><br><span class="line">    Pallet2: pallet2, </span><br><span class="line">    Pallet1: pallet1,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>别的非重要步骤这里就不展示了</p>
<h2 id="4-封装和扩展现有的pallet">4. 封装和扩展现有的pallet</h2>
<p>为了更直观解释，这里使用如下案例：<br>
使用substrate提供的contracts pallet，然后对其中的功能进行封装。封装中，将contracts pallet的call函数封装成sudo_call，即需要root权限才能调用。同时，在runtime中加载contracts时，去掉直接调用contracts函数的方式。<br>
也就是说，对外只暴露封装后pallet的方法</p>
<p>整个方式分成两大步骤：</p>
<ol>
<li>编写extend-pallet;</li>
<li>在runtime配置extend-pallet和contracts pallet。</li>
</ol>
<p>备注：这表示，最终在页面上只能看到extend-pallet对外暴露的方法，而contracts pallet的方法不再对外展示。</p>
<h3 id="4-1-编写extend-pallet">4.1 编写extend-pallet</h3>
<p>extend-pallet的lib.rs中：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![cfg_attr(not(feature = <span class="string">&quot;std&quot;</span>), no_std)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> codec::&#123;Encode, HasCompact&#125;;</span><br><span class="line"><span class="keyword">use</span> frame_support::traits::Currency;</span><br><span class="line"><span class="keyword">use</span> scale_info::TypeInfo;</span><br><span class="line"><span class="keyword">use</span> sp_core::crypto::UncheckedFrom;</span><br><span class="line"><span class="keyword">use</span> sp_runtime::traits::StaticLookup;</span><br><span class="line"><span class="keyword">use</span> sp_std::&#123;fmt::<span class="built_in">Debug</span>, prelude::*&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">BalanceOf</span>&lt;T&gt; = </span><br><span class="line">  &lt;&lt;T <span class="keyword">as</span> pallet_contracts::Config&gt;::Currency <span class="keyword">as</span> Currency&lt;</span><br><span class="line">  &lt;T <span class="keyword">as</span> frame_system::Config&gt;::AccountId,&gt;&gt;::Balance;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> pallet::*;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[frame_support::pallet]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> pallet &#123;</span><br><span class="line">  <span class="keyword">use</span> super::*;</span><br><span class="line">  <span class="keyword">use</span> frame_support::pallet_prelude::*;</span><br><span class="line">  <span class="keyword">use</span> frame_system::pallet_prelude::*;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#[pallet::pallet]</span></span><br><span class="line">  <span class="meta">#[pallet::generate_store(pub(super) trait Store)]</span></span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Pallet</span>&lt;T&gt;(_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重点关注1：封装pallet的Config需要集成被封装pallet的Config</span></span><br><span class="line">  <span class="meta">#[pallet::config]</span></span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Config</span>: pallet_contracts::Config + frame_system::Config &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 重点关注2：对主要pallet-contracts的call函数进行封装，在这部分里面，添加判断root权限的语句，然后直接调用pallet-contracts的call函数。</span></span><br><span class="line">  <span class="meta">#[pallet::call]</span></span><br><span class="line">  <span class="keyword">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt;</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    T::AccountId: UncheckedFrom&lt;T::Hash&gt;,</span><br><span class="line">    T::AccountId: <span class="built_in">AsRef</span>&lt;[<span class="type">u8</span>]&gt;,</span><br><span class="line">    &lt;BalanceOf&lt;T&gt; <span class="keyword">as</span> HasCompact&gt;::Type: <span class="built_in">Clone</span> </span><br><span class="line">     + <span class="built_in">Eq</span> + <span class="built_in">PartialEq</span> + <span class="built_in">Debug</span> + TypeInfo + Encode,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="meta">#[pallet::weight(0)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sudo_call</span>(</span><br><span class="line">      origin: OriginFor&lt;T&gt;,</span><br><span class="line">      dest: &lt;T::Lookup <span class="keyword">as</span> StaticLookup&gt;::Source,</span><br><span class="line">      <span class="meta">#[pallet::compact]</span> value: BalanceOf&lt;T&gt;,</span><br><span class="line">      <span class="meta">#[pallet::compact]</span> gas_limit: Weight,</span><br><span class="line">      storage_deposit_limit: <span class="type">Option</span>&lt;&lt;BalanceOf&lt;T&gt; </span><br><span class="line">           <span class="keyword">as</span> codec::HasCompact&gt;::Type&gt;,</span><br><span class="line">      data: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> DispatchResultWithPostInfo &#123;</span><br><span class="line">      <span class="comment">//添加下面这行，用于判断是否是root权限</span></span><br><span class="line">      <span class="title function_ invoke__">ensure_root</span>(origin.<span class="title function_ invoke__">clone</span>())?;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//直接调用pallet-contracts的call函数</span></span><br><span class="line">      pallet_contracts::Pallet::&lt;T&gt;::<span class="title function_ invoke__">call</span>(</span><br><span class="line">        origin,</span><br><span class="line">        dest,</span><br><span class="line">        value,</span><br><span class="line">        gas_limit,</span><br><span class="line">        storage_deposit_limit,</span><br><span class="line">        data,</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-在runtime配置extend-pallet和contracts-pallet">4.2 在runtime配置extend-pallet和contracts pallet</h3>
<p>将extend-pallet和contracts pallet加载到runtime中，需要修改runtime/src/lib.rs如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、配置Contracts pallet</span></span><br><span class="line"><span class="keyword">use</span> pallet_contracts::weights::WeightInfo;</span><br><span class="line"><span class="keyword">const</span> AVERAGE_ON_INITIALIZE_RATIO: Perbill = Perbill::<span class="title function_ invoke__">from_percent</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> currency &#123;</span><br><span class="line">  <span class="keyword">use</span> node_primitives::Balance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">const</span> MILLICENTS: Balance = <span class="number">1_000_000_000</span>;</span><br><span class="line">  <span class="comment">// assume this is worth about a cent.</span></span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">const</span> CENTS: Balance = <span class="number">1_000</span> * MILLICENTS; </span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">const</span> DOLLARS: Balance = <span class="number">100</span> * CENTS;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">const</span> <span class="keyword">fn</span> <span class="title function_">deposit</span>(items: <span class="type">u32</span>, bytes: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> Balance &#123;</span><br><span class="line">    items <span class="keyword">as</span> Balance * <span class="number">15</span> * CENTS + (bytes <span class="keyword">as</span> Balance) * <span class="number">6</span> * CENTS</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parameter_types! &#123;</span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">const</span> DepositPerItem: Balance = currency::<span class="title function_ invoke__">deposit</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">const</span> DepositPerByte: Balance = currency::<span class="title function_ invoke__">deposit</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">const</span> MaxValueSize: <span class="type">u32</span> = <span class="number">16</span> * <span class="number">1024</span>;</span><br><span class="line">  <span class="keyword">pub</span> DeletionWeightLimit: Weight = AVERAGE_ON_INITIALIZE_RATIO *</span><br><span class="line">    BlockWeights::<span class="title function_ invoke__">get</span>().max_block;</span><br><span class="line">  <span class="keyword">pub</span> DeletionQueueDepth: <span class="type">u32</span> = ((DeletionWeightLimit::<span class="title function_ invoke__">get</span>() / (</span><br><span class="line">      &lt;Runtime <span class="keyword">as</span> pallet_contracts::Config&gt;::WeightInfo::<span class="title function_ invoke__">on_initialize_per_queue_item</span>(<span class="number">1</span>) -</span><br><span class="line">      &lt;Runtime <span class="keyword">as</span> pallet_contracts::Config&gt;::WeightInfo::<span class="title function_ invoke__">on_initialize_per_queue_item</span>(<span class="number">0</span>)</span><br><span class="line">    )) / <span class="number">5</span>) <span class="keyword">as</span> <span class="type">u32</span>;</span><br><span class="line">  <span class="keyword">pub</span> Schedule: pallet_contracts::Schedule&lt;Runtime&gt; = <span class="built_in">Default</span>::<span class="title function_ invoke__">default</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">pallet_contracts</span>::Config <span class="keyword">for</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Time</span> = Timestamp;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Randomness</span> = RandomnessCollectiveFlip;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Currency</span> = Balances;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Event</span> = Event;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Call</span> = Call;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">CallFilter</span> = Nothing;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">DepositPerItem</span> = DepositPerItem;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">DepositPerByte</span> = DepositPerByte;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">CallStack</span> = [pallet_contracts::Frame&lt;<span class="keyword">Self</span>&gt;; <span class="number">31</span>];</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">WeightPrice</span> = pallet_transaction_payment::Pallet&lt;<span class="keyword">Self</span>&gt;;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">WeightInfo</span> = pallet_contracts::weights::SubstrateWeight&lt;<span class="keyword">Self</span>&gt;;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">ChainExtension</span> = ();</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">DeletionQueueDepth</span> = DeletionQueueDepth;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">DeletionWeightLimit</span> = DeletionWeightLimit;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Schedule</span> = Schedule;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">AddressGenerator</span> = pallet_contracts::DefaultAddressGenerator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、配置extends pallet</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">pallet_extend_pallet</span>::Config <span class="keyword">for</span> <span class="title class_">Runtime</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、在runtime中定义两个pallet</span></span><br><span class="line">construct_runtime!(</span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Runtime</span> <span class="keyword">where</span></span><br><span class="line">    Block = Block,</span><br><span class="line">    NodeBlock = opaque::Block,</span><br><span class="line">    UncheckedExtrinsic = UncheckedExtrinsic</span><br><span class="line">  &#123;</span><br><span class="line">    System: frame_system,</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 注意下面两行的区别: 一定要去掉Call</span></span><br><span class="line">    <span class="comment">// 将它的Call部分去掉了，这也就表示我们在runtime层面没有对外暴露Contracts的调度函数接口，这样用户只能使用ExtendContracts提供的sudo_call函数，而不能使用Contracts的调度函数。 </span></span><br><span class="line">    <span class="comment">// Contracts: pallet_contracts::&#123;Pallet, Call, Storage, Event&lt;T&gt;&#125;,</span></span><br><span class="line">    Contracts: pallet_contracts::&#123;Pallet, Storage, Event&lt;T&gt;&#125;,</span><br><span class="line">    ExtendContracts: pallet_extend_pallet,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Substrate</category>
        <category>pallet进阶</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Substrate</tag>
      </tags>
  </entry>
  <entry>
    <title>substrate进阶(4)-pallet结构之调度函数、钩子函数、Config</title>
    <url>/articles/6fdf0de9/</url>
    <content><![CDATA[<p>本文主要介绍pallet的调度函数的实现</p>
<span id="more"></span>
<h2 id="1-调度函数">1. 调度函数</h2>
<p>调度函数即<code>Extrinsics（外部调用）</code>，在substrate中共有三种Extrinsics，分别是Inherents、Signed transactions和Unsigned transactions。一般主要用到后两种：</p>
<ol>
<li>Signed transactions：签名交易包含发起该交易的账户的签名，并会支付交易费用。因为签名交易的合法性可以在执行之前识别，所以它们可以在节点之间的网络上传播，属于垃圾信息的风险比较小。通俗说，就是需要支付gas的行为</li>
<li>Unsigned transactions：不需要支付gas的行为，如查阅链上账户余额等行为，一般是只读行为。</li>
<li>实现： 所有调度函数都放置在<code>#[pallet::call]</code>标注的代码段内，每个调度函数上面需要标注其调用的权重，并根据需要是否添加<code>#[transactional]</code>，如下格式：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[pallet::call]</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">#[pallet::weight(10_000)]</span>  <span class="comment">//具体的函数使用对应的权重计算函数</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">function1</span>(origin: OriginFor&lt;T&gt;, param: <span class="type">u32</span>, ...) <span class="punctuation">-&gt;</span> DispatchResult &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#[transactional]</span></span><br><span class="line">    <span class="meta">#[pallet::weight(10_000)]</span>  <span class="comment">//具体的函数换成对应的权重计算函数</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">function2</span>(origin: OriginFor&lt;T&gt;, param: <span class="type">u32</span>, ...) <span class="punctuation">-&gt;</span> DispatchResult &#123;&#125;</span><br><span class="line">    <span class="comment">//其它调度函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>一个函数的实现，主要是分三部分：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[pallet::weight(10_000)]</span> </span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_number_bigger_than_100</span>(origin: OriginFor&lt;T&gt;, number: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> DispatchResult &#123;</span><br><span class="line">    <span class="comment">//这第一步根据实际情况选择：</span></span><br><span class="line">    <span class="comment">// 如果是签名调用的则判断的写法是 ensure_signed(origin)?。 </span></span><br><span class="line">    <span class="comment">// 如果是需要root用户调用的则判断的写法是ensure_root(origin)?。</span></span><br><span class="line">    <span class="comment">// 如果非签名的函数调用的判断写法则是ensure_none(origin)?。</span></span><br><span class="line">    <span class="title function_ invoke__">ensure_signed</span>(origin)?;  <span class="comment">//1、判断是否是合法调用</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2、函数的具体逻辑</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3、成功后需要发出事件</span></span><br><span class="line">    <span class="keyword">Self</span>::<span class="title function_ invoke__">deposit_event</span>(Event::xx事件);</span><br><span class="line">    </span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(()) <span class="comment">//固定写法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>
<p>关于权重<br>
每个调度函数上面都需要标注其权重，在具体开发时，我们一般是先写一个固定的权重，然后在所以功能开发完成后，再写对应的benchmarking(后续文章讲解)</p>
</li>
<li>
<p>关于<code>#[transactional]</code><br>
按我个人的理解，就是关系型数据库中的<code>事务</code>概念，保证调度函数执行的一致性。更具体点说就是当在函数中遇到错误后，会回滚状态，保证错误发生之前写入的状态回滚。<br>
该宏需要引入：use frame_support::transactional;</p>
</li>
</ol>
<h2 id="2-钩子函数">2. 钩子函数</h2>
<ol>
<li>交易到打包的过程
<ol>
<li>用户通过钱包发起交易;</li>
<li>和钱包相连的全节点收到交易后会把交易广播到网络中;</li>
<li>然后根据共识算法打包区块，某个全节点获得了打包权（图中画的是节点4）， 然后将交易打包到区块中;</li>
<li>打包好区块后，将区块广播到网络中;</li>
<li>其它每个节点收到区块后验证，然后执行区块里面的交易，更新自己本地的账本。</li>
</ol>
</li>
<li>在substrate中区块执行主要分为三步，分别是：
<ol>
<li>初始化区块（Initializes the block）;
<ul>
<li>初始化区块时就会执行所有pallet（就是construct_runtime!中包含的pallet，并且也是按照construct_runtime!中定义的顺序）的on_initialize函数，不过会最先执行System模块的（frame-system）.</li>
</ul>
</li>
<li>执行区块（Executes extrinsics）;
<ul>
<li>区块初始化后，就会根据交易（extrinsics）列表的顺序执行。</li>
</ul>
</li>
<li>确认区块（Finalizes the block）.
<ul>
<li>区块中的交易执行完后，确认区块。确认区块时会调用所有pallet（就是construct_runtime!中包含的pallet，并且也是按照construct_runtime!中定义的顺序）的on_idle和on_finalize函数，不过这次最后执行System模块（frame-system）的hooks函数.</li>
</ul>
</li>
</ol>
</li>
<li>hooks模板：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Hooks</span>&lt;BlockNumber&gt; &#123;</span><br><span class="line">    <span class="comment">//在区块finalize的时候调用。</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">on_finalize</span>(_n: BlockNumber) &#123;&#125;</span><br><span class="line">    <span class="comment">//区块finalize的时候调用，不过比on_finalize先调用。</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">on_idle</span>(_n: BlockNumber, _remaining_weight: Weight) <span class="punctuation">-&gt;</span> Weight &#123;&#125;</span><br><span class="line">    <span class="comment">//区块初始化的时候调用。</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">on_initialize</span>(_n: BlockNumber) <span class="punctuation">-&gt;</span> Weight &#123;&#125;</span><br><span class="line">    <span class="comment">//执行模块升级的时候调用。</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">on_runtime_upgrade</span>() <span class="punctuation">-&gt;</span> Weight &#123;&#125;</span><br><span class="line">    <span class="comment">//升级之前的检查。</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">pre_upgrade</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;&#125;</span><br><span class="line">    <span class="comment">//升级之后的处理。</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">post_upgrade</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;&#125;</span><br><span class="line">    <span class="comment">//在一个pallet上实现此函数后可以在此函数中长时间的执行需要链下执行的功能。该函数会在每次区块导入的时候调用。后续讲ocw使用的时候就需要和这个函数打交道</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">offchain_worker</span>(_n: BlockNumber) &#123;&#125;</span><br><span class="line">    <span class="comment">//运行集成测试。</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">integrity_test</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-config">3. Config</h2>
<p>pallet的配置部分，主要是定义常量、数据类型。该内容比较简单，这里只大概介绍下。<br>
如下定义数据类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[pallet::config]</span></span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Config</span>: frame_system::Config &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Event</span>: <span class="built_in">From</span>&lt;Event&lt;<span class="keyword">Self</span>&gt;&gt; </span><br><span class="line">    + IsType&lt;&lt;<span class="keyword">Self</span> <span class="keyword">as</span> frame_system::Config&gt;::Event&gt;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//（1）声明了StudentNumberType和StudentNameType</span></span><br><span class="line">    <span class="comment">//声明StudentNumber类型</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">StudentNumberType</span>: Member</span><br><span class="line">      + Parameter</span><br><span class="line">      + AtLeast32BitUnsigned</span><br><span class="line">      + Codec</span><br><span class="line">      + <span class="built_in">Copy</span></span><br><span class="line">      + <span class="built_in">Debug</span></span><br><span class="line">      + <span class="built_in">Default</span></span><br><span class="line">      + MaxEncodedLen</span><br><span class="line">      + MaybeSerializeDeserialize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明StudentName类型</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">StudentNameType</span>: Parameter</span><br><span class="line">      + Member</span><br><span class="line">      + AtLeast32BitUnsigned</span><br><span class="line">      + Codec</span><br><span class="line">      + <span class="built_in">Default</span></span><br><span class="line">      + <span class="built_in">From</span>&lt;<span class="type">u128</span>&gt;</span><br><span class="line">      + <span class="built_in">Into</span>&lt;<span class="type">u128</span>&gt;</span><br><span class="line">      + <span class="built_in">Copy</span></span><br><span class="line">      + MaxEncodedLen</span><br><span class="line">      + MaybeSerializeDeserialize</span><br><span class="line">      + <span class="built_in">Debug</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在runtime/src/lib.rs中引入的时候，在设置具体类型，确保了pallet更通用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">pallet_use_config2</span>::Config <span class="keyword">for</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Event</span> = Event;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">StudentNumberType</span> = <span class="type">u32</span>;   <span class="comment">//指定具体的类型</span></span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">StudentNameType</span> = <span class="type">u128</span>;    <span class="comment">//指定具体的类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Substrate</category>
        <category>pallet进阶</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Substrate</tag>
      </tags>
  </entry>
  <entry>
    <title>substrate进阶(3)-pallet结构之storage、event、error</title>
    <url>/articles/c630a4ea/</url>
    <content><![CDATA[<p>本文主要介绍pallet的storage</p>
<span id="more"></span>
<h2 id="1-概述">1. 概述</h2>
<h3 id="1-1-storage模板：">1.1 storage模板：</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[pallet::storage]</span></span><br><span class="line"><span class="meta">#[pallet::getter(fn something)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">MyStorage</span>&lt;T: Config&gt; = StorageValue&lt;_, <span class="type">u32</span>&gt;;</span><br></pre></td></tr></table></figure>
<ol>
<li>第一行：<code>#[pallet::storage]</code>是定义的storage时的固定写法，表示下面定义了一个storage。在定义storage时，无论你怎么使用，都必须写这一行。</li>
<li>第二行，<code>#[pallet::getter(fn something)]</code>，在有些定义storage时会使用这一行，有些不会。这一行的意思是自动为下面定义的storage生成一个getter函数，函数的名字就是<code>something</code>。</li>
<li>第三行，存储定义</li>
</ol>
<h3 id="1-2-error类型模板">1.2 error类型模板</h3>
<p>在runtime代码执行时，代码必须是“非抛出的”，或者说不应该panic，应该是优雅的处理错误，所以在写pallet代码时，允许自定义错误类型，当错误发生时，可以返回定义的错误类型。这里的Error类型是指运行时在执行调度函数（也就是交易函数）时返回的错误。因为在调度函数执行时，返回的结果为DispatchResult类型，当执行结果错误时，返回DispatchError。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[pallet::error]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Error</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//错误类型1</span></span><br><span class="line">    InvalidParameter,</span><br><span class="line">    <span class="comment">//错误类型2</span></span><br><span class="line">    OutOfSpace,</span><br><span class="line">...</span><br><span class="line"><span class="comment">//错误类型3</span></span><br><span class="line">InvalidFee,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数中返回错误的方式：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">xx_function</span>(origin: OriginFor&lt;T&gt;, ...)</span><br><span class="line">                   <span class="punctuation">-&gt;</span> DispatchResultWithPostInfo &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> 返回错误条件成立 &#123;</span><br><span class="line">        <span class="keyword">return</span> Error::&lt;T&gt;::错误类型;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(().<span class="title function_ invoke__">into</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-event类型模板">1.3 event类型模板</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[pallet::event]</span></span><br><span class="line"><span class="meta">#[pallet::generate_deposit(pub (super) fn deposit_event)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Event</span>&lt;T: Config&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">SetClass</span>(<span class="type">u32</span>),</span><br><span class="line">    <span class="title function_ invoke__">SetStudentInfo</span>(<span class="type">u32</span>, <span class="type">u128</span>),</span><br><span class="line">    <span class="title function_ invoke__">SetDormInfo</span>(<span class="type">u32</span>, <span class="type">u32</span>, <span class="type">u32</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-案例">2. 案例</h2>
<p>案例：记录某个年纪各个寝室每个床位的学生姓名 将会使用到<code>StorageValue</code>、<code>StorageMap</code>、<code>StorageDoubleMap</code>几种存储类型<br>
使用模板项目<a href="https://github.com/substrate-developer-hub/substrate-node-template">substrate-node-template</a> 完成该案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入项目根目录</span></span><br><span class="line">cd ./pallets</span><br><span class="line">cp -rf template use-storage </span><br><span class="line">cd use-storage</span><br><span class="line">vim ./Cargo.toml</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[package]中，变更：name=<span class="string">&quot;pallet-use-storage&quot;</span></span></span><br><span class="line"></span><br><span class="line">cd src</span><br><span class="line">rm -rf benchmarking.rs</span><br><span class="line">rm -rf mock.rs</span><br><span class="line">rm -rf tests.rs</span><br></pre></td></tr></table></figure>
<h2 id="2-1-use-storage-src-lib-rs编辑">2.1 use-storage/src/lib.rs编辑</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![cfg_attr(not(feature = <span class="string">&quot;std&quot;</span>), no_std)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> pallet::*;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[frame_support::pallet]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> pallet &#123;</span><br><span class="line">    <span class="keyword">use</span> frame_support::pallet_prelude::*;</span><br><span class="line">    <span class="keyword">use</span> frame_system::pallet_prelude::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[pallet::pallet]</span></span><br><span class="line">    <span class="meta">#[pallet::generate_store(pub (super) trait Store)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Pallet</span>&lt;T&gt;(_);</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[pallet::config]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Config</span>: frame_system::Config &#123;</span><br><span class="line">        <span class="comment">//声明事件</span></span><br><span class="line">        <span class="keyword">type</span> <span class="title class_">Event</span>: <span class="built_in">From</span>&lt;Event&lt;<span class="keyword">Self</span>&gt;&gt; + IsType&lt;&lt;<span class="keyword">Self</span> <span class="keyword">as</span> frame_system::Config&gt;::Event&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[pallet::storage]</span></span><br><span class="line">    <span class="meta">#[pallet::getter(fn my_class)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">Class</span>&lt;T: Config&gt; = StorageValue&lt;_, <span class="type">u32</span>, ValueQuery&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[pallet::storage]</span></span><br><span class="line">    <span class="meta">#[pallet::getter(fn students_info)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">StudentsInfo</span>&lt;T: Config&gt; = StorageMap&lt;_, Blake2_128Concat, <span class="type">u32</span>, <span class="type">u128</span>, ValueQuery&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[pallet::storage]</span></span><br><span class="line">    <span class="meta">#[pallet::getter(fn dorm_info)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">DormInfo</span>&lt;T: Config&gt; = StorageDoubleMap&lt;</span><br><span class="line">        _,</span><br><span class="line">        Blake2_128Concat,</span><br><span class="line">        <span class="type">u32</span>, <span class="comment">//dorm number</span></span><br><span class="line">        Blake2_128Concat,</span><br><span class="line">        <span class="type">u32</span>, <span class="comment">//bed number</span></span><br><span class="line">        <span class="type">u32</span>, <span class="comment">// student number</span></span><br><span class="line">        ValueQuery,</span><br><span class="line">    &gt;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[pallet::error]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Error</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="comment">// Class 只允许设置一次</span></span><br><span class="line">        SetClassDuplicate,</span><br><span class="line">        <span class="comment">// 相同学号的只允许设置一次名字</span></span><br><span class="line">        SetStudentsInfoDuplicate,</span><br><span class="line">        <span class="comment">// 相同床位只允许设置一次</span></span><br><span class="line">        SetDormInfoDuplicate,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[pallet::event]</span></span><br><span class="line">    <span class="meta">#[pallet::generate_deposit(pub (super) fn deposit_event)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Event</span>&lt;T: Config&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">SetClass</span>(<span class="type">u32</span>),</span><br><span class="line">        <span class="title function_ invoke__">SetStudentInfo</span>(<span class="type">u32</span>, <span class="type">u128</span>),</span><br><span class="line">        <span class="title function_ invoke__">SetDormInfo</span>(<span class="type">u32</span>, <span class="type">u32</span>, <span class="type">u32</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[pallet::call]</span></span><br><span class="line">    <span class="keyword">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; &#123;</span><br><span class="line">        <span class="comment">//存储班级信息</span></span><br><span class="line">        <span class="meta">#[pallet::weight(0)]</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_class_info</span>(origin: OriginFor&lt;T&gt;, class: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> DispatchResultWithPostInfo &#123;</span><br><span class="line">            <span class="title function_ invoke__">ensure_root</span>(origin)?;  <span class="comment">//需要root权限才能设置</span></span><br><span class="line">            <span class="keyword">if</span> Class::&lt;T&gt;::<span class="title function_ invoke__">exists</span>() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(Error::&lt;T&gt;::SetClassDuplicate.<span class="title function_ invoke__">into</span>())</span><br><span class="line">            &#125;</span><br><span class="line">            Class::&lt;T&gt;::<span class="title function_ invoke__">put</span>(class);</span><br><span class="line">            <span class="keyword">Self</span>::<span class="title function_ invoke__">deposit_event</span>(Event::<span class="title function_ invoke__">SetClass</span>(class));</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(().<span class="title function_ invoke__">into</span>())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存储学生信息，存储学生的学号和姓名的对应关系，使用StorageMap存储</span></span><br><span class="line">        <span class="meta">#[pallet::weight(0)]</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_student_info</span>(</span><br><span class="line">            origin: OriginFor&lt;T&gt;,</span><br><span class="line">            student_number: <span class="type">u32</span>,</span><br><span class="line">            student_name: <span class="type">u128</span>,</span><br><span class="line">        ) <span class="punctuation">-&gt;</span> DispatchResultWithPostInfo &#123;</span><br><span class="line">            <span class="title function_ invoke__">ensure_signed</span>(origin)?;</span><br><span class="line">            <span class="keyword">if</span> StudentsInfo::&lt;T&gt;::<span class="title function_ invoke__">contains_key</span>(student_number) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(Error::&lt;T&gt;::SetStudentsInfoDuplicate.<span class="title function_ invoke__">into</span>())</span><br><span class="line">            &#125;</span><br><span class="line">            StudentsInfo::&lt;T&gt;::<span class="title function_ invoke__">insert</span>(&amp;student_number, &amp;student_name);</span><br><span class="line">            <span class="keyword">Self</span>::<span class="title function_ invoke__">deposit_event</span>(Event::<span class="title function_ invoke__">SetStudentInfo</span>(student_number, student_name));</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(().<span class="title function_ invoke__">into</span>())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存储寝室信息，储寝室号、床号、学号之间的对应关系，使用StorageDoubleMap存储。</span></span><br><span class="line">        <span class="meta">#[pallet::weight(0)]</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_dorm_info</span>(</span><br><span class="line">            origin: OriginFor&lt;T&gt;,</span><br><span class="line">            dorm_number: <span class="type">u32</span>,</span><br><span class="line">            bed_number: <span class="type">u32</span>,</span><br><span class="line">            student_number: <span class="type">u32</span>,</span><br><span class="line">        ) <span class="punctuation">-&gt;</span> DispatchResultWithPostInfo &#123;</span><br><span class="line">            <span class="title function_ invoke__">ensure_signed</span>(origin)?;</span><br><span class="line">            <span class="keyword">if</span> DormInfo::&lt;T&gt;::<span class="title function_ invoke__">contains_key</span>(dorm_number, bed_number) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(Error::&lt;T&gt;::SetDormInfoDuplicate.<span class="title function_ invoke__">into</span>())</span><br><span class="line">            &#125;</span><br><span class="line">            DormInfo::&lt;T&gt;::<span class="title function_ invoke__">insert</span>(&amp;dorm_number, &amp;bed_number, &amp;student_number);</span><br><span class="line">            <span class="keyword">Self</span>::<span class="title function_ invoke__">deposit_event</span>(Event::<span class="title function_ invoke__">SetDormInfo</span>(dorm_number, bed_number, student_number));</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(().<span class="title function_ invoke__">into</span>())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-runtime-cargo-toml添加依赖">2.2 ./runtime/Cargo.toml添加依赖</h2>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">pallet-use-storage</span> = &#123; version = <span class="string">&quot;4.0.0-dev&quot;</span>, default-features = <span class="literal">false</span>, path = <span class="string">&quot;../pallets/use-storage&quot;</span> &#125;</span><br><span class="line"><span class="section">[features]</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="attr">std</span> = [</span><br><span class="line">    <span class="string">&quot;pallet-use-storage/std&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="2-3-runtime-src-lib-rs只加入pallet">2.3 ./runtime/src/lib.rs只加入pallet</h2>
<p>在<code>construct_runtime!(//...)</code>前代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">pallet_use_storage</span>::Config <span class="keyword">for</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Event</span> = Event;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>construct_runtime!(//...)</code>最后加上：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">construct_runtime!(</span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Runtime</span> <span class="keyword">where</span></span><br><span class="line">    Block = Block,</span><br><span class="line">    NodeBlock = opaque::Block,</span><br><span class="line">    UncheckedExtrinsic = UncheckedExtrinsic</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//添加下面这行</span></span><br><span class="line">    UseStorage: pallet_use_storage,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="3-运行">3. 运行</h2>
<p>编译并启动节点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo build</span><br><span class="line">./target/debug/node-template --dev</span><br></pre></td></tr></table></figure>
<p>打开<a href="https://polkadot.js.org/apps/#/explorer">polkadot-js-app</a> 连接节点 进入：<code>开发者</code>-<code>交易</code><br>
进入：<code>开发者</code>-<code>超级管理</code><br>
进入：<code>开发者</code>-<code>链状态</code><br>
可以按需处理<code>useStorage</code>相关方法，当输入内容错误时候，则会返回错误信息（error的应用）</p>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Substrate</category>
        <category>pallet进阶</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Substrate</tag>
      </tags>
  </entry>
  <entry>
    <title>substrate进阶(2)-pallet结构概述</title>
    <url>/articles/d7096340/</url>
    <content><![CDATA[<p>本文主要综合介绍pallet的组成，初步了解pallet的全局情况</p>
<span id="more"></span>
<h2 id="pallet模板">pallet模板</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 库头</span></span><br><span class="line"><span class="meta">#![cfg_attr(not(feature = <span class="string">&quot;std&quot;</span>), no_std)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出该pallet</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> pallet::*;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[frame_support::pallet]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> pallet &#123;</span><br><span class="line">    <span class="comment">//使用到的依赖</span></span><br><span class="line">    <span class="keyword">use</span> frame_support::pallet_prelude::*;</span><br><span class="line">    <span class="keyword">use</span> frame_system::pallet_prelude::*;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个pallet类型，类似一个占位符，用于方便实现接口和方法</span></span><br><span class="line">    <span class="comment">// 其中的泛形T指的是Runtime，在runtime.rs中会调用引入</span></span><br><span class="line">    <span class="meta">#[pallet::pallet]</span></span><br><span class="line">    <span class="meta">#[pallet::generate_store(pub (super) trait Store)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Pallet</span>&lt;T&gt;(_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明配置</span></span><br><span class="line">    <span class="comment">// 一些全局常用的类型和常量均在此处配置，</span></span><br><span class="line">    <span class="comment">// 该config trait必须需要实现frame_system::Config，另外也根据业务需要实现别的config trait</span></span><br><span class="line">    <span class="meta">#[pallet::config]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Config</span>: frame_system::Config &#123;</span><br><span class="line">        <span class="comment">/// 例如定义如下两个数据类型：</span></span><br><span class="line">        <span class="comment">// 案例1：需要实现相关所有trait</span></span><br><span class="line">        <span class="keyword">type</span> <span class="title class_">Id</span>: Member</span><br><span class="line">        + Parameter</span><br><span class="line">        + AtLeast32BitUnsigned</span><br><span class="line">        + Codec</span><br><span class="line">        + <span class="built_in">Copy</span></span><br><span class="line">        + <span class="built_in">Debug</span></span><br><span class="line">        + <span class="built_in">Default</span></span><br><span class="line">        + MaybeSerializeDeserialize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//案例2：此处带有宏定义的类型以及常量，会在runtime中（就是代码runtime/src/lib.rs中）使用时，会指定具体的类型。</span></span><br><span class="line">        <span class="meta">#[pallet::constant]</span></span><br><span class="line">        <span class="keyword">type</span> <span class="title class_">Limit</span>: Get&lt;<span class="type">u32</span>&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明存储</span></span><br><span class="line">    <span class="comment">// 存储（Storage）允许我们在链上存储数据，使用它存储的数据可以通过Runtime进行访问。substrate提供了四种存储方式，分别是：</span></span><br><span class="line">    <span class="comment">// Storage Value、Storage Map、Storage Double Map、Storage N Map</span></span><br><span class="line">    <span class="comment">// 说明：StorageValue是存储单个的值，StorageMap是以map的方式存储（key-value）,StorageDoubleMap则是以双键的方式存储（就是两个key对应value的方式），StorageNMap则是N个key的方式。</span></span><br><span class="line">    <span class="meta">#[pallet::storage]</span></span><br><span class="line">    <span class="meta">#[pallet::getter(fn something)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">MyStorage</span>&lt;T: Config&gt; = StorageValue&lt;_, <span class="type">u32</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明事件</span></span><br><span class="line">    <span class="comment">// 当pallet需要把运行时上的更改或变化通知给外部主体时，就需要用到事件。事件是一个枚举类型</span></span><br><span class="line">    <span class="comment">// 在区块链写交易函数的时候，一般分为三步，分别是判断条件、修改状态、发出事件。</span></span><br><span class="line">    <span class="meta">#[pallet::event]</span></span><br><span class="line">    <span class="meta">#[pallet::generate_deposit(pub (super) fn deposit_event)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Event</span>&lt;T: Config&gt; &#123;</span><br><span class="line">        <span class="comment">// 例如：</span></span><br><span class="line">        <span class="title function_ invoke__">ValueSet</span>(<span class="type">u32</span>, T::AccountId),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  声明钩子函数</span></span><br><span class="line">    <span class="comment">//  钩子函数，是在区块链运行过程中希望固定执行的函数，例如希望在每个区块构建之前、之后的时候执行某些逻辑等，就可以把这些逻辑放在钩子函数中。</span></span><br><span class="line">    <span class="comment">// 钩子函数一共有如下几个实现：</span></span><br><span class="line">    <span class="meta">#[pallet::hooks]</span></span><br><span class="line">    <span class="keyword">impl</span>&lt;T: Config&gt; Hooks&lt;BlockNumberFor&lt;T&gt;&gt; <span class="keyword">for</span> <span class="title class_">Pallet</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="comment">//on_finalize是在区块finalize的时候执行</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">on_finalize</span>(_n: BlockNumber) &#123;&#125;</span><br><span class="line">        <span class="comment">//on_idle是在on_finalize之前执行</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">on_idle</span>(_n: BlockNumber, _remaining_weight: Weight) <span class="punctuation">-&gt;</span> Weight &#123;&#125;</span><br><span class="line">        <span class="comment">//on_initialize是在准备打包区块之前执行</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">on_initialize</span>(_n: BlockNumber) <span class="punctuation">-&gt;</span> Weight &#123;&#125;</span><br><span class="line">        <span class="comment">//on_runtime_upgrade是升级的时候执行</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">on_runtime_upgrade</span>() <span class="punctuation">-&gt;</span> Weight &#123;&#125;</span><br><span class="line">        <span class="comment">//pre_upgrade是在升级之前执行</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">pre_upgrade</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;&#125;</span><br><span class="line">        <span class="comment">//post_upgrade是在升级之后执行</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">post_upgrade</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;&#125;</span><br><span class="line">        <span class="comment">//offchain_worker在每个区块同步的时候执行</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">offchain_worker</span>(_n: BlockNumber) &#123;&#125;</span><br><span class="line">        <span class="comment">//待定</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">integrity_test</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是可以从runtime外部可以调用的函数，也是pallet对外提供的逻辑功能。</span></span><br><span class="line">    <span class="meta">#[pallet::call]</span></span><br><span class="line">    <span class="keyword">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一般还会有一个内部逻辑，不对外开放，方便开发内部pallet使用</span></span><br><span class="line">    <span class="keyword">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Substrate</category>
        <category>pallet进阶</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Substrate</tag>
      </tags>
  </entry>
  <entry>
    <title>Aleo基础(2)-编译和部署</title>
    <url>/articles/82d119bd/</url>
    <content><![CDATA[<p>编译和部署，会根据官方的变化做出调整</p>
<span id="more"></span>
<h2 id="1-概述">1. 概述</h2>
<p>当前官方项目进度是<code>test3的第一节阶段</code>，目前只放出同步节点的代码，方便开发者调试应用</p>
<h2 id="2-准备工作">2. 准备工作</h2>
<ol>
<li>rust的安装，可以参考我别的相关文章</li>
<li>目前的运行要求是设备最少有16个核(经过测试，这是指逻辑核)，也就是物理核心8个，i7 十代的水平。
<ul>
<li>根据源码可知如下数据：
<ol>
<li>num_tokio_worker_threads（工作线程数）：<code>cpu逻辑核数量/8*2</code>，最小数量为1</li>
<li>max_tokio_blocking_threads（阻塞线程数）：<code>cpu逻辑核数量</code></li>
<li>num_rayon_cores_global （并行计算核数）：<code>cpu逻辑核数量/8*5</code>，最小数量为1</li>
</ol>
</li>
</ul>
</li>
<li>mac也可以编译成功，但没法运行，除非你搞交叉编译，但这就弄复杂了。建议直接使用ubuntu，我这里用的<code>ubuntu20.04</code></li>
</ol>
<p>接着是系统环境，这里有两种方式</p>
<h3 id="2-1-官方方式">2.1 官方方式</h3>
<p>必须是在ubuntu环境，项目根目录执行脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./build_ubuntu.sh</span><br></pre></td></tr></table></figure>
<h3 id="2-2-手动方式">2.2 手动方式</h3>
<ol>
<li>系统：ubuntu20.04</li>
<li>开放端口：<code>4130</code>和<code>4180</code></li>
<li>ubuntu下安装如下依赖：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install -y \</span><br><span class="line">build-essential \</span><br><span class="line">curl \</span><br><span class="line">clang \</span><br><span class="line">gcc \</span><br><span class="line">libssl-dev \</span><br><span class="line">llvm \</span><br><span class="line">make \</span><br><span class="line">pkg-config \</span><br><span class="line">tmux \</span><br><span class="line">xz-utils</span><br></pre></td></tr></table></figure>
<h2 id="3-编译和部署">3. 编译和部署</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载项目</span></span><br><span class="line">git clone https://github.com/AleoHQ/snarkOS.git</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 按官方方式编译并启动</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">./run-client.sh</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#  手动编译编译并启动</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="built_in">cd</span> snarkOS</span></span><br><span class="line">cargo build --release</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检测是否可使用</span></span><br><span class="line">./target/release/snarkos help</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当前版本，数据同步期间会报错，无法启动</span></span><br><span class="line">./target/release/snarkos --verbosity 2 &amp;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>会根据官方进行调整本文</p>
<p>//aleo1wv4srpxngu0wtsurur93th5d57fu3svtuec0a6chgtan0ll3ccyqsyz0jt</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Aleo</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Aleo</tag>
      </tags>
  </entry>
  <entry>
    <title>substrate进阶(1)-概念和理论</title>
    <url>/articles/bfceb217/</url>
    <content><![CDATA[<p>Pallet相关的基础概念以及理论汇总，方便查阅</p>
<span id="more"></span>
<h2 id="1-概念">1. 概念</h2>
<ol>
<li>优点:
<ol>
<li>substrate模块化（积木），封装了区块链各层技术，可以直接使用，也可以定制化开发</li>
<li>可以一条链为一个应用开发，降低多个应用抢占一条链资源导致链被阻塞的现象(ethereum)，也就是平行链概念</li>
</ol>
</li>
<li>应用方式
<ol>
<li>直接编译生成默认的链即可使用：可以参考：<a href="https://www.bitxx.top/articles/113dc518/">substrate基础(1)-substrate-node-template编译及部署</a></li>
<li>使用bstrate frame构建运行时：也就是根据自己的业务需要，选择不同的pallet或者自行开发一些pallet，然后组成一个完整的链</li>
<li>使用substrate core：抛开frame，自行开发，难度很大，一般也不建议</li>
</ol>
</li>
</ol>
<h2 id="2-rust前置基础">2. Rust前置基础</h2>
<p>substrate中，由于本身框架特性，Rust的使用是及其灵活的，如果没有良好的Rust基础，想深入了解Rust会很累的。<br>
比如宏、trait等，一定要掌握，substrate的灵魂</p>
<h3 id="2-1-trait基础">2.1 trait基础</h3>
<ol>
<li>孤儿规则：<br>
<code>如果想要为类型A实现trait T，那么A或者T至少有一个是在当前作用域中定义的</code>:<br>
以下正确和错误的例子，</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正确的例子，遵守规则</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">MyTrait</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MyType</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MyTrait</span> <span class="keyword">for</span> <span class="title class_">MyType</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;This is ok.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误的例子，无法编译通过</span></span><br><span class="line"><span class="keyword">use</span> std::fmt::&#123;Error, Formatter&#125;;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">std</span>::fmt::<span class="built_in">Debug</span> <span class="keyword">for</span> () &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之所以错误的例子无法编译，是因为：不管是trait Debug的定义还是类型()的定义都是外部引入的，所以无法在代码中为类型()实现trait Debug。</p>
<ol start="2">
<li>trait对象<br>
常规标准使用<br>
Rust中不直接将trait当作数据类型使用，但可以将实现了某个trait的具体的类型当作trait对象使用（可以理解为接口，不直接作为数据类型的）：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Drive</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drive</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Truck</span>;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drive</span> <span class="keyword">for</span> <span class="title class_">Truck</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drive</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Truck run!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MotorCycle</span>;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drive</span> <span class="keyword">for</span> <span class="title class_">MotorCycle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drive</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;MotorCycle run!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">use_transportation</span>(t: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Drive&gt;) &#123;</span><br><span class="line">   t.<span class="title function_ invoke__">drive</span>(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">truck</span> = Truck;</span><br><span class="line">    <span class="title function_ invoke__">use_transportation</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(truck));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">moto</span> = MotorCycle;</span><br><span class="line">    <span class="title function_ invoke__">use_transportation</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(moto));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本例中<code>use_transportation</code>的参数就是一个trait对象，不关注具体的类型，只需要它具备drive能力即可。</p>
<ol start="3">
<li>trait的继承<br>
只支持Trait之间的继承，比如Trait A继承Trait B，语法为：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">B</span>&#123;&#125;</span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">A</span>: B&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>Trait A继承Trait B后，当某个类型C想要实现Trait A时，还必须要同时也去实现trait B</p>
<ol start="4">
<li>关联类型<br>
关联类型是在trait定义的语句块中，申明一个自定义类型（使用<code>type</code>），这样就可以在trait的方法签名中使用该类型：<br>
注：type的类型可以指定要实现哪些trait，比如：<code>type Event: ToString;</code>表示Event类型要实现能够转化为String类型的trait。对此，当赋实际类型时，举例：<code>type Event = u64;</code></li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当为某个类型实现具有关联类型的trait时，需要指定关联类型为具体的类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Counter</span>(<span class="type">u32</span>);</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">u32</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Counter</span>(<span class="number">1</span>);</span><br><span class="line">    c.<span class="title function_ invoke__">next</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-宏">2.2 宏</h3>
<h2 id="总结">总结</h2>
<p>本文编辑中，会根据需要不断累加</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Substrate</category>
        <category>pallet进阶</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Substrate</tag>
      </tags>
  </entry>
  <entry>
    <title>substrate基础(14)-升级运行中的网络</title>
    <url>/articles/84ae716c/</url>
    <content><![CDATA[<p>由于精力有限，暂时先不看升级功能了。后续有必要的时候，再来完善该文。</p>
<span id="more"></span>
<h2 id="概述">概述</h2>
<p>substrate的热更新操作非常简便，但现在没空，目前也没有非常必要去了解，就先不写了</p>
<h2 id="总结">总结</h2>
<p>本文编辑中</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://docs.substrate.io/quick-start/">Substrate官方文档</a></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Substrate</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Substrate</tag>
      </tags>
  </entry>
  <entry>
    <title>substrate基础(13)-智能合约初体验</title>
    <url>/articles/5b9fab93/</url>
    <content><![CDATA[<p>初步掌握ink智能合约的使用</p>
<span id="more"></span>
<h2 id="1-概述">1. 概述</h2>
<ol>
<li>substrate的合约称为ink</li>
<li>ink！是一种嵌入式领域特定语言，可以用Rust来编写基于webassembly的智能合约。</li>
<li>ink！实际上是一种使用#[ink(…)]属性宏标准的Rust写法。</li>
</ol>
<h2 id="2-准备工作">2. 准备工作</h2>
<p>下载<code>带有合约功能的节点模板</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/paritytech/substrate-contracts-node</span><br></pre></td></tr></table></figure>
<p>该节点模板需要编译并启动，这个过程就不在这里阐述了，不是重点。</p>
<p>为了方便设置substrate智能合约，安装<code>ink！CLI</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> 先安装依赖工具binaryen</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">For Ubuntu or Debian <span class="built_in">users</span></span></span><br><span class="line">sudo apt install binaryen</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">For MacOS <span class="built_in">users</span></span></span><br><span class="line">brew install binaryen</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装合约依赖</span></span><br><span class="line">cargo install dylint-link --force</span><br><span class="line">cargo install cargo-dylint --force</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再安装lik! cli：</span></span><br><span class="line">cargo install cargo-contract --force</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line">cargo install cargo-contract --vers ^0.16 --force --locked</span><br></pre></td></tr></table></figure>
<p>检测是否安装成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo contract --help</span><br></pre></td></tr></table></figure>
<h2 id="3-模板体验">3. 模板体验</h2>
<h3 id="3-1-创建合约">3.1 创建合约</h3>
<p>生成合约模板(flipper表示项目名)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo contract new flipper</span><br></pre></td></tr></table></figure>
<p>执行后，生成一个ink合约项目模板，官方提供了一个类似<code>HelloWorld</code>的案例，可以用其进一步开发合约，也可以立即部署去体验：</p>
<p>测试合约代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo test</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line">cargo +nightly test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nocapture表示输出测试详情</span></span><br><span class="line">cargo +nightly test -- --nocapture</span><br></pre></td></tr></table></figure>
<p>编译合约</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo contract build</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line">cargo +nightly contract build</span><br></pre></td></tr></table></figure>
<p>编译好后的合约在target目录中<code>flipper/target/ink/</code>，其中包含一个<code>flipper.wasm</code>和<code>flipper.contract文件</code>。<code>.contract文件</code>就是用来部署到链上的合约文件，而<code>wasm文件</code>则包含合约的ABI。</p>
<h3 id="3-2-部署并体验合约">3.2 部署并体验合约</h3>
<p>启动节点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">substrate-contracts-node --dev</span><br></pre></td></tr></table></figure>
<p>打开<a href="https://contracts-ui.substrate.io/">合约用户界面</a> 连接节点<br>
单击“添加新合同”。<br>
单击上传新合约代码，即上传前面生成的<code>flipper.contract</code>文件</p>
<p>具体页面上合约的调用比较简单，这里就不详细阐述了</p>
<h2 id="4-基本语法">4. 基本语法</h2>
<h3 id="4-1-存储类型">4.1 存储类型</h3>
<p>substrate合约可以存储使用Parity Codec编码和解码的类型，例如像bool, u8, u16, u32, u64, u128, i8, i16, i32, i64, i128, string, 元组，数组等。另外ink！还提供substrate特定类型如AccountId，Balance，Hash等作为原始类型。</p>
<h3 id="4-2-函数">4.2 函数</h3>
<ol>
<li>合约函数</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">MyContract</span> &#123;</span><br><span class="line">    <span class="comment">// Public and Private functions go here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>构造函数<br>
每个ink！智能合约必须有在创建时运行一次的构造函数。每个ink！智能合约可以有多个构造函数。构造函数写法如下：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> ink_lang <span class="keyword">as</span> ink;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[ink::contract]</span></span><br><span class="line"><span class="keyword">mod</span> mycontract &#123;</span><br><span class="line">    <span class="meta">#[ink(storage)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MyContract</span> &#123;</span><br><span class="line">        number: <span class="type">u32</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">MyContract</span> &#123;</span><br><span class="line">        <span class="comment">/// Constructor that initializes the `u32` value to the given `init_value`.</span></span><br><span class="line">        <span class="meta">#[ink(constructor)]</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(init_value: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">            <span class="keyword">Self</span> &#123;</span><br><span class="line">                number: init_value,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// Constructor that initializes the `u32` value to the `u32` default.</span></span><br><span class="line">        <span class="comment">///</span></span><br><span class="line">        <span class="comment">/// Constructors can delegate to other constructors.</span></span><br><span class="line">        <span class="meta">#[ink(constructor)]</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">default</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">            <span class="keyword">Self</span> &#123;</span><br><span class="line">                number: <span class="built_in">Default</span>::<span class="title function_ invoke__">default</span>(),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">/* --snip-- */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>公有函数和私有函数</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">MyContract</span> &#123;</span><br><span class="line">    <span class="comment">/// Public function</span></span><br><span class="line">    <span class="meta">#[ink(message)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">my_public_function</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">/* --snip-- */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Private function</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">my_private_function</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">/* --snip-- */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* --snip-- */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>获取合约上的值</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">MyContract</span> &#123;</span><br><span class="line">    <span class="meta">#[ink(message)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">my_getter</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.number</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>可变和不可变的函数</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">MyContract</span> &#123;</span><br><span class="line">    <span class="meta">#[ink(message)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">my_getter</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.my_number</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[ink(message)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">my_setter</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, new_value: <span class="type">u32</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.my_number = new_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>惰性存储值<br>
当需要使用的时候，才会被加载，减少gas浪费</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[ink(storage)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MyContract</span> &#123;</span><br><span class="line">    <span class="comment">// Store some number</span></span><br><span class="line">    my_number: ink_storage::Lazy&lt;<span class="type">u32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MyContract</span> &#123;</span><br><span class="line">    <span class="meta">#[ink(constructor)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(init_value: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            my_number: ink_storage::Lazy::&lt;<span class="type">u32</span>&gt;::<span class="title function_ invoke__">new</span>(init_value),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[ink(message)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">my_setter</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, new_value: <span class="type">u32</span>) &#123;</span><br><span class="line">        ink_storage::Lazy::&lt;<span class="type">u32</span>&gt;::<span class="title function_ invoke__">set</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.my_number, new_value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[ink(message)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">my_adder</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, add_value: <span class="type">u32</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">my_number</span> = &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.my_number;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cur</span> = ink_storage::Lazy::&lt;<span class="type">u32</span>&gt;::<span class="title function_ invoke__">get</span>(my_number);</span><br><span class="line">        ink_storage::Lazy::&lt;<span class="type">u32</span>&gt;::<span class="title function_ invoke__">set</span>(my_number, cur + add_value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>mapping存储<br>
HashMap</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[ink(storage)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MyContract</span> &#123;</span><br><span class="line">    <span class="comment">// Store a mapping from AccountIds to a u32</span></span><br><span class="line">    my_number_map: ink_storage::collections::HashMap&lt;AccountId, <span class="type">u32</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化一个HashMap</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![cfg_attr(not(feature = <span class="string">&quot;std&quot;</span>), no_std)]</span></span><br><span class="line"><span class="keyword">use</span> ink_lang <span class="keyword">as</span> ink;</span><br><span class="line"><span class="meta">#[ink::contract]</span></span><br><span class="line"><span class="keyword">mod</span> mycontract &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[ink(storage)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MyContract</span> &#123;</span><br><span class="line">        <span class="comment">// Store a mapping from AccountIds to a u32</span></span><br><span class="line">        my_number_map: ink_storage::collections::HashMap&lt;AccountId, <span class="type">u32</span>&gt;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">MyContract</span> &#123;</span><br><span class="line">        <span class="comment">/// Public function.</span></span><br><span class="line">        <span class="comment">/// Default constructor.</span></span><br><span class="line">        <span class="meta">#[ink(constructor)]</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">default</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">            <span class="keyword">Self</span> &#123;</span><br><span class="line">                my_number_map: <span class="built_in">Default</span>::<span class="title function_ invoke__">default</span>(),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// Private function.</span></span><br><span class="line">        <span class="comment">/// Returns the number for an AccountId or 0 if it is not set.</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">my_number_or_zero</span>(&amp;<span class="keyword">self</span>, of: &amp;AccountId) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">balance</span> = <span class="keyword">self</span>.my_number_map.<span class="title function_ invoke__">get</span>(of).<span class="title function_ invoke__">unwrap_or</span>(&amp;<span class="number">0</span>);</span><br><span class="line">            *balance</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改hash map</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">caller</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">env</span>().<span class="title function_ invoke__">caller</span>();</span><br><span class="line"><span class="keyword">self</span>.my_number_map</span><br><span class="line">    .<span class="title function_ invoke__">entry</span>(caller)</span><br><span class="line">    .<span class="title function_ invoke__">and_modify</span>(|old_value| *old_value += by)</span><br><span class="line">    .<span class="title function_ invoke__">or_insert</span>(by);</span><br></pre></td></tr></table></figure>
<ol start="9">
<li>合约调用者</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![cfg_attr(not(feature = <span class="string">&quot;std&quot;</span>), no_std)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> ink_lang <span class="keyword">as</span> ink;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[ink::contract]</span></span><br><span class="line"><span class="keyword">mod</span> mycontract &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[ink(storage)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MyContract</span> &#123;</span><br><span class="line">        <span class="comment">// Store a contract owner</span></span><br><span class="line">        owner: AccountId,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">MyContract</span> &#123;</span><br><span class="line">        <span class="meta">#[ink(constructor)]</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">            <span class="keyword">Self</span> &#123;</span><br><span class="line">                owner: <span class="keyword">Self</span>::<span class="title function_ invoke__">env</span>().<span class="title function_ invoke__">caller</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* --snip-- */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-实现erc20智能合约">4. 实现ERC20智能合约</h2>
<p>生成合约项目模板(flipper表示项目名)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo contract new erc20</span><br></pre></td></tr></table></figure>
<p>lib.rs中实现erc20</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![cfg_attr(not(feature = <span class="string">&quot;std&quot;</span>), no_std)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> ink_lang <span class="keyword">as</span> ink;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[ink::contract]</span></span><br><span class="line"><span class="keyword">mod</span> erc20 &#123;</span><br><span class="line">    <span class="keyword">use</span> ink_storage::&#123;</span><br><span class="line">        traits::SpreadAllocate,</span><br><span class="line">        Mapping,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Create storage for a simple ERC-20 contract.</span></span><br><span class="line">    <span class="meta">#[ink(storage)]</span></span><br><span class="line">    <span class="meta">#[derive(SpreadAllocate)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Erc20</span> &#123;</span><br><span class="line">        <span class="comment">/// Total token supply.</span></span><br><span class="line">        total_supply: Balance,</span><br><span class="line">        <span class="comment">/// Mapping from owner to number of owned tokens.</span></span><br><span class="line">        balances: Mapping&lt;AccountId, Balance&gt;,</span><br><span class="line">        allowances: Mapping&lt;(AccountId, AccountId), Balance&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[ink(event)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Transfer</span> &#123;</span><br><span class="line">        <span class="meta">#[ink(topic)]</span></span><br><span class="line">        from: <span class="type">Option</span>&lt;AccountId&gt;,</span><br><span class="line"></span><br><span class="line">        <span class="meta">#[ink(topic)]</span></span><br><span class="line">        to: <span class="type">Option</span>&lt;AccountId&gt;,</span><br><span class="line"></span><br><span class="line">        <span class="meta">#[ink(topic)]</span></span><br><span class="line">        value: Balance,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[ink(event)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Approval</span> &#123;</span><br><span class="line">        <span class="meta">#[ink(topic)]</span></span><br><span class="line">        owner: AccountId,</span><br><span class="line">        <span class="meta">#[ink(topic)]</span></span><br><span class="line">        spender: AccountId,</span><br><span class="line">        <span class="meta">#[ink(topic)]</span></span><br><span class="line">        value: Balance,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Erc20</span> &#123;</span><br><span class="line">        <span class="comment">/// Create a new ERC-20 contract with an initial supply.</span></span><br><span class="line">        <span class="meta">#[ink(constructor)]</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(initial_supply: Balance) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">            <span class="comment">// Initialize mapping for the contract.</span></span><br><span class="line">            ink_lang::utils::<span class="title function_ invoke__">initialize_contract</span>(|contract| &#123;</span><br><span class="line">                <span class="keyword">Self</span>::<span class="title function_ invoke__">new_init</span>(contract, initial_supply)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// Initialize the ERC-20 contract with the specified initial supply.</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">new_init</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, initial_supply: Balance) &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">caller</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">env</span>().<span class="title function_ invoke__">caller</span>();</span><br><span class="line">            <span class="keyword">self</span>.balances.<span class="title function_ invoke__">insert</span>(&amp;caller, &amp;initial_supply);</span><br><span class="line">            <span class="keyword">self</span>.total_supply = initial_supply;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">Self</span>::<span class="title function_ invoke__">env</span>().<span class="title function_ invoke__">emit_event</span>(Transfer &#123;</span><br><span class="line">                from: <span class="literal">None</span>,</span><br><span class="line">                to: <span class="title function_ invoke__">Some</span>(caller),</span><br><span class="line">                value: initial_supply,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// Returns the total token supply.</span></span><br><span class="line">        <span class="meta">#[ink(message)]</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">total_supply</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Balance &#123;</span><br><span class="line">            <span class="keyword">self</span>.total_supply</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// Returns the account balance for the specified `owner`.</span></span><br><span class="line">        <span class="meta">#[ink(message)]</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">balance_of</span>(&amp;<span class="keyword">self</span>, owner: AccountId) <span class="punctuation">-&gt;</span> Balance &#123;</span><br><span class="line">            <span class="keyword">self</span>.balances.<span class="title function_ invoke__">get</span>(owner).<span class="title function_ invoke__">unwrap_or_default</span>()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#[ink(message)]</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">approve</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, spender: AccountId, value: Balance) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">owner</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">env</span>().<span class="title function_ invoke__">caller</span>();</span><br><span class="line">            <span class="keyword">self</span>.allowances.<span class="title function_ invoke__">insert</span>((owner, spender), &amp;value);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">env</span>().<span class="title function_ invoke__">emit_event</span>(Approval &#123;</span><br><span class="line">                owner,</span><br><span class="line">                spender,</span><br><span class="line">                value,</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#[ink(message)]</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">allowance</span>(&amp;<span class="keyword">self</span>, owner: AccountId, spender: AccountId) <span class="punctuation">-&gt;</span> Balance &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">allowance_of_or_zero</span>(&amp;owner, &amp;spender)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#[ink(message)]</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">transfer_from</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, from: AccountId, to: AccountId, value: Balance) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">caller</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">env</span>().<span class="title function_ invoke__">caller</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">allowance</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">allowance_of_or_zero</span>(&amp;from, &amp;caller);</span><br><span class="line">            <span class="keyword">if</span> allowance &lt; value &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">transfer_result</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">transfer_from_to</span>(from, to, value);</span><br><span class="line">            <span class="keyword">if</span> !transfer_result &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">self</span>.allowances.<span class="title function_ invoke__">insert</span>((from, caller), &amp;(&amp;allowance - &amp;value));</span><br><span class="line">            <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#[ink(message)]</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">transfer</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, to: AccountId, value: Balance) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">transfer_from_to</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">env</span>().<span class="title function_ invoke__">caller</span>(), to, value)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">transfer_from_to</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, from: AccountId, to: AccountId, value: Balance) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">from_balance</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">balance_of_or_zero</span>(&amp;from);</span><br><span class="line">            <span class="keyword">if</span> from_balance &lt; value &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">self</span>.balances.<span class="title function_ invoke__">insert</span>(from, &amp;(&amp;from_balance - &amp;value));</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">to_balance</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">balance_of_or_zero</span>(&amp;to);</span><br><span class="line">            <span class="keyword">self</span>.balances.<span class="title function_ invoke__">insert</span>(to, &amp;(&amp;to_balance + &amp;value));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">Self</span>::<span class="title function_ invoke__">env</span>().<span class="title function_ invoke__">emit_event</span>(Transfer &#123;</span><br><span class="line">                from: <span class="title function_ invoke__">Some</span>(from),</span><br><span class="line">                to: <span class="title function_ invoke__">Some</span>(to),</span><br><span class="line">                value,</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">balance_of_or_zero</span>(&amp;<span class="keyword">self</span>, owner: &amp;AccountId) <span class="punctuation">-&gt;</span> Balance &#123;</span><br><span class="line">            <span class="keyword">self</span>.balances.<span class="title function_ invoke__">get</span>(owner).<span class="title function_ invoke__">unwrap_or_default</span>()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">allowance_of_or_zero</span>(&amp;<span class="keyword">self</span>, owner: &amp;AccountId, spender: &amp;AccountId) <span class="punctuation">-&gt;</span> Balance &#123;</span><br><span class="line">            <span class="keyword">self</span>.allowances.<span class="title function_ invoke__">get</span>(&amp;(*owner, *spender)).<span class="title function_ invoke__">unwrap_or_default</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[cfg(test)]</span></span><br><span class="line">    <span class="keyword">mod</span> tests &#123;</span><br><span class="line">        <span class="keyword">use</span> super::*;</span><br><span class="line">        <span class="keyword">use</span> ink_lang <span class="keyword">as</span> ink;</span><br><span class="line">        <span class="meta">#[ink::test]</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">new_works</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">contract</span> = Erc20::<span class="title function_ invoke__">new</span>(<span class="number">888</span>);</span><br><span class="line">            <span class="built_in">assert_eq!</span>(contract.<span class="title function_ invoke__">total_supply</span>(), <span class="number">888</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#[ink::test]</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">balance_works</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">contract</span> = Erc20::<span class="title function_ invoke__">new</span>(<span class="number">100</span>);</span><br><span class="line">            <span class="built_in">assert_eq!</span>(contract.<span class="title function_ invoke__">total_supply</span>(), <span class="number">100</span>);</span><br><span class="line">            <span class="built_in">assert_eq!</span>(contract.<span class="title function_ invoke__">balance_of</span>(AccountId::<span class="title function_ invoke__">from</span>([<span class="number">0x1</span>; <span class="number">32</span>])), <span class="number">100</span>);</span><br><span class="line">            <span class="built_in">assert_eq!</span>(contract.<span class="title function_ invoke__">balance_of</span>(AccountId::<span class="title function_ invoke__">from</span>([<span class="number">0x0</span>; <span class="number">32</span>])), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#[ink::test]</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">transfer_works</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contract</span> = Erc20::<span class="title function_ invoke__">new</span>(<span class="number">100</span>);</span><br><span class="line">            <span class="built_in">assert_eq!</span>(contract.<span class="title function_ invoke__">balance_of</span>(AccountId::<span class="title function_ invoke__">from</span>([<span class="number">0x1</span>; <span class="number">32</span>])), <span class="number">100</span>);</span><br><span class="line">            <span class="built_in">assert!</span>(contract.<span class="title function_ invoke__">transfer</span>(AccountId::<span class="title function_ invoke__">from</span>([<span class="number">0x0</span>; <span class="number">32</span>]), <span class="number">10</span>));</span><br><span class="line">            <span class="built_in">assert_eq!</span>(contract.<span class="title function_ invoke__">balance_of</span>(AccountId::<span class="title function_ invoke__">from</span>([<span class="number">0x0</span>; <span class="number">32</span>])), <span class="number">10</span>);</span><br><span class="line">            <span class="built_in">assert!</span>(!contract.<span class="title function_ invoke__">transfer</span>(AccountId::<span class="title function_ invoke__">from</span>([<span class="number">0x0</span>; <span class="number">32</span>]), <span class="number">100</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#[ink::test]</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">transfer_from_works</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contract</span> = Erc20::<span class="title function_ invoke__">new</span>(<span class="number">100</span>);</span><br><span class="line">            <span class="built_in">assert_eq!</span>(contract.<span class="title function_ invoke__">balance_of</span>(AccountId::<span class="title function_ invoke__">from</span>([<span class="number">0x1</span>; <span class="number">32</span>])), <span class="number">100</span>);</span><br><span class="line">            contract.<span class="title function_ invoke__">approve</span>(AccountId::<span class="title function_ invoke__">from</span>([<span class="number">0x1</span>; <span class="number">32</span>]), <span class="number">20</span>);</span><br><span class="line">            contract.<span class="title function_ invoke__">transfer_from</span>(AccountId::<span class="title function_ invoke__">from</span>([<span class="number">0x1</span>; <span class="number">32</span>]), AccountId::<span class="title function_ invoke__">from</span>([<span class="number">0x0</span>; <span class="number">32</span>]), <span class="number">10</span>);</span><br><span class="line">            <span class="built_in">assert_eq!</span>(contract.<span class="title function_ invoke__">balance_of</span>(AccountId::<span class="title function_ invoke__">from</span>([<span class="number">0x0</span>; <span class="number">32</span>])), <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#[ink::test]</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">allowances_works</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contract</span> = Erc20::<span class="title function_ invoke__">new</span>(<span class="number">100</span>);</span><br><span class="line">            <span class="built_in">assert_eq!</span>(contract.<span class="title function_ invoke__">balance_of</span>(AccountId::<span class="title function_ invoke__">from</span>([<span class="number">0x1</span>; <span class="number">32</span>])), <span class="number">100</span>);</span><br><span class="line">            contract.<span class="title function_ invoke__">approve</span>(AccountId::<span class="title function_ invoke__">from</span>([<span class="number">0x1</span>; <span class="number">32</span>]), <span class="number">200</span>);</span><br><span class="line">            <span class="built_in">assert_eq!</span>(</span><br><span class="line">                contract.<span class="title function_ invoke__">allowance</span>(AccountId::<span class="title function_ invoke__">from</span>([<span class="number">0x1</span>; <span class="number">32</span>]), AccountId::<span class="title function_ invoke__">from</span>([<span class="number">0x1</span>; <span class="number">32</span>])),</span><br><span class="line">                <span class="number">200</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="built_in">assert!</span>(contract.<span class="title function_ invoke__">transfer_from</span>(</span><br><span class="line">                AccountId::<span class="title function_ invoke__">from</span>([<span class="number">0x1</span>; <span class="number">32</span>]),</span><br><span class="line">                AccountId::<span class="title function_ invoke__">from</span>([<span class="number">0x0</span>; <span class="number">32</span>]),</span><br><span class="line">                <span class="number">50</span></span><br><span class="line">            ));</span><br><span class="line">            <span class="built_in">assert_eq!</span>(contract.<span class="title function_ invoke__">balance_of</span>(AccountId::<span class="title function_ invoke__">from</span>([<span class="number">0x0</span>; <span class="number">32</span>])), <span class="number">50</span>);</span><br><span class="line">            <span class="built_in">assert_eq!</span>(</span><br><span class="line">                contract.<span class="title function_ invoke__">allowance</span>(AccountId::<span class="title function_ invoke__">from</span>([<span class="number">0x1</span>; <span class="number">32</span>]), AccountId::<span class="title function_ invoke__">from</span>([<span class="number">0x1</span>; <span class="number">32</span>])),</span><br><span class="line">                <span class="number">150</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="built_in">assert!</span>(!contract.<span class="title function_ invoke__">transfer_from</span>(</span><br><span class="line">                AccountId::<span class="title function_ invoke__">from</span>([<span class="number">0x1</span>; <span class="number">32</span>]),</span><br><span class="line">                AccountId::<span class="title function_ invoke__">from</span>([<span class="number">0x0</span>; <span class="number">32</span>]),</span><br><span class="line">                <span class="number">100</span></span><br><span class="line">            ));</span><br><span class="line">            <span class="built_in">assert_eq!</span>(contract.<span class="title function_ invoke__">balance_of</span>(AccountId::<span class="title function_ invoke__">from</span>([<span class="number">0x0</span>; <span class="number">32</span>])), <span class="number">50</span>);</span><br><span class="line">            <span class="built_in">assert_eq!</span>(</span><br><span class="line">                contract.<span class="title function_ invoke__">allowance</span>(AccountId::<span class="title function_ invoke__">from</span>([<span class="number">0x1</span>; <span class="number">32</span>]), AccountId::<span class="title function_ invoke__">from</span>([<span class="number">0x1</span>; <span class="number">32</span>])),</span><br><span class="line">                <span class="number">150</span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo test</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">或</span></span><br><span class="line">cargo +nightly test</span><br></pre></td></tr></table></figure>
<p>编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo contract build</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">或</span></span><br><span class="line">cargo +nightly contract build</span><br></pre></td></tr></table></figure>
<p>编译好后的合约在target目录中<code>erc20/target/ink/</code>，其中包含一个<code>erc20.wasm</code>和<code>erc20.contract文件</code>。<code>.contract文件</code>就是用来部署到链上的合约文件，而<code>wasm文件</code>则包含合约的ABI。</p>
<p>启动节点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">substrate-contracts-node --dev</span><br></pre></td></tr></table></figure>
<p><a href="https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Frococo-contracts-rpc.polkadot.io#/explorer">rococo测试网app环境（平行链）</a><br>
领取该合约平行链的token：前往<a href="https://matrix.to/#/#rococo-faucet:matrix.org">Rococo faucet matrix channel</a> 在频道里输入：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">!drip 你的Substrate地址（即SS58 prefix的地址 ）:1002</span><br></pre></td></tr></table></figure>
<p>打开<a href="https://contracts-ui.substrate.io/">合约用户界面</a> 连接节点，也可以去polkadot-app提供的<a href="https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Frococo-contracts-rpc.polkadot.io#/contracts">合约页面(建议，功能齐全)</a><br>
单击“添加新合同”。<br>
单击上传新合约代码，即上传前面生成的<code>erc20.contract</code>文件</p>
<p>具体页面上合约的调用比较简单，这里就不详细阐述了</p>
<p>备注：<br>
phala提供了一个合约测试环境也很方便：<br>
<a href="https://phat.phala.network/">phala合约测试</a><br>
可以在此处领取phala的测试币：<br>
<a href="https://phala-decoded-2022.netlify.app/easy-challenge">phala测试币领取方式一</a><br>
<a href="https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fpoc5.phala.network%2Fws#/accounts">phala测试币领取方式二</a> 手动将内置账户余额转入到你的测试账号</p>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://docs.substrate.io/quick-start/">Substrate官方文档</a></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Substrate</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Substrate</tag>
      </tags>
  </entry>
  <entry>
    <title>substrate加密猫</title>
    <url>/articles/94db7c74/</url>
    <content><![CDATA[<p>通过加密猫案例，来完整了解下substrate的整个操作。新版substrate官方文档貌似已经移除了加密猫的实现，以下是使用新版substrate代码结合旧的文档整合而成。<br>
代码结合最新的substrate框架做了调整，已亲自完整测试，按本文操作，该项目可以成功运行。</p>
<span id="more"></span>  
<h2 id="1-概述">1. 概述</h2>
<p>加密猫现在在各大平台都已经出现了其身影，本文主要实现以下功能：</p>
<ul>
<li>通过一些原始来源或者通过使用现有小猫进行繁殖创造</li>
<li>以其所有者设定的价格出售</li>
<li>从一个所有者转移到另一个所有者</li>
</ul>
<p>大体说明：substrate会涉及到一个权重(weights)的概念，会让开发者考虑函数的复杂度，类似于以太坊中gas的高低。本文我们统一<code>weight=100</code></p>
<h2 id="2-根据模板template-node创建对应的kitties项目框架">2. 根据模板template-node创建对应的kitties项目框架</h2>
<p><code>kickstart</code>这是个模板工具，通过该工具，可以将模板生成为我们需要的项目框架，安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo install kickstart</span><br></pre></td></tr></table></figure>
<p>根据模板创建项目框架：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kickstart https://github.com/sacha-l/kickstart-substrate</span><br></pre></td></tr></table></figure>
<p>会自动指定<code>tmp</code>目录，然后会提示输入节点名称以及pallet名称，这里依次输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kitties</span><br><span class="line">kitties</span><br></pre></td></tr></table></figure>
<p>然后就能生成项目框架文件了，具体各目录作用，这里就不解释了。看前面文章去。<br>
项目根目录的名称现在应该是：<code>kitties</code>，全局搜索项目，将文本<code>TemplateModule</code>都替换为：<code>SubstrateKitties</code>，后续开发可读性更高一些</p>
<p>然后就可以编译和启动项目了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译</span></span><br><span class="line">cargo build --release</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者使用入下编译</span></span><br><span class="line">cargo +nightly build --release</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动</span></span><br><span class="line">./target/release/node-kitties --dev</span><br></pre></td></tr></table></figure>
<h2 id="3-实现pallet-kitties脚手架及其具体功能">3. 实现pallet_kitties脚手架及其具体功能</h2>
<p>也就是pallet的整体框架<br>
<code>pallets/kitties/src</code>目录下，删除<code>benchmarking.rs</code>、<code>mock.rs</code>、<code>tests.rs</code>这三个文件。<code>lib.rs</code>文件中的内容清空，然后加入如下内容：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![cfg_attr(not(feature = <span class="string">&quot;std&quot;</span>), no_std)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Edit this file to define custom logic or remove it if it is not needed.</span></span><br><span class="line"><span class="comment">/// Learn more about FRAME and the core library of Substrate FRAME pallets:</span></span><br><span class="line"><span class="comment">/// &lt;https://docs.substrate.io/v3/runtime/frame&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[frame_support::pallet]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> pallet &#123;</span><br><span class="line">    <span class="keyword">use</span> frame_support::&#123;</span><br><span class="line">        dispatch::&#123;DispatchResult&#125;,</span><br><span class="line">        pallet_prelude::*,</span><br><span class="line">        sp_runtime::traits::&#123;Hash&#125;,</span><br><span class="line">        traits::&#123;Currency, ExistenceRequirement, Randomness&#125;,</span><br><span class="line">        transactional,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">use</span> frame_system::pallet_prelude::*;</span><br><span class="line">    <span class="keyword">use</span> sp_io::hashing::blake2_128;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Configure the pallet by specifying the parameters and types on which it depends.</span></span><br><span class="line">    <span class="meta">#[pallet::config]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Config</span>: frame_system::Config &#123;</span><br><span class="line">        <span class="comment">/// Because this pallet emits events, it depends on the runtime&#x27;s definition of an event.</span></span><br><span class="line">        <span class="keyword">type</span> <span class="title class_">Event</span>: <span class="built_in">From</span>&lt;Event&lt;<span class="keyword">Self</span>&gt;&gt; + IsType&lt;&lt;<span class="keyword">Self</span> <span class="keyword">as</span> frame_system::Config&gt;::Event&gt;;</span><br><span class="line">        <span class="comment">/// The Currency handler for the Kitties pallet.</span></span><br><span class="line">        <span class="keyword">type</span> <span class="title class_">Currency</span>: Currency&lt;<span class="keyword">Self</span>::AccountId&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//TODO Part II: Specify the custom types for our runtime.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[pallet::pallet]</span></span><br><span class="line">    <span class="meta">#[pallet::generate_store(pub(super) trait Store)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Pallet</span>&lt;T&gt;(_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The pallet&#x27;s runtime storage items.</span></span><br><span class="line">    <span class="comment">// https://docs.substrate.io/v3/runtime/storage</span></span><br><span class="line">    <span class="meta">#[pallet::storage]</span></span><br><span class="line">    <span class="meta">#[pallet::getter(fn something)]</span></span><br><span class="line">    <span class="comment">// Learn more about declaring storage items:</span></span><br><span class="line">    <span class="comment">// https://docs.substrate.io/v3/runtime/storage#declaring-storage-items</span></span><br><span class="line">    <span class="comment">// ACTION: store item to keep a count of all existing Kitties.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">Something</span>&lt;T&gt; = StorageValue&lt;_, <span class="type">u32</span>&gt;;</span><br><span class="line">    <span class="comment">// TODO Part II: Remaining sotre items.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// TODO Part III: Our pallet&#x27;s genesis configuration.</span></span><br><span class="line">    <span class="comment">// #[pallet::genesis_config]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pallets use events to inform users when important changes are made.</span></span><br><span class="line">    <span class="comment">// https://docs.substrate.io/v3/runtime/events-and-errors</span></span><br><span class="line">    <span class="meta">#[pallet::event]</span></span><br><span class="line">    <span class="meta">#[pallet::generate_deposit(pub(super) fn deposit_event)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Event</span>&lt;T: Config&gt; &#123;</span><br><span class="line">        <span class="comment">/// Event documentation should end with an array that provides descriptive names for event</span></span><br><span class="line">        <span class="comment">// TODO Part III</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Errors inform users that something went wrong.</span></span><br><span class="line">    <span class="meta">#[pallet::error]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Error</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="comment">///Error names should be descriptive.</span></span><br><span class="line">        <span class="comment">/// Errors should have helpful documentation associated with them.</span></span><br><span class="line">        <span class="comment">// TODO Part III</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dispatchable functions allows users to interact with the pallet and invoke state changes.</span></span><br><span class="line">    <span class="comment">// These functions materialize as &quot;extrinsics&quot;, which are often compared to transactions.</span></span><br><span class="line">    <span class="comment">// Dispatchable functions must be annotated with a weight and must return a DispatchResult.</span></span><br><span class="line">    <span class="meta">#[pallet::call]</span></span><br><span class="line">    <span class="keyword">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; &#123;</span><br><span class="line">        <span class="comment">//TODO Part III: create_kitty</span></span><br><span class="line">        <span class="comment">//TODO Part III: set_price</span></span><br><span class="line">        <span class="comment">//TODO Part III: transfer</span></span><br><span class="line">        <span class="comment">//TODO Part III: buy_kitty</span></span><br><span class="line">        <span class="comment">//TODO Part III: breed_kitty</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> Parts II： helper function for Kitty struct</span></span><br><span class="line">    <span class="comment">//简单说，就是内部方法，用来支持上面#[pallet::call]中的方法使用</span></span><br><span class="line">    <span class="keyword">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; &#123;</span><br><span class="line">        <span class="comment">//TODO Part III: helper functions for dispatchable functions</span></span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> increment_noce, random_hash, mint, transfer_from</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中todo内容为后续要加入的内容（即业务逻辑）</p>
<h2 id="3-1-cargo-toml添加依赖">3.1 Cargo.toml添加依赖</h2>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">sp-io</span> = &#123; default-features = <span class="literal">false</span>, version = <span class="string">&quot;6.0.0&quot;</span>, git = <span class="string">&quot;https://github.com/paritytech/substrate.git&quot;</span>, branch = <span class="string">&quot;polkadot-v0.9.26&quot;</span> &#125;</span><br><span class="line"><span class="attr">serde</span> = &#123; default-features = <span class="literal">false</span>, version = <span class="string">&quot;1.0.119&quot;</span>&#125;</span><br><span class="line"><span class="attr">log</span> = &#123; default-features = <span class="literal">false</span>, version = <span class="string">&quot;0.4.14&quot;</span> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-实现存储">3.1 实现存储</h3>
<p>此时pallets中的lib.rs内容如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#[frame_support::pallet]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> pallet &#123;</span><br><span class="line">    <span class="keyword">use</span> frame_support::&#123;</span><br><span class="line">        dispatch::&#123;DispatchResult&#125;,</span><br><span class="line">        pallet_prelude::*,</span><br><span class="line">        sp_runtime::traits::&#123;Hash&#125;,</span><br><span class="line">        traits::&#123;Currency, ExistenceRequirement, Randomness&#125;,</span><br><span class="line">        transactional,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">use</span> frame_system::pallet_prelude::*;</span><br><span class="line">    <span class="keyword">use</span> sp_io::hashing::blake2_128;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#[cfg(feature = <span class="string">&quot;std&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">use</span> serde::&#123;Deserialize, Serialize&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">AccountOf</span>&lt;T&gt; = &lt;T <span class="keyword">as</span> frame_system::Config&gt;::AccountId;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">BalanceOf</span>&lt;T&gt; =</span><br><span class="line">	&lt;&lt;T <span class="keyword">as</span> Config&gt;::Currency <span class="keyword">as</span> Currency&lt;&lt;T <span class="keyword">as</span> frame_system::Config&gt;::AccountId&gt;&gt;::Balance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Struct for holding Kitty information.</span></span><br><span class="line">    <span class="comment">// MaxEncodedLen务必需要加上，否则编译无法知晓结构体大小</span></span><br><span class="line">    <span class="meta">#[derive(Clone, Encode, Decode, PartialEq, RuntimeDebug, TypeInfo, MaxEncodedLen)]</span></span><br><span class="line">    <span class="meta">#[scale_info(skip_type_params(T))]</span></span><br><span class="line">    <span class="meta">#[codec(mel_bound())]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Kitty</span>&lt;T: Config&gt; &#123;</span><br><span class="line">        <span class="keyword">pub</span> dna: [<span class="type">u8</span>; <span class="number">16</span>],</span><br><span class="line">        <span class="keyword">pub</span> price: <span class="type">Option</span>&lt;BalanceOf&lt;T&gt;&gt;,</span><br><span class="line">        <span class="keyword">pub</span> gender: Gender,</span><br><span class="line">        <span class="keyword">pub</span> owner: AccountOf&lt;T&gt;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// MaxEncodedLen务必需要加上，否则编译无法知晓结构体大小</span></span><br><span class="line">    <span class="meta">#[derive(Clone, Encode, Decode, PartialEq, RuntimeDebug, TypeInfo, MaxEncodedLen)]</span></span><br><span class="line">    <span class="meta">#[cfg_attr(feature = <span class="string">&quot;std&quot;</span>, derive(Serialize, Deserialize))]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Gender</span> &#123;</span><br><span class="line">        Male,</span><br><span class="line">        Female,</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/// Configure the pallet by specifying the parameters and types on which it depends.</span></span><br><span class="line">	<span class="meta">#[pallet::config]</span></span><br><span class="line">	<span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Config</span>: frame_system::Config &#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		<span class="comment">//Part II: Specify the custom types for our runtime.</span></span><br><span class="line">		<span class="comment">//新增随机数配置</span></span><br><span class="line">		<span class="keyword">type</span> <span class="title class_">KittyRandomness</span>: Randomness&lt;<span class="keyword">Self</span>::Hash, <span class="keyword">Self</span>::BlockNumber&gt;;</span><br><span class="line">		<span class="meta">#[pallet::constant]</span></span><br><span class="line">		<span class="keyword">type</span> <span class="title class_">MaxKittyOwned</span>: Get&lt;<span class="type">u32</span>&gt;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="meta">#[pallet::storage]</span></span><br><span class="line">	<span class="meta">#[pallet::getter(fn kitty_cnt)]</span></span><br><span class="line">	<span class="title function_ invoke__">pub</span>(<span class="keyword">super</span>) <span class="keyword">type</span> <span class="title class_">KittyCnt</span>&lt;T: Config&gt; = StorageValue&lt;_, <span class="type">u64</span>, ValueQuery&gt;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//存储资产</span></span><br><span class="line">	<span class="meta">#[pallet::storage]</span></span><br><span class="line">	<span class="meta">#[pallet::getter(fn kitties)]</span></span><br><span class="line">	<span class="title function_ invoke__">pub</span>(<span class="keyword">super</span>) <span class="keyword">type</span> <span class="title class_">Kitties</span>&lt;T: Config&gt; = StorageMap&lt;_, Twox64Concat, T::Hash, Kitty&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//存储资产所有权</span></span><br><span class="line">	<span class="meta">#[pallet::storage]</span></span><br><span class="line">	<span class="meta">#[pallet::getter(fn kitties_owned)]</span></span><br><span class="line">	<span class="comment">/// Keeps track of what accounts own what Kitty.</span></span><br><span class="line">	<span class="title function_ invoke__">pub</span>(<span class="keyword">super</span>) <span class="keyword">type</span> <span class="title class_">KittiesOwned</span>&lt;T: Config&gt; = StorageMap&lt;_, Twox64Concat, T::AccountId, BoundedVec&lt;T::Hash, T::MaxKittyOwned&gt;, ValueQuery&gt;;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Parts II： helper function for Kitty struct</span></span><br><span class="line">	<span class="comment">//简单说，就是内部方法，用来支持上面#[pallet::call]中的方法使用</span></span><br><span class="line">	<span class="keyword">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; &#123;</span><br><span class="line">		<span class="comment">//Part III: helper functions for dispatchable functions</span></span><br><span class="line">		<span class="comment">//increment_noce, random_hash, mint, transfer_from</span></span><br><span class="line">		<span class="comment">//生成性别</span></span><br><span class="line">		<span class="keyword">fn</span> <span class="title function_">gen_gender</span>() <span class="punctuation">-&gt;</span> Gender &#123;</span><br><span class="line">			<span class="keyword">let</span> <span class="variable">random</span> = T::KittyRandomness::<span class="title function_ invoke__">random</span>(&amp;<span class="string">b&quot;gender&quot;</span>[..]).<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">match</span> random.<span class="title function_ invoke__">as_ref</span>()[<span class="number">0</span>] % <span class="number">2</span> &#123;</span><br><span class="line">				<span class="number">0</span> =&gt; Gender::Male,</span><br><span class="line">				_ =&gt; Gender::Female,</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//生成DNA</span></span><br><span class="line">		<span class="keyword">fn</span> <span class="title function_">gen_dna</span>() <span class="punctuation">-&gt;</span> [<span class="type">u8</span>; <span class="number">16</span>] &#123;</span><br><span class="line">			<span class="keyword">let</span> <span class="variable">payload</span> = (</span><br><span class="line">				T::KittyRandomness::<span class="title function_ invoke__">random</span>(&amp;<span class="string">b&quot;dna&quot;</span>[..]).<span class="number">0</span>,</span><br><span class="line">				&lt;frame_system::Pallet&lt;T&gt;&gt;::<span class="title function_ invoke__">block_number</span>(),</span><br><span class="line">			);</span><br><span class="line">			payload.<span class="title function_ invoke__">using_encoded</span>(blake2_128)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://xn--runtimelib-1t2pu689a.rs">runtime中的lib.rs</a>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">pallet_kitties</span>::Config <span class="keyword">for</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Event</span> = Event;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Currency</span> = Balances;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">KittyRandomness</span> = RandomnessCollectiveFlip;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">MaxKittyOwned</span> = MaxKittyOwned;</span><br><span class="line">&#125;</span><br><span class="line">parameter_types! &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">const</span> MaxKittyOwned: <span class="type">u32</span> = <span class="number">9999</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-公-私有函数以及事件的实现">3.2 公/私有函数以及事件的实现</h3>
<p>其中也包括<br>
主要实现如下内容：</p>
<ol>
<li>create_kitty(): 允许一个账户创建一个kitty的函数</li>
<li>mint()：更新我们的pallet的存储和error检查的函数，会被create_kitty调用。</li>
<li>pallet Events：使用FRAME的#[pallet::event]属性</li>
<li>create_kitty为公有函数，会调用私有函数mint。</li>
<li>其余用于交互的功能：设置交易价格、交易、购买、繁殖</li>
</ol>
<p>公有函数是在其中实现，这是要对用户开放的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[pallet::call]</span> </span><br><span class="line"><span class="keyword">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; &#123;</span><br><span class="line"> <span class="comment">//...   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>私有函数的实现，是在其中实现，不带有宏：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; &#123;</span><br><span class="line"> <span class="comment">//...   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新增代码如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[pallet::event]</span></span><br><span class="line"><span class="meta">#[pallet::generate_deposit(pub (super) fn deposit_event)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Event</span>&lt;T: Config&gt; &#123;</span><br><span class="line">    <span class="comment">/// Event documentation should end with an array that provides descriptive names for event</span></span><br><span class="line">    <span class="comment">// Part III</span></span><br><span class="line">    <span class="comment">//添加下面这几行</span></span><br><span class="line">    <span class="comment">/// A new Kitty was sucessfully created. \[sender, kitty_id\]</span></span><br><span class="line">    <span class="title function_ invoke__">Created</span>(T::AccountId, T::Hash),</span><br><span class="line">    <span class="comment">/// Kitty price was sucessfully set. \[sender, kitty_id, new_price\]</span></span><br><span class="line">    <span class="title function_ invoke__">PriceSet</span>(T::AccountId, T::Hash, <span class="type">Option</span>&lt;BalanceOf&lt;T&gt;&gt;),</span><br><span class="line">    <span class="comment">/// A Kitty was sucessfully transferred. \[from, to, kitty_id\]</span></span><br><span class="line">    <span class="title function_ invoke__">Transferred</span>(T::AccountId, T::AccountId, T::Hash),</span><br><span class="line">    <span class="comment">/// A Kitty was sucessfully bought. \[buyer, seller, kitty_id, bid_price\]</span></span><br><span class="line">    <span class="title function_ invoke__">Bought</span>(T::AccountId, T::AccountId, T::Hash, BalanceOf&lt;T&gt;),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Errors inform users that something went wrong.</span></span><br><span class="line"><span class="meta">#[pallet::error]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Error</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">///Error names should be descriptive.</span></span><br><span class="line">    <span class="comment">/// Errors should have helpful documentation associated with them.</span></span><br><span class="line">    <span class="comment">// Part III</span></span><br><span class="line">    <span class="comment">/// Handles arithemtic overflow when incrementing the Kitty counter.</span></span><br><span class="line">    KittyCntOverflow,</span><br><span class="line">    <span class="comment">/// An account cannot own more Kitties than `MaxKittyCount`.</span></span><br><span class="line">    ExceedMaxKittyOwned,</span><br><span class="line">    <span class="comment">/// Buyer cannot be the owner.</span></span><br><span class="line">    BuyerIsKittyOwner,</span><br><span class="line">    <span class="comment">/// Cannot transfer a kitty to its owner.</span></span><br><span class="line">    TransferToSelf,</span><br><span class="line">    <span class="comment">/// Handles checking whether the Kitty exists.</span></span><br><span class="line">    KittyNotExist,</span><br><span class="line">    <span class="comment">/// Handles checking that the Kitty is owned by the account transferring, buying or setting a price for it.</span></span><br><span class="line">    NotKittyOwner,</span><br><span class="line">    <span class="comment">/// Ensures the Kitty is for sale.</span></span><br><span class="line">    KittyNotForSale,</span><br><span class="line">    <span class="comment">/// Ensures that the buying price is greater than the asking price.</span></span><br><span class="line">    KittyBidPriceTooLow,</span><br><span class="line">    <span class="comment">/// Ensures that an account has enough funds to purchase a Kitty.</span></span><br><span class="line">    NotEnoughBalance,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//公共方法</span></span><br><span class="line"><span class="meta">#[pallet::call]</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//Part III: create_kitty 创建</span></span><br><span class="line">    <span class="meta">#[pallet::weight(100)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">create_kitty</span>(origin: OriginFor&lt;T&gt;) <span class="punctuation">-&gt;</span> DispatchResult &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">sender</span> = <span class="title function_ invoke__">ensure_signed</span>(origin)?; <span class="comment">// &lt;- add this line</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">kitty_id</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">mint</span>(&amp;sender, <span class="literal">None</span>, <span class="literal">None</span>)?;</span><br><span class="line">        <span class="comment">// &lt;- add this line</span></span><br><span class="line">        <span class="comment">// Logging to the console</span></span><br><span class="line">        log::info!(<span class="string">&quot;A kitty is born with ID: &#123;:?&#125;.&quot;</span>, kitty_id); <span class="comment">// &lt;- add this line</span></span><br><span class="line">        <span class="comment">// ACTION #4: Deposit `Created` event</span></span><br><span class="line">        <span class="comment">//发出事件创建</span></span><br><span class="line">        <span class="keyword">Self</span>::<span class="title function_ invoke__">deposit_event</span>(Event::<span class="title function_ invoke__">Created</span>(sender, kitty_id));</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Part III: set_price 设置价格</span></span><br><span class="line">    <span class="meta">#[pallet::weight(100)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_price</span>(</span><br><span class="line">        origin: OriginFor&lt;T&gt;,</span><br><span class="line">        kitty_id: T::Hash,</span><br><span class="line">        new_price: <span class="type">Option</span>&lt;BalanceOf&lt;T&gt;&gt;,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> DispatchResult &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">sender</span> = <span class="title function_ invoke__">ensure_signed</span>(origin)?;</span><br><span class="line">        <span class="comment">// Ensure the kitty exists and is called by the kitty owner</span></span><br><span class="line">        ensure!(<span class="keyword">Self</span>::<span class="title function_ invoke__">is_kitty_owner</span>(&amp;kitty_id, &amp;sender)?, &lt;Error&lt;T&gt;&gt;::NotKittyOwner);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">kitty</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">kitties</span>(&amp;kitty_id).<span class="title function_ invoke__">ok_or</span>(&lt;Error&lt;T&gt;&gt;::KittyNotExist)?;</span><br><span class="line">        kitty.price = new_price.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        &lt;Kitties&lt;T&gt;&gt;::<span class="title function_ invoke__">insert</span>(&amp;kitty_id, kitty);</span><br><span class="line">        <span class="comment">// Deposit a &quot;PriceSet&quot; event.</span></span><br><span class="line">        <span class="keyword">Self</span>::<span class="title function_ invoke__">deposit_event</span>(Event::<span class="title function_ invoke__">PriceSet</span>(sender, kitty_id, new_price));</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Part III: transfer 交易</span></span><br><span class="line">    <span class="meta">#[pallet::weight(100)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">transfer</span>(</span><br><span class="line">        origin: OriginFor&lt;T&gt;,</span><br><span class="line">        to: T::AccountId,</span><br><span class="line">        kitty_id: T::Hash,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> DispatchResult &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">from</span> = <span class="title function_ invoke__">ensure_signed</span>(origin)?;</span><br><span class="line">        <span class="comment">// Ensure the kitty exists and is called by the kitty owner</span></span><br><span class="line">        ensure!(<span class="keyword">Self</span>::<span class="title function_ invoke__">is_kitty_owner</span>(&amp;kitty_id, &amp;from)?, &lt;Error&lt;T&gt;&gt;::NotKittyOwner);</span><br><span class="line">        <span class="comment">// Verify the kitty is not transferring back to its owner.</span></span><br><span class="line">        ensure!(from != to, &lt;Error&lt;T&gt;&gt;::TransferToSelf);</span><br><span class="line">        <span class="comment">// Verify the recipient has the capacity to receive one more kitty</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">to_owned</span> = &lt;KittiesOwned&lt;T&gt;&gt;::<span class="title function_ invoke__">get</span>(&amp;to);</span><br><span class="line">        ensure!((to_owned.<span class="title function_ invoke__">len</span>() <span class="keyword">as</span> <span class="type">u32</span>) &lt; T::MaxKittyOwned::<span class="title function_ invoke__">get</span>(), &lt;Error&lt;T&gt;&gt;::ExceedMaxKittyOwned);</span><br><span class="line">        <span class="keyword">Self</span>::<span class="title function_ invoke__">transfer_kitty_to</span>(&amp;kitty_id, &amp;to)?;</span><br><span class="line">        <span class="keyword">Self</span>::<span class="title function_ invoke__">deposit_event</span>(Event::<span class="title function_ invoke__">Transferred</span>(from, to, kitty_id));</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Part III: buy_kitty 购买</span></span><br><span class="line">    <span class="meta">#[transactional]</span></span><br><span class="line">    <span class="meta">#[pallet::weight(100)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">buy_kitty</span>(</span><br><span class="line">        origin: OriginFor&lt;T&gt;,</span><br><span class="line">        kitty_id: T::Hash,</span><br><span class="line">        bid_price: BalanceOf&lt;T&gt;</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> DispatchResult &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">buyer</span> = <span class="title function_ invoke__">ensure_signed</span>(origin)?;</span><br><span class="line">        <span class="comment">// Check the kitty exists and buyer is not the current kitty owner</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">kitty</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">kitties</span>(&amp;kitty_id).<span class="title function_ invoke__">ok_or</span>(&lt;Error&lt;T&gt;&gt;::KittyNotExist)?;</span><br><span class="line">        ensure!(kitty.owner != buyer, &lt;Error&lt;T&gt;&gt;::BuyerIsKittyOwner);</span><br><span class="line">        <span class="comment">// Check the kitty is for sale and the kitty ask price &lt;= bid_price</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(ask_price) = kitty.price &#123;</span><br><span class="line">            ensure!(ask_price &lt;= bid_price, &lt;Error&lt;T&gt;&gt;::KittyBidPriceTooLow);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(&lt;Error&lt;T&gt;&gt;::KittyNotForSale)?;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Check the buyer has enough free balance</span></span><br><span class="line">        ensure!(T::Currency::<span class="title function_ invoke__">free_balance</span>(&amp;buyer) &gt;= bid_price, &lt;Error&lt;T&gt;&gt;::NotEnoughBalance);</span><br><span class="line">        <span class="comment">// Verify the buyer has the capacity to receive one more kitty</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">to_owned</span> = &lt;KittiesOwned&lt;T&gt;&gt;::<span class="title function_ invoke__">get</span>(&amp;buyer);</span><br><span class="line">        ensure!((to_owned.<span class="title function_ invoke__">len</span>() <span class="keyword">as</span> <span class="type">u32</span>) &lt; T::MaxKittyOwned::<span class="title function_ invoke__">get</span>(), &lt;Error&lt;T&gt;&gt;::ExceedMaxKittyOwned);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">seller</span> = kitty.owner.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="comment">// Transfer the amount from buyer to seller</span></span><br><span class="line">        T::Currency::<span class="title function_ invoke__">transfer</span>(&amp;buyer, &amp;seller, bid_price, ExistenceRequirement::KeepAlive)?;</span><br><span class="line">        <span class="comment">// Transfer the kitty from seller to buyer</span></span><br><span class="line">        <span class="keyword">Self</span>::<span class="title function_ invoke__">transfer_kitty_to</span>(&amp;kitty_id, &amp;buyer)?;</span><br><span class="line">        <span class="keyword">Self</span>::<span class="title function_ invoke__">deposit_event</span>(Event::<span class="title function_ invoke__">Bought</span>(buyer, seller, kitty_id, bid_price));</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Part III: breed_kitty 繁殖</span></span><br><span class="line">    <span class="meta">#[pallet::weight(100)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">breed_kitty</span>(</span><br><span class="line">        origin: OriginFor&lt;T&gt;,</span><br><span class="line">        parent1: T::Hash,</span><br><span class="line">        parent2: T::Hash</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> DispatchResult &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">sender</span> = <span class="title function_ invoke__">ensure_signed</span>(origin)?;</span><br><span class="line">        <span class="comment">// Check: Verify `sender` owns both kitties (and both kitties exist).</span></span><br><span class="line">        ensure!(<span class="keyword">Self</span>::<span class="title function_ invoke__">is_kitty_owner</span>(&amp;parent1, &amp;sender)?, &lt;Error&lt;T&gt;&gt;::NotKittyOwner);</span><br><span class="line">        ensure!(<span class="keyword">Self</span>::<span class="title function_ invoke__">is_kitty_owner</span>(&amp;parent2, &amp;sender)?, &lt;Error&lt;T&gt;&gt;::NotKittyOwner);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">new_dna</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">breed_dna</span>(&amp;parent1, &amp;parent2)?;</span><br><span class="line">        <span class="keyword">Self</span>::<span class="title function_ invoke__">mint</span>(&amp;sender, <span class="title function_ invoke__">Some</span>(new_dna), <span class="literal">None</span>)?;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有方法：</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//Part III: helper functions for dispatchable functions</span></span><br><span class="line">    <span class="comment">//increment_noce, random_hash, mint, transfer_from</span></span><br><span class="line">    <span class="comment">//生成性别</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">gen_gender</span>() <span class="punctuation">-&gt;</span> Gender &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">random</span> = T::KittyRandomness::<span class="title function_ invoke__">random</span>(&amp;<span class="string">b&quot;gender&quot;</span>[..]).<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">match</span> random.<span class="title function_ invoke__">as_ref</span>()[<span class="number">0</span>] % <span class="number">2</span> &#123;</span><br><span class="line">            <span class="number">0</span> =&gt; Gender::Male,</span><br><span class="line">            _ =&gt; Gender::Female,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成DNA</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">gen_dna</span>() <span class="punctuation">-&gt;</span> [<span class="type">u8</span>; <span class="number">16</span>] &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">payload</span> = (</span><br><span class="line">            T::KittyRandomness::<span class="title function_ invoke__">random</span>(&amp;<span class="string">b&quot;dna&quot;</span>[..]).<span class="number">0</span>,</span><br><span class="line">            &lt;frame_system::Pallet&lt;T&gt;&gt;::<span class="title function_ invoke__">block_number</span>(),</span><br><span class="line">        );</span><br><span class="line">        payload.<span class="title function_ invoke__">using_encoded</span>(blake2_128)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">mint</span>(</span><br><span class="line">        owner: &amp;T::AccountId,</span><br><span class="line">        dna: <span class="type">Option</span>&lt;[<span class="type">u8</span>; <span class="number">16</span>]&gt;,</span><br><span class="line">        gender: <span class="type">Option</span>&lt;Gender&gt;,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;T::Hash, Error&lt;T&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">kitty</span> = Kitty::&lt;T&gt; &#123;</span><br><span class="line">            dna: dna.<span class="title function_ invoke__">unwrap_or_else</span>(<span class="keyword">Self</span>::gen_dna),</span><br><span class="line">            price: <span class="literal">None</span>,</span><br><span class="line">            gender: gender.<span class="title function_ invoke__">unwrap_or_else</span>(<span class="keyword">Self</span>::gen_gender),</span><br><span class="line">            owner: owner.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">kitty_id</span> = T::Hashing::<span class="title function_ invoke__">hash_of</span>(&amp;kitty);</span><br><span class="line">        <span class="comment">// Performs this operation first as it may fail</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">new_cnt</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">kitty_cnt</span>().<span class="title function_ invoke__">checked_add</span>(<span class="number">1</span>)</span><br><span class="line">            .<span class="title function_ invoke__">ok_or</span>(&lt;Error&lt;T&gt;&gt;::KittyCntOverflow)?;</span><br><span class="line">        <span class="comment">// Performs this operation first because as it may fail</span></span><br><span class="line">        &lt;KittiesOwned&lt;T&gt;&gt;::<span class="title function_ invoke__">try_mutate</span>(&amp;owner, |kitty_vec| &#123;</span><br><span class="line">            kitty_vec.<span class="title function_ invoke__">try_push</span>(kitty_id)</span><br><span class="line">        &#125;).<span class="title function_ invoke__">map_err</span>(|_| &lt;Error&lt;T&gt;&gt;::ExceedMaxKittyOwned)?;</span><br><span class="line">        &lt;Kitties&lt;T&gt;&gt;::<span class="title function_ invoke__">insert</span>(kitty_id, kitty);</span><br><span class="line">        &lt;KittyCnt&lt;T&gt;&gt;::<span class="title function_ invoke__">put</span>(new_cnt);</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(kitty_id)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将is_kitty_owner函数的代码放在mint函数下方</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">is_kitty_owner</span>(kitty_id: &amp;T::Hash, acct: &amp;T::AccountId) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">bool</span>, Error&lt;T&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">Self</span>::<span class="title function_ invoke__">kitties</span>(kitty_id) &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(kitty) =&gt; <span class="title function_ invoke__">Ok</span>(kitty.owner == *acct),</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="title function_ invoke__">Err</span>(&lt;Error&lt;T&gt;&gt;::KittyNotExist)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[transactional]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">transfer_kitty_to</span>(</span><br><span class="line">        kitty_id: &amp;T::Hash,</span><br><span class="line">        to: &amp;T::AccountId,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">kitty</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">kitties</span>(&amp;kitty_id).<span class="title function_ invoke__">ok_or</span>(&lt;Error&lt;T&gt;&gt;::KittyNotExist)?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">prev_owner</span> = kitty.owner.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="comment">// Remove `kitty_id` from the KittyOwned vector of `prev_kitty_owner`</span></span><br><span class="line">        &lt;KittiesOwned&lt;T&gt;&gt;::<span class="title function_ invoke__">try_mutate</span>(&amp;prev_owner, |owned| &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(ind) = owned.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">position</span>(|&amp;id| id == *kitty_id) &#123;</span><br><span class="line">                owned.<span class="title function_ invoke__">swap_remove</span>(ind);</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(())</span><br><span class="line">        &#125;).<span class="title function_ invoke__">map_err</span>(|_| &lt;Error&lt;T&gt;&gt;::KittyNotExist)?;</span><br><span class="line">        <span class="comment">// Update the kitty owner</span></span><br><span class="line">        kitty.owner = to.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="comment">// Reset the ask price so the kitty is not for sale until `set_price()` is called</span></span><br><span class="line">        <span class="comment">// by the current owner.</span></span><br><span class="line">        kitty.price = <span class="literal">None</span>;</span><br><span class="line">        &lt;Kitties&lt;T&gt;&gt;::<span class="title function_ invoke__">insert</span>(kitty_id, kitty);</span><br><span class="line">        &lt;KittiesOwned&lt;T&gt;&gt;::<span class="title function_ invoke__">try_mutate</span>(to, |vec| &#123;</span><br><span class="line">            vec.<span class="title function_ invoke__">try_push</span>(*kitty_id)</span><br><span class="line">        &#125;).<span class="title function_ invoke__">map_err</span>(|_| &lt;Error&lt;T&gt;&gt;::ExceedMaxKittyOwned)?;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//繁殖</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">breed_dna</span>(parent1: &amp;T::Hash, parent2: &amp;T::Hash) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;[<span class="type">u8</span>; <span class="number">16</span>], Error&lt;T&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">dna1</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">kitties</span>(parent1).<span class="title function_ invoke__">ok_or</span>(&lt;Error&lt;T&gt;&gt;::KittyNotExist)?.dna;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">dna2</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">kitties</span>(parent2).<span class="title function_ invoke__">ok_or</span>(&lt;Error&lt;T&gt;&gt;::KittyNotExist)?.dna;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">new_dna</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">gen_dna</span>();</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..new_dna.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">            new_dna[i] = (new_dna[i] &amp; dna1[i]) | (!new_dna[i] &amp; dna2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(new_dna)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-初始化">4. 初始化</h2>
<p>在<code>// TODO Part III: Our pallet's genesis configuration.</code>位置处加入如下代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[pallet::genesis_config]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">GenesisConfig</span>&lt;T: Config&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> kitties: <span class="type">Vec</span>&lt;(T::AccountId, [<span class="type">u8</span>; <span class="number">16</span>], Gender)&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Required to implement default for GenesisConfig.</span></span><br><span class="line"><span class="meta">#[cfg(feature = <span class="string">&quot;std&quot;</span>)]</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Config&gt; <span class="built_in">Default</span> <span class="keyword">for</span> <span class="title class_">GenesisConfig</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">default</span>() <span class="punctuation">-&gt;</span> GenesisConfig&lt;T&gt; &#123;</span><br><span class="line">        GenesisConfig &#123; kitties: <span class="built_in">vec!</span>[] &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[pallet::genesis_build]</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Config&gt; GenesisBuild&lt;T&gt; <span class="keyword">for</span> <span class="title class_">GenesisConfig</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">build</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// When building a kitty from genesis config, we require the dna and gender to be supplied.</span></span><br><span class="line">        <span class="keyword">for</span> (acct, dna, gender) <span class="keyword">in</span> &amp;<span class="keyword">self</span>.kitties &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">_</span> = &lt;Pallet&lt;T&gt;&gt;::<span class="title function_ invoke__">mint</span>(acct, <span class="title function_ invoke__">Some</span>(dna.<span class="title function_ invoke__">clone</span>()), <span class="title function_ invoke__">Some</span>(gender.<span class="title function_ invoke__">clone</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时为了生效，需要在<code>node/src/chain_spec.rs</code>的<code>testnet_genesis</code>的方法中加入如下代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">testnet_genesis</span>(</span><br><span class="line">	wasm_binary: &amp;[<span class="type">u8</span>],</span><br><span class="line">	initial_authorities: <span class="type">Vec</span>&lt;(AuraId, GrandpaId)&gt;,</span><br><span class="line">	root_key: AccountId,</span><br><span class="line">	endowed_accounts: <span class="type">Vec</span>&lt;AccountId&gt;,</span><br><span class="line">	_enable_println: <span class="type">bool</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> GenesisConfig &#123;</span><br><span class="line">	GenesisConfig &#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">        <span class="comment">//加入如下代码</span></span><br><span class="line">		substrate_kitties: SubstrateKittiesConfig &#123;</span><br><span class="line">			kitties: <span class="built_in">vec!</span>[],</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，在<code>node/src/chain_spec.rs</code>的顶部加入：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> node_kitties_runtime::SubstrateKittiesConfig;</span><br></pre></td></tr></table></figure>
<h2 id="5-编译并运行">5. 编译并运行</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译</span></span><br><span class="line">cargo build --release</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行</span></span><br><span class="line">./target/release/node-kitties --dev</span><br></pre></td></tr></table></figure>
<h2 id="6-使用polkadot-js-apps-ui进行测试">6. 使用Polkadot-JS Apps UI进行测试</h2>
<p>打开<a href="https://polkadot.js.org/apps">polkadot-app</a> ，连接到本地节点，对<code>kitties</code>进行测试<br>
前往&quot;开发者&quot;-&quot;交易&quot;中，调用<code>substrateKitties</code>，则可找到相关方法进行操作</p>
<img src="/articles/94db7c74/1.png" class="" title="测试kitties">
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://learn.figment.io/tutorials/substrate-kitties-setup">Substrate Kitties - Basic Setup</a><br>
[2] <a href="https://mp.weixin.qq.com/s/1Yf6H6NoEOlpYQlBtuhy7A">使用substrate构建kitties链</a></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Substrate</category>
        <category>pallet应用</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Substrate</tag>
      </tags>
  </entry>
  <entry>
    <title>WebAssembly(3)-康威生命游戏案例-交互</title>
    <url>/articles/57d3ce21/</url>
    <content><![CDATA[<p>康威生命游戏案例-交互和性能分析<br>
本文是在上一节基础上的进一步完善，增加交互以及性能分析</p>
<span id="more"></span>  
<h2 id="1-暂停和恢复游戏">1. 暂停和恢复游戏</h2>
<p>可以手动控制运行和停止</p>
<h3 id="1-1-index-html代码">1.1 index.html代码</h3>
<p>加入了一个button</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello wasm-pack!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">flex-direction</span>: column;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;play-pause&quot;</span>&gt;</span>启/停<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;game-of-life-canvas&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./bootstrap.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-index-js代码">1.2 index.js代码</h3>
<p>控制开关的逻辑</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Universe</span>, <span class="title class_">Cell</span>&#125; <span class="keyword">from</span> <span class="string">&quot;wasm-game-of-life&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;memory&#125; <span class="keyword">from</span> <span class="string">&quot;wasm-game-of-life/wasm_game_of_life_bg&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">CELL_SIZE</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">GRID_COLOR</span> = <span class="string">&quot;#CCCCCC&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">DEAD_COLOR</span> = <span class="string">&quot;#FFFFFF&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">ALIVE_COLOR</span> = <span class="string">&quot;#000000&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> universe = <span class="title class_">Universe</span>.<span class="title function_">new</span>();</span><br><span class="line"><span class="keyword">const</span> width = universe.<span class="title function_">width</span>();</span><br><span class="line"><span class="keyword">const</span> height = universe.<span class="title function_">height</span>();</span><br><span class="line"><span class="keyword">const</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;game-of-life-canvas&quot;</span>);</span><br><span class="line">canvas.<span class="property">height</span> = (<span class="variable constant_">CELL_SIZE</span> + <span class="number">1</span>) * height + <span class="number">1</span>;</span><br><span class="line">canvas.<span class="property">width</span> = (<span class="variable constant_">CELL_SIZE</span> + <span class="number">1</span>) * width + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> animationId = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">renderLoop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">drawGrid</span>();</span><br><span class="line">    <span class="title function_">drawCells</span>();</span><br><span class="line">    universe.<span class="title function_">tick</span>();</span><br><span class="line">    animationId = <span class="title function_">requestAnimationFrame</span>(renderLoop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isPaused</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> animationId === <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> playPauseButton = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;play-pause&quot;</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">play</span>(<span class="params"></span>)&#123;</span><br><span class="line">    playPauseButton.<span class="property">textContent</span> = <span class="string">&quot;⏸️&quot;</span>;</span><br><span class="line">    <span class="title function_">renderLoop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pause</span>(<span class="params"></span>)&#123;</span><br><span class="line">    playPauseButton.<span class="property">textContent</span> = <span class="string">&quot;▶&quot;</span>;</span><br><span class="line">    <span class="title function_">cancelAnimationFrame</span>(animationId)</span><br><span class="line">    animationId = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">drawGrid</span>(<span class="params"></span>) &#123;</span><br><span class="line">    ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">    ctx.<span class="property">strokeStyle</span> = <span class="variable constant_">GRID_COLOR</span>;</span><br><span class="line">    <span class="comment">// Vertical lines.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= width; i++) &#123;</span><br><span class="line">        ctx.<span class="title function_">moveTo</span>(i * (<span class="variable constant_">CELL_SIZE</span> + <span class="number">1</span>) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        ctx.<span class="title function_">lineTo</span>(i * (<span class="variable constant_">CELL_SIZE</span> + <span class="number">1</span>) + <span class="number">1</span>, (<span class="variable constant_">CELL_SIZE</span> + <span class="number">1</span>) * height + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Horizontal lines.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= height; j++) &#123;</span><br><span class="line">        ctx.<span class="title function_">moveTo</span>(<span class="number">0</span>, j * (<span class="variable constant_">CELL_SIZE</span> + <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">        ctx.<span class="title function_">lineTo</span>((<span class="variable constant_">CELL_SIZE</span> + <span class="number">1</span>) * width + <span class="number">1</span>, j * (<span class="variable constant_">CELL_SIZE</span> + <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.<span class="title function_">stroke</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getIndex</span>(<span class="params">row, column</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> row * width + column;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">drawCells</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cellsPtr = universe.<span class="title function_">cells</span>();</span><br><span class="line">    <span class="keyword">const</span> cells = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(memory.<span class="property">buffer</span>, cellsPtr, width * height);</span><br><span class="line">    ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> row = <span class="number">0</span>; row &lt; height; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> col = <span class="number">0</span>; col &lt; width; col++) &#123;</span><br><span class="line">            <span class="keyword">const</span> idx = <span class="title function_">getIndex</span>(row, col);</span><br><span class="line">            ctx.<span class="property">fillStyle</span> = cells[idx] === <span class="title class_">Cell</span>.<span class="property">Dead</span></span><br><span class="line">                ? <span class="variable constant_">DEAD_COLOR</span></span><br><span class="line">                : <span class="variable constant_">ALIVE_COLOR</span>;</span><br><span class="line">            ctx.<span class="title function_">fillRect</span>(</span><br><span class="line">                col * (<span class="variable constant_">CELL_SIZE</span> + <span class="number">1</span>) + <span class="number">1</span>,</span><br><span class="line">                row * (<span class="variable constant_">CELL_SIZE</span> + <span class="number">1</span>) + <span class="number">1</span>,</span><br><span class="line">                <span class="variable constant_">CELL_SIZE</span>,</span><br><span class="line">                <span class="variable constant_">CELL_SIZE</span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.<span class="title function_">stroke</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(renderLoop);</span><br><span class="line">playPauseButton.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isPaused</span>())&#123;</span><br><span class="line">        <span class="title function_">play</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="title function_">pause</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="2-细胞点击变化">2. 细胞点击变化</h2>
<p>在上一节基础上<br>
鼠标点击细胞，可以发生变化</p>
<h2 id="2-1-lib-rs加入内容">2.1 lib.rs加入内容</h2>
<p>可变换Cell：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Cell实现切换</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Cell</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">toggle</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        *<span class="keyword">self</span> = <span class="keyword">match</span> *<span class="keyword">self</span> &#123;</span><br><span class="line">            Cell::Dead =&gt; Cell::Alive,</span><br><span class="line">            Cell::Alive =&gt; Cell::Dead,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Universe中新增方法</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">toggle_cell</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, row: <span class="type">u32</span>, col: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">idx</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">get_index</span>(row, col);</span><br><span class="line">    <span class="keyword">self</span>.cells[idx].<span class="title function_ invoke__">toggle</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-index-js中加入交互">2.2 index.js中加入交互</h2>
<p>非重点，这里不讲解</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">canvas.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)  &#123;</span><br><span class="line">    <span class="keyword">const</span> boundingRect = canvas.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> scaleX = canvas.<span class="property">width</span> / boundingRect.<span class="property">width</span>;</span><br><span class="line">    <span class="keyword">const</span> scaleY = canvas.<span class="property">height</span> / boundingRect.<span class="property">height</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> canvasLeft = (event.<span class="property">clientX</span> - boundingRect.<span class="property">left</span>) * scaleX;</span><br><span class="line">    <span class="keyword">const</span> canvasTop = (event.<span class="property">clientY</span> - boundingRect.<span class="property">top</span>) * scaleY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> row = <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(canvasTop / (<span class="variable constant_">CELL_SIZE</span> + <span class="number">1</span>)), height - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> col = <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(canvasLeft / (<span class="variable constant_">CELL_SIZE</span> + <span class="number">1</span>)), width - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    universe.<span class="title function_">toggle_cell</span>(row, col);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">drawGrid</span>();</span><br><span class="line">    <span class="title function_">drawCells</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文已编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://rustwasm.github.io/docs/book/">Wasm官方文档</a></p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>WebAssembly</category>
      </categories>
      <tags>
        <tag>rust基础</tag>
        <tag>WebAssembly</tag>
      </tags>
  </entry>
  <entry>
    <title>WebAssembly(2)-康威生命游戏案例</title>
    <url>/articles/76ce031b/</url>
    <content><![CDATA[<p>通过案例来展示WebAssembly的应用</p>
<span id="more"></span>  
<h2 id="1-游戏规则和设计">1. 游戏规则和设计</h2>
<ol>
<li>规则：在一个二维方格中，每个方格的状态都为“生”或者“死”。每个方格对应的就是一个细胞，每个细胞和它的周围的八个方格相邻。在每个时间推移过程中，都会发生以下转换（<code>就是说，下一秒的状态，根据前一秒的状态来判断生死</code>）：
<ul>
<li>任何少于两个活邻居的活细胞都会死亡。</li>
<li>任何有两个或三个活邻居的活细胞都能存活到下一代。</li>
<li>任何一个有三个以上邻居的活细胞都会死亡。</li>
<li>任何一个有三个活邻居的死细胞都会变成一个活细胞。</li>
</ul>
</li>
<li>设计：创建一个固定大小的宇宙（二维方格），但是左边的尽头就是右边。</li>
</ol>
<h2 id="2-基本实现">2. 基本实现</h2>
<p>以正常思路完成以上功能</p>
<h3 id="2-1-rust实现">2.1 rust实现</h3>
<p>计算和打印，都由rust来实现，这个只是简单的设计逻辑，具体注释都在代码中标注了<br>
<code>lib.rs</code>文件中</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> wasm_bindgen::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[wasm_bindgen]</span></span><br><span class="line"><span class="meta">#[repr(u8)]</span>   <span class="comment">//表示下方枚举只占用8个bit</span></span><br><span class="line"><span class="meta">#[derive(Clone, Copy, Debug, PartialEq, Eq)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Cell</span> &#123;</span><br><span class="line">    Dead = <span class="number">0</span>,</span><br><span class="line">    Alive = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[wasm_bindgen]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Universe</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">    cells: <span class="type">Vec</span>&lt;Cell&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[wasm_bindgen]</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Universe</span> &#123;</span><br><span class="line">   <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Universe &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">w</span> = <span class="number">64</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">h</span> = <span class="number">64</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cells</span> = (<span class="number">0</span>..w * h).<span class="title function_ invoke__">map</span>(|i| &#123;</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span> || i % <span class="number">7</span> == <span class="number">0</span> &#123;</span><br><span class="line">                Cell::Alive</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Cell::Dead</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">        Universe &#123;</span><br><span class="line">            width: w,</span><br><span class="line">            height: h,</span><br><span class="line">            cells,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">render</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取到一维数组中的索引</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_index</span>(&amp;<span class="keyword">self</span>, row: <span class="type">u32</span>, col: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">        (row * <span class="keyword">self</span>.width + col) <span class="keyword">as</span> <span class="type">usize</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取活着的邻居的个数</span></span><br><span class="line">    <span class="comment">//相邻的步进是-1,0,1</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">live_neighbor_count</span>(&amp;<span class="keyword">self</span>, row: <span class="type">u32</span>, col: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">delta_row</span> <span class="keyword">in</span> [<span class="keyword">self</span>.height - <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>].<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">cloned</span>() &#123;</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">delta_col</span> <span class="keyword">in</span> [<span class="keyword">self</span>.width - <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>].<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">cloned</span>() &#123;</span><br><span class="line">                <span class="keyword">if</span> delta_row == <span class="number">0</span> &amp;&amp; delta_col == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">neighbor_row</span> = (row + delta_row) % <span class="keyword">self</span>.height;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">neighbor_col</span> = (col + delta_col) % <span class="keyword">self</span>.width;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">idx</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">get_index</span>(neighbor_row, neighbor_col);</span><br><span class="line">                count += <span class="keyword">self</span>.cells[idx] <span class="keyword">as</span> <span class="type">u8</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下一个时间点，宇宙的变化</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">tick</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">next</span> = <span class="keyword">self</span>.cells.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">row</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="keyword">self</span>.height &#123;</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">col</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="keyword">self</span>.width &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">idx</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">get_index</span>(row, col);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">cell</span> = <span class="keyword">self</span>.cells[idx];</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">live_neighbors</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">live_neighbor_count</span>(row, col);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">next_cell</span> = <span class="keyword">match</span> (cell, live_neighbors) &#123;</span><br><span class="line">                    (Cell::Alive, x) <span class="keyword">if</span> x &lt; <span class="number">2</span> =&gt; Cell::Dead,</span><br><span class="line">                    (Cell::Alive, <span class="number">2</span>) | (Cell::Alive, <span class="number">3</span>) =&gt; Cell::Alive,</span><br><span class="line">                    (Cell::Alive, x) <span class="keyword">if</span> x &gt; <span class="number">3</span> =&gt; Cell::Dead,</span><br><span class="line">                    (Cell::Dead, <span class="number">3</span>) =&gt; Cell::Alive,</span><br><span class="line">                    (otherwise, _) =&gt; otherwise,</span><br><span class="line">                &#125;;</span><br><span class="line">                next[idx] = next_cell;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.cells = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">use</span> std::fmt::write;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Universe</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> <span class="keyword">self</span>.cells.<span class="title function_ invoke__">as_slice</span>().<span class="title function_ invoke__">chunks</span>(<span class="keyword">self</span>.width <span class="keyword">as</span> <span class="type">usize</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> &amp;cell <span class="keyword">in</span> line &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">symbol</span> = <span class="keyword">if</span> cell == Cell::Dead &#123;</span><br><span class="line">                    <span class="string">&#x27;◻&#x27;</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="string">&#x27;◼&#x27;</span></span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="built_in">write!</span>(f, <span class="string">&quot;&#123;&#125;&quot;</span>, symbol)?;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">write!</span>(f, <span class="string">&quot;\n&quot;</span>)?;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-web页面处理">2.2 web页面处理</h3>
<p>用于调用rust的函数<br>
index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello wasm-pack!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">flex-direction</span>: column;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pre</span> <span class="attr">id</span>=<span class="string">&quot;game-of-life-canvas&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./bootstrap.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Universe</span>&#125; <span class="keyword">from</span> <span class="string">&quot;wasm-game-of-life&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> pre = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;game-of-life-canvas&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> universe = <span class="title class_">Universe</span>.<span class="title function_">new</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">renderLoop</span>(<span class="params"></span>)&#123;</span><br><span class="line">    pre.<span class="property">textContent</span> = universe.<span class="title function_">render</span>();</span><br><span class="line">    universe.<span class="title function_">tick</span>();</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(renderLoop);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(renderLoop);</span><br></pre></td></tr></table></figure>
<h3 id="2-3-启动">2.3 启动</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run start</span><br></pre></td></tr></table></figure>
<p>浏览器访问：<a href="http://localhost:8080">http://localhost:8080</a>]</p>
<h2 id="3-进一步优化">3. 进一步优化</h2>
<p>上面实现的问题：<br>
在Rust中实现了填充的内容，然后让wasm bindgen转换为一个有效的js字符串，这样就产生了不必要的副本。因为js代码已经知道宇宙的宽度和高度，因此可以直接读取构成cell的web assembly内存。另外我们将切换到Canvas API，而不是直接使用unicode文本。</p>
<h3 id="3-1-rsut中将宽度-高度和数组指针返回给js">3.1 rsut中将宽度、高度和数组指针返回给js</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回宽度</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">width</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.width</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回高度</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">height</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数组指针返回给js</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">cells</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> *<span class="keyword">const</span> Cell &#123;</span><br><span class="line">    <span class="keyword">self</span>.cells.<span class="title function_ invoke__">as_ptr</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-index-html">3.2 index.html</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello wasm-pack!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">flex-direction</span>: column;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;game-of-life-canvas&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./bootstrap.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-index-js">3.3 index.js</h3>
<p>原先在rust中生成画面的逻辑，迁移到了js中，减少了一次数据的复制</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Universe</span>, <span class="title class_">Cell</span>&#125; <span class="keyword">from</span> <span class="string">&quot;wasm-game-of-life&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;memory&#125; <span class="keyword">from</span> <span class="string">&quot;wasm-game-of-life/wasm_game_of_life_bg&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">CELL_SIZE</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">GRID_COLOR</span> = <span class="string">&quot;#CCCCCC&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">DEAD_COLOR</span> = <span class="string">&quot;#FFFFFF&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">ALIVE_COLOR</span> = <span class="string">&quot;#000000&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> universe = <span class="title class_">Universe</span>.<span class="title function_">new</span>();</span><br><span class="line"><span class="keyword">const</span> width = universe.<span class="title function_">width</span>();</span><br><span class="line"><span class="keyword">const</span> height = universe.<span class="title function_">height</span>();</span><br><span class="line"><span class="keyword">const</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;game-of-life-canvas&quot;</span>);</span><br><span class="line">canvas.<span class="property">height</span> = (<span class="variable constant_">CELL_SIZE</span> + <span class="number">1</span>) * height + <span class="number">1</span>;</span><br><span class="line">canvas.<span class="property">width</span> = (<span class="variable constant_">CELL_SIZE</span> + <span class="number">1</span>) * width + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">renderLoop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    universe.<span class="title function_">tick</span>();</span><br><span class="line">    <span class="title function_">drawGrid</span>();</span><br><span class="line">    <span class="title function_">drawCells</span>();</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(renderLoop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">drawGrid</span>(<span class="params"></span>) &#123;</span><br><span class="line">    ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">    ctx.<span class="property">strokeStyle</span> = <span class="variable constant_">GRID_COLOR</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Vertical lines.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= width; i++) &#123;</span><br><span class="line">        ctx.<span class="title function_">moveTo</span>(i * (<span class="variable constant_">CELL_SIZE</span> + <span class="number">1</span>) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        ctx.<span class="title function_">lineTo</span>(i * (<span class="variable constant_">CELL_SIZE</span> + <span class="number">1</span>) + <span class="number">1</span>, (<span class="variable constant_">CELL_SIZE</span> + <span class="number">1</span>) * height + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Horizontal lines.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= height; j++) &#123;</span><br><span class="line">        ctx.<span class="title function_">moveTo</span>(<span class="number">0</span>, j * (<span class="variable constant_">CELL_SIZE</span> + <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">        ctx.<span class="title function_">lineTo</span>((<span class="variable constant_">CELL_SIZE</span> + <span class="number">1</span>) * width + <span class="number">1</span>, j * (<span class="variable constant_">CELL_SIZE</span> + <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx.<span class="title function_">stroke</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getIndex</span>(<span class="params">row, column</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> row * width + column;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">drawCells</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cellsPtr = universe.<span class="title function_">cells</span>();</span><br><span class="line">    <span class="keyword">const</span> cells = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(memory.<span class="property">buffer</span>, cellsPtr, width * height);</span><br><span class="line"></span><br><span class="line">    ctx.<span class="title function_">beginPath</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> row = <span class="number">0</span>; row &lt; height; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> col = <span class="number">0</span>; col &lt; width; col++) &#123;</span><br><span class="line">            <span class="keyword">const</span> idx = <span class="title function_">getIndex</span>(row, col);</span><br><span class="line"></span><br><span class="line">            ctx.<span class="property">fillStyle</span> = cells[idx] === <span class="title class_">Cell</span>.<span class="property">Dead</span></span><br><span class="line">                ? <span class="variable constant_">DEAD_COLOR</span></span><br><span class="line">                : <span class="variable constant_">ALIVE_COLOR</span>;</span><br><span class="line"></span><br><span class="line">            ctx.<span class="title function_">fillRect</span>(</span><br><span class="line">                col * (<span class="variable constant_">CELL_SIZE</span> + <span class="number">1</span>) + <span class="number">1</span>,</span><br><span class="line">                row * (<span class="variable constant_">CELL_SIZE</span> + <span class="number">1</span>) + <span class="number">1</span>,</span><br><span class="line">                <span class="variable constant_">CELL_SIZE</span>,</span><br><span class="line">                <span class="variable constant_">CELL_SIZE</span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.<span class="title function_">stroke</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(renderLoop);</span><br></pre></td></tr></table></figure>
<h2 id="4-测试">4. 测试</h2>
<p>需要先在rust中设置一些方法，用于测试调用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Universe的wasm中实现方法：</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_width</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>,width:<span class="type">u32</span>)&#123;</span><br><span class="line">   <span class="keyword">self</span>.width = width;</span><br><span class="line">   <span class="keyword">self</span>.cells = (<span class="number">0</span>..width*<span class="keyword">self</span>.height).<span class="title function_ invoke__">map</span>(|_i| Cell::Dead).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_height</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>,height:<span class="type">u32</span>)&#123;</span><br><span class="line">   <span class="keyword">self</span>.height = height;</span><br><span class="line">   <span class="keyword">self</span>.cells = (<span class="number">0</span>..height*<span class="keyword">self</span>.width).<span class="title function_ invoke__">map</span>(|_i| Cell::Dead).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">非wasm实现方法</span><br><span class="line"><span class="comment">//没有#[wasm_bindgen]</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Universe</span>&#123;</span><br><span class="line">   <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_cells</span>(&amp;<span class="keyword">self</span>)<span class="punctuation">-&gt;</span>&amp;[Cell]&#123;</span><br><span class="line">      &amp;<span class="keyword">self</span>.cells</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_cells</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>,cells:&amp;[(<span class="type">u32</span>,<span class="type">u32</span>)])&#123;</span><br><span class="line">      <span class="keyword">for</span> (row,col) <span class="keyword">in</span> cells.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">cloned</span>()&#123;</span><br><span class="line">         <span class="keyword">let</span> <span class="variable">idx</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">get_index</span>(row,col);</span><br><span class="line">         <span class="keyword">self</span>.cells[idx] = Cell::Alive;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在tests中的web.rs中：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! Test suite for the Web and headless browsers.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#![cfg(target_arch = <span class="string">&quot;wasm32&quot;</span>)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> wasm_bindgen_test;</span><br><span class="line"><span class="keyword">use</span> wasm_bindgen_test::*;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> wasm_game_of_life;</span><br><span class="line"><span class="keyword">use</span> wasm_game_of_life::Universe;</span><br><span class="line"></span><br><span class="line">wasm_bindgen_test_configure!(run_in_browser);</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">input_spaceship</span>() <span class="punctuation">-&gt;</span> Universe &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">universe</span> = Universe::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    universe.<span class="title function_ invoke__">set_width</span>(<span class="number">6</span>);</span><br><span class="line">    universe.<span class="title function_ invoke__">set_height</span>(<span class="number">6</span>);</span><br><span class="line">    universe.<span class="title function_ invoke__">set_cells</span>(&amp;[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">3</span>)]);</span><br><span class="line">    universe</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">excepted_spaceship</span>() <span class="punctuation">-&gt;</span> Universe &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">universe</span> = Universe::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    universe.<span class="title function_ invoke__">set_width</span>(<span class="number">6</span>);</span><br><span class="line">    universe.<span class="title function_ invoke__">set_height</span>(<span class="number">6</span>);</span><br><span class="line">    universe.<span class="title function_ invoke__">set_cells</span>(&amp;[(<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">2</span>)]);</span><br><span class="line">    universe</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[wasm_bindgen_test]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">test_tick</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input_universe</span> = <span class="title function_ invoke__">input_spaceship</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">excepted_universe</span> = <span class="title function_ invoke__">excepted_spaceship</span>();</span><br><span class="line">    input_universe.<span class="title function_ invoke__">tick</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(&amp;input_universe.<span class="title function_ invoke__">get_cells</span>(), &amp;excepted_universe.<span class="title function_ invoke__">get_cells</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wasm-pack test --firefox --headless</span><br></pre></td></tr></table></figure>
<h2 id="5-调试代码">5. 调试代码</h2>
<p>要在浏览器控制台打印日志，需要：<br>
wasm-pack-template附带了一个可选的，默认情况下启用的依赖，该依赖属于console_error_panic_hook包，在wasm-game-of-life/src/utils中配置，需要在初始化函数活着公共代码路径中安装钩子，在本项目中，可以如下调用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span>Universe&#123;</span><br><span class="line">   utils::<span class="title function_ invoke__">set_panic_hook</span>();</span><br><span class="line">   <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Cargo.toml依赖：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="attr">web-sys</span> = &#123;version=<span class="string">&quot;0.3&quot;</span>,features=[<span class="string">&quot;console&quot;</span>]&#125;</span><br></pre></td></tr></table></figure>
<p>日志宏：<br>
<a href="http://lib.rs">lib.rs</a> :</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> web_sys;</span><br><span class="line"><span class="built_in">macro_rules!</span> log &#123;</span><br><span class="line">    ($($t:tt)*)=&gt;&#123;</span><br><span class="line">        web_sys::console::<span class="title function_ invoke__">log_1</span>(&amp;<span class="built_in">format!</span>($($t)*).<span class="title function_ invoke__">into</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rust中设置需要打印的内容：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//变化前打印情况</span></span><br><span class="line"> log!(</span><br><span class="line">     <span class="string">&quot;cell [&#123;&#125;,&#123;&#125;] is initally &#123;:?&#125; and has &#123;&#125; live neighbors&quot;</span>,</span><br><span class="line">     row,</span><br><span class="line">     col,</span><br><span class="line">     cell,</span><br><span class="line">     live_neighbors</span><br><span class="line"> );</span><br></pre></td></tr></table></figure>
<p>index.js中开启debug：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">renderLoop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">debugger</span>;<span class="comment">//添加调试</span></span><br><span class="line">    universe.<span class="title function_">tick</span>();</span><br><span class="line">    <span class="title function_">drawGrid</span>();</span><br><span class="line">    <span class="title function_">drawCells</span>();</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(renderLoop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动后，即可在浏览器控制台看到打印的信息</p>
<h2 id="总结">总结</h2>
<p>本文已编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://rustwasm.github.io/docs/book/">Wasm官方文档</a></p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>WebAssembly</category>
      </categories>
      <tags>
        <tag>rust基础</tag>
        <tag>WebAssembly</tag>
      </tags>
  </entry>
  <entry>
    <title>WebAssembly(1)-入门</title>
    <url>/articles/bc9ee434/</url>
    <content><![CDATA[<p>WebAssembly相关入门。<br>
在圈子里经常听说webassembly，也听到很多人不同的解释，但这究竟是什么，总得亲自体验下，才会深有体会。</p>
<span id="more"></span>  
<h2 id="1-概述">1. 概述</h2>
<ol>
<li>目前该技术主要是和js进行交互，如果个人方向在rust上，则仅需要关注下rust部分的应用即可。</li>
<li>WebAssembly（wasm）是一种简单的机器模型和具有广泛规范的可执行格式。它被设计成可移植的、紧凑的，并且以或接近本机速度执行。<code>说白了就是：简而言之，它是一种将用一种编程语言编写的代码转换为浏览器可理解的机器代码的技术。让在浏览器上能够高效执行一些复杂程序</code></li>
<li>WebAssembly有两种表示相同结构的格式：
<ol>
<li>.wat 文本格式（WebAssembly Text）使用S表达式，和Lisp家族的语言有些类似；</li>
<li>.wasm二进制格式，级别较低，直接供wasm虚拟机使用，它在概念上类似于ELF和Mach-O。</li>
</ol>
</li>
<li>线性存储器：WebAssembly有一个非常简单的内存模型。wasm模块可以访问单个的线性内存（本质就是数组），此内存可以按照页大小（64K）的倍数增长，但是不能缩小。</li>
<li>wasm并没有对其宿主环境做出任何假设，但是到目前为止，主要还是与js相关。</li>
</ol>
<h2 id="2-方式一实现helloworld">2. 方式一实现HelloWorld</h2>
<p>很基本的方式实现，用于体验</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装wasm-pack</span></span><br><span class="line">cargo install wasm-pack</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装npm（本案例暂时不需要）</span></span><br><span class="line">npm install npm@latest -g</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建工程</span></span><br><span class="line">cargo new --lib mywasm</span><br></pre></td></tr></table></figure>
<p>Cargo.toml中加入依赖：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[lib]</span></span><br><span class="line"><span class="attr">crate-type</span> = [<span class="string">&quot;cdylib&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">wasm-bindgen</span> = <span class="string">&quot;0.2&quot;</span></span><br></pre></td></tr></table></figure>
<p>src/lib.rs中：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> wasm_bindgen::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[wasm_bindgen]</span></span><br><span class="line"><span class="keyword">extern</span>&#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">alert</span>(s:&amp;<span class="type">str</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[wasm_bindgen]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">greet</span>(name:&amp;<span class="type">str</span>)&#123;</span><br><span class="line">    <span class="title function_ invoke__">alert</span>(&amp;<span class="built_in">format!</span>(<span class="string">&quot;Hello,My wasm! I&#x27;m &#123;&#125;!&quot;</span>,name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>项目根目录编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wasm-pack build --target web</span><br></pre></td></tr></table></figure>
<p>在项目根目录下创建<code>index.html</code>，调用wasm，内容如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hello-wasm example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">import</span> init, &#123;greet&#125; <span class="keyword">from</span> <span class="string">&quot;./pkg/hello_wasm.js&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">init</span>()</span></span><br><span class="line"><span class="language-javascript">        .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">greet</span>(<span class="string">&quot;WebAssembly&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">      </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行server：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 -m http.server</span><br></pre></td></tr></table></figure>
<p>测试：<br>
浏览器输入：<code>http://localhost:8000</code></p>
<h2 id="3-方式二实现helloworld">3. 方式二实现HelloWorld</h2>
<p>官方标准方式实现，利用模板实现，更加符合工程需要</p>
<p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh</span><br><span class="line">cargo install cargo-generate</span><br><span class="line">npm install npm@latest -g</span><br></pre></td></tr></table></figure>
<p>注意，在macos环境下，执行：<code>cargo install cargo-generate</code>，八成会报：openssl错误。这种时候就不要再强制去按着报错解决问题了。直接去github下载已经编译好的：<a href="https://github.com/cargo-generate/cargo-generate/releases">cargo-generate</a> 下载后，将解压出来的<code>cargo-generate</code>二进制文件放到你的<code>.cargo/bin/</code>目录下</p>
<p>下载模板（macos系统会提示权限安全异常，用mac的应该都知道咋处理，不知道的自己百度吧）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo generate --git https://github.com/rustwasm/wasm-pack-template</span><br></pre></td></tr></table></figure>
<p>Cargo.toml中加入如下，否则编译的时候会很难通过：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[package.metadata.wasm-pack.profile.dev]</span></span><br><span class="line"><span class="attr">wasm-opt</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="section">[package.metadata.wasm-pack.profile.release]</span></span><br><span class="line"><span class="attr">wasm-opt</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>进去根目录，开始编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wasm-pack build</span><br></pre></td></tr></table></figure>
<p>将wasm放入网页</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm init wasm-app www</span><br><span class="line">cd www</span><br></pre></td></tr></table></figure>
<p>打开package.json，添加如下代码</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>                     <span class="comment">// Add this three lines block!</span></span><br><span class="line">    <span class="attr">&quot;wasm-game-of-life&quot;</span><span class="punctuation">:</span> <span class="string">&quot;file:../pkg&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>修改index.js如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//import * as wasm from &quot;hello-wasm-pack&quot;;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> wasm <span class="keyword">from</span> <span class="string">&quot;wasm-game-of-life&quot;</span>;</span><br><span class="line">wasm.<span class="title function_">greet</span>();</span><br></pre></td></tr></table></figure>
<p>启动测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm run start</span><br></pre></td></tr></table></figure>
<p>浏览器输入：<br>
<a href="http://localhost:8080">http://localhost:8080</a></p>
<h2 id="总结">总结</h2>
<p>本文已编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://rustwasm.github.io/docs/book/">Wasm官方文档</a></p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>WebAssembly</category>
      </categories>
      <tags>
        <tag>rust基础</tag>
        <tag>WebAssembly</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust异步编程(5)-问号使用、send的trait、递归</title>
    <url>/articles/242aca23/</url>
    <content><![CDATA[<p>问号</p>
<span id="more"></span> 
<h2 id="1-问号使用">1. 问号使用</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> futures;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">foo</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(),<span class="type">String</span>&gt;&#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">func</span>()<span class="punctuation">-&gt;</span><span class="type">Result</span>&lt;(),<span class="type">String</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">fut</span> = <span class="keyword">async</span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">foo</span>().<span class="keyword">await</span>?;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;;</span><br><span class="line">    fut.<span class="keyword">await</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_</span> = futures::executor::<span class="title function_ invoke__">block_on</span>(<span class="title function_ invoke__">func</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-send的trait">2. send的trait</h2>
<ol>
<li>如果所有的子类型都是实现Send trait的，那么它本身也是实现Send trait的;否则未实现，下方代码无法编译通过：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="meta">#[derive(Default)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NoSend</span>(Rc&lt;()&gt;);</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">bar</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">foo</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = NoSend::<span class="title function_ invoke__">default</span>();  <span class="comment">//x未实现Send trait，则无法在线程之间传递，不安全，因此无法编译</span></span><br><span class="line">    <span class="title function_ invoke__">bar</span>().<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">required_send</span>(_: <span class="keyword">impl</span> <span class="title class_">Send</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">required_send</span>(<span class="title function_ invoke__">foo</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>如果要在async方法中使用未实现Send trait的变量，则需要在变量外层加上代码块标记：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Default)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NoSend</span>(Rc&lt;()&gt;);</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">bar</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">foo</span>()&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = NoSend::<span class="title function_ invoke__">default</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">bar</span>().<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-递归">3. 递归</h2>
<ol>
<li>正常递归执行的问题</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> futures;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">first</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">second</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">foo</span>()&#123;</span><br><span class="line">    <span class="title function_ invoke__">first</span>().<span class="keyword">await</span>;</span><br><span class="line">    <span class="title function_ invoke__">second</span>().<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面代码编译后生成的代码：</span></span><br><span class="line"><span class="comment">////-------------</span></span><br><span class="line"><span class="comment">//enum Foo&#123;</span></span><br><span class="line"><span class="comment">//	First(first),</span></span><br><span class="line"><span class="comment">//	Second(second),</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//enum FooState &#123;</span></span><br><span class="line"><span class="comment">//	F1_Pending,</span></span><br><span class="line"><span class="comment">//	F1_Ready,</span></span><br><span class="line"><span class="comment">//	F2_Pending,</span></span><br><span class="line"><span class="comment">//	F2_Ready,</span></span><br><span class="line"><span class="comment">//  Ready</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//struct Foo &#123;</span></span><br><span class="line"><span class="comment">//	f1: Foo::First,</span></span><br><span class="line"><span class="comment">//	f2: Foo::Second,</span></span><br><span class="line"><span class="comment">//	state: FooState, </span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">////--------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">re</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">re</span>().<span class="keyword">await</span>;</span><br><span class="line">    <span class="title function_ invoke__">re</span>().<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面方法递归编译后内容，无限循环的结构体，导致无法确定大小，因此编译失败</span></span><br><span class="line"><span class="comment">//enum Re &#123;</span></span><br><span class="line"><span class="comment">//	First(Re),</span></span><br><span class="line"><span class="comment">//	Second(Re),</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//struct Re &#123;</span></span><br><span class="line"><span class="comment">//	f1: Ree::First,</span></span><br><span class="line"><span class="comment">//	f2: Ree::Second,</span></span><br><span class="line"><span class="comment">//	//state,</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    futures::executor::<span class="title function_ invoke__">block_on</span>(<span class="title function_ invoke__">foo</span>());</span><br><span class="line">    futures::executor::<span class="title function_ invoke__">block_on</span>(<span class="title function_ invoke__">re</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>解决方法<br>
使用BoxFuture，装载递归方法，可以避免死循环<br>
加入到box中，编译出的结构体，不会无限死循环，固定大小</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> futures::future::&#123;BoxFuture, FutureExt&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">re</span>() <span class="punctuation">-&gt;</span> BoxFuture&lt;<span class="symbol">&#x27;static</span>, ()&gt; &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">move</span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">re</span>().<span class="keyword">await</span>;</span><br><span class="line">        <span class="title function_ invoke__">re</span>().<span class="keyword">await</span>;</span><br><span class="line">    &#125;.<span class="title function_ invoke__">boxed</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">re</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust异步编程</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust异步编程(4)-join!、try_jion!、select</title>
    <url>/articles/1c25f8a5/</url>
    <content><![CDATA[<p>join!、try_jion!、select</p>
<span id="more"></span> 
<h2 id="1-join">1. join!</h2>
<ol>
<li>join!本身不返回结果</li>
<li>等待所有其中的future执行完毕，才返回Result告诉程序执行是否异常</li>
<li>futures::join!可以将futures汇总到执行队列中。另外，下方代码，由于使用的tokio的time进行线程延迟管理，<br>
因此，执行future时，需要使用tokio的runtime，而不能直接使用标注库的executor<br>
依赖：<br>
futures = “0.3.5”<br>
tokio = {version = “0.2”,features= [“full”]}</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> futures;</span><br><span class="line"><span class="keyword">use</span> tokio::runtime::Runtime;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">func1</span>()&#123;</span><br><span class="line">    tokio::time::<span class="title function_ invoke__">delay_for</span>(tokio::time::Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>)).<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;func1 finished!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">func2</span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;func2 finished!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">async_main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f1</span> = <span class="title function_ invoke__">func1</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f2</span> = <span class="title function_ invoke__">func2</span>();</span><br><span class="line">    futures::join!(f1,f2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">runtime</span> = Runtime::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    runtime.<span class="title function_ invoke__">block_on</span>(<span class="title function_ invoke__">async_main</span>());   <span class="comment">//因为上面的time延迟使用的是tokio的，这里必须用runtime配套使用，不能再用标准库的executor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-try-join">2. try_join!</h2>
<ol>
<li>try_join!会返回Result信息，因此每个异步async函数需要加上返回Result类型，具体使用如下：</li>
<li><code>try_join!</code>中，只要有一个future执行异常，则立马返回Result告诉程序执行是否异常</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> futures;</span><br><span class="line"><span class="keyword">use</span> tokio::runtime::Runtime;</span><br><span class="line"><span class="keyword">use</span> std::io::<span class="type">Result</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">func1</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt;&#123;</span><br><span class="line">    tokio::time::<span class="title function_ invoke__">delay_for</span>(tokio::time::Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>)).<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;func1 finished!&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">func2</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt;&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;func2 finished!&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">async_main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f1</span> = <span class="title function_ invoke__">func1</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f2</span> = <span class="title function_ invoke__">func2</span>();</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(_) = futures::try_join!(f1,f2)&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">runtime</span> = Runtime::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    runtime.<span class="title function_ invoke__">block_on</span>(<span class="title function_ invoke__">async_main</span>());   <span class="comment">//因为上面的time延迟使用的是tokio的，这里必须用runtime配套使用，不能再用标准库的executor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-select">3. select</h2>
<ol>
<li>异步执行future，只要有一个future执行完，就会返回执行结果，</li>
<li>需要用select接收执行结果并做进一步处理</li>
<li>select中使用的Future必须实现Unpin trait和FusedFuture trait
<ul>
<li>必须实现unpin的原因是，select中使用的future不是按值获取的，而是按照可变引用获取的，也就是没有获取future的所有权，所以在调用select后，未完成的futrue可以继续使用，如下 代码，a_fut是引用，因此每次select!都能获取到指向的数据，进而继续操作</li>
</ul>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">select!</span> &#123;</span><br><span class="line">    a = a_fut =&gt; total += a,</span><br><span class="line">    b = b_fut =&gt; total += b,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>必须实现FusedFuture的原因，select完成后不会再轮询future，因此需要实现FusedFuture来跟踪future是否完成</li>
<li>同样的，对应到stream上，会有一个FusedStream trait’</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> futures::&#123;</span><br><span class="line">    stream::&#123;Stream, StreamExt, FusedStream&#125;,</span><br><span class="line">    select,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">add_two_streams</span>(</span><br><span class="line">    <span class="keyword">mut</span> s1: <span class="keyword">impl</span> <span class="title class_">Stream</span>&lt;Item = <span class="type">u8</span>&gt; + FusedStream + Unpin,</span><br><span class="line">    <span class="keyword">mut</span> s2: <span class="keyword">impl</span> <span class="title class_">Stream</span>&lt;Item = <span class="type">u8</span>&gt; + FusedStream + Unpin,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">total</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">item</span> = <span class="built_in">select!</span> &#123;</span><br><span class="line">            x = s1.<span class="title function_ invoke__">next</span>() =&gt; x,</span><br><span class="line">            x = s2.<span class="title function_ invoke__">next</span>() =&gt; x,</span><br><span class="line">            complete =&gt; <span class="keyword">break</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(next_num) = item &#123;</span><br><span class="line">            total += next_num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>Fuse::terminated()允许构建一个已经终止的空的Future；</li>
<li>当需要同时运行同一Future的多个副本时，可以使用FuturesUnordered类型</li>
</ol>
<h3 id="3-1-基本使用">3.1 基本使用</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> futures::&#123;select,future::FutureExt,pin_mut&#125;;</span><br><span class="line"><span class="keyword">use</span> tokio::runtime::Runtime;</span><br><span class="line"><span class="keyword">use</span> std::io::<span class="type">Result</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">func1</span>()<span class="punctuation">-&gt;</span><span class="type">Result</span>&lt;()&gt;&#123;</span><br><span class="line">    tokio::time::<span class="title function_ invoke__">delay_for</span>(tokio::time::Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>)).<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;func1 finished!&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">func2</span>()<span class="punctuation">-&gt;</span><span class="type">Result</span>&lt;()&gt;&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;func2 finished!&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">async_main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f1</span> = <span class="title function_ invoke__">func1</span>().<span class="title function_ invoke__">fuse</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f2</span> = <span class="title function_ invoke__">func2</span>().<span class="title function_ invoke__">fuse</span>();</span><br><span class="line">    pin_mut!(f1,f2);</span><br><span class="line">    <span class="built_in">select!</span>&#123;</span><br><span class="line">         </span><br><span class="line">        _ = f1 =&gt; <span class="built_in">println!</span>(<span class="string">&quot;func1 finished+++++++++&quot;</span>),</span><br><span class="line">        _ = f2 =&gt; <span class="built_in">println!</span>(<span class="string">&quot;func2 finished+++++++++&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">runtime</span>= Runtime::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    runtime.<span class="title function_ invoke__">block_on</span>(<span class="title function_ invoke__">async_main</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-select中default-complete的使用">3.1 select中default、complete的使用</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> futures::&#123;future, select, executor&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">count</span>() &#123;</span><br><span class="line">    <span class="comment">//快速创建两个future</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a_fut</span> = future::<span class="title function_ invoke__">ready</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b_fut</span> = future::<span class="title function_ invoke__">ready</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">total</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">select!</span> &#123;</span><br><span class="line">            <span class="comment">//表示a或者b分支就绪</span></span><br><span class="line">            a = a_fut =&gt; total += a,</span><br><span class="line">            b = b_fut =&gt; total += b,</span><br><span class="line">            <span class="comment">//表示所有分支全部就绪，并且不会再取得进展的情况</span></span><br><span class="line">            complete =&gt; <span class="keyword">break</span>,</span><br><span class="line">            <span class="comment">//若极端情况，默认处理方式，这里表示没有分支完成</span></span><br><span class="line">            default =&gt; <span class="built_in">unreachable!</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(total, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    executor::<span class="title function_ invoke__">block_on</span>(<span class="title function_ invoke__">count</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust异步编程</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust异步编程(3)-async、Pin、Stream原理</title>
    <url>/articles/29ccf340/</url>
    <content><![CDATA[<p>async、Pin、Stream原理</p>
<span id="more"></span> 
<h2 id="1-async和pin结合代码讲解原理">1. async和Pin结合代码讲解原理</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> futures::executor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">async_function1</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;async function1 ++++ !&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">async_function2</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;async function2 ++++ !&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">async_main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f1</span> = <span class="title function_ invoke__">async_function1</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f2</span> = <span class="title function_ invoke__">async_function2</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重点关注这里---------</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        f1.<span class="keyword">await</span>;</span><br><span class="line">        f2.<span class="keyword">await</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//---------------------</span></span><br><span class="line">    f.<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////分析编译器展开的过程(先后等f1和f2执行完毕，才开始f3):</span></span><br><span class="line"><span class="comment">//// (1)创建一个匿名结构体</span></span><br><span class="line"><span class="comment">//// （2）为结构体定义了对应的状态</span></span><br><span class="line"><span class="comment">//// （3）实现Future trait</span></span><br><span class="line"><span class="comment">//struct AsyncFuture &#123;</span></span><br><span class="line"><span class="comment">//    fut_one: FutFunction1,</span></span><br><span class="line"><span class="comment">//    fut_two: FutFunction2,</span></span><br><span class="line"><span class="comment">//    state: State,</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//enum State &#123;</span></span><br><span class="line"><span class="comment">//    AwaitFut1,</span></span><br><span class="line"><span class="comment">//    AwaitFut2,</span></span><br><span class="line"><span class="comment">//    Done,</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//impl Future for AsyncFuture &#123;</span></span><br><span class="line"><span class="comment">//    type Output = ();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    fn poll(mut self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;&#x27;_&gt;) -&gt; Poll&lt;()&gt; &#123;</span></span><br><span class="line"><span class="comment">//        loop &#123;</span></span><br><span class="line"><span class="comment">//            match self.state &#123;</span></span><br><span class="line"><span class="comment">//                State::AwaitFut1 =&gt; match self.fut_one.poll(...) &#123;</span></span><br><span class="line"><span class="comment">//                    Poll::Ready(()) =&gt; self.state = State::AwaitFut2,</span></span><br><span class="line"><span class="comment">//                    Poll::Pending =&gt; return Poll::Pending,</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//                State::AwaitFut2 =&gt; match self.fut_two.poll(...) &#123;</span></span><br><span class="line"><span class="comment">//                    Poll::Ready(()) =&gt; self.state = State::Done,</span></span><br><span class="line"><span class="comment">//                    Poll::Pending =&gt; return Poll::Pending,</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//                State::Done =&gt; return Poll::Ready(());</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    executor::<span class="title function_ invoke__">block_on</span>(<span class="title function_ invoke__">async_main</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 分析pin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">async_put_data_to_buf</span>(<span class="keyword">mut</span> buf: &amp;[<span class="type">u8</span>]) &#123;</span><br><span class="line">    <span class="comment">//to do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">async_main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = [<span class="number">0</span>: <span class="number">128</span>];</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">async_put</span> = <span class="title function_ invoke__">async_put_data_to_buf</span>(&amp;<span class="keyword">mut</span> x);</span><br><span class="line">        async_put.<span class="keyword">await</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////编译器展开</span></span><br><span class="line"><span class="comment">//struct AsyncFuture &#123;</span></span><br><span class="line"><span class="comment">//    x: [u8: 128],</span></span><br><span class="line"><span class="comment">//    async_put: PutIntoBuf&lt;&#x27;what_lifetime&gt;,</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//struct PutIntoBuf &#123;</span></span><br><span class="line"><span class="comment">//    buf: &amp;&#x27;a mut[u8],</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">////如果AsyncFuture发生移动，那么x和async_put都发生移动，</span></span><br><span class="line"><span class="comment">//// 但是async_put.buf还是指向移动之前的x，显然不是我们期望的</span></span><br><span class="line"><span class="comment">//// 我们期望的是async_put.buf指向移动之后的x</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//// Pin类型包着指针类型，保证指针类型背后的值不被移动</span></span><br><span class="line"><span class="comment">//// Pin&lt;T&gt;</span></span><br><span class="line"><span class="comment">//// 大多数类型都不存移动的问题，这些类型实现UnPin trait，u8</span></span><br><span class="line"><span class="comment">//// let f = Pin&lt;AsyncFuture&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//let f = async &#123;&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//fn my_function&lt;T&gt;(T: impl UnPin)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//let fut = Box::pin(f);</span></span><br><span class="line"><span class="comment">//pin_mut!(fut);</span></span><br><span class="line"><span class="comment">//my_function(fut);</span></span><br></pre></td></tr></table></figure>
<h2 id="2-stream原理">2. Stream原理</h2>
<p>Stream和Future类似，但是Future对应的是一个item的状态变化，而Stream则是类似于iterator，在结束之前能够得到多个值。或者我们可以简单的理解为，Stream是由一系列的Future组成，我们可以从Stream读取各个Future的结果，直到Stream结束。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Stream</span>&#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll_next</span>(<span class="keyword">self</span>:Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;,lw:&amp;LocalWaker )<span class="punctuation">-&gt;</span> Poll&lt;<span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中,poll_next函数有三种可能的返回值，分别如下：</p>
<ul>
<li>Poll::Pending 说明下一个值还没有就绪，仍然需要等待</li>
<li>Poll::Ready(Some(val))已经就绪，成功返回一个值，程序可以通过调用poll_next再获取下一个值</li>
<li>Poll::Ready(None)表示Stream已经结束，不应再调用poll_next。</li>
</ul>
<img src="/articles/29ccf340/1.png" class="" title="Stream原理">
<h3 id="2-1-迭代">2.1 迭代</h3>
<p>和同步的Iterator类似，Stream可以迭代处理其中的值，如使用map，filter，fold，try_map，try_filter，和 try_fold等，但Stream不支持使用for，而while let和next/try_next则是允许的。<br>
如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">sum_with_next</span>(<span class="keyword">mut</span> stream:Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">dyn</span> Stream&lt;Item=<span class="type">i32</span>&gt;&gt;)<span class="punctuation">-&gt;</span><span class="type">i32</span>&#123;</span><br><span class="line">    <span class="keyword">use</span> futures::stream::StreamExt; <span class="comment">//for next</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">sum</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(item)=stream.<span class="title function_ invoke__">next</span>().<span class="keyword">await</span>&#123;</span><br><span class="line">        sum += item;</span><br><span class="line">    &#125;</span><br><span class="line">    sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">sum_with_try_next</span>(<span class="keyword">mut</span> stream:Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">dyn</span> Stream&lt;Item = <span class="type">Result</span>&lt;<span class="type">i32</span>, io::Error&gt;&gt;&gt;)<span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>,io::Error&gt;&#123;</span><br><span class="line">    <span class="keyword">use</span> futures::stream::TryStreamExt; </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">sum</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(item) = stream.<span class="title function_ invoke__">try_next</span>().<span class="keyword">await</span>?&#123;</span><br><span class="line">        sum += item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-并发">2.2 并发</h3>
<p>上面的使用的迭代处理，如果要并发的处理流，则应该使用for_each_concurrent和try_for_each_concurrent，如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">jump_around</span>(<span class="keyword">mut</span> stream:Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">dyn</span> Stream&lt;Item = <span class="type">Result</span>&lt;<span class="type">u8</span>,io::Error&gt;&gt;&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(),io::Error&gt;&#123;</span><br><span class="line">    <span class="keyword">use</span> futures::stream::TryStreamExt;</span><br><span class="line">    <span class="keyword">const</span> MAX_CONCURRENT_JUMPERS: <span class="type">usize</span> = <span class="number">100</span>;</span><br><span class="line">    stream.<span class="title function_ invoke__">try_for_eacn_concurrent</span>(MAX_CONCURRENT_JUMPERS,|num| <span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">jump_n_times</span>(num).<span class="keyword">await</span>?;</span><br><span class="line">        <span class="title function_ invoke__">report_n_jumps</span>(num).<span class="keyword">await</span>?;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://rust-lang.github.io/async-book/">Rust 异步编程</a></p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust异步编程</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust异步编程(1)-async、await、future、move</title>
    <url>/articles/1836fbc0/</url>
    <content><![CDATA[<p>async、await、future、move</p>
<span id="more"></span> 
<h2 id="1-概述">1. 概述</h2>
<ol>
<li>async/.await是Rust编写异步的内置工具</li>
<li>async将一个代码块转化为实现了future特征的状态机
<ul>
<li>状态机四要素：状态、动作、事件、跳转</li>
</ul>
</li>
<li>future作用：在同步方法中调用阻塞函数(async转化的函数)会阻塞整个线程，但阻塞的future会让出线程控制权，允许其它future运行。
<ol>
<li>通俗说：当有多个任务进入同一个阻塞函数，转化为多个future，每个future执行各自的任务，如果当前任务被阻塞（时间片到期等原因），则切换成另一个future来执行任务。</li>
<li>就是说，多个任务在同一个线程下，高速切换来执行</li>
</ol>
</li>
<li>定义的async方法调用的时候不会自己执行，必须要通过executor来执行</li>
<li><code>async</code>关键词，目前只支持在方法和代码块上使用，不支持闭包(不稳定版本支持，好几年了)</li>
</ol>
<h2 id="2-async和executor简单案例">2. async和executor简单案例</h2>
<p>依赖：<br>
futures = “0.3.4”</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> futures::executor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">hello</span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该hello等价于：</span></span><br><span class="line"><span class="comment">//==&gt;</span></span><br><span class="line"><span class="comment">//fn hello1() -&gt; impl Future&lt;Output=()&gt; &#123;</span></span><br><span class="line"><span class="comment">//    async &#123;</span></span><br><span class="line"><span class="comment">//        println!(&quot;hello&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span>= <span class="title function_ invoke__">hello</span>();</span><br><span class="line">    executor::<span class="title function_ invoke__">block_on</span>(f);  <span class="comment">//阻塞，如果不使用executor，hello方法不会被执行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于executor的block_on，阻塞了线程，my_functiion方法必须等待</span></span><br><span class="line">    <span class="title function_ invoke__">my_function</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">my_function</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;my function!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-await案例">3. await案例</h2>
<p>await用于阻塞当前future</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> futures::&#123;<span class="keyword">self</span>,executor&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread::sleep;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">learn_song</span>()&#123;</span><br><span class="line">    <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">5</span>));  <span class="comment">//这个阻塞了整个线程，非async的</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;learn song&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">sing_song</span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;sing song&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">dance</span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;dance&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">œ</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">learn_and_sing_song</span>()&#123;</span><br><span class="line">    <span class="title function_ invoke__">learn_song</span>().<span class="keyword">await</span>;  <span class="comment">//await阻塞当前执行，确保先后顺序，此处应该是future的阻塞</span></span><br><span class="line">    <span class="title function_ invoke__">sing_song</span>().<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">async_main</span>()&#123;</span><br><span class="line">    <span class="comment">//f1和f2并行执行</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f1</span> = <span class="title function_ invoke__">learn_and_sing_song</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f2</span> = <span class="title function_ invoke__">dance</span>();</span><br><span class="line">    futures::join!(f1,f2); <span class="comment">//表示f1和f2可以并发执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    executor::<span class="title function_ invoke__">block_on</span>(<span class="title function_ invoke__">async_main</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-async生命周期">4. async生命周期</h2>
<p>为确保方法传入到future的变量生命周期和async一样，可以在变量外面包一层async</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> futures::executor;</span><br><span class="line"><span class="keyword">use</span> std::future::Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">foo</span>(x: &amp;<span class="type">u8</span>) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    *x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的foo等价于该方法</span></span><br><span class="line"><span class="comment">/*fn foo_expand(x: &amp;&#x27;a u8) -&gt; impl Future&lt;Output=u8&gt; + &#x27;a &#123;</span></span><br><span class="line"><span class="comment">    async &#123;</span></span><br><span class="line"><span class="comment">        *x</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//由于future挂起，会导致x生命周期结束，该方法无法执行</span></span><br><span class="line"><span class="comment">fn bad() -&gt; impl Future&lt;Output=u8&gt; &#123;</span></span><br><span class="line"><span class="comment">    let x = 5;</span></span><br><span class="line"><span class="comment">    foo_expand(&amp;x)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//将x包在async中</span></span><br><span class="line"><span class="comment">fn good() -&gt; impl Future&lt;Output=u8&gt; &#123;</span></span><br><span class="line"><span class="comment">    async &#123;</span></span><br><span class="line"><span class="comment">        let x = 5;</span></span><br><span class="line"><span class="comment">        foo_expand(&amp;x).await</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="title function_ invoke__">foo</span>(&amp;x);</span><br><span class="line">    executor::<span class="title function_ invoke__">block_on</span>(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-move-重点">5. move（重点）</h2>
<p>在async中的变量，要确保能在不同线程之间传输</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> futures::executor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">move_block</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_string</span> = <span class="string">&quot;my_string&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">async</span> <span class="keyword">move</span>&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;String:&#123;&#125;&quot;</span>,my_string);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//已经被移动到async里了，外面不能再调用my_string</span></span><br><span class="line">    <span class="comment">// println!(&quot;after move,String:&#123;&#125;&quot;,my_string);</span></span><br><span class="line">    f.<span class="keyword">await</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    executor::<span class="title function_ invoke__">block_on</span>(<span class="title function_ invoke__">move_block</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="6-官方future-重点">6. 官方future（重点）</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// //通过Pin可以创建不可移动的Future。不可移动的对象可以在它们的字段之间存储指针(就是说，堆空间移动的时候，栈指针也会跟着移动)，例如：</span></span><br><span class="line"><span class="comment">// struct MyFut &#123;</span></span><br><span class="line"><span class="comment">//     a: i32,</span></span><br><span class="line"><span class="comment">//     ptr: *const i32,</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pub trait Future &#123;</span></span><br><span class="line"><span class="comment">//     type Output;</span></span><br><span class="line"><span class="comment">//     fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;&#x27;_&gt;) -&gt; Poll&lt;Self::Output&gt;;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="7-简单实现异步执行原理-future">7. 简单实现异步执行原理(future)</h2>
<p>sleeper是一个future；reactor检测状态，然后通过wake通知future是否可执行<br>
future中的poll是一个检测方法，用于接收wake提供的信息，并判读是否能够执行该future</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">SimpleFuture</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">    <span class="comment">//fn poll(&amp;mut self, wake: fn()) -&gt; Poll&lt;Self::Output&gt;;</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, wake: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> Poll&lt;<span class="keyword">Self</span>::Output&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Poll</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ready</span>(T),</span><br><span class="line">    Pending,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MySleeper</span> &#123;</span><br><span class="line">    polls: <span class="type">u64</span>,</span><br><span class="line">    wake: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> FINISHED: <span class="type">bool</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MySleeper</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(wake:<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        MySleeper &#123;</span><br><span class="line">            polls: <span class="number">0</span>,</span><br><span class="line">            wake,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">SimpleFuture</span> <span class="keyword">for</span> <span class="title class_">MySleeper</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = ();</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, wake: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> Poll&lt;<span class="keyword">Self</span>::Output&gt; &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> FINISHED &#123;</span><br><span class="line">                Poll::<span class="title function_ invoke__">Ready</span>(())</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.wake = wake;</span><br><span class="line">                <span class="keyword">self</span>.polls += <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;polls=&#123;&#125;&quot;</span>, <span class="keyword">self</span>.polls);</span><br><span class="line">                Poll::Pending</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyReactor</span> &#123;</span><br><span class="line">    wake: <span class="type">u32</span>,</span><br><span class="line">    handle: <span class="type">Option</span>&lt;thread::JoinHandle&lt;()&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MyReactor</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        MyReactor &#123;</span><br><span class="line">            wake: <span class="number">0</span>,</span><br><span class="line">            handle: <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add_wake</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>,wake:<span class="type">u32</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.wake = wake;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">check_status</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.handle.<span class="title function_ invoke__">is_none</span>()&#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">_wake</span> = <span class="keyword">self</span>.wake;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| <span class="keyword">loop</span>&#123;</span><br><span class="line">               thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">5</span>));</span><br><span class="line">                <span class="keyword">unsafe</span> &#123; <span class="comment">//模拟future就绪，调用wake</span></span><br><span class="line">                    FINISHED = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">self</span>.handle = <span class="title function_ invoke__">Some</span>(handle);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyExecutor</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MyExecutor</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">block_on</span>&lt;F:SimpleFuture&gt;(<span class="keyword">mut</span> myfuture:F,wake:<span class="type">u32</span>)&#123;</span><br><span class="line">        <span class="keyword">loop</span>&#123;</span><br><span class="line">            <span class="keyword">match</span> myfuture.<span class="title function_ invoke__">poll</span>(wake)&#123;</span><br><span class="line">                Poll::<span class="title function_ invoke__">Ready</span>(_)=&gt;&#123;</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;my future is ok!&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;,</span><br><span class="line">                Poll::Pending=&gt;&#123;</span><br><span class="line">                    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                        <span class="keyword">while</span> !FINISHED&#123;</span><br><span class="line">                            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">reactor</span> = MyReactor::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sleeper</span> = MySleeper::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">wake</span> = sleeper.wake;</span><br><span class="line">    reactor.<span class="title function_ invoke__">add_wake</span>(wake);</span><br><span class="line">    reactor.<span class="title function_ invoke__">check_status</span>();</span><br><span class="line">    MyExecutor::<span class="title function_ invoke__">block_on</span>(sleeper,wake);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://rust-lang.github.io/async-book/">Rust 异步编程</a></p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust异步编程</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust异步编程(1)-async和await</title>
    <url>/articles/37aa4bf6/</url>
    <content><![CDATA[<p>async和await</p>
<span id="more"></span> 
<h2 id="1-为什么异步编程">1. 为什么异步编程</h2>
<p>使用少量线程，减少开销，达到高效异步。也就是<code>async</code>的使用<br>
如下案例，一个线程，达到了多线程异步的效果</p>
<h2 id="2-原理">2. 原理</h2>
<p>reactor通过通知executor，让executor选择性的执行任务(类似future)</p>
<img src="/articles/37aa4bf6/1.png" class="" title="异步原理">
<h3 id="3-客户端">3. 客户端</h3>
<p>使用了关键词<code>async</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::net::TcpStream;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123; prelude::*, BufReader, Write &#125;;</span><br><span class="line"><span class="keyword">use</span> std::<span class="type">str</span>;</span><br><span class="line"><span class="keyword">use</span> futures::join;</span><br><span class="line"><span class="keyword">use</span> futures::executor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">use_server</span>(server: &amp;<span class="type">str</span>, port: <span class="type">u16</span>, content: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> std::io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stream</span> = TcpStream::<span class="title function_ invoke__">connect</span>((server, port))?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_</span> = stream.<span class="title function_ invoke__">write</span>(content.<span class="title function_ invoke__">as_bytes</span>())?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">reader</span> = BufReader::<span class="title function_ invoke__">new</span>(&amp;stream);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buffer</span>: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    reader.<span class="title function_ invoke__">read_until</span>(<span class="string">b&#x27;\n&#x27;</span>, &amp;<span class="keyword">mut</span> buffer)?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;recv from server: &#123;&#125; &quot;</span>, <span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(&amp;buffer).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">async_use_server</span>(server: &amp;<span class="type">str</span>, port: <span class="type">u16</span>, content: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">use_server</span>(server, port, content).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">use_all_server</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f1</span> = <span class="title function_ invoke__">async_use_server</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>, <span class="string">&quot;use server1 download 127.0.0.1:8080&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f2</span> = <span class="title function_ invoke__">async_use_server</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8081</span>, <span class="string">&quot;use server2 download 127.0.0.1:8081&quot;</span>);</span><br><span class="line">    join!(f1, f2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> std::io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="title function_ invoke__">use_all_server</span>();</span><br><span class="line">    executor::<span class="title function_ invoke__">block_on</span>(f);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-服务器端">4. 服务器端</h3>
<p>总共需要启动两个服务器端，代码基本一样，只是端口号和<code>wait_time</code>不一样</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::net::&#123;TcpListener, TcpStream&#125;;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;Read, Write&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_client</span>(<span class="keyword">mut</span> stream: TcpStream, wait_time: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> std::io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = [<span class="number">0</span>; <span class="number">512</span>];</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">bytes_read</span> = stream.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buf)?;</span><br><span class="line">        <span class="keyword">if</span> bytes_read == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(());</span><br><span class="line">        &#125;</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(time::Duration::<span class="title function_ invoke__">from_secs</span>(wait_time));</span><br><span class="line">        stream.<span class="title function_ invoke__">write</span>(&amp;buf[..bytes_read])?;</span><br><span class="line">        stream.<span class="title function_ invoke__">write</span>(&amp;(<span class="string">&quot;\n&quot;</span>.<span class="title function_ invoke__">as_bytes</span>()))?;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> std::io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">listener</span> = TcpListener::<span class="title function_ invoke__">bind</span>(<span class="string">&quot;127.0.0.1:8080&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">stream</span> <span class="keyword">in</span> listener.<span class="title function_ invoke__">incoming</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">handle_client</span>(stream?, <span class="number">3</span>)?;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://rust-lang.github.io/async-book/">Rust 异步编程</a></p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust异步编程</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust网络编程(7)-ftp和tftp</title>
    <url>/articles/8c644148/</url>
    <content><![CDATA[<p>ftp和tftp 非重点，仅作为手册记录，方便以后需要时查询</p>
<span id="more"></span>
<h2 id="1-ftp">1. ftp</h2>
<ol>
<li>FTP（File Transfer Protocol，文件传输协议）是 TCP/IP 协议组中的协议之一。其主要作用是在服务器和客户端之间实现文件的传输和共享。FTP协议运行在TCP连接上，保证了文件传输的可靠性。</li>
<li>FTP使用了两个并行的tcp来传输文件：一个是控制连接，使用21号端口；一个是数据连接，使用20号端口，控制连接用于在两个主机之间传输控制信息，如口令，用户标识，存放、获取文件等命令。数据连接用于实际发送一个文件，发送完文件之后数据连接会关闭。</li>
<li>FTP主要有主动模式和被动模式两种。主动模式是FTP客户端告诉服务端用哪个端口作为数据端口，然后让服务端来连接自己。被动模式则是由客户端发起控制连接请求和数据连接请求。</li>
</ol>
<p>自行搭建ftp服务器端，这里提供客户端代码案例<br>
依赖：<br>
ftp = “3.0.1”<br>
代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::<span class="type">str</span>;</span><br><span class="line"><span class="keyword">use</span> std::io::Cursor;</span><br><span class="line"><span class="keyword">use</span> ftp::FtpStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ftp_stream</span> = FtpStream::<span class="title function_ invoke__">connect</span>(<span class="string">&quot;127.0.0.1:21&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_</span> = ftp_stream.<span class="title function_ invoke__">login</span>(<span class="string">&quot;tt&quot;</span>, <span class="string">&quot;1&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Current directory: &#123;&#125;&quot;</span>, ftp_stream.<span class="title function_ invoke__">pwd</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">remote_file</span> = ftp_stream.<span class="title function_ invoke__">simple_retr</span>(<span class="string">&quot;./hello&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Contents: \n&#123;&#125;\n&quot;</span>, <span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(&amp;remote_file.<span class="title function_ invoke__">into_inner</span>()).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">reader</span> = Cursor::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Hello from client&quot;</span>.<span class="title function_ invoke__">as_bytes</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_</span> = ftp_stream.<span class="title function_ invoke__">put</span>(<span class="string">&quot;upload&quot;</span>, &amp;<span class="keyword">mut</span> reader);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_</span> = ftp_stream.<span class="title function_ invoke__">quit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-tftp">2. tftp</h2>
<p>TFTP（Trivial File Transfer Protocol,简单文件传输协议）是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。TFTP基于UDP，对应端口号为69.</p>
<p>自行搭建服务器端</p>
<p>依赖：<br>
tftp_server = “0.0.3”</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> tftp_server::server::TftpServerBuilder;</span><br><span class="line"><span class="keyword">use</span> std::net::&#123;IpAddr, Ipv4Addr, SocketAddr&#125;;</span><br><span class="line"><span class="comment">//use std::str::FromStr;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// let addr = format!(&quot;0.0.0.0.&#123;&#125;&quot;, 69);</span></span><br><span class="line">    <span class="comment">// let socket_addr = SocketAddr::from_str(addr.as_str()).unwrap();</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">socket_addr</span> = SocketAddr::<span class="title function_ invoke__">new</span>(IpAddr::<span class="title function_ invoke__">V4</span>(Ipv4Addr::<span class="title function_ invoke__">new</span>(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)), <span class="number">69</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">builder</span> = TftpServerBuilder::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">addr</span>(socket_addr);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">server</span> = builder.<span class="title function_ invoke__">build</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    server.<span class="title function_ invoke__">run</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;some error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust网络编程</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust网络编程(6)-smtp之lettre库</title>
    <url>/articles/67726876/</url>
    <content><![CDATA[<p>邮件协议smtp，使用lettre库。非重点，仅作为手册记录。</p>
<span id="more"></span> 
<h2 id="概述">概述</h2>
<ol>
<li>SMTP工作在两种情况下，一种是电子邮件从客机传到服务器，另一种是从某个服务器传输到另一个服务器</li>
<li>SMTP是请求/响应协议，命令和响应都是基于ASCII文本，并且以CR和LF富结尾，响应一个表示返回状态的三位数字代码</li>
<li>SMTP是基于TCP协议的，并且在25号端口监听链接请求</li>
</ol>
<h2 id="使用">使用</h2>
<p>依赖：<br>
lettre = “0.9.3”<br>
lettre_email = “0.9.3”</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> lettre::smtp::authentication::Credentials;</span><br><span class="line"><span class="keyword">use</span> lettre::&#123;SmtpClient, Transport&#125;;</span><br><span class="line"><span class="keyword">use</span> lettre_email::&#123;EmailBuilder, Mailbox&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">email</span> = EmailBuilder::<span class="title function_ invoke__">new</span>()</span><br><span class="line">        .<span class="title function_ invoke__">from</span>(Mailbox::<span class="title function_ invoke__">new</span>(<span class="string">&quot;发送者的邮箱地址&quot;</span>.<span class="title function_ invoke__">to_string</span>())) </span><br><span class="line">        <span class="comment">//.from(Mailbox::new(&quot;xiaoming@163.com&quot;.to_string())) //发送者：xiaoming@163.com</span></span><br><span class="line">        .<span class="title function_ invoke__">to</span>(Mailbox::<span class="title function_ invoke__">new</span>(<span class="string">&quot;接收者邮箱地址&quot;</span>.<span class="title function_ invoke__">to_string</span>()))</span><br><span class="line">        <span class="comment">//.to(Mailbox::new(&quot;xiaohong@126.com&quot;.to_string())) //接收者：xiaohong@126.com</span></span><br><span class="line">        .<span class="title function_ invoke__">subject</span>(<span class="string">&quot;Test&quot;</span>) <span class="comment">//邮件标题</span></span><br><span class="line">        .<span class="title function_ invoke__">body</span>(<span class="string">&quot;This is a test email!&quot;</span>) <span class="comment">//邮件内容</span></span><br><span class="line">        .<span class="title function_ invoke__">build</span>()</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for example: xiaoming@163.com, password: 123456</span></span><br><span class="line">    <span class="comment">//let creds = Credentials::new(&quot;xiaoming&quot;.to_string(), &quot;123456&quot;.to_string());</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">creds</span> = Credentials::<span class="title function_ invoke__">new</span>(<span class="string">&quot;你的邮箱用户名&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;你的邮箱密码&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如163的邮箱就是smtp.163.com, 126的邮箱就是smtp.126.com</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">mailer</span> = SmtpClient::<span class="title function_ invoke__">new_simple</span>(<span class="string">&quot;邮箱服务器地址&quot;</span>) </span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">        .<span class="title function_ invoke__">credentials</span>(creds)</span><br><span class="line">        .<span class="title function_ invoke__">transport</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = mailer.<span class="title function_ invoke__">send</span>(email.<span class="title function_ invoke__">into</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> result.<span class="title function_ invoke__">is_ok</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Email sent&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Could not send email: &#123;:?&#125;&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(result.<span class="title function_ invoke__">is_ok</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust网络编程</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust网络编程(5)-grpc</title>
    <url>/articles/12c441a9/</url>
    <content><![CDATA[<p>grpc应用，本文非当前重点，仅粗略过了一遍</p>
<span id="more"></span> 
<h2 id="概述">概述</h2>
<ol>
<li>gRPC默认使用protocol buffers序列化机制，grpc和protobuf不在此处讲解</li>
<li>grpc允许定义4类服务方法：
<ol>
<li>单向RPC，即客户端发送一个请求给服务器端，从服务器端获取一个应答，就像一次普通的函数调用</li>
<li>服务器端流式rpc，即客户端发送一个请求给服务器端，可以获取一个数据流用来读取一系列服务器端发来的消息，客户端从返回的数据流里一直读取到没有更多消息为止</li>
<li>客户端流式RPC,即客户端用提供的一个数据流写入并发送一系列消息给服务器端，一旦客户端完成消息写入，就等待服务器端读取这些消息并返回应答。</li>
<li>双向流式RPC，即两边都可以分别通过一个读写数据流来发送一系列消息。这两个数据流操作是相互独立的，所以客户端和服务器端能按其希望的任意顺序读写，例如：服务器端可以在写应答前等待所有的客户端消息，或者它可以先读一个消息再写一个消息，或者是读写相结合的其它方式。每个数据流里消息的顺序会被保持。</li>
</ol>
</li>
</ol>
<h2 id="1-依赖">1. 依赖</h2>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">protobuf</span> = <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="attr">grpc</span> = <span class="string">&quot;0.7.1&quot;</span></span><br><span class="line"><span class="attr">grpc-protobuf</span> = <span class="string">&quot;0.7.1&quot;</span></span><br><span class="line"><span class="attr">futures</span> = <span class="string">&quot;0.3.*&quot;</span></span><br><span class="line"><span class="attr">tls-api</span> = <span class="string">&quot;0.3.*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[build-dependencies]</span></span><br><span class="line"><span class="attr">protoc-rust-grpc</span> = <span class="string">&quot;0.7.1&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-foobar-proto">2. foobar.proto</h2>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> foobar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">service </span><span class="title class_">FooBarService</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">rpc</span> record_cab_location(CabLocationRequest) <span class="keyword">returns</span> (CabLocationResponse)</span>;</span><br><span class="line">   <span class="function"><span class="keyword">rpc</span> get_cabs(GetCabRequest) <span class="keyword">returns</span> (GetCabResponse)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">CabLocationRequest</span> &#123;</span><br><span class="line">   <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">   Location location = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">CabLocationResponse</span> &#123;</span><br><span class="line">   <span class="type">bool</span> accepted = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetCabRequest</span> &#123;</span><br><span class="line">   Location location = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetCabResponse</span> &#123;</span><br><span class="line">   <span class="keyword">repeated</span> Cab cabs = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Cab</span> &#123;</span><br><span class="line">   <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">   Location location = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Location</span> &#123;</span><br><span class="line">   <span class="type">float</span> latitude = <span class="number">1</span>;</span><br><span class="line">   <span class="type">float</span> longitude = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-build-rs">3. <a href="http://build.rs">build.rs</a></h2>
<p>将proto文件生成对应的rs文件</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> protoc_rust_grpc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   protoc_rust_grpc::Codegen::<span class="title function_ invoke__">new</span>()</span><br><span class="line">           .<span class="title function_ invoke__">out_dir</span>(<span class="string">&quot;src&quot;</span>)</span><br><span class="line">           .<span class="title function_ invoke__">input</span>(<span class="string">&quot;foobar.proto&quot;</span>)</span><br><span class="line">           .<span class="title function_ invoke__">rust_protobuf</span>(<span class="literal">true</span>)</span><br><span class="line">           .<span class="title function_ invoke__">run</span>()</span><br><span class="line">           .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;protoc-rust-grpc&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-lib-rs">4. <a href="http://lib.rs">lib.rs</a></h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// extern crate protobuf;</span></span><br><span class="line"><span class="comment">// extern crate grpc;</span></span><br><span class="line"><span class="comment">// extern crate tls_api;</span></span><br><span class="line"><span class="comment">// extern crate grpc_protobuf;</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> foobar;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> foobar_grpc;</span><br></pre></td></tr></table></figure>
<h2 id="5-bin-server">5. bin/server</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> use_grpc::foobar_grpc::*;</span><br><span class="line"><span class="keyword">use</span> use_grpc::foobar::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FooBarServer</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FooBarService</span> <span class="keyword">for</span> <span class="title class_">FooBarServer</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">record_cab_location</span>(&amp;<span class="keyword">self</span>,</span><br><span class="line">                           _o: grpc::ServerHandlerContext,</span><br><span class="line">                           req: grpc::ServerRequestSingle&lt;CabLocationRequest&gt;,</span><br><span class="line">                           resp: grpc::ServerResponseUnarySink&lt;CabLocationResponse&gt;)</span><br><span class="line">                           <span class="punctuation">-&gt;</span> grpc::<span class="type">Result</span>&lt;()&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">r</span> = CabLocationResponse::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Record cab &#123;&#125; at &#123;&#125;, &#123;&#125;&quot;</span>,</span><br><span class="line">                 req.message.<span class="title function_ invoke__">get_name</span>(),</span><br><span class="line">                 req.message.<span class="title function_ invoke__">get_location</span>().latitude,</span><br><span class="line">                 req.message.<span class="title function_ invoke__">get_location</span>().longitude);</span><br><span class="line"></span><br><span class="line">        r.<span class="title function_ invoke__">set_accepted</span>(<span class="literal">true</span>);</span><br><span class="line">        resp.<span class="title function_ invoke__">finish</span>(r)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_cabs</span>(&amp;<span class="keyword">self</span>,</span><br><span class="line">                _o: grpc::ServerHandlerContext,</span><br><span class="line">                _req: grpc::ServerRequestSingle&lt;GetCabRequest&gt;,</span><br><span class="line">                resp: grpc::ServerResponseUnarySink&lt;GetCabResponse&gt;)</span><br><span class="line">                <span class="punctuation">-&gt;</span> grpc::<span class="type">Result</span>&lt;()&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">r</span> = GetCabResponse::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">location</span> = Location::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        location.latitude = <span class="number">40.7128</span>;</span><br><span class="line">        location.longitude = -<span class="number">74.0060</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">one</span> = Cab::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        one.<span class="title function_ invoke__">set_name</span>(<span class="string">&quot;Limo&quot;</span>.<span class="title function_ invoke__">to_owned</span>());</span><br><span class="line">        one.<span class="title function_ invoke__">set_location</span>(location.<span class="title function_ invoke__">clone</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">two</span> = Cab::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        two.<span class="title function_ invoke__">set_name</span>(<span class="string">&quot;Merc&quot;</span>.<span class="title function_ invoke__">to_owned</span>());</span><br><span class="line">        two.<span class="title function_ invoke__">set_location</span>(location.<span class="title function_ invoke__">clone</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">vec</span> = <span class="built_in">vec!</span>[one, two];</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cabs</span> = ::protobuf::RepeatedField::<span class="title function_ invoke__">from_vec</span>(vec);</span><br><span class="line"></span><br><span class="line">        r.<span class="title function_ invoke__">set_cabs</span>(cabs);</span><br><span class="line"></span><br><span class="line">        resp.<span class="title function_ invoke__">finish</span>(r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">server</span> = grpc::ServerBuilder::<span class="title function_ invoke__">new_plain</span>();</span><br><span class="line">    server.http.<span class="title function_ invoke__">set_port</span>(<span class="number">9001</span>);</span><br><span class="line">    server.<span class="title function_ invoke__">add_service</span>(FooBarServiceServer::<span class="title function_ invoke__">new_service_def</span>(FooBarServer));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_server</span> = server.<span class="title function_ invoke__">build</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Could not start server&quot;</span>);</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        thread::<span class="title function_ invoke__">park</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-bin-client">6. bin/client</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> use_grpc::foobar::*;        <span class="comment">//use_grpc为当前包的名字，如果名字不一样需要修改</span></span><br><span class="line"><span class="keyword">use</span> use_grpc::foobar_grpc::*;   <span class="comment">//use_grpc为当前包的名字，如果名字不一样需要修改</span></span><br><span class="line"><span class="keyword">use</span> futures::executor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> grpc::ClientStubExt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">client</span> =</span><br><span class="line">        FooBarServiceClient::<span class="title function_ invoke__">new_plain</span>(<span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">                                       <span class="number">9001</span>,</span><br><span class="line">                                       <span class="built_in">Default</span>::<span class="title function_ invoke__">default</span>())</span><br><span class="line">            .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">req</span> = CabLocationRequest::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    req.<span class="title function_ invoke__">set_name</span>(<span class="string">&quot;foo&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">location</span> = Location::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    location.latitude = <span class="number">40.730610</span>;</span><br><span class="line">    location.longitude = -<span class="number">73.935242</span>;</span><br><span class="line">    req.<span class="title function_ invoke__">set_location</span>(location);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">resp</span> = client</span><br><span class="line">        .<span class="title function_ invoke__">record_cab_location</span>(grpc::RequestOptions::<span class="title function_ invoke__">new</span>(), req)</span><br><span class="line">        .<span class="title function_ invoke__">join_metadata_result</span>(); <span class="comment">//future</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">resp</span> = executor::<span class="title function_ invoke__">block_on</span>(resp);</span><br><span class="line">    <span class="keyword">match</span> resp &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, e),</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>((_, r, _)) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, r),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">nearby_req</span> = GetCabRequest::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">location</span> = Location::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    location.latitude = <span class="number">40.730610</span>;</span><br><span class="line">    location.longitude = -<span class="number">73.935242</span>;</span><br><span class="line">    nearby_req.<span class="title function_ invoke__">set_location</span>(location);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">nearby_resp</span> = client</span><br><span class="line">        .<span class="title function_ invoke__">get_cabs</span>(grpc::RequestOptions::<span class="title function_ invoke__">new</span>(), nearby_req)</span><br><span class="line">        .<span class="title function_ invoke__">join_metadata_result</span>(); <span class="comment">//返回future</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">nearby_resp</span> = executor::<span class="title function_ invoke__">block_on</span>(nearby_resp);</span><br><span class="line">    <span class="keyword">match</span> nearby_resp &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, e),</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>((_, cabs, _)) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, cabs),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust网络编程</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust网络编程(4)-构建脚本</title>
    <url>/articles/db58bc7/</url>
    <content><![CDATA[<p>在实际的项目中，有些包需要编译第三方非Rust代码，例如 C库；有些包需要链接到 C库，当然这些库既可以位于系统上， 也可以从源代码构建。其它的需求则有可能是需要构建代码生成 。 在Cargo中，提供了构建脚本，来满足这些需求。</p>
<span id="more"></span> 
<h2 id="1-概述">1. 概述</h2>
<p>指定的build命令应执行的Rust文件，将在包编译其它内容之前，被编译和调用，从而具备Rust代码所依赖的构建或生成的组件。Build通常被用来：<br>
构建一个捆绑的C库；<br>
在主机系统上找到C库；<br>
生成Rust模块；<br>
为crate执行所需的某平台特定配置。</p>
<p>主要就是编译不同语言生成库，并调用</p>
<h2 id="2-基本使用">2. 基本使用</h2>
<p>从这个案例可以看出，脚本<code>build.rs</code>可以在程序运行期间，动态变更脚本内容<br>
在<code>Cargo.toml</code>中<code>[package]</code>，加入：<code>build = &quot;build.rs&quot;</code>，表示启动时会先编译执行该文件。<br>
待编译脚本<code>build.rs</code>，从它生成文件<code>hello.rs</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::Write;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">out_dir</span> = env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;OUT_DIR&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">dest_path</span> = Path::<span class="title function_ invoke__">new</span>(&amp;out_dir).<span class="title function_ invoke__">join</span>(<span class="string">&quot;hello.rs&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">create</span>(&amp;dest_path).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    f.<span class="title function_ invoke__">write_all</span>(<span class="string">b&quot;</span></span><br><span class="line"><span class="string">        fn say_hello() -&gt; &amp;&#x27;static str &#123;</span></span><br><span class="line"><span class="string">            \&quot;hello\&quot;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译并调用脚本<code>build.rs</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">include!(<span class="built_in">concat!</span>(<span class="built_in">env!</span>(<span class="string">&quot;OUT_DIR&quot;</span>), <span class="string">&quot;/hello.rs&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">say_hello</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-编译并调用c库">3. 编译并调用C库</h2>
<p><code>cargo.toml</code>中加入依赖：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">build</span> = <span class="string">&quot;build.rs&quot;</span></span><br><span class="line"><span class="section">[build-dependencies]</span></span><br><span class="line"><span class="attr">cc</span> = <span class="string">&quot;1.0&quot;</span></span><br></pre></td></tr></table></figure>
<p>src/hello.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world! \n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://build.rs">build.rs</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> cc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="comment">//将c文件编译为hello.o文件</span></span><br><span class="line">    cc::Build::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">file</span>(<span class="string">&quot;src/hello.c&quot;</span>).<span class="title function_ invoke__">compile</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://main.rs">main.rs</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> &#123; <span class="keyword">fn</span> <span class="title function_">hello</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">//调用c语言需要加上unsafe</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">hello</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust网络编程</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust网络编程(3)-ipnet、mio、pnet、dns和serde介绍</title>
    <url>/articles/c3284793/</url>
    <content><![CDATA[<p>ipnet、mio、pnet和dns介绍</p>
<span id="more"></span> 
<h2 id="1-ipnet">1. ipnet</h2>
<p>无类别域间路由<br>
说白了就是带有掩码管理Ip<br>
<code>ipnet</code>，更好的管理IP</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::net::&#123;Ipv4Addr,Ipv6Addr&#125;;</span><br><span class="line"><span class="keyword">use</span> ipnet::&#123;IpNet, Ipv4Net, Ipv6Net&#125;;</span><br><span class="line"><span class="keyword">use</span> std::<span class="type">str</span>::FromStr;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()<span class="punctuation">-&gt;</span> std::io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_v4</span> = Ipv4Net::<span class="title function_ invoke__">new</span>(Ipv4Addr::<span class="title function_ invoke__">new</span>(<span class="number">10</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>),<span class="number">24</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_v6</span> = Ipv6Net::<span class="title function_ invoke__">new</span>(Ipv6Addr::<span class="title function_ invoke__">new</span>(<span class="number">0xfd</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">24</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_v4</span> = Ipv4Net::<span class="title function_ invoke__">from_str</span>(<span class="string">&quot;10.1.1.0/24&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_v6</span> = Ipv6Net::<span class="title function_ invoke__">from_str</span>(<span class="string">&quot;fd00::/24&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_v4</span>: Ipv4Net = <span class="string">&quot;10.1.1.0/24&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_v6</span>: Ipv6Net = <span class="string">&quot;fd00::/24&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_net</span> = IpNet::<span class="title function_ invoke__">from</span>(_v4);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_net</span> = IpNet::<span class="title function_ invoke__">from_str</span>(<span class="string">&quot;10.1.1.0/24&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">net</span>: IpNet = <span class="string">&quot;10.1.1.0/24&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, hostmask = &#123;&#125;&quot;</span>,net,net.<span class="title function_ invoke__">hostmask</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, netmask = &#123;&#125;&quot;</span>,net,net.<span class="title function_ invoke__">netmask</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&quot;192.168.12.34/16&quot;</span>.parse::&lt;IpNet&gt;().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">trunc</span>(),<span class="string">&quot;192.168.0.0/16&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-mio">2. mio</h2>
<p>通俗的说，就是异步网络IO框架，可以理解为是个消息队列(类似golang中的nsq)<br>
mio是rust实现的一个轻量级的I/O库。其实现基本上就是对不同操作系统底层相关API的封装，抽象出统一的接口供上层使用。<br>
重要特性：<br>
非阻塞TCP，UDP<br>
I/O事件通知epoll,kqeue,IOCP实现<br>
运行时零分配<br>
平台可扩展<br>
引入依赖：<code>mio=&#123;version=&quot;0.7.0&quot;,features=[&quot;os-poll&quot;,&quot;tcp&quot;]&#125;</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> mio::net::&#123;TcpListener, TcpStream&#125;;</span><br><span class="line"><span class="keyword">use</span> mio::&#123;Events,Interest,Poll,Token&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SERVER: Token = <span class="title function_ invoke__">Token</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> CLIENT: Token = <span class="title function_ invoke__">Token</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span>std::io::<span class="type">Result</span>&lt;()&gt;&#123;</span><br><span class="line">    <span class="comment">//服务器端</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">poll</span> = Poll::<span class="title function_ invoke__">new</span>()?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">events</span> = Events::<span class="title function_ invoke__">with_capacity</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">addr</span> = <span class="string">&quot;127.0.0.1:8080&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">server</span> = TcpListener::<span class="title function_ invoke__">bind</span>(addr)?;</span><br><span class="line">    poll.<span class="title function_ invoke__">registry</span>().<span class="title function_ invoke__">register</span>(&amp;<span class="keyword">mut</span> server,SERVER,Interest::READABLE)?;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//客户端</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">client</span> = TcpStream::<span class="title function_ invoke__">connect</span>(addr)?;</span><br><span class="line">    poll.<span class="title function_ invoke__">registry</span>().<span class="title function_ invoke__">register</span>(&amp;<span class="keyword">mut</span> client,CLIENT,Interest::READABLE |Interest::WRITABLE)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span>&#123;</span><br><span class="line">        poll.<span class="title function_ invoke__">poll</span>(&amp;<span class="keyword">mut</span> events,<span class="literal">None</span>)?;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">event</span> <span class="keyword">in</span> events.<span class="title function_ invoke__">iter</span>()&#123;</span><br><span class="line">            <span class="keyword">match</span> event.<span class="title function_ invoke__">token</span>()&#123;</span><br><span class="line">                SERVER =&gt;&#123; </span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">connection</span> = server.<span class="title function_ invoke__">accept</span>();</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;SERVER recv a connection!&quot;</span>);</span><br><span class="line">                    <span class="title function_ invoke__">drop</span>(connection);</span><br><span class="line">                &#125;</span><br><span class="line">                CLIENT =&gt;&#123;</span><br><span class="line">                    <span class="keyword">if</span> event.<span class="title function_ invoke__">is_writable</span>()&#123;</span><br><span class="line">                        <span class="built_in">println!</span>(<span class="string">&quot;Client write&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> event.<span class="title function_ invoke__">is_readable</span>()&#123;</span><br><span class="line">                        <span class="built_in">println!</span>(<span class="string">&quot;Client read&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">                &#125;</span><br><span class="line">                _ =&gt; <span class="built_in">unreachable!</span>(),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-pnet">3 pnet</h2>
<p>为Rust提供一组跨平台的底层网络API<br>
案例：监听网卡信息（数据从本地传到哪里）<br>
以下代码执行后，需要sudo才能读取网卡信息。<br>
cargo传入参数：<code>cargo run -- en0</code>，传入网卡名称<br>
执行时，需要到debug找到二进制文件，并sudo执行：sudo ./use_pnet en0</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> pnet::datalink::Channel::Ethernet;</span><br><span class="line"><span class="keyword">use</span> pnet::datalink::&#123;<span class="keyword">self</span>, NetworkInterface&#125;;</span><br><span class="line"><span class="keyword">use</span> pnet::packet::ethernet::&#123;EthernetPacket, EtherTypes&#125;;</span><br><span class="line"><span class="keyword">use</span> pnet::packet::ip::IpNextHeaderProtocols;</span><br><span class="line"><span class="keyword">use</span> pnet::packet::ipv4::Ipv4Packet;</span><br><span class="line"><span class="keyword">use</span> pnet::packet::tcp::TcpPacket;</span><br><span class="line"><span class="keyword">use</span> pnet::packet::Packet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">//终端输入的网卡名称</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">interface_name</span> = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">nth</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取网卡列表</span></span><br><span class="line">    <span class="comment">//判断网卡列表里是否有终端输入的网卡名称</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">interfaces</span> = datalink::<span class="title function_ invoke__">interfaces</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">interface</span> = interfaces</span><br><span class="line">        .<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|iface: &amp;NetworkInterface| iface.name == interface_name)</span><br><span class="line">        .<span class="title function_ invoke__">next</span>()</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Error get interface&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,interface);</span><br><span class="line">    <span class="comment">//_tx 接收（忽略） rx 发送（该案例关注）</span></span><br><span class="line">    <span class="keyword">let</span> (_tx, <span class="keyword">mut</span> rx) = <span class="keyword">match</span> datalink::<span class="title function_ invoke__">channel</span>(&amp;interface, <span class="built_in">Default</span>::<span class="title function_ invoke__">default</span>()) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">Ethernet</span>(tx, rx)) =&gt; (tx, rx),</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Other&quot;</span>),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;error:&#123;&#125;&quot;</span>, e),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//读取从网卡发送消息</span></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> rx.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(packet) =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">packet</span> = EthernetPacket::<span class="title function_ invoke__">new</span>(packet).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                <span class="title function_ invoke__">handle_packet</span>(&amp;packet);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(e) =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Some error: &#123;&#125;&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_packet</span>(ethernet: &amp;EthernetPacket) &#123;</span><br><span class="line">    <span class="keyword">match</span> ethernet.<span class="title function_ invoke__">get_ethertype</span>() &#123;</span><br><span class="line">        EtherTypes::Ipv4 =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">header</span> = Ipv4Packet::<span class="title function_ invoke__">new</span>(ethernet.<span class="title function_ invoke__">payload</span>());</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(header) = header &#123;</span><br><span class="line">                <span class="keyword">match</span> header.<span class="title function_ invoke__">get_next_level_protocol</span>() &#123;</span><br><span class="line">                    IpNextHeaderProtocols::Tcp =&gt; &#123;</span><br><span class="line">                        <span class="keyword">let</span> <span class="variable">tcp</span> = TcpPacket::<span class="title function_ invoke__">new</span>(header.<span class="title function_ invoke__">payload</span>());</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(tcp) = tcp &#123;</span><br><span class="line">                            <span class="comment">//消息从哪块发送到哪块</span></span><br><span class="line">                            <span class="built_in">println!</span>(<span class="string">&quot;Tcp packet &#123;&#125;:&#123;&#125; to &#123;&#125;:&#123;&#125;&quot;</span>, header.<span class="title function_ invoke__">get_source</span>(), tcp.<span class="title function_ invoke__">get_source</span>(), header.<span class="title function_ invoke__">get_destination</span>(), tcp.<span class="title function_ invoke__">get_destination</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;ignore&quot;</span>),</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;ignore&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-dns">4 dns</h2>
<p>依赖库：<br>
trust-dns-resolver = “0.11.0”<br>
trust-dns = “0.16.0”</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> trust_dns_resolver::Resolver;</span><br><span class="line"><span class="keyword">use</span> trust_dns_resolver::config::*;</span><br><span class="line"><span class="keyword">use</span> trust_dns::rr::record_type::RecordType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() != <span class="number">2</span> &#123;</span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;Please provide a name to query!&quot;</span>);</span><br><span class="line">        std::process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;.&quot;</span>, args[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//默认方式配置解析器</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;use default:&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">resolver</span> = Resolver::<span class="title function_ invoke__">new</span>(ResolverConfig::<span class="title function_ invoke__">default</span>(), ResolverOpts::<span class="title function_ invoke__">default</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">response</span> = resolver.<span class="title function_ invoke__">lookup_ip</span>(query.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">ans</span> <span class="keyword">in</span> response.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从系统文件配置解析器</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;use system:&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">resolver</span> = Resolver::<span class="title function_ invoke__">from_system_conf</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">response</span> = resolver.<span class="title function_ invoke__">lookup_ip</span>(query.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">ans</span> <span class="keyword">in</span> response.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;use ns:&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ns</span> = resolver.<span class="title function_ invoke__">lookup</span>(query.<span class="title function_ invoke__">as_str</span>(),RecordType::NS);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">ans</span> <span class="keyword">in</span> response.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-serde">5. serde</h2>
<p>serde crate 是 Serde 生态的核心。<br>
serde_derive crate 提供必要的工具，<br>
使用过程宏来派生 Serialize 和 Deserialize。<br>
但是serde只提供序列化和反序列化的框架，具体的操作还需要依赖具体的包：如serde_json和serde_yaml等。</p>
<h3 id="5-1-基本使用">5.1 基本使用</h3>
<p>依赖：<br>
serde = { version = “1.0.106”, features = [“derive”] }<br>
serde_json = “1.0”<br>
serde_yaml = “0.8”</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> serde::&#123;Serialize,Deserialize&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug,Serialize,Deserialize)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ServerConfig</span>&#123;</span><br><span class="line">    workers:<span class="type">u64</span>,</span><br><span class="line">    ignore:<span class="type">bool</span>,</span><br><span class="line">    auth_server:<span class="type">Option</span>&lt;<span class="type">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = ServerConfig&#123;</span><br><span class="line">        workers:<span class="number">100</span>,</span><br><span class="line">        ignore:<span class="literal">false</span>,</span><br><span class="line">        auth_server:<span class="title function_ invoke__">Some</span>(<span class="string">&quot;auth.server.io&quot;</span>.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">    &#125;;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;json:&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">serialized</span> = serde_json::<span class="title function_ invoke__">to_string</span>(&amp;config).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;serialized:&#123;&#125;&quot;</span>,serialized);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">deserialized</span>: ServerConfig = serde_json::<span class="title function_ invoke__">from_str</span>(&amp;serialized).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;deserialized: &#123;:#?&#125;&quot;</span>,deserialized);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;yaml:&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">serialized</span> = serde_yaml::<span class="title function_ invoke__">to_string</span>(&amp;config).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;serialized:&#123;&#125;&quot;</span>,serialized);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">deserialized</span>: ServerConfig = serde_yaml::<span class="title function_ invoke__">from_str</span>(&amp;serialized).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;deserialized: &#123;:#?&#125;&quot;</span>,deserialized);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-serde网络编程中的应用">5.2 serde网络编程中的应用</h3>
<p>服务器端代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> serde::&#123;Deserialize, Serialize&#125;;</span><br><span class="line"><span class="keyword">use</span> serde_json;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, prelude::*, BufReader, Write&#125;;</span><br><span class="line"><span class="keyword">use</span> std::net::&#123;TcpListener, TcpStream&#125;;</span><br><span class="line"><span class="keyword">use</span> std::&#123;thread,<span class="type">str</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug,Serialize,Deserialize)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point3D</span> &#123;</span><br><span class="line">    x: <span class="type">u32</span>,</span><br><span class="line">    y: <span class="type">u32</span>,</span><br><span class="line">    z: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_client</span>(stream:TcpStream)<span class="punctuation">-&gt;</span>io::<span class="type">Result</span>&lt;()&gt;&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Incoming connection from: &#123;&#125;&quot;</span>,stream.<span class="title function_ invoke__">peer_addr</span>()?);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">data</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stream</span> = BufReader::<span class="title function_ invoke__">new</span>(stream);</span><br><span class="line">    <span class="keyword">loop</span>&#123;</span><br><span class="line">        data.<span class="title function_ invoke__">clear</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">bytes_read</span> = stream.<span class="title function_ invoke__">read_until</span>(<span class="string">b&#x27;\n&#x27;</span>,&amp;<span class="keyword">mut</span> data)?;</span><br><span class="line">        <span class="keyword">if</span> bytes_read==<span class="number">0</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">input</span>:Point3D = serde_json::<span class="title function_ invoke__">from_slice</span>(&amp;data)?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">value</span> = input.x.<span class="title function_ invoke__">pow</span>(<span class="number">2</span>)+input.y.<span class="title function_ invoke__">pow</span>(<span class="number">2</span>)+input.z.<span class="title function_ invoke__">pow</span>(<span class="number">2</span>);</span><br><span class="line">        stream.<span class="title function_ invoke__">get_mut</span>().<span class="title function_ invoke__">write</span>(&amp;(serde_json::<span class="title function_ invoke__">to_vec</span>(&amp;(<span class="type">f64</span>::<span class="title function_ invoke__">from</span>(value).<span class="title function_ invoke__">sqrt</span>()))?))?;</span><br><span class="line">        stream.<span class="title function_ invoke__">get_mut</span>().<span class="title function_ invoke__">write</span>(&amp;(<span class="string">&quot;\n&quot;</span>.<span class="title function_ invoke__">as_bytes</span>()))?;</span><br><span class="line">        stream.<span class="title function_ invoke__">get_mut</span>().<span class="title function_ invoke__">flush</span>()?;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span>std::io::<span class="type">Result</span>&lt;()&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">listener</span> = TcpListener::<span class="title function_ invoke__">bind</span>(<span class="string">&quot;0.0.0.0:8080&quot;</span>)?;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">stream</span> <span class="keyword">in</span> listener.<span class="title function_ invoke__">incoming</span>()&#123;</span><br><span class="line">        <span class="keyword">match</span> stream&#123;</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">eprintln!</span>(<span class="string">&quot;error: &#123;&#125;&quot;</span>,e),</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(stream)=&gt;&#123;</span><br><span class="line">                thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> ||&#123;</span><br><span class="line">                    <span class="title function_ invoke__">handle_client</span>(stream).<span class="title function_ invoke__">unwrap_or_else</span>(|error|<span class="built_in">eprintln!</span>(<span class="string">&quot;error:&#123;&#125;&quot;</span>,error));</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> serde::&#123;Deserialize, Serialize&#125;;</span><br><span class="line"><span class="keyword">use</span> serde_json;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, prelude::*, BufReader, Write&#125;;</span><br><span class="line"><span class="keyword">use</span> std::net::&#123;TcpStream&#125;;</span><br><span class="line"><span class="keyword">use</span> std::&#123;<span class="type">str</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, Serialize, Deserialize)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point3D</span> &#123;</span><br><span class="line">    x: <span class="type">u32</span>,</span><br><span class="line">    y: <span class="type">u32</span>,</span><br><span class="line">    z: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> std::io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stream</span> = TcpStream::<span class="title function_ invoke__">connect</span>(<span class="string">&quot;127.0.0.1:8080&quot;</span>)?;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写数据给服务器端</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buffer</span>: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> input).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read from stdin&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">parts</span>: <span class="type">Vec</span>&lt;&amp;<span class="type">str</span>&gt; = input.<span class="title function_ invoke__">trim_matches</span>(<span class="string">&#x27;\n&#x27;</span>).<span class="title function_ invoke__">split</span>(<span class="string">&#x27;,&#x27;</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">point</span> = Point3D &#123;</span><br><span class="line">            x: parts[<span class="number">0</span>].<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>(),</span><br><span class="line">            y: parts[<span class="number">1</span>].<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>(),</span><br><span class="line">            z: parts[<span class="number">2</span>].<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>(),</span><br><span class="line">        &#125;;</span><br><span class="line">        stream.<span class="title function_ invoke__">write_all</span>(serde_json::<span class="title function_ invoke__">to_string</span>(&amp;point).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">as_bytes</span>()).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to write&quot;</span>);</span><br><span class="line">        stream.<span class="title function_ invoke__">write_all</span>(<span class="string">b&quot;\n&quot;</span>)?; <span class="comment">//已传递给服务器端</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//从服务器端读数据</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">reader</span> = BufReader::<span class="title function_ invoke__">new</span>(&amp;stream);</span><br><span class="line">        reader.<span class="title function_ invoke__">read_until</span>(<span class="string">b&#x27;\n&#x27;</span>, &amp;<span class="keyword">mut</span> buffer)?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">input</span> = <span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(&amp;buffer).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">if</span> input == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            <span class="built_in">eprintln!</span>(<span class="string">&quot;Empty response&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Respnse:&#123;&#125;&quot;</span>, input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust网络编程</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust网络编程(2)-IpAddr和SocketAddr使用</title>
    <url>/articles/d368fb2c/</url>
    <content><![CDATA[<p>IpAddr和SocketAddr使用</p>
<span id="more"></span> 
<h2 id="1-ipaddr">1. IpAddr</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::net::&#123;IpAddr,Ipv4Addr,Ipv6Addr&#125;;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v4</span> = IpAddr::<span class="title function_ invoke__">V4</span>(Ipv4Addr::<span class="title function_ invoke__">new</span>(<span class="number">127</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v6</span> = IpAddr::<span class="title function_ invoke__">V6</span>(Ipv6Addr::<span class="title function_ invoke__">new</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&quot;127.0.0.1&quot;</span>.<span class="title function_ invoke__">parse</span>(),<span class="title function_ invoke__">Ok</span>(v4));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&quot;::1&quot;</span>.<span class="title function_ invoke__">parse</span>(),<span class="title function_ invoke__">Ok</span>(v6));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(v4.<span class="title function_ invoke__">is_loopback</span>(),<span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v6.<span class="title function_ invoke__">is_loopback</span>(),<span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(IpAddr::<span class="title function_ invoke__">V4</span>(Ipv4Addr::<span class="title function_ invoke__">new</span>(<span class="number">192</span>,<span class="number">168</span>,<span class="number">0</span>,<span class="number">1</span>)).<span class="title function_ invoke__">is_loopback</span>(),<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(v4.<span class="title function_ invoke__">is_multicast</span>(),<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v6.<span class="title function_ invoke__">is_multicast</span>(),<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(IpAddr::<span class="title function_ invoke__">V4</span>(Ipv4Addr::<span class="title function_ invoke__">new</span>(<span class="number">224</span>,<span class="number">254</span>,<span class="number">0</span>,<span class="number">0</span>)).<span class="title function_ invoke__">is_multicast</span>(),<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(v4.<span class="title function_ invoke__">is_ipv4</span>(),<span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v6.<span class="title function_ invoke__">is_ipv6</span>(),<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-socketaddr">2. SocketAddr</h2>
<p>SocketAddr和IpAddr区别：需要绑定端口才能运行</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::net::&#123;IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr&#125;;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v4</span> = SocketAddr::<span class="title function_ invoke__">new</span>(IpAddr::<span class="title function_ invoke__">V4</span>(Ipv4Addr::<span class="title function_ invoke__">new</span>(<span class="number">127</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)),<span class="number">8080</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v6</span> = SocketAddr::<span class="title function_ invoke__">new</span>(IpAddr::<span class="title function_ invoke__">V6</span>(Ipv6Addr::<span class="title function_ invoke__">new</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65535</span>,<span class="number">0</span>,<span class="number">1</span>)),<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(v4.<span class="title function_ invoke__">ip</span>(),IpAddr::<span class="title function_ invoke__">V4</span>(Ipv4Addr::<span class="title function_ invoke__">new</span>(<span class="number">127</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">    v4.<span class="title function_ invoke__">set_ip</span>(IpAddr::<span class="title function_ invoke__">V4</span>(Ipv4Addr::<span class="title function_ invoke__">new</span>(<span class="number">192</span>,<span class="number">168</span>,<span class="number">0</span>,<span class="number">1</span>)));</span><br><span class="line">    v6.<span class="title function_ invoke__">set_ip</span>(IpAddr::<span class="title function_ invoke__">V6</span>(Ipv6Addr::<span class="title function_ invoke__">new</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65535</span>,<span class="number">0</span>,<span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(v4.<span class="title function_ invoke__">ip</span>(),IpAddr::<span class="title function_ invoke__">V4</span>(Ipv4Addr::<span class="title function_ invoke__">new</span>(<span class="number">192</span>,<span class="number">168</span>,<span class="number">0</span>,<span class="number">1</span>)));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v4.<span class="title function_ invoke__">port</span>(),<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">    v4.<span class="title function_ invoke__">set_port</span>(<span class="number">1025</span>);</span><br><span class="line">    v6.<span class="title function_ invoke__">set_port</span>(<span class="number">1025</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(v4.<span class="title function_ invoke__">is_ipv4</span>(),<span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v6.<span class="title function_ invoke__">is_ipv4</span>(),<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(v4.<span class="title function_ invoke__">is_ipv6</span>(),<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v6.<span class="title function_ invoke__">is_ipv6</span>(),<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust网络编程</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust网络编程(1)-tcp和udp</title>
    <url>/articles/97bbf081/</url>
    <content><![CDATA[<p>tcp和udp开发</p>
<span id="more"></span> 
<h2 id="1-tcp">1. tcp</h2>
<p>客户端输入信息，服务器端接收，并反馈给客户端</p>
<h3 id="1-1-tcp服务器端">1.1 tcp服务器端</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::net::&#123;TcpListener,TcpStream&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>,Read,Write&#125;;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_client</span>(<span class="keyword">mut</span> stream:TcpStream)<span class="punctuation">-&gt;</span>io::<span class="type">Result</span>&lt;()&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = [<span class="number">0</span>;<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">1000</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">bytes_read</span> = stream.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buf)?;</span><br><span class="line">        <span class="keyword">if</span> bytes_read==<span class="number">0</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(());</span><br><span class="line">        &#125;</span><br><span class="line">        stream.<span class="title function_ invoke__">write</span>(&amp;buf[..bytes_read])?;</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(time::Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span>io::<span class="type">Result</span>&lt;()&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">listener</span> = TcpListener::<span class="title function_ invoke__">bind</span>(<span class="string">&quot;127.0.0.1:9999&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">thread_vec</span> :<span class="type">Vec</span>&lt;thread::JoinHandle&lt;()&gt;&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">stream</span> <span class="keyword">in</span> listener.<span class="title function_ invoke__">incoming</span>()&#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">stream</span> = stream.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;failed&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> ||&#123;</span><br><span class="line">            <span class="title function_ invoke__">handle_client</span>(stream).<span class="title function_ invoke__">unwrap_or_else</span>(|error| <span class="built_in">eprintln!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,error));</span><br><span class="line">        &#125;);</span><br><span class="line">        thread_vec.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> thread_vec&#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-tcp服务器端">1.2 tcp服务器端</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>,prelude::*,BufReader,Write&#125;;</span><br><span class="line"><span class="keyword">use</span> std::net::TcpStream;</span><br><span class="line"><span class="keyword">use</span> std::<span class="type">str</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span>io::<span class="type">Result</span>&lt;()&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stream</span> = TcpStream::<span class="title function_ invoke__">connect</span>(<span class="string">&quot;127.0.0.1:9999&quot;</span>)?;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> input).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read&quot;</span>);</span><br><span class="line">        stream.<span class="title function_ invoke__">write</span>(input.<span class="title function_ invoke__">as_bytes</span>()).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to wrote&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">reader</span> = BufReader::<span class="title function_ invoke__">new</span>(&amp;stream);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buffer</span>: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        reader.<span class="title function_ invoke__">read_until</span>(<span class="string">b&#x27;\n&#x27;</span>,&amp;<span class="keyword">mut</span> buffer).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read into buffer&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;read from server : &#123;&#125;&quot;</span>,<span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(&amp;buffer).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-udp">2. udp</h2>
<h3 id="2-1-udp客户端">2.1 udp客户端</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::net::UdpSocket;</span><br><span class="line"><span class="keyword">use</span> std::&#123;io,<span class="type">str</span>&#125;;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">socket</span> = UdpSocket::<span class="title function_ invoke__">bind</span>(<span class="string">&quot;127.0.0.1:8888&quot;</span>)?;</span><br><span class="line">    socket.<span class="title function_ invoke__">connect</span>(<span class="string">&quot;127.0.0.1:9999&quot;</span>)?;</span><br><span class="line">    <span class="keyword">loop</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> input)?;</span><br><span class="line">        socket.<span class="title function_ invoke__">send</span>(input.<span class="title function_ invoke__">as_bytes</span>())?;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buffer</span> = [<span class="number">0u8</span>;<span class="number">1500</span>];</span><br><span class="line">        socket.<span class="title function_ invoke__">recv_from</span>(&amp;<span class="keyword">mut</span> buffer)?;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;recv:&#123;&#125;&quot;</span>,<span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(&amp;buffer).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Could not write buffer as string&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-udp服务器端">2.2 udp服务器端</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::net::UdpSocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> std::io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">socket</span> = UdpSocket::<span class="title function_ invoke__">bind</span>(<span class="string">&quot;127.0.0.1:9999&quot;</span>)?;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = [<span class="number">0u8</span>; <span class="number">1500</span>];</span><br><span class="line">        <span class="keyword">let</span> (amt, src) = socket.<span class="title function_ invoke__">recv_from</span>(&amp;<span class="keyword">mut</span> buf)?;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;size = &#123;&#125;&quot;</span>, amt);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">buf</span> = &amp;<span class="keyword">mut</span> buf[..amt];</span><br><span class="line">        buf.<span class="title function_ invoke__">reverse</span>();</span><br><span class="line">        socket.<span class="title function_ invoke__">send_to</span>(buf,src)?;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust网络编程</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust基础(12)-文件读写</title>
    <url>/articles/8d6dde7e/</url>
    <content><![CDATA[<p>操作文件</p>
<span id="more"></span>
<h2 id="文件的读取-目录的递归">文件的读取、目录的递归</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">visit_dirs</span>(dir:&amp;Path)<span class="punctuation">-&gt;</span>io::<span class="type">Result</span>&lt;()&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span> dir.<span class="title function_ invoke__">is_dir</span>()&#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">entry</span> <span class="keyword">in</span> fs::<span class="title function_ invoke__">read_dir</span>(dir)?&#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">entry</span> = entry?;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">path</span> = entry.<span class="title function_ invoke__">path</span>();</span><br><span class="line">            <span class="keyword">if</span> path.<span class="title function_ invoke__">is_dir</span>()&#123;</span><br><span class="line">                <span class="title function_ invoke__">visit_dirs</span>(&amp;path);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">c</span> = fs::<span class="title function_ invoke__">read_to_string</span>(path).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;file = &#123;&#125;&quot;</span>,c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">context</span> = fs::<span class="title function_ invoke__">read</span>(<span class="string">&quot;./test/tt1&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;content = &#123;:#?&#125;&quot;</span>, context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">context</span> = fs::<span class="title function_ invoke__">read_to_string</span>(<span class="string">&quot;./test/tt1&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;content = &#123;:#?&#125;&quot;</span>, context);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">visit_dirs</span>(Path::<span class="title function_ invoke__">new</span>(<span class="string">&quot;./test&quot;</span>)).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust基础</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust基础(11)-基本数据结构</title>
    <url>/articles/a9694440/</url>
    <content><![CDATA[<p>队列 栈等数据结构的实现</p>
<span id="more"></span>
<h2 id="1-队列">1. 队列</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Queue</span>&lt;T&gt; &#123;</span><br><span class="line">    qdata: <span class="type">Vec</span>&lt;T&gt;,</span><br><span class="line">    capacity: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Queue&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(size: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Queue &#123;</span><br><span class="line">            qdata: <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(size),</span><br><span class="line">            capacity: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">enqueue</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, item: T) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.qdata.<span class="title function_ invoke__">len</span>() == <span class="keyword">self</span>.capacity &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;No space in queue!&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.qdata.<span class="title function_ invoke__">push</span>(item);</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">dequeue</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">size</span> = <span class="keyword">self</span>.qdata.<span class="title function_ invoke__">len</span>();</span><br><span class="line">        <span class="keyword">if</span> size &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">v</span> = <span class="keyword">self</span>.qdata.<span class="title function_ invoke__">remove</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(v)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">size</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.qdata.<span class="title function_ invoke__">len</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">q</span> = Queue::<span class="title function_ invoke__">new</span>(<span class="number">2</span>);</span><br><span class="line">    q.<span class="title function_ invoke__">enqueue</span>(<span class="number">1</span>);</span><br><span class="line">    q.<span class="title function_ invoke__">enqueue</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(error) = q.<span class="title function_ invoke__">enqueue</span>(<span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;enqueue error: &#123;&#125;&quot;</span>, error)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;size:&#123;&#125;&quot;</span>, q.<span class="title function_ invoke__">size</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;q: &#123;:#?&#125;&quot;</span>, q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(data) = q.<span class="title function_ invoke__">dequeue</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;data: &#123;&#125;&quot;</span>, data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;queue empty!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>2. 栈（vector实现）</h1>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span>&lt;T&gt; &#123;</span><br><span class="line">    data: <span class="type">Vec</span>&lt;T&gt;,</span><br><span class="line">    top: <span class="type">usize</span>,</span><br><span class="line">    capacity: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Stack&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(size: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Stack &#123;</span><br><span class="line">            data: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">            top: <span class="number">0</span>,</span><br><span class="line">            capacity: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">push</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, item: T) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.top &gt;= <span class="keyword">self</span>.capacity &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;There is no space in stack!&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.data.<span class="title function_ invoke__">push</span>(item);</span><br><span class="line">        <span class="keyword">self</span>.top += <span class="number">1</span>;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">pop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.top == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.top -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">self</span>.data.<span class="title function_ invoke__">pop</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">top</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.top</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = Stack::<span class="title function_ invoke__">new</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_</span> = s.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_</span> = s.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_</span> = s.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(error) = s.<span class="title function_ invoke__">push</span>(<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;push 4 error:&#123;&#125;&quot;</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;++++++++++++++++&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;top: &#123;&#125;&quot;</span>,s.<span class="title function_ invoke__">top</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s: &#123;:#?&#125;&quot;</span>, s);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">4</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">a</span> = s.<span class="title function_ invoke__">pop</span>();</span><br><span class="line">        <span class="keyword">match</span> a &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(item) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;pop item:&#123;&#125;&quot;</span>, item),</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;stack empty!&quot;</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>3. 栈（链表实现）</h1>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StackNode</span>&lt;T&gt; &#123;</span><br><span class="line">    data: T,</span><br><span class="line">    next: <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;StackNode&lt;T&gt;&gt;&gt;, <span class="comment">//使用Option，可以用它的None;智能指针指向下一个节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span>&lt;T&gt; &#123;</span><br><span class="line">    top: <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;StackNode&lt;T&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Stack&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Stack&lt;T&gt; &#123;</span><br><span class="line">        Stack &#123; top: <span class="literal">None</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">push</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, data: T) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">node</span> = StackNode &#123; data, next: <span class="literal">None</span> &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">next</span> = <span class="keyword">self</span>.top.<span class="title function_ invoke__">take</span>();</span><br><span class="line">        node.next = next;</span><br><span class="line">        <span class="keyword">self</span>.top = <span class="title function_ invoke__">Some</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(node));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">pop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">node</span> = <span class="keyword">self</span>.top.<span class="title function_ invoke__">take</span>();</span><br><span class="line">        <span class="keyword">match</span> node &#123;</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(<span class="keyword">mut</span> x) =&gt; &#123;</span><br><span class="line">                <span class="keyword">self</span>.top = x.next.<span class="title function_ invoke__">take</span>();</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(x.data)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = Stack::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    s.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">    s.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">    s.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;after push, s:&#123;:#?&#125;&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">4</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(data)=s.<span class="title function_ invoke__">pop</span>()&#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;data:&#123;&#125;&quot;</span>,data)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust基础</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust基础(10)-读取命令行参数</title>
    <url>/articles/c3428151/</url>
    <content><![CDATA[<p>读取命令行参数</p>
<span id="more"></span>
<p>案例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;size = &#123;&#125;&quot;</span>,args.<span class="title function_ invoke__">len</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, args);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;&#125;&quot;</span>,a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = &amp;args[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;&#125;&quot;</span>,a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = &amp;args[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;&#125;&quot;</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust基础</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust基础(9)-struct内存分布</title>
    <url>/articles/4badbb44/</url>
    <content><![CDATA[<p>struct的内存分布，大小堆对齐情况</p>
<span id="more"></span>
<h2 id="概述">概述</h2>
<ol>
<li>在x86平台（64位系统），按照32位来对齐</li>
<li>一种类型的大小，是它对齐属性的整数倍</li>
<li>结构体对齐属性，是它所有成员中，对齐属性最大的那个</li>
</ol>
<h2 id="案例">案例</h2>
<p>标准计算出，需要12个字节，但rust做了优化，最终只有8个字节</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::mem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    a: <span class="type">u8</span>,     <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="comment">//填充      // 3 byte</span></span><br><span class="line">    b: <span class="type">u32</span>,    <span class="comment">// 4 byte</span></span><br><span class="line">    c: <span class="type">u16</span>,    <span class="comment">// 2 byte</span></span><br><span class="line">     <span class="comment">//填充      // 2 byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">aa</span> = A &#123; a: <span class="number">1</span>, b: <span class="number">2</span>, c: <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="comment">//打印出的是字节，x8后，就是位数</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;size = &#123;&#125;&quot;</span>,mem::size_of::&lt;A&gt;());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;size = &#123;&#125;&quot;</span>, mem::<span class="title function_ invoke__">size_of_val</span>(&amp;aa));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://kaisery.github.io/trpl-zh-cn/">Rust 程序设计语言</a></p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust基础</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Aleo基础(1)-综述</title>
    <url>/articles/87b7c6b8/</url>
    <content><![CDATA[<p>Aleo常规背景内容均汇总在此处，当前总结内容是在test即将发布前</p>
<span id="more"></span>  
<h2 id="1-隐私计算">1. 隐私计算</h2>
<ol>
<li>主流技术（前三者主流）：多方安全计算、联邦学习、可信执行环境、差分隐私、同态加密、零知识证明(ZKP)</li>
<li>零知识证明被广泛用在web3中：
<ol>
<li>概念：既能充分证明自己是某种权益的合法拥有者，又不把有关的信息泄露出去，即给外界的&quot;知识&quot;为&quot;零&quot;</li>
<li>形象比喻：阿里巴巴和四十大盗，开山门；要让大盗们相信自己知道山洞的咒语，又不告诉大盗们咒语，那就让大盗们离自己远一些，然后自己说出咒语；大盗们看到门开了，但又听不到自己说的什么咒语。</li>
</ol>
</li>
</ol>
<h2 id="2-什么是aleo">2. 什么是Aleo</h2>
<ol>
<li>概念：通过区块链的去中心化系统和零知识证明的隐私加密技术保证网络上的数据实现为用户和应用程序开发人员提供绝对隐私的计算和数据保护。</li>
<li><code>霍华德</code>的论文《ZEXE:实现去中心化私人计算》，<code>ZEXE技术</code>引导开发隐私公链，进而吸引到a16z投资。逐步成为目前零知识证明领域最大的投资项目。
<ol>
<li><code>ZEXE技术</code>是在ZK-Snarks技术中进一步优化，也是Aleo的核心技术，就是当自己在各种DAPP交互时，信息不会被公开</li>
</ol>
</li>
<li>Aleo会把记录拆解为两步，首先会产生一个出生证明，说明资产创建的条件、地点信息；第二步就是创建一个死亡证明，用于说明资产被消费或被转移</li>
<li>Aleo的运行是分为链下计算和链上验证两个层面，各种记录的生成是在链下完成的，资源的证明则是在链上完成的，Aleo的验证人只需要验证记录离的零知识证明是否正确，这样就保证了隐私，这种证明方式又被称为简洁工作量证明，即<code>POSW</code>。Aleo把链下验证的这个环节称为:<code>zkCloud</code>，程序以私密、安全、廉价的方式执行，并且运行时间不受限制。</li>
<li>构建了验证的零知识应用程序的编程语言：<code>Leo</code>，确保用户的数据在默认情况下是隐私的，并且可以在web上无缝运行。为了让web开发人员更容易尝试使用<code>Leo</code>开发应用，发布了一个Playground，也就是PM管理软件，并且集成到<code>Aleo Studio</code>中（IDE）</li>
<li>按官方最终目标，任何设备都可以部署aleo</li>
</ol>
<h2 id="3-test3情况">3. test3情况</h2>
<ol>
<li>初始积分：10亿</li>
<li>目前积分是通过kyc领取，无法转卖</li>
<li>9月1号开始，在aleo上运行Prover节点，解开coinbase难题获得积分；提交关于snarkOS和snarkVM的bug获得积分</li>
<li>10月1号开启aleo bft，拥有100万个积分的节点，可以成为验证人，能够进行代币的质押，（pos机制）</li>
<li>由于test2有矿工大量掌握了算力，为了避免中心化问题，增加pos机制</li>
<li>转为pos机制，要求高，质押100万积分起步。并且性能会好</li>
<li>转为pos之后，posw机制依旧存在。两者共识的奖励分配暂未公布</li>
<li>pos参与门槛变高，保持20秒的区块出块时间，每个区块奖励100积分，每个验证人7.7%币龄。</li>
</ol>
<h2 id="总结">总结</h2>
<p>会根据情况进行调整本文</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Aleo</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Aleo</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust小项目</title>
    <url>/articles/15641b54/</url>
    <content><![CDATA[<p>结合前面掌握的基础技术，来完成一个小项目</p>
<span id="more"></span>  
<h2 id="1-单线程webserver实现">1. 单线程webserver实现</h2>
<p>简单的request请求以及response响应</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::net::&#123;TcpListener, TcpStream&#125;;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;Read, Write&#125;;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_client</span>(<span class="keyword">mut</span> stream: TcpStream) &#123;</span><br><span class="line">    <span class="comment">// 第一种处理请求方式：浏览器请求http://localhost:9999 后台则会打印下面这句话</span></span><br><span class="line">    <span class="comment">// println!(&quot;收到了一些内容&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种处理请求方式：读取并打印stream接收到的请求</span></span><br><span class="line">    <span class="comment">/*let mut buffer = [0; 512];</span></span><br><span class="line"><span class="comment">    stream.read(&amp;mut buffer).unwrap();</span></span><br><span class="line"><span class="comment">    println!(&quot;Request:&#123;&#125;&quot;,String::from_utf8_lossy(&amp;buffer[..]))*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三种处理请求方式：响应结果，这里返回http正常的提示</span></span><br><span class="line">    <span class="comment">/*let reponse = &quot;HTTP/1.1 200 OK\r\n\r\n&quot;;</span></span><br><span class="line"><span class="comment">    stream.write(reponse.as_bytes()).unwrap();</span></span><br><span class="line"><span class="comment">    stream.flush().unwrap();*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第四种处理请求方式：响应返回一个网页；浏览器兼容问题，可以使用 curl http://127.0.0.1:9999</span></span><br><span class="line">    <span class="comment">/*let content = fs::read_to_string(&quot;main.html&quot;).unwrap();</span></span><br><span class="line"><span class="comment">    let reponse = format!(&quot;HTTP/1.1 200 OK\r\n\r\n&#123;&#125;&quot;, content);</span></span><br><span class="line"><span class="comment">    stream.write(reponse.as_bytes()).unwrap();</span></span><br><span class="line"><span class="comment">    stream.flush().unwrap();*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第五种处理请求方式：有条件的返回网页；请求http://localhost:9999返回main.html，请求http://localhost:9999/xxx返回404.html</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buffer</span> = [<span class="number">0</span>; <span class="number">512</span>];</span><br><span class="line">    stream.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buffer).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">get</span> = <span class="string">b&quot;Get / HTTP/1.1/\r\n&quot;</span>;  <span class="comment">//b表示转化为字节</span></span><br><span class="line">    <span class="comment">//笨重实现</span></span><br><span class="line">    <span class="comment">/*if buffer.starts_with(get) &#123;</span></span><br><span class="line"><span class="comment">        println!(&quot;收到了一些内容&quot;);</span></span><br><span class="line"><span class="comment">        //返回main.html</span></span><br><span class="line"><span class="comment">        let content = fs::read_to_string(&quot;main.html&quot;).unwrap();</span></span><br><span class="line"><span class="comment">        let reponse = format!(&quot;HTTP/1.1 200 OK\r\n\r\n&#123;&#125;&quot;, content);</span></span><br><span class="line"><span class="comment">        stream.write(reponse.as_bytes()).unwrap();</span></span><br><span class="line"><span class="comment">        stream.flush().unwrap();</span></span><br><span class="line"><span class="comment">    &#125; else &#123;</span></span><br><span class="line"><span class="comment">        //返回404</span></span><br><span class="line"><span class="comment">        let content = fs::read_to_string(&quot;404.html&quot;).unwrap();</span></span><br><span class="line"><span class="comment">        let reponse = format!(&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&#123;&#125;&quot;, content);</span></span><br><span class="line"><span class="comment">        stream.write(reponse.as_bytes()).unwrap();</span></span><br><span class="line"><span class="comment">        stream.flush().unwrap();</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="comment">//代码优化实现，代码更清爽</span></span><br><span class="line">    <span class="keyword">let</span> (status_line, filename) = <span class="keyword">if</span> buffer.<span class="title function_ invoke__">starts_with</span>(get) &#123;</span><br><span class="line">        (<span class="string">&quot;HTTP/1.1 200 OK\r\n\r\n&#123;&#125;&quot;</span>, <span class="string">&quot;main.html&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (<span class="string">&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&#123;&#125;&quot;</span>, <span class="string">&quot;404.html&quot;</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(filename).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reponse</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&quot;</span>,status_line,contents);</span><br><span class="line">    stream.<span class="title function_ invoke__">write</span>(reponse.<span class="title function_ invoke__">as_bytes</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    stream.<span class="title function_ invoke__">flush</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> std::io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">listener</span> = TcpListener::<span class="title function_ invoke__">bind</span>(<span class="string">&quot;127.0.0.1:9999&quot;</span>)?;</span><br><span class="line">    <span class="comment">//?表示Result，等价如下：</span></span><br><span class="line">    <span class="comment">// let listener = TcpListener::bind(&quot;127.0.0.1:80&quot;).unwrap();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// accept connections and process them serially</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">stream</span> <span class="keyword">in</span> listener.<span class="title function_ invoke__">incoming</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">handle_client</span>(stream?);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-多线程webserver实现">2. 多线程webserver实现</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::net::&#123;TcpListener, TcpStream&#125;;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;Read, Write&#125;;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::&#123;thread, time&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_client</span>(<span class="keyword">mut</span> stream: TcpStream) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buffer</span> = [<span class="number">0</span>; <span class="number">512</span>];</span><br><span class="line">    stream.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buffer).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">get</span> = <span class="string">b&quot;Get / HTTP/1.1/\r\n&quot;</span>;  <span class="comment">//b表示转化为字节</span></span><br><span class="line">    <span class="keyword">let</span> (status_line, filename) = <span class="keyword">if</span> buffer.<span class="title function_ invoke__">starts_with</span>(get) &#123;</span><br><span class="line">        (<span class="string">&quot;HTTP/1.1 200 OK\r\n\r\n&#123;&#125;&quot;</span>, <span class="string">&quot;main.html&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (<span class="string">&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&#123;&#125;&quot;</span>, <span class="string">&quot;404.html&quot;</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(filename).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reponse</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&quot;</span>, status_line, contents);</span><br><span class="line">    stream.<span class="title function_ invoke__">write</span>(reponse.<span class="title function_ invoke__">as_bytes</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    stream.<span class="title function_ invoke__">flush</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">te</span> = time::Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">10000</span>);</span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(te);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> std::io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">listener</span> = TcpListener::<span class="title function_ invoke__">bind</span>(<span class="string">&quot;127.0.0.1:9999&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">thread_vec</span>: <span class="type">Vec</span>&lt;thread::JoinHandle&lt;()&gt;&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">stream</span> <span class="keyword">in</span> listener.<span class="title function_ invoke__">incoming</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">stream</span> = stream.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="title function_ invoke__">handle_client</span>(stream);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread_vec.<span class="title function_ invoke__">push</span>(handle)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> thread_vec&#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-线程池webserver实现-初版">3. 线程池webserver实现-初版</h2>
<p>lib中：<br>
<code>cargo new mylib --lib</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;thread&#125;;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    id: <span class="type">usize</span>,</span><br><span class="line">    thread: thread::JoinHandle&lt;()&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(id: <span class="type">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) <span class="punctuation">-&gt;</span> Worker &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">thread</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">loop</span>&#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">job</span> = receiver.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Worker&#123;&#125; got a job!&quot;</span>,id);</span><br><span class="line">                <span class="title function_ invoke__">job</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            receiver;</span><br><span class="line">        &#125;);</span><br><span class="line">        Worker &#123;</span><br><span class="line">            id,</span><br><span class="line">            thread,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    workers: <span class="type">Vec</span>&lt;Worker&gt;,</span><br><span class="line">    sender: mpsc::Sender&lt;Job&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Job</span> = <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">FnOnce</span>()+<span class="built_in">Send</span>+<span class="symbol">&#x27;static</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(size: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> ThreadPool &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(size &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">workers</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(size);</span><br><span class="line">        <span class="keyword">let</span> (sender, receiver) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">receiver</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(receiver)); <span class="comment">//线程安全</span></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">id</span> <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">            workers.<span class="title function_ invoke__">push</span>(Worker::<span class="title function_ invoke__">new</span>(id, Arc::<span class="title function_ invoke__">clone</span>(&amp;receiver)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ThreadPool &#123;</span><br><span class="line">            workers,</span><br><span class="line">            sender,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">execute</span>&lt;F&gt;(&amp;<span class="keyword">self</span>, f: F)</span><br><span class="line">        <span class="keyword">where</span> F: <span class="title function_ invoke__">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">job</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(f);</span><br><span class="line">        <span class="keyword">self</span>.sender.<span class="title function_ invoke__">send</span>(job).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main.rs中</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::net::&#123;TcpListener, TcpStream&#125;;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;Read, Write&#125;;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::&#123;thread, time&#125;;</span><br><span class="line"><span class="keyword">use</span> mylib::ThreadPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_client</span>(<span class="keyword">mut</span> stream: TcpStream) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buffer</span> = [<span class="number">0</span>; <span class="number">512</span>];</span><br><span class="line">    stream.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buffer).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">get</span> = <span class="string">b&quot;Get / HTTP/1.1/\r\n&quot;</span>;  <span class="comment">//b表示转化为字节</span></span><br><span class="line">    <span class="keyword">let</span> (status_line, filename) = <span class="keyword">if</span> buffer.<span class="title function_ invoke__">starts_with</span>(get) &#123;</span><br><span class="line">        (<span class="string">&quot;HTTP/1.1 200 OK\r\n\r\n&#123;&#125;&quot;</span>, <span class="string">&quot;main.html&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (<span class="string">&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&#123;&#125;&quot;</span>, <span class="string">&quot;404.html&quot;</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(filename).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reponse</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&quot;</span>, status_line, contents);</span><br><span class="line">    stream.<span class="title function_ invoke__">write</span>(reponse.<span class="title function_ invoke__">as_bytes</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    stream.<span class="title function_ invoke__">flush</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">te</span> = time::Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">10000</span>);</span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(te);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> std::io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">listener</span> = TcpListener::<span class="title function_ invoke__">bind</span>(<span class="string">&quot;127.0.0.1:9999&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pool</span> = ThreadPool::<span class="title function_ invoke__">new</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">stream</span> <span class="keyword">in</span> listener.<span class="title function_ invoke__">incoming</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">stream</span> = stream.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        pool.<span class="title function_ invoke__">execute</span>(||&#123;</span><br><span class="line">            <span class="title function_ invoke__">handle_client</span>(stream)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-线程池webserver实现-完善">4. 线程池webserver实现-完善</h2>
<p>支持线程池结束</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;thread&#125;;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    id: <span class="type">usize</span>,</span><br><span class="line">    thread: <span class="type">Option</span>&lt;thread::JoinHandle&lt;()&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(id: <span class="type">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) <span class="punctuation">-&gt;</span> Worker &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">thread</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">message</span> = receiver.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                <span class="keyword">match</span> message &#123;</span><br><span class="line">                    Message::<span class="title function_ invoke__">NewJob</span>(job) =&gt; &#123;</span><br><span class="line">                        <span class="built_in">println!</span>(<span class="string">&quot;worker &#123;&#125; receive a job&quot;</span>, id);</span><br><span class="line">                        <span class="title function_ invoke__">job</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Message::Terminate =&gt; &#123;</span><br><span class="line">                        <span class="built_in">println!</span>(<span class="string">&quot;worker &#123;&#125; receive terminate&quot;</span>, id);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Worker &#123;</span><br><span class="line">            id,</span><br><span class="line">            thread: <span class="title function_ invoke__">Some</span>(thread),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    workers: <span class="type">Vec</span>&lt;Worker&gt;,</span><br><span class="line">    sender: mpsc::Sender&lt;Message&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Job</span> = <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">NewJob</span>(Job),</span><br><span class="line">    Terminate,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(size: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> ThreadPool &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(size &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">workers</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(size);</span><br><span class="line">        <span class="keyword">let</span> (sender, receiver) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">receiver</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(receiver)); <span class="comment">//线程安全</span></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">id</span> <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">            workers.<span class="title function_ invoke__">push</span>(Worker::<span class="title function_ invoke__">new</span>(id, Arc::<span class="title function_ invoke__">clone</span>(&amp;receiver)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ThreadPool &#123;</span><br><span class="line">            workers,</span><br><span class="line">            sender,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">execute</span>&lt;F&gt;(&amp;<span class="keyword">self</span>, f: F)</span><br><span class="line">        <span class="keyword">where</span> F: <span class="title function_ invoke__">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">job</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(f);</span><br><span class="line">        <span class="keyword">self</span>.sender.<span class="title function_ invoke__">send</span>(Message::<span class="title function_ invoke__">NewJob</span>(job)).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">//发送中断消息</span></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.workers &#123;</span><br><span class="line">            <span class="keyword">self</span>.sender.<span class="title function_ invoke__">send</span>(Message::Terminate).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">worker</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.workers &#123;</span><br><span class="line">            <span class="comment">//等待worker结束</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(thread) = worker.thread.<span class="title function_ invoke__">take</span>() &#123;</span><br><span class="line">                thread.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main.rs中</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::net::&#123;TcpListener, TcpStream&#125;;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;Read, Write&#125;;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::&#123;thread, time&#125;;</span><br><span class="line"><span class="keyword">use</span> mylib::ThreadPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_client</span>(<span class="keyword">mut</span> stream: TcpStream) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buffer</span> = [<span class="number">0</span>; <span class="number">512</span>];</span><br><span class="line">    stream.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buffer).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">get</span> = <span class="string">b&quot;Get / HTTP/1.1/\r\n&quot;</span>;  <span class="comment">//b表示转化为字节</span></span><br><span class="line">    <span class="keyword">let</span> (status_line, filename) = <span class="keyword">if</span> buffer.<span class="title function_ invoke__">starts_with</span>(get) &#123;</span><br><span class="line">        (<span class="string">&quot;HTTP/1.1 200 OK\r\n\r\n&#123;&#125;&quot;</span>, <span class="string">&quot;main.html&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (<span class="string">&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&#123;&#125;&quot;</span>, <span class="string">&quot;404.html&quot;</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(filename).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reponse</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&quot;</span>, status_line, contents);</span><br><span class="line">    stream.<span class="title function_ invoke__">write</span>(reponse.<span class="title function_ invoke__">as_bytes</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    stream.<span class="title function_ invoke__">flush</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">te</span> = time::Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">10000</span>);</span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(te);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> std::io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">listener</span> = TcpListener::<span class="title function_ invoke__">bind</span>(<span class="string">&quot;127.0.0.1:9999&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pool</span> = ThreadPool::<span class="title function_ invoke__">new</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">stream</span> <span class="keyword">in</span> listener.<span class="title function_ invoke__">incoming</span>().<span class="title function_ invoke__">take</span>(<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">stream</span> = stream.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        pool.<span class="title function_ invoke__">execute</span>(||&#123;</span><br><span class="line">            <span class="title function_ invoke__">handle_client</span>(stream)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>编辑完毕</p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust</category>
      </categories>
      <tags>
        <tag>rust</tag>
        <tag>开发语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust笔记-综合</title>
    <url>/articles/a7f71777/</url>
    <content><![CDATA[<p>记录一些遇到的未知的内容</p>
<span id="more"></span> 
<h1>1. Cargo.toml中</h1>
<h2 id="1-1-workspace">1.1 <code>[workspace]</code></h2>
<h3 id="1-1-1-resolver">1.1.1 resolver</h3>
<p>resolver = “2”<br>
Rust 1.51.0 版本中，Cargo.toml 中将有一个新的可选域 resolver。可以通过设置 resolver=“2”，来告诉 cargo 尝试一种新的方式来解析特性。可以查看 RFC 2957 以获得 resolver 行为的详细描述，其总结如下：</p>
<ol>
<li>Dev dependencies — 当包被普通依赖项和开发依赖项所共享，仅当当前编译包含开发依赖项时，才启用开发依赖项的特性。</li>
<li>Host dependencies — 当包被普通依赖项和编译依赖项，或过程宏共享时，普通依赖项的特性将独立于编译依赖项或过程宏。</li>
<li>Target dependencies — 当包在编译图中多次出现，并且其中一个实例是特定目标的依赖项，则仅当当前目标正在编译时，才会启用特定目标的依赖项特性。</li>
</ol>
<h3 id="1-1-2-exclude">1.1.2 exclude</h3>
<p>exclude 可以将指定的目录排除在工作空间之外</p>
<h2 id="1-2-patch">1.2. <code>[patch]</code></h2>
<p>表示用指定的版本覆盖默认的版本</p>
<h3 id="1-3-profile">1.3 <code>[profile]</code></h3>
<h3 id="1-3-1-profile-release">1.3.1 <code>[profile.release]</code></h3>
<p>panic = ‘unwind’  （可用参数：unwind和abort）<br>
unwind表示遇到panic异常后继续运行；<br>
abort表示遇到异常立马停止</p>
<h2 id="1-4-package">1.4 <code>[package]</code></h2>
<p>publish<br>
该字段常常用于防止项目因为失误被发布到 <a href="http://crates.io">crates.io</a> 等注册服务上，例如如果希望项目在公司内部私有化，你应该设置：<code>publish = false</code></p>
<h2 id="1-5-dependencies">1.5 <code>[dependencies]</code></h2>
<p>default-features = false<br>
即不使用默认的feature进行编译</p>
<p>features = []，表示仅使用features中指定的部分</p>
<h2 id="1-6-dev-dependencies">1.6 <code>[dev-dependencies]</code></h2>
<p>等同于<code>[dependencies]</code><br>
不同之处在于，<code>[dependencies]</code>段落声明的依赖用于构建软件包，<br>
而<code>[dev-dependencies]</code>段落声明的依赖仅用于构建测试和性能评估。<br>
此外，<code>[dev-dependencies]</code>段落声明的依赖不会传递给其他依赖本软件包的项目</p>
<h1>2. 宏</h1>
<p><code>#[macro_use]</code> :可以使被注解的module模块中的宏应用到当前作用域中；或者注释crate中的宏应用到当前crate作用域中。参考：<a href="https://blog.csdn.net/teamlet/article/details/50989186">#[macro_use]的用法</a><br>
<code>#[derive(Debug,xxx)]</code>：Rust提供了一个属性derive来自动实现一些trait，这样可以避免重复繁琐地实现他们，能被derive使用的trait包括：Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd</p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust</category>
      </categories>
      <tags>
        <tag>rust</tag>
        <tag>开发语言</tag>
      </tags>
  </entry>
  <entry>
    <title>phala基础(1)-KhalaParachain编译</title>
    <url>/articles/19419e94/</url>
    <content><![CDATA[<p>项目<a href="https://github.com/Phala-Network/khala-parachain">khala-parachain</a> 为phala的节点部分，本文主要讲解该节点的编译及调试。部署等请参考我早期别的文章</p>
<span id="more"></span>  
<h2 id="简介">简介</h2>
<p>这里说明下，编译的时候，老老实实用ubuntu20.04的机器来编译。<br>
不要考虑windows、mac等别的系统。各种环境问题处理到最后都不一定能处理好。<br>
也不建议用docker编译，容器限制，编译速度会很慢，不是一般的慢（windows下我用docker编译成功了；但在mac下，docker死活编译不成功）。<br>
想用docker镜像编译的，可以参考我的这个<code>Dockefile</code>：<a href="https://github.com/bitxx/my-dockerfile/blob/master/Dockerfile_khala_node">khala-node docker</a><br>
本文介绍在<code>ubuntu20.04</code>和<code>macos Monterey 12.5(intel)</code>下的编译，其中<code>macos</code>你不一定能编译成功，只是结合官方给出个编译思路</p>
<h2 id="ubuntu-20-04编译步骤">Ubuntu 20.04编译步骤</h2>
<ol>
<li>安装rust<br>
包括相关环境变量，请参考：<a href="https://www.bitxx.top/articles/10db6b0/">Rust基础(1)-环境搭建及HelloWorld</a></li>
<li>安装需要的工具</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install -y apt-utils apt-transport-https software-properties-common readline-common curl vim wget gnupg gnupg2 gnupg-agent ca-certificates cmake pkg-config libssl-dev git build-essential llvm clang libclang-dev</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>安装rust的nightly版，当前我根据phala官方的节奏，选择的<code>nightly-2022-07-11</code>这个版本</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装nightly版</span></span><br><span class="line">rustup toolchain install nightly-2022-07-11</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将编译环境切换为nightly版</span></span><br><span class="line">rustup default nightly-2022-07-11</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手动添加依赖（该依赖一定是在这里手动添加的）</span></span><br><span class="line">rustup target add wasm32-unknown-unknown</span><br><span class="line">cargo install wasm-pack </span><br></pre></td></tr></table></figure>
<ol start="4">
<li>进入项目<a href="https://github.com/Phala-Network/khala-parachain">khala-parachain</a> 根目录进行编译：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试编译</span></span><br><span class="line">cargo build --profile testnet</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生产编译</span></span><br><span class="line">cargo build --profile production</span><br></pre></td></tr></table></figure>
<p>一路等待编译完成即可，我大概等了40分钟</p>
<h2 id="macos-monterey-12-5-intel-编译步骤">macos Monterey 12.5(intel)编译步骤</h2>
<p>这个是官方2022-07-24给出的编译方案，目前看可以编译成功：</p>
<ol>
<li>安装llvm</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install llvm</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">具体brew的应用安装位置需要你根据你的实际情况来找</span></span><br><span class="line">cd /usr/local/Cellar/llvm/14.0.6_1/bin</span><br><span class="line">ln -s llvm-ar ar</span><br><span class="line">ln -s llvm-ar ranlib</span><br></pre></td></tr></table></figure>
<p>llvm安装完毕后，根据提示，加入环境变量（你根据自身实际提示来操作）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br><span class="line"></span><br><span class="line">export LDFLAGS=&quot;-L/usr/local/opt/llvm/lib&quot;</span><br><span class="line">export CPPFLAGS=&quot;-I/usr/local/opt/llvm/include&quot;</span><br><span class="line"></span><br><span class="line">export PATH=&quot;/usr/local/opt/llvm/bin:$PATH&quot;</span><br><span class="line"></span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>安装rust<br>
包括相关环境变量，请参考：<a href="https://www.bitxx.top/articles/10db6b0/">Rust基础(1)-环境搭建及HelloWorld</a></li>
<li>安装rust的nightly版，当前我根据phala官方的节奏，选择的<code>nightly-2022-07-11</code>这个版本</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装nightly版</span></span><br><span class="line">rustup toolchain install nightly-2022-07-11</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将编译环境切换为nightly版</span></span><br><span class="line">rustup default nightly-2022-07-11</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手动添加依赖（该依赖一定是在这里手动添加的）</span></span><br><span class="line">rustup target add wasm32-unknown-unknown</span><br><span class="line">cargo install wasm-pack </span><br></pre></td></tr></table></figure>
<ol start="4">
<li>进入项目<a href="https://github.com/Phala-Network/khala-parachain">khala-parachain</a> 根目录进行编译：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试编译</span></span><br><span class="line">cargo build --profile testnet</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生产编译</span></span><br><span class="line">cargo build --profile production</span><br></pre></td></tr></table></figure>
<p>一路等待编译完成即可，我大概等了40分钟<br>
mac这个我编译成功了</p>
<h2 id="总结">总结</h2>
<p>本文编辑完成</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Phala</category>
        <category>应用</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Phala</tag>
      </tags>
  </entry>
  <entry>
    <title>substrate基础(12)-访问evm账户</title>
    <url>/articles/6f8bd562/</url>
    <content><![CDATA[<p>可以使用官方的<a href="https://github.com/paritytech/frontier">Frontier</a> 项目构建一条兼容以太坊的链。想想也很激动吧？</p>
<span id="more"></span>
<h2 id="1-编译frontier模板项目">1. 编译Frontier模板项目</h2>
<p><a href="https://github.com/substrate-developer-hub/frontier-node-template">Frontier模板项目</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/substrate-developer-hub/frontier-node-template.git</span><br><span class="line">cd frontier-node-template</span><br><span class="line">cargo build --release</span><br></pre></td></tr></table></figure>
<h2 id="2-连接到节点">2. 连接到节点</h2>
<ol>
<li>运行启动节点</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./target/release/frontier-template-node --dev</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>打开web <a href="https://polkadot.js.org/apps">polkadot-app</a> ，将网络连接到刚刚启动的节点，然后前往：<code>设置</code>-<code>tab开发者</code><br>
在其中定义以下账户信息以创建EVM类型，以便使帐户能够发送交易和检查区块</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MultiAddress&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;LookupSource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MultiAddress&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Account&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">     <span class="attr">&quot;nonce&quot;</span><span class="punctuation">:</span> <span class="string">&quot;U256&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;balance&quot;</span><span class="punctuation">:</span> <span class="string">&quot;U256&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Transaction&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">     <span class="attr">&quot;nonce&quot;</span><span class="punctuation">:</span> <span class="string">&quot;U256&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;String&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;gas_price&quot;</span><span class="punctuation">:</span> <span class="string">&quot;u64&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;gas_limit&quot;</span><span class="punctuation">:</span> <span class="string">&quot;u64&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;U256&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;input&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Vec&lt;u8&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;signature&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Signature&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Signature&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">     <span class="attr">&quot;v&quot;</span><span class="punctuation">:</span> <span class="string">&quot;u64&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;r&quot;</span><span class="punctuation">:</span> <span class="string">&quot;H256&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;s&quot;</span><span class="punctuation">:</span> <span class="string">&quot;H256&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>点击保存<br>
3. 调用rpc查看余额：<br>
前往web：<code>开发者</code>-<code>RPC calls</code>，然后如下操作（选择<code>eth</code>和<code>getBalance</code>）：<br>
其中账户输入的是预定义的<code>alice</code>的账户：<code>0xd43593c715fdd31c61141abd04a99fd6822c8558</code></p>
<img src="/articles/6f8bd562/1.png" class="" title="RPC调用">
<p>返回结果即为账户余额</p>
<h2 id="3-发布智能合约">3. 发布智能合约</h2>
<p>非重点，直接看官方文档：<a href="https://docs.substrate.io/tutorials/connect-other-chains/access-evm-accounts/">evm</a></p>
<h2 id="4-查看智能合约">4. 查看智能合约</h2>
<p>非重点，直接看官方文档：<a href="https://docs.substrate.io/tutorials/connect-other-chains/access-evm-accounts/">evm</a></p>
<h2 id="5-查看帐户存储空间">5. 查看帐户存储空间</h2>
<p>非重点，直接看官方文档：<a href="https://docs.substrate.io/tutorials/connect-other-chains/access-evm-accounts/">evm</a></p>
<h2 id="6-转移token">6. 转移Token</h2>
<p>非重点，直接看官方文档：<a href="https://docs.substrate.io/tutorials/connect-other-chains/access-evm-accounts/">evm</a></p>
<h2 id="7-验证token传输">7. 验证Token传输</h2>
<p>非重点，直接看官方文档：<a href="https://docs.substrate.io/tutorials/connect-other-chains/access-evm-accounts/">evm</a></p>
<h2 id="8-总结">8. 总结</h2>
<p>本文主要是讲述如何兼容以太坊网络的基本应用。一些细节功能我就不去尝试了，当前不是我关注的重点，只要大体了解有这样一回事即可。后续有必要再去细究</p>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://docs.substrate.io/quick-start/">Substrate官方文档</a></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Substrate</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Substrate</tag>
      </tags>
  </entry>
  <entry>
    <title>substrate基础(10)-连接Rococo测试网</title>
    <url>/articles/e189f974/</url>
    <content><![CDATA[<p>Rococo为Parity的公开测试网。</p>
<span id="more"></span>
<h2 id="1-领取测试币">1. 领取测试币</h2>
<p>前往<a href="https://matrix.to/#/#rococo-faucet:matrix.org">Rococo faucet matrix channel</a> 领取测试币100个，进去后，在频道里输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">!drip 你的Substrate地址（即SS58 prefix的地址 ）</span><br></pre></td></tr></table></figure>
<p>前往<a href="https://polkadot.js.org/apps">polkadot-app</a> 将网络切换到<code>Rococo</code>，然后<code>账户</code>中可以看到有100个<code>ROC</code></p>
<h2 id="2-申请paraid">2. 申请ParaID</h2>
<p>前往<a href="https://polkadot.js.org/apps">polkadot-app</a> 并 将网络切换到<code>Rococo</code>，依次打开位置：<code>Network</code>-&gt;<code>Parachains</code>-&gt;<code>选项卡Parathreads</code>,然后点击右上方的<code>+paraId</code>，弹出框后，输入如下内容（上一篇文章<a href="">substrate基础(10)-启动本地中继链并连接本地平行链</a> 已详述该使用方式）：</p>
<img src="/articles/e189f974/1.png" class="" title="申请">
<p>可以看出，需要支付5个ROC，然后点击提交。<br>
此时成功获取到ParaID：<code>4035</code></p>
<h2 id="3-配置自己平行链的genesis和wasm">3. 配置自己平行链的genesis和wasm</h2>
<p>这个上一章<a href="">substrate基础(10)-启动本地中继链并连接本地平行链</a> 也介绍过，就不详细解释了，直接生成：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Assumes that `rococo-local` is <span class="keyword">in</span> `node/chan_spec.rs` as the relay you registered with</span></span><br><span class="line">./target/release/parachain-collator build-spec --disable-default-bootnode &gt; parachain_custom_read.json</span><br></pre></td></tr></table></figure>
<p>打开该配置，更改如下位置：<br>
就是将下方位置<code>1000</code>改为<code>2000</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;para_id&quot;</span><span class="punctuation">:</span> <span class="number">4035</span><span class="punctuation">,</span> <span class="comment">// &lt;--- your already registered ID</span></span><br><span class="line">  <span class="attr">&quot;parachainInfo&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;parachainId&quot;</span><span class="punctuation">:</span> <span class="number">4035</span> <span class="comment">// &lt;--- your already registered ID</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<p>进一步生成：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./target/release/parachain-collator build-spec --chain parachain_custom_read.json --raw --disable-default-bootnode &gt; parachain_custom_4035.json</span><br><span class="line">./target/release/parachain-collator export-genesis-wasm --chain ./parachain_custom_4035.json &gt; para-4035-wasm</span><br><span class="line">./target/release/parachain-collator export-genesis-state --chain ./parachain_custom_4035.json &gt; para-4035-genesis</span><br></pre></td></tr></table></figure>
<p>至此，平行链的<code>wasm</code>和<code>genesis</code>均已生成</p>
<h2 id="4-注册paraid">4. 注册paraID</h2>
<p>前往<a href="https://polkadot.js.org/apps">polkadot-app</a> 并 将网络切换到<code>Rococo</code>，依次打开位置：<code>Network</code>-&gt;<code>Parachains</code>-&gt;<code>选项卡Parathreads</code>,然后点击右上方的<code>+paraThread</code>，弹出框后，</p>
<img src="/articles/e189f974/2.png" class="" title="注册">
<p>点击提交<br>
之后在下方列表就能看到了：</p>
<img src="/articles/e189f974/3.png" class="" title="注册成功">
<p>此时状态为：<code>onboarding</code>，表示注册成功。此时就可以申请成为平行链了，可以联系<code>Parity</code>官方的人进行操作，在<code>element频道</code>中联系</p>
<h2 id="5-启动平行链">5. 启动平行链</h2>
<p>如果官方的人将Parathread升级为parachain后，我们就可以开始本地启动平行链进行测试。</p>
<p>启动的时候需要关联到<code>rococo</code>链的raw原始配置文件，这个文件是在<a href="https://github.com/paritytech/polkadot">polkadot</a> 项目的：<code>/node/service/res./rococo.json</code><br>
启动第一个验证节点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./target/release/parachain-collator --alice --collator --force-authoring --chain parachain_custom_4035.json --base-path ./tmp/parachain/alice --port 40333 --ws-port 8844 -- --execution wasm --chain ./rococo.json --port 30343 --ws-port 9977</span><br></pre></td></tr></table></figure>
<p>官方开通后，就可以看到正常出块了</p>
<h2 id="总结">总结</h2>
<p>本文通过加入智能合约模块到节点中的流程，来让开发者了解模块功能整合的整体过程，由浅及深。<br>
按照本文流程，每个结果都可以复现的，亲自实现的。</p>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://docs.substrate.io/quick-start/">Substrate官方文档</a><br>
[2] <a href="https://www.ylfx.com/Show/index/id/1246612/cid/24.html">平行链上线技术系列三：Rococo local and public test network</a></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Substrate</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Substrate</tag>
      </tags>
  </entry>
  <entry>
    <title>substrate基础(10)-启动本地中继链并连接本地平行链</title>
    <url>/articles/c7670c6a/</url>
    <content><![CDATA[<p>为确保能够稳定启动中继链和平行链，本文指定各自相应版本。</p>
<ol>
<li>中继链：<a href="https://github.com/paritytech/polkadot/tree/release-v0.9.24">polkadot v0.9.24</a></li>
<li>平行链：<a href="https://github.com/substrate-developer-hub/substrate-parachain-template/tree/polkadot-v0.9.24">Substrate Parachain Template polkadot-v0.9.24</a></li>
<li>前端页面：<a href="https://github.com/polkadot-js/apps/commit/151c4cd75b6eb68ac275d90fd17f98b28b6e57a7">Polkadot-JS Apps v0.116.2-34</a></li>
</ol>
<span id="more"></span>
<h2 id="1-运行中继链">1. 运行中继链</h2>
<p>编译并启动<code>alice</code>和<code>bob</code>节点</p>
<h3 id="1-1-编译polkadot中继链">1.1 编译polkadot中继链</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Clone the Polkadot Repository, with correct version</span></span><br><span class="line">git clone --depth 1 --branch release-v0.9.24 https://github.com/paritytech/polkadot.git</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Switch into the Polkadot directory</span></span><br><span class="line">cd polkadot</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Build the relay chain Node</span></span><br><span class="line">cargo b -r</span><br></pre></td></tr></table></figure>
<h3 id="1-2-制定中继链的配置文件">1.2 制定中继链的配置文件</h3>
<p>中继链的验证节点数量必须比平行链的节点数量多一个及以上，也就是本文需要为中继链配置两个验证节点。<br>
官方文档中，为了完成该测试，提供了一个配置文件：<a href="https://github.com/substrate-developer-hub/substrate-docs/blob/main/static/assets/tutorials/cumulus/chain-specs/rococo-custom-2-raw.json">官方提供下载配置custom.json</a><br>
为了以防官方这文档变化，我单独做了备份：<a href="">本文备份custom.json</a><br>
其中预置了两个账户：<code>alice</code>和<code>bob</code><br>
将该json文件下载好后，放在指定位置</p>
<h3 id="1-3-启动第一个中继器验证节点-alice">1.3 启动第一个中继器验证节点(Alice)</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Start Relay `Alice` node</span></span><br><span class="line">./target/release/polkadot --alice --validator --base-path ./tmp/relay/alice --chain ./custom.json --port 30333 --ws-port 9944</span><br></pre></td></tr></table></figure>
<p>得到该节点地址：<code>12D3KooWHmheVDMmKwTbofSVwfS6HEQMGtgLzrRTdMzBrXuLndjs</code></p>
<h3 id="1-4-启动第二个中继器验证节点-bob">1.4 启动第二个中继器验证节点(bob)</h3>
<p>记得将第一个节点的地址添加到<code>bootnodes</code>中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Start Relay `Alice` node</span></span><br><span class="line">./target/release/polkadot --bob --validator --base-path ./tmp/relay/bob --chain ./custom.json --bootnodes /ip4/127.0.0.1/tcp/30333/p2p/12D3KooWHmheVDMmKwTbofSVwfS6HEQMGtgLzrRTdMzBrXuLndjs --port 30334 --ws-port 9945</span><br></pre></td></tr></table></figure>
<p>此时平行链就能正常运转了</p>
<h2 id="2-运行平行链">2. 运行平行链</h2>
<h3 id="2-1-编译平行链">2.1 编译平行链</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Clone the parachain template with the correct Polkadot version</span></span><br><span class="line">git clone --depth 1 --branch polkadot-v0.9.24 https://github.com/substrate-developer-hub/substrate-parachain-template</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Switch into the parachain template directory</span></span><br><span class="line">cd substrate-parachain-template</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Build the parachain template collator</span></span><br><span class="line">cargo b -r</span><br></pre></td></tr></table></figure>
<h3 id="2-2-预定paraid-即竞拍卡槽获取id">2.2 预定ParaID(即竞拍卡槽获取ID)</h3>
<p>平行链要想连接到指定的中继链，需要支付中继链的token来竞争卡槽，并获取唯一的ID。卡槽是有使用期限的。<br>
本文通过预置配置，默认会申请ParaID<code>2000</code><br>
这里我使用官方的<a href="https://polkadot.js.org/apps">polkadot-app</a>，依次打开位置：<code>Network</code>-&gt;<code>Parachains</code>-&gt;<code>选项卡Parathreads</code>,然后点击右上方的<code>+</code>：</p>
<img src="/articles/c7670c6a/1.png" class="" title="找到平行链位置">
<p>然后出现如下画面后，直接先后点击<code>提交</code>-<code>签名并提交</code></p>
<img src="/articles/c7670c6a/2.png" class="" title="申请">
<p>至此，申请完毕</p>
<h3 id="2-3-获取并修改默认配置文件">2.3 获取并修改默认配置文件</h3>
<p>先获取配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Assumes that `rococo-local` is <span class="keyword">in</span> `node/chan_spec.rs` as the relay you registered with</span></span><br><span class="line">./target/release/parachain-collator build-spec --disable-default-bootnode &gt; parachain_custom_read.json</span><br></pre></td></tr></table></figure>
<p>打开该配置，更改如下位置：<br>
就是将下方位置<code>1000</code>改为<code>2000</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;para_id&quot;</span><span class="punctuation">:</span> <span class="number">2000</span><span class="punctuation">,</span> <span class="comment">// &lt;--- your already registered ID</span></span><br><span class="line">  <span class="attr">&quot;parachainInfo&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;parachainId&quot;</span><span class="punctuation">:</span> <span class="number">2000</span> <span class="comment">// &lt;--- your already registered ID</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<p>然后更新转换为链可以加载的文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./target/release/parachain-collator build-spec --chain parachain_custom_read.json --raw --disable-default-bootnode &gt; parachain_custom_2000.json</span><br></pre></td></tr></table></figure>
<p>中继链需要特定特定的运行时来验证平行链的块，因此上面的<code>parachain_custom_2000.json</code>需要进一步处理，来生成相应的<code>wasm blob</code>，结合命令导出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./target/release/parachain-collator export-genesis-wasm --chain ./parachain_custom_2000.json &gt; para-2000-wasm</span><br></pre></td></tr></table></figure>
<p>要注册平行链，中继链需要知道平行链的创世状态。可以将该状态按如下方式导出创世文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./target/release/parachain-collator export-genesis-state --chain ./parachain_custom_2000.json &gt; para-2000-genesis</span><br></pre></td></tr></table></figure>
<p>生成的这个仅适用于平行链的创世块</p>
<h3 id="2-4-启动平行链">2.4 启动平行链</h3>
<p>如下，使用了<code>--</code>符号，将中继链和平行链关联注册并启动。第一个<code>chain</code>传入的是平行链的配置，第二个<code>chain</code>传入的是中继链的额配置。包括port和ws-port也同样。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./target/release/parachain-collator --alice --collator --force-authoring --chain parachain_custom_2000.json --base-path ./tmp/parachain/alice --port 40333 --ws-port 8844 -- --execution wasm --chain ./custom.json --port 30343 --ws-port 9977</span><br></pre></td></tr></table></figure>
<p>得到：<br>
平行链账号：5Ec4AhPUwPeyTFyuhGuBbD224mY85LKLMSqSSo33JYWCazU4<br>
节点ID：12D3KooWEDJmXrka9vBEvwm9MQDEFntYv45Mo7zJkrbVbcPv82X4</p>
<p><code>注意</code>：为了确保链运行，还得再启动一条，用不同的端口。别的都一样。</p>
<h3 id="2-5-注册平行链">2.5 注册平行链</h3>
<p>有两种方式可以完成注册</p>
<h4 id="2-5-1-通过parasudowrapper-sudoscheduleparainitialize完成注册">2.5.1 通过paraSudoWrapper.sudoScheduleParaInitialize完成注册</h4>
<p>绕过<code>插槽租赁机制</code>，使用超级管理员账户来操作。也是测试时比较简单的一种方式。但在下一个插槽结束时段，需要重新注册。<br>
打开web app页面，选择&quot;开发者&quot;-“超级管理”，选择<code>paraSudoWrapper.sudoScheduleParaInitialize</code>如下图：</p>
<img src="/articles/c7670c6a/3.png" class="" title="注册平行链">
<p><code>ParaId</code>要设置成<code>2000</code><br>
导入前面生成的文件，文件位置一定要放对.<br>
然后点击提交，完成注册。</p>
<h4 id="2-5-2-通过slots-forcelease完成注册">2.5.2 通过slots.forceLease完成注册</h4>
<p>也就是正常的插槽拍卖机制注册。</p>
<img src="/articles/c7670c6a/4.png" class="" title="注册平行链">
<h2 id="3-清除">3. 清除</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Purge the collator(s)</span></span><br><span class="line">./target/release/parachain-collator purge-chain --base-path ./ tmp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Purge the validator(s)</span></span><br><span class="line">polkadot purge-chain --base-path ./tmp</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文通过加入智能合约模块到节点中的流程，来让开发者了解模块功能整合的整体过程，由浅及深。<br>
按照本文流程，每个结果都可以复现的，亲自实现的。</p>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://docs.substrate.io/quick-start/">Substrate官方文档</a></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Substrate</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Substrate</tag>
      </tags>
  </entry>
  <entry>
    <title>substrate基础(9)-实现简单的pallet</title>
    <url>/articles/7416087e/</url>
    <content><![CDATA[<p>通过本文，可以初步掌握如何实现一个pallet</p>
<span id="more"></span>
<h2 id="1-概述">1. 概述</h2>
<ol>
<li>一条平行链的开发，一般都是基于模板进行开发的：<a href="https://github.com/substrate-developer-hub/substrate-node-template">substrate-node-template</a> ，当然，pallet的也是在其中进行开发</li>
<li><a href="https://github.com/substrate-developer-hub/substrate-node-template">substrate-node-template</a> 根目录中，主要关注3个目录：<code>node</code>、<code>pallet</code>、<code>runtime</code>：
<ol>
<li><code>node</code>：是链的一些基础功能的实现（或者说比较底层的实现，如网络、rpc，搭建链的最基础的code)，一般情况下，很少去动这个目录的内容</li>
<li><code>pallet</code>：各个pallet都是在该目录下汇总的，可以理解成是一个个的业务功能包。当然<code>substrate</code>本身也提供了很多现成的pallet，可以直接引用</li>
<li><code>runtime</code>：用于整合<code>pallet</code>中的功能，并运行</li>
</ol>
</li>
<li>本文是要了解如何在自定义的pallet中使用宏。实现如下案例功能：<br>
构建一个简单的存在证明（验证你手中的数字对象在链上是否存在，是否正确，归属人是否正确等）<br>
本文主要可以掌握：
<ol>
<li>如何将事件、错误、存储和可调用函数添加到自定义托拍。</li>
<li>如何将自定义托盘集成到运行时。</li>
<li>如何编译和启动包含自定义托盘的节点。</li>
<li>如何添加 React 前端组件以向用户公开自定义托盘。</li>
</ol>
</li>
</ol>
<h2 id="2-设计存在证明程序">2. 设计存在证明程序</h2>
<p>要求存储有关已声明的证明以及谁提出了这些声明的信息。即POE证明<br>
公开两个可供调用的函数：</p>
<ol>
<li><code>create_claim()</code>：允许用户通过上传哈希来声明文件存在</li>
<li><code>revoke_claim()</code>：允许声明当前所有者撤销所有权</li>
</ol>
<h2 id="3-为自定义pallet设置脚手架">3. 为自定义pallet设置脚手架</h2>
<ol>
<li>进入目录：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd pallets/template/src</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>删除文件：<br>
测试相关文件，目前不需要，后续若想掌握，可单独查阅资料</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">benchmarking.rs</span><br><span class="line">mock.rs</span><br><span class="line">tests.rs</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>打开<code>lib.rs</code>，删除其中所有代码；然后在其中加入如下代码，这个其实就是pallet的基本格式：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. Imports and Dependencies</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> pallet::*;</span><br><span class="line"><span class="meta">#[frame_support::pallet]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> pallet &#123;</span><br><span class="line">   <span class="keyword">use</span> frame_support::pallet_prelude::*;</span><br><span class="line">   <span class="keyword">use</span> frame_system::pallet_prelude::*;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2. Declaration of the Pallet type</span></span><br><span class="line">   <span class="comment">// This is a placeholder to implement traits and methods.</span></span><br><span class="line">   <span class="meta">#[pallet::pallet]</span></span><br><span class="line">   <span class="meta">#[pallet::generate_store(pub(super) trait Store)]</span></span><br><span class="line">   <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Pallet</span>&lt;T&gt;(_);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3. Runtime Configuration Trait</span></span><br><span class="line">   <span class="comment">// All types and constants go here.</span></span><br><span class="line">   <span class="comment">// Use #[pallet::constant] and #[pallet::extra_constants]</span></span><br><span class="line">   <span class="comment">// to pass in values to metadata.</span></span><br><span class="line">   <span class="meta">#[pallet::config]</span></span><br><span class="line">   <span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Config</span>: frame_system::Config &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4. Runtime Storage</span></span><br><span class="line">   <span class="comment">// Use to declare storage items.</span></span><br><span class="line">   <span class="meta">#[pallet::storage]</span></span><br><span class="line">   <span class="meta">#[pallet::getter(fn something)]</span></span><br><span class="line">   <span class="keyword">pub</span> MyStorage&lt;T: Config&gt; = StorageValue&lt;_, <span class="type">u32</span>&gt;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 5. Runtime Events</span></span><br><span class="line">   <span class="comment">// Can stringify event types to metadata.</span></span><br><span class="line">   <span class="meta">#[pallet::event]</span></span><br><span class="line">   <span class="meta">#[pallet::generate_deposit(pub(super) fn deposit_event)]</span></span><br><span class="line">   <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Event</span>&lt;T: Config&gt; &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 6. Hooks</span></span><br><span class="line">   <span class="comment">// Define some logic that should be executed</span></span><br><span class="line">   <span class="comment">// regularly in some context, for e.g. on_initialize.</span></span><br><span class="line">   <span class="meta">#[pallet::hooks]</span></span><br><span class="line">   <span class="keyword">impl</span>&lt;T: Config&gt; Hooks&lt;BlockNumberFor&lt;T&gt;&gt; <span class="keyword">for</span> <span class="title class_">Pallet</span>&lt;T&gt; &#123; ... &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 7. Extrinsics</span></span><br><span class="line">   <span class="comment">// Functions that are callable from outside the runtime.</span></span><br><span class="line">   <span class="meta">#[pallet::call]</span></span><br><span class="line">   <span class="keyword">impl</span>&lt;T:Config&gt; Pallet&lt;T&gt; &#123; ... &#125;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，一个pallet大体需要实现以下内容：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1. 依赖; </span><br><span class="line">2. pallet类型声明;</span><br><span class="line">3. config trait;</span><br><span class="line">4. 定义要使用的链上存储;</span><br><span class="line">5. 事件;</span><br><span class="line">6. 钩子函数;</span><br><span class="line">7. 交易调用函数;</span><br></pre></td></tr></table></figure>
<p>1和2基本上是固定的写法，而对于后面的3-7部分，则是根据实际需要写或者不写。</p>
<h2 id="4-为pallet配置事件">4. 为pallet配置事件</h2>
<p>每个<code>pallet</code>都有一个称为<code>Config</code>的特征。可以用这个属性来为<code>pallet</code>配置所需要的设置</p>
<ol>
<li>在<code>pallets/template/src/lib.rs</code>中，在<code>#[pallet::config]</code>之后新增内容：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Configure the pallet by specifying the parameters and types on which it depends.</span></span><br><span class="line"><span class="meta">#[pallet::config]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Config</span>: frame_system::Config &#123;</span><br><span class="line">    <span class="comment">/// Because this pallet emits events, it depends on the runtime&#x27;s definition of an event.</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Event</span>: <span class="built_in">From</span>&lt;Event&lt;<span class="keyword">Self</span>&gt;&gt; + IsType&lt;&lt;<span class="keyword">Self</span> <span class="keyword">as</span> frame_system::Config&gt;::Event&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>实现事件<br>
要确保在如下行为时触发事件： <code>当新证明添加到区块链时</code>以及<code>当证明被撤销时</code><br>
打开<code>pallets/template/src/lib.rs</code>，在<code>#[pallet::event]</code>后编辑代码：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Pallets use events to inform users when important changes are made.</span></span><br><span class="line"><span class="comment">// Event documentation should end with an array that provides descriptive names for parameters.</span></span><br><span class="line"><span class="meta">#[pallet::event]</span></span><br><span class="line"><span class="meta">#[pallet::generate_deposit(pub(super) fn deposit_event)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Event</span>&lt;T: Config&gt; &#123;</span><br><span class="line">    <span class="comment">/// Event emitted when a claim has been created.</span></span><br><span class="line">    ClaimCreated &#123; who: T::AccountId, claim: T::Hash &#125;,</span><br><span class="line">    <span class="comment">/// Event emitted when a claim is revoked by the owner.</span></span><br><span class="line">    ClaimRevoked &#123; who: T::AccountId, claim: T::Hash &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误处理，打开<code>pallets/template/src/lib.rs</code>，在<code>#[pallet::error]</code>后编辑代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[pallet::error]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Error</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/// The claim already exists.</span></span><br><span class="line">    AlreadyClaimed,</span><br><span class="line">    <span class="comment">/// The claim does not exist, so it cannot be revoked.</span></span><br><span class="line">    NoSuchClaim,</span><br><span class="line">    <span class="comment">/// The claim is owned by another account, so caller can&#x27;t revoke it.</span></span><br><span class="line">    NotClaimOwner,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>实现存储映射<br>
打开<code>pallets/template/src/lib.rs</code>,在<code>#[pallet::error]</code>后编辑代码：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[pallet::storage]</span></span><br><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">super</span>) <span class="keyword">type</span> <span class="title class_">Claims</span>&lt;T: Config&gt; = StorageMap&lt;_, Blake2_128Concat, T::Hash, (T::AccountId, T::BlockNumber)&gt;;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>实现公开的两个可调用函数(即前面提到的<code>create_claim()</code>和<code>revoke_claim()</code>)<br>
具体功能直接看代码吧，很简单：<br>
打开<code>pallets/template/src/lib.rs</code>,在<code>#[pallet::call]</code>后编辑代码：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dispatchable functions allow users to interact with the pallet and invoke state changes.</span></span><br><span class="line"><span class="comment">// These functions materialize as &quot;extrinsics&quot;, which are often compared to transactions.</span></span><br><span class="line"><span class="comment">// Dispatchable functions must be annotated with a weight and must return a DispatchResult.</span></span><br><span class="line"><span class="meta">#[pallet::call]</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">#[pallet::weight(0)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">create_claim</span>(origin: OriginFor&lt;T&gt;, claim: T::Hash) <span class="punctuation">-&gt;</span> DispatchResult &#123;</span><br><span class="line">        <span class="comment">// Check that the extrinsic was signed and get the signer.</span></span><br><span class="line">        <span class="comment">// This function will return an error if the extrinsic is not signed.</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">sender</span> = <span class="title function_ invoke__">ensure_signed</span>(origin)?;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Verify that the specified claim has not already been stored.</span></span><br><span class="line">        ensure!(!Claims::&lt;T&gt;::<span class="title function_ invoke__">contains_key</span>(&amp;claim), Error::&lt;T&gt;::AlreadyClaimed);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the block number from the FRAME System pallet.</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">current_block</span> = &lt;frame_system::Pallet&lt;T&gt;&gt;::<span class="title function_ invoke__">block_number</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Store the claim with the sender and block number.</span></span><br><span class="line">        Claims::&lt;T&gt;::<span class="title function_ invoke__">insert</span>(&amp;claim, (&amp;sender, current_block));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Emit an event that the claim was created.</span></span><br><span class="line">        <span class="keyword">Self</span>::<span class="title function_ invoke__">deposit_event</span>(Event::ClaimCreated &#123; who: sender, claim &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[pallet::weight(0)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">revoke_claim</span>(origin: OriginFor&lt;T&gt;, claim: T::Hash) <span class="punctuation">-&gt;</span> DispatchResult &#123;</span><br><span class="line">        <span class="comment">// Check that the extrinsic was signed and get the signer.</span></span><br><span class="line">        <span class="comment">// This function will return an error if the extrinsic is not signed.</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">sender</span> = <span class="title function_ invoke__">ensure_signed</span>(origin)?;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get owner of the claim, if none return an error.</span></span><br><span class="line">        <span class="keyword">let</span> (owner, _) = Claims::&lt;T&gt;::<span class="title function_ invoke__">get</span>(&amp;claim).<span class="title function_ invoke__">ok_or</span>(Error::&lt;T&gt;::NoSuchClaim)?;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Verify that sender of the current call is the claim owner.</span></span><br><span class="line">        ensure!(sender == owner, Error::&lt;T&gt;::NotClaimOwner);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remove claim from storage.</span></span><br><span class="line">        Claims::&lt;T&gt;::<span class="title function_ invoke__">remove</span>(&amp;claim);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Emit an event that the claim was erased.</span></span><br><span class="line">        <span class="keyword">Self</span>::<span class="title function_ invoke__">deposit_event</span>(Event::ClaimRevoked &#123; who: sender, claim &#125;);</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>项目根目录检测是否能够编译成功：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo check -p node-template-runtime</span><br></pre></td></tr></table></figure>
<h2 id="5-启动节点并连接页面进行交互">5. 启动节点并连接页面进行交互</h2>
<h3 id="5-1-编译并启动节点">5.1 编译并启动节点</h3>
<p>回到项目根目录，编译节点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo build --release</span><br></pre></td></tr></table></figure>
<p>启动节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./target/release/node-template --dev --base-path ./tmp/</span><br></pre></td></tr></table></figure>
<h3 id="5-2-前端页面">5.2 前端页面</h3>
<p>打开web <a href="https://polkadot.js.org/apps">polkadot-app</a> ，将网络连接到刚刚启动的节点，然后前往：<code>开发者</code>-<code>交易</code></p>

<p>文件hash上链<br>
按如下图选择，然后添加要hash的文件，最后&quot;提交交易&quot;<br>
同样类似方式，可以撤销文件的hash，这里就不演示了</p>
<h2 id="6-总结">6. 总结</h2>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://docs.substrate.io/quick-start/">Substrate官方文档</a>å</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Substrate</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Substrate</tag>
      </tags>
  </entry>
  <entry>
    <title>substrate基础(8)-添加智能合约pallet到runtime</title>
    <url>/articles/949c0277/</url>
    <content><![CDATA[<p>本文依旧基于<a href="https://github.com/substrate-developer-hub/substrate-node-template">substrate-node-template</a> 进行操作.<br>
该项目主要是为了方便开发人员调试和测试，以及初次接触substrate的入门者首选，掌握该项目后，再去接触正式项目，会容易很多<br>
本文假定你已经编译好了这个项目，具体编译可以参考本系列第一篇文章：<a href="https://www.bitxx.top/articles/113dc518/">substrate基础(1)-substrate-node-template编译及部署</a></p>
<p>本文是要将智能合约的pallet添加到runtime中</p>
<span id="more"></span>
<h2 id="1-添加合约模块">1. 添加合约模块</h2>
<h3 id="1-1-添加依赖">1.1 添加依赖</h3>
<p>在项目根目录，编辑文件<code>runtime/Cargo.toml</code>：<br>
在<code>[dependencies]</code>下添加：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pallet-contracts：不要直接复制我的。其中的version default-features branch请参考该[dependencies]中相同git属性别的依赖所使用的，保持一致即可，否则编译很可能会失败。</span></span><br><span class="line"><span class="attr">pallet-contracts</span> = &#123; version = <span class="string">&quot;4.0.0-dev&quot;</span>, default-features = <span class="literal">false</span>, git = <span class="string">&quot;https://github.com/paritytech/substrate.git&quot;</span>, branch = <span class="string">&quot;polkadot-v0.9.24&quot;</span> &#125;</span><br><span class="line"><span class="comment"># pallet-contracts-primitives：建议前往substrate的branch分支，找对应的pallet-contracts，在cargo.toml文件中，找到正确的pallet-contracts-primitives版本号</span></span><br><span class="line"><span class="attr">pallet-contracts-primitives</span> = &#123; version = <span class="string">&quot;6.0.0&quot;</span>, default-features = <span class="literal">false</span>, git = <span class="string">&quot;https://github.com/paritytech/substrate.git&quot;</span>, branch = <span class="string">&quot;polkadot-v0.9.24&quot;</span> &#125;</span><br></pre></td></tr></table></figure>
<p>在<code>[features]</code>的<code>std[]</code>中，添加如下两行：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">&#x27;pallet-contracts/std&#x27;,</span><br><span class="line">&#x27;pallet-contracts-primitives/std&#x27;,</span><br></pre></td></tr></table></figure>
<p>然后在当前目录<code>runtime/</code>下检测是否能够编译成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo check -p pallet-contracts</span><br><span class="line">cargo check -p pallet-contracts-primitives</span><br></pre></td></tr></table></figure>
<h3 id="1-2-在runtime中添加contract相关配置">1.2 在runtime中添加contract相关配置</h3>
<p><code>注</code>：由于合约版本问题，需要根据编译提示，对以下代码做相应调整。（默认官方提供的示例代码我是跑不通，自己按如下做的调整），具体每步骤如下：</p>
<ol>
<li>编辑<code>runtime/src/lib.rs</code>，在<code>pub use frame_support</code>代码块中的<code>traits</code>中添加上<code>Nothing</code>，如下：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">traits::&#123;</span><br><span class="line">    ConstU128, ConstU32, ConstU64, ConstU8, KeyOwnerProofSystem, Randomness, StorageInfo,Nothing</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>编辑<code>runtime/src/lib.rs</code>，添加如下：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在这行代码之后</span></span><br><span class="line"><span class="keyword">use</span> pallet_transaction_payment::CurrencyAdapter;</span><br><span class="line"><span class="comment">//添加这一行</span></span><br><span class="line"><span class="keyword">use</span> pallet_contracts::weights::WeightInfo;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>编辑<code>runtime/src/lib.rs</code>，添加如下静态变量：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//索引到在这三行之后</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> MINUTES: BlockNumber = <span class="number">60_000</span> / (MILLISECS_PER_BLOCK <span class="keyword">as</span> BlockNumber);</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> HOURS: BlockNumber = MINUTES * <span class="number">60</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> DAYS: BlockNumber = HOURS * <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加下方代码 */</span></span><br><span class="line"><span class="comment">// Contracts price units.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> MILLICENTS: Balance = <span class="number">1_000_000_000</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> CENTS: Balance = <span class="number">1_000</span> * MILLICENTS;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> DOLLARS: Balance = <span class="number">100</span> * CENTS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">fn</span> <span class="title function_">deposit</span>(items: <span class="type">u32</span>, bytes: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> Balance &#123;</span><br><span class="line">	items <span class="keyword">as</span> Balance * <span class="number">15</span> * CENTS + (bytes <span class="keyword">as</span> Balance) * <span class="number">6</span> * CENTS</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Assume ~10% of the block weight is consumed by `on_initialize` handlers.</span></span><br><span class="line"><span class="comment">/// This is used to limit the maximal weight of a single extrinsic.</span></span><br><span class="line"><span class="keyword">const</span> AVERAGE_ON_INITIALIZE_RATIO: Perbill = Perbill::<span class="title function_ invoke__">from_percent</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>编辑<code>runtime/src/lib.rs</code>，在方法<code>impl pallet_timestamp::Config for Runtime&#123; xxx &#125;</code>之后增加如下代码块：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">parameter_types! &#123;</span><br><span class="line">	<span class="keyword">pub</span> <span class="keyword">const</span> DepositPerStorageByte: Balance = <span class="title function_ invoke__">deposit</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">pub</span> <span class="keyword">const</span> DepositPerStorageItem: Balance = <span class="title function_ invoke__">deposit</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">pub</span> RentFraction: Perbill = Perbill::<span class="title function_ invoke__">from_rational</span>(<span class="number">1u32</span>, <span class="number">30</span> * DAYS);</span><br><span class="line">	<span class="keyword">pub</span> <span class="keyword">const</span> SurchargeReward: Balance = <span class="number">150</span> * MILLICENTS;</span><br><span class="line">	<span class="keyword">pub</span> <span class="keyword">const</span> SignedClaimHandicap: <span class="type">u32</span> = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">pub</span> <span class="keyword">const</span> MaxValueSize: <span class="type">u32</span> = <span class="number">16</span> * <span class="number">1024</span>;</span><br><span class="line">	<span class="comment">// The lazy deletion runs inside on_initialize.</span></span><br><span class="line">	<span class="keyword">pub</span> DeletionWeightLimit: Weight = AVERAGE_ON_INITIALIZE_RATIO *</span><br><span class="line">	 BlockWeights::<span class="title function_ invoke__">get</span>().max_block;</span><br><span class="line">	<span class="comment">// The weight needed for decoding the queue should be less or equal than a fifth</span></span><br><span class="line">	<span class="comment">// of the overall weight dedicated to the lazy deletion.</span></span><br><span class="line">	<span class="keyword">pub</span> DeletionQueueDepth: <span class="type">u32</span> = ((DeletionWeightLimit::<span class="title function_ invoke__">get</span>() / (</span><br><span class="line">		&lt;Runtime <span class="keyword">as</span> pallet_contracts::Config&gt;::WeightInfo::<span class="title function_ invoke__">on_initialize_per_queue_item</span>(<span class="number">1</span>) -</span><br><span class="line">		&lt;Runtime <span class="keyword">as</span> pallet_contracts::Config&gt;::WeightInfo::<span class="title function_ invoke__">on_initialize_per_queue_item</span>(<span class="number">0</span>)</span><br><span class="line">	 )) / <span class="number">5</span>) <span class="keyword">as</span> <span class="type">u32</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pub</span> Schedule: pallet_contracts::Schedule&lt;Runtime&gt; = <span class="built_in">Default</span>::<span class="title function_ invoke__">default</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">pallet_contracts</span>::Config <span class="keyword">for</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Time</span> = Timestamp;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Randomness</span> = RandomnessCollectiveFlip;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Currency</span> = Balances;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Event</span> = Event;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">WeightPrice</span> = pallet_transaction_payment::Pallet&lt;<span class="keyword">Self</span>&gt;;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">WeightInfo</span> = pallet_contracts::weights::SubstrateWeight&lt;<span class="keyword">Self</span>&gt;;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">ChainExtension</span> = ();</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">DeletionQueueDepth</span> = DeletionQueueDepth;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">DeletionWeightLimit</span> = DeletionWeightLimit;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Call</span> = Call;</span><br><span class="line">    <span class="comment">/// The safest default is to allow no calls at all.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// Runtimes should whitelist dispatchables that are allowed to be called from contracts</span></span><br><span class="line">    <span class="comment">/// and make sure they are stable. Dispatchables exposed to contracts are not allowed to</span></span><br><span class="line">    <span class="comment">/// change because that would break already deployed contracts. The `Call` structure itself</span></span><br><span class="line">    <span class="comment">/// is not allowed to change the indices of existing pallets, too.</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">CallFilter</span> = Nothing;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Schedule</span> = Schedule;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">CallStack</span> = [pallet_contracts::Frame&lt;<span class="keyword">Self</span>&gt;; <span class="number">31</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">DepositPerByte</span> = DepositPerStorageByte;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">ContractAccessWeight</span> = pallet_contracts::DefaultContractAccessWeight&lt;BlockWeights&gt;;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">DepositPerItem</span> = DepositPerStorageItem;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">AddressGenerator</span> =  pallet_contracts::DefaultAddressGenerator;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">MaxCodeLen</span> = ConstU32&lt;&#123; <span class="number">128</span> * <span class="number">1024</span> &#125;&gt;;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">RelaxedMaxCodeLen</span> = ConstU32&lt;&#123; <span class="number">256</span> * <span class="number">1024</span> &#125;&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6<code>runtime/src/lib.rs</code>，在<code>construct_runtime!</code>宏代码块中的<code>Runtime枚举</code>添加下方代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">Contracts: pallet_contracts::&#123;Pallet, Call, Storage, Event&lt;T&gt;&#125;,</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>然后在<code>runtime/</code>目录下检测是否能够编译成功：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo check -p node-template-runtime</span><br></pre></td></tr></table></figure>
<h2 id="2-公开contract的接口">2. 公开contract的接口</h2>
<h3 id="2-1-添加依赖">2.1 添加依赖</h3>
<p>在项目根目录，编辑文件<code>runtime/Cargo.toml</code>：<br>
在<code>[dependencies]</code>下添加：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pallet-contracts：不要直接复制我的。其中的version default-features branch请参考该[dependencies]中相同git属性别的依赖所使用的，保持一致即可，否则编译很可能会失败。</span></span><br><span class="line"><span class="attr">pallet-contracts-rpc-runtime-api</span> = &#123; version = <span class="string">&quot;4.0.0-dev&quot;</span>, default-features = <span class="literal">false</span>, git = <span class="string">&quot;https://github.com/paritytech/substrate.git&quot;</span>, branch = <span class="string">&quot;polkadot-v0.9.24&quot;</span> &#125;</span><br></pre></td></tr></table></figure>
<p>在<code>[features]</code>的<code>std[]</code>中，添加如下两行：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">&#x27;pallet-contracts-rpc-runtime-api/std&#x27;,</span><br></pre></td></tr></table></figure>
<p>然后在当前目录<code>runtime/</code>下检测是否能够编译成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo check -p pallet-contracts-rpc-runtime-api</span><br></pre></td></tr></table></figure>
<h3 id="2-2-在runtime中添加contract接口相关配置">2.2 在runtime中添加contract接口相关配置</h3>
<ol>
<li>在代码块<code>impl_runtime_apis!&#123;xxx&#125;</code>中追加如下代码：<br>
<code>注：</code>需要根据导入的依赖版本号对如下代码进行调整，我这里直接用官方提供的代码会报错，根据自己的版本号做了改动。具体你也可以去<code>substrate</code>对应版本中找相应新的代码该如何更改</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">pallet_contracts_rpc_runtime_api</span>::ContractsApi&lt;</span><br><span class="line">		Block, AccountId, Balance, BlockNumber, Hash,</span><br><span class="line">	&gt;</span><br><span class="line">		<span class="keyword">for</span> <span class="title class_">Runtime</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">fn</span> <span class="title function_">call</span>(</span><br><span class="line">			origin: AccountId,</span><br><span class="line">			dest: AccountId,</span><br><span class="line">			value: Balance,</span><br><span class="line">			gas_limit: <span class="type">u64</span>,</span><br><span class="line">			storage_deposit_limit: <span class="type">Option</span>&lt;Balance&gt;,</span><br><span class="line">			input_data: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;,</span><br><span class="line">		) <span class="punctuation">-&gt;</span> pallet_contracts_primitives::ContractExecResult&lt;Balance&gt; &#123;</span><br><span class="line">			Contracts::<span class="title function_ invoke__">bare_call</span>(origin, dest, value, gas_limit, storage_deposit_limit, input_data, <span class="literal">true</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">fn</span> <span class="title function_">instantiate</span>(</span><br><span class="line">			origin: AccountId,</span><br><span class="line">			value: Balance,</span><br><span class="line">			gas_limit: <span class="type">u64</span>,</span><br><span class="line">			storage_deposit_limit: <span class="type">Option</span>&lt;Balance&gt;,</span><br><span class="line">			code: pallet_contracts_primitives::Code&lt;Hash&gt;,</span><br><span class="line">			data: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;,</span><br><span class="line">			salt: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;,</span><br><span class="line">		) <span class="punctuation">-&gt;</span> pallet_contracts_primitives::ContractInstantiateResult&lt;AccountId, Balance&gt;</span><br><span class="line">		&#123;</span><br><span class="line">			Contracts::<span class="title function_ invoke__">bare_instantiate</span>(origin, value, gas_limit, storage_deposit_limit, code, data, salt, <span class="literal">true</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">fn</span> <span class="title function_">upload_code</span>(</span><br><span class="line">			origin: AccountId,</span><br><span class="line">			code: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;,</span><br><span class="line">			storage_deposit_limit: <span class="type">Option</span>&lt;Balance&gt;,</span><br><span class="line">		) <span class="punctuation">-&gt;</span> pallet_contracts_primitives::CodeUploadResult&lt;Hash, Balance&gt;</span><br><span class="line">		&#123;</span><br><span class="line">			Contracts::<span class="title function_ invoke__">bare_upload_code</span>(origin, code, storage_deposit_limit)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">fn</span> <span class="title function_">get_storage</span>(</span><br><span class="line">			address: AccountId,</span><br><span class="line">			key: [<span class="type">u8</span>; <span class="number">32</span>],</span><br><span class="line">		) <span class="punctuation">-&gt;</span> pallet_contracts_primitives::GetStorageResult &#123;</span><br><span class="line">			Contracts::<span class="title function_ invoke__">get_storage</span>(address, key)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>然后在<code>runtime/</code>目录下检测是否能够编译成功：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo check -p node-template-runtime</span><br></pre></td></tr></table></figure>
<h2 id="3-更新外部节点">3. 更新外部节点</h2>
<p>前面对合约做了变更，那外部节点相应的代码也需要做一些调整，以便兼容合约</p>
<h3 id="3-1-添加依赖">3.1 添加依赖</h3>
<p>在项目根目录，编辑文件<code>node/Cargo.toml</code>：<br>
在<code>[dependencies]</code>下添加：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pallet-contracts：不要直接复制我的。其中的version default-features branch请参考该[dependencies]中相同git属性别的依赖所使用的，保持一致即可，否则编译很可能会失败。</span></span><br><span class="line"><span class="attr">pallet-contracts</span> = &#123; version = <span class="string">&quot;4.0.0-dev&quot;</span>, git = <span class="string">&quot;https://github.com/paritytech/substrate.git&quot;</span>, branch = <span class="string">&quot;polkadot-v0.9.24&quot;</span> &#125;</span><br><span class="line"><span class="attr">pallet-contracts-rpc</span> = &#123; version = <span class="string">&quot;4.0.0-dev&quot;</span>, git = <span class="string">&quot;https://github.com/paritytech/substrate.git&quot;</span>, branch = <span class="string">&quot;polkadot-v0.9.24&quot;</span> &#125;</span><br></pre></td></tr></table></figure>
<p>然后在当前目录<code>runtime/</code>下检测是否能够编译成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo check -p pallet-contracts</span><br></pre></td></tr></table></figure>
<h3 id="3-2-添加配置">3.2 添加配置</h3>
<p>和官方提供文档提供的有些许不一样，根据实际情况要做调整，此处只是满足我能够正常运行起来<br>
在项目根目录，编辑文件<code>node/src/rpc.rs</code>：</p>
<ol>
<li>增加两行：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个是原本就有这一行，后面加上BlockNumber和Hash</span></span><br><span class="line"><span class="keyword">use</span> node_template_runtime::&#123;opaque::Block, AccountId, Balance, Index, BlockNumber, Hash&#125;;  <span class="comment">//这个是原本就有这一行，后面加上BlockNumber和Hash</span></span><br><span class="line"><span class="comment">//新增这一行</span></span><br><span class="line"><span class="keyword">use</span> pallet_contracts_rpc::&#123;Contracts, ContractsApi&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在<code>pub fn create_full&lt;C, P&gt;</code>代码块中：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该行之后</span></span><br><span class="line">C::Api: substrate_frame_rpc_system::AccountNonceApi&lt;Block, AccountId, Index&gt;,</span><br><span class="line"><span class="comment">//新增这一行：</span></span><br><span class="line">C::Api: pallet_contracts_rpc::ContractsRuntimeApi&lt;Block, AccountId, Balance, BlockNumber, Hash&gt;,</span><br><span class="line"><span class="comment">//该行之后</span></span><br><span class="line">module.<span class="title function_ invoke__">merge</span>(TransactionPayment::<span class="title function_ invoke__">new</span>(client).<span class="title function_ invoke__">into_rpc</span>())?;</span><br><span class="line"><span class="comment">//新增这一行</span></span><br><span class="line">module.<span class="title function_ invoke__">merge</span>(Contracts::<span class="title function_ invoke__">new</span>(client.<span class="title function_ invoke__">clone</span>()).<span class="title function_ invoke__">into_rpc</span>())?;</span><br></pre></td></tr></table></figure>
<p>3然后在项目根目录下检测是否能够编译成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo check -p node-template-runtime</span><br></pre></td></tr></table></figure>
<h2 id="4-启动节点并连接页面进行交互">4. 启动节点并连接页面进行交互</h2>
<h3 id="4-1-编译并启动节点">4.1 编译并启动节点</h3>
<p>回到项目根目录，编译节点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo build --release</span><br></pre></td></tr></table></figure>
<p>启动节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./target/release/node-template --dev --base-path ./tmp/</span><br></pre></td></tr></table></figure>
<h3 id="4-2-启动web">4.2 启动web</h3>
<p><a href="https://github.com/substrate-developer-hub/substrate-front-end-template">substrate-front-end-template</a> 可视化，具体编译和部署，请自行查阅资料或参考:<a href="https://www.bitxx.top/articles/113dc518/">substrate基础(1)-substrate-node-template编译及部署</a></p>
<h3 id="4-3-操作相应接口">4.3 操作相应接口</h3>
<p>在web页面中，根据需要操作相应接口</p>
<h2 id="总结">总结</h2>
<p>本文通过加入智能合约模块到节点中的流程，来让开发者了解模块功能整合的整体过程，由浅及深。<br>
按照本文流程，每个结果都可以复现的，亲自实现的。</p>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://docs.substrate.io/quick-start/">Substrate官方文档</a></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Substrate</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Substrate</tag>
      </tags>
  </entry>
  <entry>
    <title>substrate基础(7)-将pallet添加到runtime</title>
    <url>/articles/d0691bdb/</url>
    <content><![CDATA[<p>本文依旧基于<a href="https://github.com/substrate-developer-hub/substrate-node-template">substrate-node-template</a> 进行操作.<br>
该项目主要是为了方便开发人员调试和测试，以及初次接触substrate的入门者首选，掌握该项目后，再去接触正式项目，会容易很多<br>
本文假定你已经编译好了这个项目，具体编译可以参考本系列第一篇文章：<a href="https://www.bitxx.top/articles/113dc518/">substrate基础(1)-substrate-node-template编译及部署</a></p>
<p>本文通过案例主要介绍如何将pallet添加到runtime：</p>
<ol>
<li>质押费用来为自己的账户设置一个昵称</li>
<li>删除该账户自定义昵称并退还质押费用</li>
<li>在不退还质押的情况下强行删除该账户的昵称</li>
</ol>
<span id="more"></span>
<h2 id="1-添加依赖">1. 添加依赖</h2>
<p>在项目根目录，编辑文件<code>runtime/Cargo.toml</code>：<br>
在<code>[dependencies]</code>下添加：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不要直接复制我这一行。其中的version default-features branch请参考该[dependencies]中相同git属性别的依赖所使用的，保持一致即可，否则编译很可能会失败。</span></span><br><span class="line"><span class="attr">pallet-nicks</span> = &#123; version = <span class="string">&quot;4.0.0-dev&quot;</span>, default-features = <span class="literal">false</span>, git = <span class="string">&quot;https://github.com/paritytech/substrate.git&quot;</span>, branch = <span class="string">&quot;polkadot-v0.9.28&quot;</span> &#125;</span><br></pre></td></tr></table></figure>
<p>在<code>[features]</code>的<code>std[]</code>中，添加如下一行：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">&#x27;pallet-nicks/std&#x27;, </span><br></pre></td></tr></table></figure>
<p>然后在当前目录<code>runtime/</code>下检测是否能够编译成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo check -p pallet-nicks</span><br></pre></td></tr></table></figure>
<h2 id="2-查看nick-pallet的配置并在runtime中添加相关参数">2. 查看nick-pallet的配置并在runtime中添加相关参数</h2>
<ol>
<li>查看<a href="https://github.com/paritytech/substrate/blob/master/frame/nicks/src/lib.rs">昵称plate配置源码</a> ：<br>
其中已经声明的内容：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[pallet::config]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Config</span>: frame_system::Config &#123;</span><br><span class="line">    <span class="comment">/// The overarching event type.</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Event</span>: <span class="built_in">From</span>&lt;Event&lt;<span class="keyword">Self</span>&gt;&gt; + IsType&lt;&lt;<span class="keyword">Self</span> <span class="keyword">as</span> frame_system::Config&gt;::Event&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The currency trait.</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Currency</span>: ReservableCurrency&lt;<span class="keyword">Self</span>::AccountId&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Reservation fee.</span></span><br><span class="line">    <span class="comment">/// 预留费用，也就是质押费用</span></span><br><span class="line">    <span class="meta">#[pallet::constant]</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">ReservationFee</span>: Get&lt;BalanceOf&lt;<span class="keyword">Self</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// What to do with slashed funds.</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Slashed</span>: OnUnbalanced&lt;NegativeImbalanceOf&lt;<span class="keyword">Self</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The origin which may forcibly set or remove a name. Root can always do this.</span></span><br><span class="line">    <span class="comment">/// 谁可以强制设置或修改昵称，root账户可以随时修改</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">ForceOrigin</span>: EnsureOrigin&lt;<span class="keyword">Self</span>::Origin&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The minimum length a name may be.</span></span><br><span class="line">    <span class="comment">/// 昵称最小长度</span></span><br><span class="line">    <span class="meta">#[pallet::constant]</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">MinLength</span>: Get&lt;<span class="type">u32</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The maximum length a name may be.</span></span><br><span class="line">    <span class="comment">/// 昵称最大长度</span></span><br><span class="line">    <span class="meta">#[pallet::constant]</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">MaxLength</span>: Get&lt;<span class="type">u32</span>&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>编辑<code>runtime/src/lib.rs</code>，在<code>parameter_types!</code>宏代码块中添加下方代码：<br>
这个<code>parameter_types!</code>主要是用来设置管理全局变量的</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">parameter_types! &#123;</span><br><span class="line">	<span class="comment">// Choose a fee that incentivizes desireable behavior.</span></span><br><span class="line">	<span class="keyword">pub</span> <span class="keyword">const</span> NickReservationFee: <span class="type">u128</span> = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">pub</span> <span class="keyword">const</span> MinNickLength: <span class="type">u32</span> = <span class="number">8</span>;</span><br><span class="line">	<span class="comment">// Maximum bounds on storage are important to secure your chain.</span></span><br><span class="line">	<span class="keyword">pub</span> <span class="keyword">const</span> MaxNickLength: <span class="type">u32</span> = <span class="number">32</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>runtime/src/lib.rs</code>添加如下代码块：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">pallet_nicks</span>::Config <span class="keyword">for</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">	<span class="comment">// The Balances pallet implements the ReservableCurrency trait.</span></span><br><span class="line">	<span class="comment">// `Balances` is defined in `construct_runtime!` macro. See below.</span></span><br><span class="line">	<span class="comment">// https://paritytech.github.io/substrate/master/pallet_balances/index.html#implementations-2</span></span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">Currency</span> = Balances;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Use the NickReservationFee from the parameter_types block.</span></span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">ReservationFee</span> = NickReservationFee;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// No action is taken when deposits are forfeited.</span></span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">Slashed</span> = ();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Configure the FRAME System Root origin as the Nick pallet admin.</span></span><br><span class="line">	<span class="comment">// https://paritytech.github.io/substrate/master/frame_system/enum.RawOrigin.html#variant.Root</span></span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">ForceOrigin</span> = frame_system::EnsureRoot&lt;AccountId&gt;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Use the MinNickLength from the parameter_types block.</span></span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">MinLength</span> = MinNickLength;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Use the MaxNickLength from the parameter_types block.</span></span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">MaxLength</span> = MaxNickLength;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The ubiquitous event type.</span></span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">Event</span> = Event;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><code>runtime/src/lib.rs</code>，在<code>construct_runtime!</code>宏代码块中的<code>Runtime枚举</code>添加下方代码：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">Nicks: pallet_nicks,</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>然后在<code>runtime/</code>目录下检测是否能够编译成功：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo check -p node-template-runtime</span><br></pre></td></tr></table></figure>
<h2 id="3-启动节点并连接页面进行交互">3. 启动节点并连接页面进行交互</h2>
<h3 id="3-1-编译并启动节点：">3.1 编译并启动节点：</h3>
<p>回到项目根目录，编译节点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo build --release</span><br></pre></td></tr></table></figure>
<p>启动节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./target/release/node-template --dev --base-path ./tmp/</span><br></pre></td></tr></table></figure>
<h3 id="3-2-启动web">3.2 启动web</h3>
<p><a href="https://github.com/substrate-developer-hub/substrate-front-end-template">substrate-front-end-template</a> 可视化，具体编译和部署，请自行查阅资料或参考:<a href="https://www.bitxx.top/articles/113dc518/">substrate基础(1)-substrate-node-template编译及部署</a></p>
<h3 id="3-3-设置昵称">3.3 设置昵称</h3>
<p>页面中，账户为：<code>ALICE</code>，下方<code>Pallet Interactor</code>选中<code>Extrinsic</code>，第一行下拉框<code>Pallets\RPC</code>中，选择<code>nicks</code>；第二行下拉框<code>Callables</code>中，选中<code>setName</code>。然后下方文本框输入昵称：<code>HelloPlate</code>，最后执行<code>Signed</code></p>
<img src="/articles/d0691bdb/1.png" class="" title="设置昵称">
<h3 id="3-4-查询昵称">3.4 查询昵称</h3>
<p>页面中，账户为：<code>ALICE</code>，下方<code>Pallet Interactor</code>选中<code>Query</code>，第一行下拉框<code>Pallets\RPC</code>中，选择<code>nicks</code>；第二行下拉框<code>Callables</code>中，选中<code>nameOf</code>。然后下方文本框输入账户地址(alice的)：<code>5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY</code>，最后执行<code>Query</code></p>
<img src="/articles/d0691bdb/2.png" class="" title="查询账户昵称">
<p>其中返回的是昵称的十六进制编码，以及设置昵称所质押的费用</p>
<h3 id="3-5-其余操作">3.5 其余操作</h3>
<p>其余操作类似，可以自行尝试下sudo</p>
<h2 id="总结">总结</h2>
<p>按照本文流程，每个结果都可以复现的，亲自实现的。</p>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://docs.substrate.io/quick-start/">Substrate官方文档</a></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Substrate</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Substrate</tag>
      </tags>
  </entry>
  <entry>
    <title>substrate基础(6)-新增节点并授权特定节点行为</title>
    <url>/articles/90299bc0/</url>
    <content><![CDATA[<p>本文依旧基于<a href="https://github.com/substrate-developer-hub/substrate-node-template">substrate-node-template</a> 进行操作.<br>
该项目主要是为了方便开发人员调试和测试，以及初次接触substrate的入门者首选，掌握该项目后，再去接触正式项目，会容易很多<br>
本文假定你已经编译好了这个项目，具体编译可以参考本系列第一篇文章：<a href="https://www.bitxx.top/articles/113dc518/">substrate基础(1)-substrate-node-template编译及部署</a></p>
<p>本文主要介绍如何授权特定节点行为：比如授予某些节点验证块的权限，而向其他节点授予传播事务的权限。联盟链等有限网络。<br>
初步掌握pallet添加到runtime中的流程</p>
<span id="more"></span>
<h2 id="1-项目导入授权模块">1. 项目导入授权模块</h2>
<p><a href="https://github.com/substrate-developer-hub/substrate-node-template">substrate-node-template</a><br>
项目中默认没有添加节点授权模块，因此需要先从substrate引入<code>pallet-node-authorization</code>模块。 从项目根目录开始，具体步骤如下：</p>
<ol>
<li>前往<code>runtime/Cargo.toml</code>进行编辑：</li>
</ol>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加入pallet-node-authorization，其中version、branch、default-features要以当前[dependencies]别的依赖的版本号为准（不要直接复制官方文档或者下方的）</span></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">pallet-node-authorization</span> = &#123; version = <span class="string">&quot;4.0.0-dev&quot;</span>, default-features = <span class="literal">false</span>, git = <span class="string">&quot;https://github.com/paritytech/substrate.git&quot;</span>, branch = <span class="string">&quot;polkadot-v0.9.24&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># std中加入一行pallet-node-authorization/std即可</span></span><br><span class="line"><span class="section">[features]</span></span><br><span class="line"><span class="attr">std</span> = [</span><br><span class="line">    <span class="string">&quot;pallet-node-authorization/std&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>再次说明<code>[dependencies]</code>中，<code>pallet-node-authorization</code>的<code>version、branch、default-features</code><br>
属性值，根据同标签下方别的已有的依赖来设置对应的属性，不要复制我提供的，也不要直接复制官方文档的。否则你大概率编译失败。</p>
<ol start="2">
<li>上述操作完成后，依旧是在<code>runtime</code>目录，执行下面命令，检测新添加的<code>node-template-runtime</code>依赖是否正常：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo check -p node-template-runtime</span><br></pre></td></tr></table></figure>
<h2 id="2-添加授权规则">2. 添加授权规则</h2>
<p>本文用来初步了解如何在<code>runtime</code>中添加<code>pattle</code><br>
为了模拟权限管理，我们可以使用<code>sudo pallet</code>来调用权限相关的方法，<code>sudo pallet</code><br>
默认已经是在<a href="https://github.com/substrate-developer-hub/substrate-node-template">substrate-node-template</a> 中，允许你通过<code>root-level</code><br>
来管理账户。在真是项目中，我们一般使用<code>governance-based</code>来更加全面的管理账户。 这里，我们编辑文件：<code>runtime/src/lib.rs</code>，添加一行即可：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> frame_system::EnsureRoot;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-实现pallet的config-trait">2.1 实现pallet的Config trait</h3>
<p>编辑：<code>runtime/src/lib.rs</code></p>
<ol>
<li>在宏<code>parameter_types!</code>模块下新增两行：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> MaxWellKnownNodes: <span class="type">u32</span> = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> MaxPeerIdLength: <span class="type">u32</span> = <span class="number">128</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>新增如下整块代码：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">pallet_node_authorization</span>::Config <span class="keyword">for</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Event</span> = Event;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">MaxWellKnownNodes</span> = MaxWellKnownNodes;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">MaxPeerIdLength</span> = MaxPeerIdLength;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">AddOrigin</span> = EnsureRoot&lt;AccountId&gt;;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">RemoveOrigin</span> = EnsureRoot&lt;AccountId&gt;;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">SwapOrigin</span> = EnsureRoot&lt;AccountId&gt;;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">ResetOrigin</span> = EnsureRoot&lt;AccountId&gt;;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">WeightInfo</span> = ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在宏<code>construct_runtime!</code><br>
的<code>pub enum Runtime where Block = Block, NodeBlock = opaque::Block, UncheckedExtrinsic = UncheckedExtrinsic &#123; xxx &#125;</code><br>
中，新增一行：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">NodeAuthorization: pallet_node_authorization::&#123;Pallet, Call, Storage, Event&lt;T&gt;, Config&lt;T&gt;&#125;,</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>在<code>runtime</code>目录下，检测是否可编译：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo check -p node-template-runtime</span><br></pre></td></tr></table></figure>
<p>正常是完全可编译通过的</p>
<h3 id="2-2-为授权节点添加genesis存储">2.2 为授权节点添加genesis存储</h3>
<p>标题为官方文档提供的，但我认为，这一章节的目的是，通过的代码默认将启动的<code>Alice</code>和<code>Bob</code>两个节点能够自动组成一个网络。<br>
说白了就是在代码层面直接预置两个可信节点。</p>
<p>因为substrate默认节点使用的是<code>bs58</code>编码账户，授权节点要想兼容，则需要加入依赖库</p>
<ol>
<li>在<code>node/Cargo.toml</code>的<code>[dependencies]</code>中加入：</li>
</ol>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="attr">bs58</span> = <span class="string">&quot;0.4.0&quot;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>编辑<code>node/src/chain_spec.rs</code>，添加如下两行：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> sp_core::OpaquePeerId;</span><br><span class="line"><span class="comment">// A struct wraps Vec&lt;u8&gt;, represents as our `PeerId`.</span></span><br><span class="line"><span class="keyword">use</span> node_template_runtime::NodeAuthorizationConfig; <span class="comment">// The genesis config that serves for our pallet.</span></span><br></pre></td></tr></table></figure>
<p>在<code>fn testnet_genesis( *** )</code>最内层的<code>GenesisConfig</code>代码块中添加：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">node_authorization: NodeAuthorizationConfig &#123;</span><br><span class="line">nodes: <span class="built_in">vec!</span>[</span><br><span class="line">    (</span><br><span class="line">        <span class="title function_ invoke__">OpaquePeerId</span>(bs58::<span class="title function_ invoke__">decode</span>(<span class="string">&quot;12D3KooWBmAwcd4PJNJvfV89HwE48nwkRmAgo8Vy3uQEyNNHBox2&quot;</span>).<span class="title function_ invoke__">into_vec</span>().<span class="title function_ invoke__">unwrap</span>()),</span><br><span class="line">        endowed_accounts[<span class="number">0</span>].<span class="title function_ invoke__">clone</span>()</span><br><span class="line">    ),</span><br><span class="line">    (</span><br><span class="line">        <span class="title function_ invoke__">OpaquePeerId</span>(bs58::<span class="title function_ invoke__">decode</span>(<span class="string">&quot;12D3KooWQYV9dGMFoRzNStwpXztXaBUjtPqi6aU76ZgUriHhKust&quot;</span>).<span class="title function_ invoke__">into_vec</span>().<span class="title function_ invoke__">unwrap</span>()),</span><br><span class="line">        endowed_accounts[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>()</span><br><span class="line">    ),</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>上方元组中，有两个属性，一个表示节点的PeerId转换为二进制；另一个表示这个节点属于谁：endowed_accounts[0]为<code>Alice</code>，endowed_accounts[1]为<code>Bob</code><br>
该目的是，<code>Alice</code>和<code>Bob</code>配置为了内置的可信网络，这两个节点启动后，立马可以组成一个网络</p>
<ol start="3">
<li><code>node</code>目录下，执行如下命令，检测是否能编译：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo check -p  bs58</span><br></pre></td></tr></table></figure>
<h3 id="2-3-编译节点">2.3 编译节点</h3>
<p>回到项目<code>substrate-node-template</code>根目录，执行命令开始编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo build --release</span><br></pre></td></tr></table></figure>
<h2 id="3-网络启动">3 网络启动</h2>
<p>节点的启动，为方便开发和测试，会用到多个substrate内部提供的账户信息，均为固定值，具体如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>账户</strong></th>
<th style="text-align:left"><strong>键值</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Alice</td>
<td style="text-align:left">Node key: c12b6d18942f5ee8528c8e2baf4e147b5c5c18710926ea492d09cbd9f6c9f82a</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left">PeerID (generated from the node key): 12D3KooWBmAwcd4PJNJvfV89HwE48nwkRmAgo8Vy3uQEyNNHBox2</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left">Decoded PeerID in hex: 0024080112201ce5f00ef6e89374afb625f1ae4c1546d31234e87e3c3f51a62b91dd6bfa57df</td>
</tr>
<tr>
<td style="text-align:center">Bob</td>
<td style="text-align:left">Node key: 6ce3be907dbcabf20a9a5a60a712b4256a54196000a8ed4050d352bc113f8c58</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left">PeerID (generated from the node key): 12D3KooWQYV9dGMFoRzNStwpXztXaBUjtPqi6aU76ZgUriHhKust</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left">Decoded PeerID in hex: 002408011220dacde7714d8551f674b8bb4b54239383c76a2b286fa436e93b2b7eb226bf4de7</td>
</tr>
<tr>
<td style="text-align:center">Charlie</td>
<td style="text-align:left">Node key: 3a9d5b35b9fb4c42aafadeca046f6bf56107bd2579687f069b42646684b94d9e</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left">PeerID (generated from the node key): 12D3KooWJvyP3VJYymTqG7eH4PM5rN4T2agk5cdNCfNymAqwqcvZ</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left">Decoded PeerID in hex: 002408011220876a7b4984f98006dc8d666e28b60de307309835d775e7755cc770328cdacf2e</td>
</tr>
<tr>
<td style="text-align:center">Dave</td>
<td style="text-align:left">Node key: a99331ff4f0e0a0434a6263da0a5823ea3afcfffe590c9f3014e6cf620f2b19a</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left">PeerID (generated from the node key): 12D3KooWPHWFrfaJzxPnqnAYAoRUyAHHKqACmEycGTVmeVhQYuZN</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left">Decoded PeerID in hex: 002408011220c81bc1d7057a1511eb9496f056f6f53cdfe0e14c8bd5ffca47c70a8d76c1326d</td>
</tr>
</tbody>
</table>
<h3 id="3-1-节点启动">3.1 节点启动</h3>
<p>前面的可信配置和编译，<code>Alice</code>和<code>Bob</code>两个账户的节点启动后，即可组成一个双节点的测试网络，后续新的测试都是在这两个之上完成的。</p>
<ol>
<li>启动第一个节点，<code>alice</code>节点： 预先内置的可信节点<br>
<code>注：</code>如果节点不是在同一个本地网络，启动应该加上：–no-mdns</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./target/release/node-template \</span><br><span class="line">--chain=local \</span><br><span class="line">--base-path ./tmp/validator1 \</span><br><span class="line">--alice \</span><br><span class="line">--node-key=c12b6d18942f5ee8528c8e2baf4e147b5c5c18710926ea492d09cbd9f6c9f82a \</span><br><span class="line">--port 30333 \</span><br><span class="line">--ws-port 9944</span><br></pre></td></tr></table></figure>
<p>在创世默认local配置中，<code>sudo</code>账户默认是<code>Alice</code></p>
<ol start="2">
<li>启动第二个节点，<code>bob</code>节点： 预先内置的可信节点<br>
<code>注：</code>如果节点不是在同一个本地网络，启动应该加上：–no-mdns</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./target/release/node-template \</span><br><span class="line">--chain=local \</span><br><span class="line">--base-path ./tmp/validator2 \</span><br><span class="line">--bob \</span><br><span class="line">--node-key=6ce3be907dbcabf20a9a5a60a712b4256a54196000a8ed4050d352bc113f8c58 \</span><br><span class="line">--port 30334 \</span><br><span class="line">--ws-port 9945</span><br></pre></td></tr></table></figure>
<p>在创世默认local配置中，<code>sudo</code>账户默认是<code>Alice</code><br>
前两个节点基于内置配置，启动后网络可以互通，正常运行</p>
<ol start="3">
<li>启动第三个节点，<code>charlie</code>节点：<br>
<code>最终目的</code>：授权为<code>alice</code>和<code>bob</code>组成的网络可识别的节点。 该节点为外部配置的<code>charlie</code>节点，默认无法被<code>alice</code>和<code>bob</code>组成的网络识别。启动时需要使用<code>--offchain-worker</code>标记<br>
<code>注：</code>如果节点不是在同一个本地网络，启动应该加上：–no-mdns</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./target/release/node-template \</span><br><span class="line">--chain=local \</span><br><span class="line">--base-path ./tmp/validator3 \</span><br><span class="line">--name charlie  \</span><br><span class="line">--node-key=3a9d5b35b9fb4c42aafadeca046f6bf56107bd2579687f069b42646684b94d9e \</span><br><span class="line">--port 30335 \</span><br><span class="line">--ws-port=9946 \</span><br><span class="line">--offchain-worker always</span><br></pre></td></tr></table></figure>
<p>启动后，会发现该节点没有同步块，这是因为没有预置账户，没有被前两个节点组成的网络识别到。需要手动添加。 打开<a href="https://polkadot.js.org/apps">polkadot web apps</a> (具体使用请参考前面文章)<br>
，连接到节点一和节点二组成的网络，这里我们连接到节点一。 进入：<code>开发者</code>-<code>超级管理</code>目录</p>
<p>在创世默认local配置中，<code>sudo</code>账户默认是<code>Alice</code>，选择：<code>nodeAuthorization</code>-<code>addWellKnownNode(node,owner)</code>，在下方node中输入(节点编号)<br>
：<code>0x002408011220876a7b4984f98006dc8d666e28b60de307309835d775e7755cc770328cdacf2e</code>(一定要带上0x)，owner中选择：<code>CHARLIE</code>，表示该节点属于它。<br>
然后点击<code>提交Sudo</code>。之后，第三个节点就能正常同步块了。<br>
(个人猜测：<code>CHARLIE</code>节点此时也参与块的验证，addWellKnownNode中已经包含validated属性)</p>
<img src="/articles/90299bc0/1.png" class="" title="添加外部可信节点">
<ol start="4">
<li>启动第四个节点，<code>dave</code>节点：<br>
<code>最终目的</code>：配置为<code>charlie</code>的子节点，该节点是有限访问的 该节点为外部配置的<code>dave</code>节点，默认无法被<code>alice</code>和<code>bob</code>组成的网络识别。启动时需要使用<code>--offchain-worker</code>标记<br>
<code>注：</code>如果节点不是在同一个本地网络，启动应该加上：–no-mdns</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./target/release/node-template \</span><br><span class="line">--chain=local \</span><br><span class="line">--base-path ./tmp/validator4 \</span><br><span class="line">--name dave \</span><br><span class="line">--node-key=a99331ff4f0e0a0434a6263da0a5823ea3afcfffe590c9f3014e6cf620f2b19a \</span><br><span class="line">--port 30336 \</span><br><span class="line">--ws-port 9947 \</span><br><span class="line">--offchain-worker always</span><br></pre></td></tr></table></figure>
<p>启动后，会发现该节点没有同步块，这是因为没有预置账户，没有被前两个节点组成的网络识别到。 打开<a href="https://polkadot.js.org/apps">polkadot web apps</a> (具体使用请参考前面文章)<br>
，连接到节点一和节点二组成的网络，这里我们连接到节点一。 选择<code>开发者</code>-<code>交易</code>，具体填写内容看下图： 先申明<code>dave</code>为一个节点 <img src="/articles/90299bc0/3.png" class="" title="申明dave为节点"> 接着授权dave连接到charlie</p>
<img src="/articles/90299bc0/2.png" class="" title="授权dave连接到charlie"> 此时dave开始同步块数据了。 同样的操作，授权charlie连接到dave 目前可以看出，`dave`只属于`charlie`
<h2 id="总结">总结</h2>
<p>按照本文流程，每个结果都可以复现的，亲自实现的。</p>
<p>流程一句话：添加授权模块，动态添加节点</p>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://docs.substrate.io/quick-start/">Substrate官方文档</a></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Substrate</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Substrate</tag>
      </tags>
  </entry>
  <entry>
    <title>substrate基础(5)-创建密钥并自定义两个初始节点的网络</title>
    <url>/articles/d13fa01d/</url>
    <content><![CDATA[<p>本文依旧基于<a href="https://github.com/substrate-developer-hub/substrate-node-template">substrate-node-template</a> 进行操作.<br>
该项目主要是为了方便开发人员调试和测试，以及初次接触substrate的入门者首选，掌握该项目后，再去接触正式项目，会容易很多<br>
本文假定你已经编译好了这个项目，具体编译可以参考本系列第一篇文章：<a href="https://www.bitxx.top/articles/113dc518/">substrate基础(1)-substrate-node-template编译及部署</a></p>
<p>前面介绍的节点部署，是使用内置的测试账号来部署的，但实际生产环境，账户都需要我们自行创建，本文主要介绍如何创建，并加入节点</p>
<span id="more"></span>
<h2 id="1-必要知识点">1. 必要知识点</h2>
<ol>
<li><code>auar</code>共识（生成块）需要使用<code>Sr25519</code>生成的密钥</li>
<li><code>grandpa</code>最终确认块使用<code>Ed25519</code>生成的密钥</li>
<li>密钥细节，建议读下这篇文章：<a href="https://zhuanlan.zhihu.com/p/120344168">Polkadot 中的加密签名库 Schnorrkel</a></li>
</ol>
<h2 id="2-创建密钥-sr25519和ed25519">2. 创建密钥(sr25519和ed25519)</h2>
<ol>
<li>项目根目录，执行如下命令，生成<code>sr25519</code>密钥信息，为<code>auar</code>共识（生成块）使用：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./target/release/node-template key generate --scheme sr25519 --password-interactive</span><br></pre></td></tr></table></figure>
<p>根据提示输入生成该密钥所需要的密码(可以理解成是种子信息，用于生成不同账户信息所需)，这里使用密码：<code>test</code><br>
生成信息如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Secret phrase:       era size item shell hood bag ritual asthma symbol team busy clog</span><br><span class="line">  Network ID:        substrate</span><br><span class="line">  Secret seed:       0xaefb49a08562b993aa30a8dba6771172914fbffa6f64f15aae9d9720fddd0cec</span><br><span class="line">  Public key (hex):  0x9c19b9f0a9f9c7e9d09702442c25d0f2789b4022ca428a37d411b5482997640b</span><br><span class="line">  Account ID:        0x9c19b9f0a9f9c7e9d09702442c25d0f2789b4022ca428a37d411b5482997640b</span><br><span class="line">  Public key (SS58): 5FbNyBcpifYq9tdAp8JHQvi9eh9mwuttLMiLwmShCmmH7XNJ</span><br><span class="line">  SS58 Address:      5FbNyBcpifYq9tdAp8JHQvi9eh9mwuttLMiLwmShCmmH7XNJ</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>接着根据上面生成的助记词来生成<code>grandpa</code>所需要的<code>ed25519</code>密钥：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./target/release/node-template key inspect --password-interactive --scheme ed25519 &quot;era size item shell hood bag ritual asthma symbol team busy clog&quot;</span><br></pre></td></tr></table></figure>
<p>根据提示输入生成该密钥所需要的密码(可以理解成是种子信息，用于生成不同账户信息所需)，这里使用密码：<code>test</code><br>
生成信息如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Secret phrase:       era size item shell hood bag ritual asthma symbol team busy clog</span><br><span class="line">  Network ID:        substrate</span><br><span class="line">  Secret seed:       0xaefb49a08562b993aa30a8dba6771172914fbffa6f64f15aae9d9720fddd0cec</span><br><span class="line">  Public key (hex):  0xe275d4b8c10f07d9f29bdd8d3e8b6e57085a530185112cfea0049b3e69453fdf</span><br><span class="line">  Account ID:        0xe275d4b8c10f07d9f29bdd8d3e8b6e57085a530185112cfea0049b3e69453fdf</span><br><span class="line">  Public key (SS58): 5HBdgXC7fp2gLqqFL5DWVAuubieCkiGYg4xPL8zzBP719m5H</span><br><span class="line">  SS58 Address:      5HBdgXC7fp2gLqqFL5DWVAuubieCkiGYg4xPL8zzBP719m5H</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>根据上面描述的方式，我们再生成一组账户，用于方便后续我们节点的操作：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">auar账户</span></span><br><span class="line">Secret phrase:       foil friend giant measure helmet awake outer pottery vessel number liquid chief</span><br><span class="line">  Network ID:        substrate</span><br><span class="line">  Secret seed:       0x615bdebc756449ecf05112edaf9c2d59660b1a22d15985509f0a4af947479765</span><br><span class="line">  Public key (hex):  0x92c61fcb68272ce526cfb7f1cafb612abd1884c54e2551a51cc8972ed144153d</span><br><span class="line">  Account ID:        0x92c61fcb68272ce526cfb7f1cafb612abd1884c54e2551a51cc8972ed144153d</span><br><span class="line">  Public key (SS58): 5FP9hkrQENoSsX1Kxxsf5E2MYyd9ZntkBGHKvuoc36kDx3Yu</span><br><span class="line">  SS58 Address:      5FP9hkrQENoSsX1Kxxsf5E2MYyd9ZntkBGHKvuoc36kDx3Yu</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">grandpa账户</span></span><br><span class="line">Secret phrase:       foil friend giant measure helmet awake outer pottery vessel number liquid chief</span><br><span class="line">  Network ID:        substrate</span><br><span class="line">  Secret seed:       0x615bdebc756449ecf05112edaf9c2d59660b1a22d15985509f0a4af947479765</span><br><span class="line">  Public key (hex):  0x51982f1078349637e68bce0818a80ffc8559e21bf283fd0efc9936c4e74c43b5</span><br><span class="line">  Account ID:        0x51982f1078349637e68bce0818a80ffc8559e21bf283fd0efc9936c4e74c43b5</span><br><span class="line">  Public key (SS58): 5DugwhRKHdXZtAZ8hhcL92NYZaAGb8u5PmdUc8Nj5vTvLWk9</span><br><span class="line">  SS58 Address:      5DugwhRKHdXZtAZ8hhcL92NYZaAGb8u5PmdUc8Nj5vTvLWk9</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>本文我们需要两组节点的账户信息，根据上面的操作，这里汇总一下总共需要的账户信息：<br>
第一组账户信息如上为：<br>
<code>auar</code>账户：5FbNyBcpifYq9tdAp8JHQvi9eh9mwuttLMiLwmShCmmH7XNJ<br>
<code>grandpa</code>账户：5HBdgXC7fp2gLqqFL5DWVAuubieCkiGYg4xPL8zzBP719m5H<br>
第二组账户信息：<br>
<code>auar</code>账户：5FP9hkrQENoSsX1Kxxsf5E2MYyd9ZntkBGHKvuoc36kDx3Yu<br>
<code>grandpa</code>账户：5DugwhRKHdXZtAZ8hhcL92NYZaAGb8u5PmdUc8Nj5vTvLWk9</li>
</ol>
<h2 id="3-修改节点配置文件">3. 修改节点配置文件</h2>
<p>substrate中有默认的配置文件，我们可以先导出为可编辑的json文件，根据这个默认配置文件来改成我们需要的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导出配置文件</span></span><br><span class="line">./target/release/node-template build-spec --disable-default-bootnode --chain local &gt; customSpec.json</span><br></pre></td></tr></table></figure>
<p>打开该json文件，修改如下字段，其中<code>auar</code>和<code>grandpa</code>中的账户信息需要修改为上面生成的账户信息：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;My Custom Testnet&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;aura&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;authorities&quot;</span><span class="punctuation">:</span> </span><br><span class="line">      <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;5FbNyBcpifYq9tdAp8JHQvi9eh9mwuttLMiLwmShCmmH7XNJ&quot;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="string">&quot;5FP9hkrQENoSsX1Kxxsf5E2MYyd9ZntkBGHKvuoc36kDx3Yu&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;grandpa&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">   <span class="attr">&quot;authorities&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">     <span class="punctuation">[</span></span><br><span class="line">       <span class="string">&quot;5HBdgXC7fp2gLqqFL5DWVAuubieCkiGYg4xPL8zzBP719m5H&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="number">1</span></span><br><span class="line">     <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">     <span class="punctuation">[</span></span><br><span class="line">       <span class="string">&quot;5DugwhRKHdXZtAZ8hhcL92NYZaAGb8u5PmdUc8Nj5vTvLWk9&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="number">1</span></span><br><span class="line">     <span class="punctuation">]</span></span><br><span class="line">   <span class="punctuation">]</span></span><br><span class="line"> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>aura</code>中表示需要这两个<code>Sr25519</code>账户才能共识生成块<br>
<code>grandpa</code>中表示需要这两个<code> Ed25519</code>账户才能共识确认块，其中有两个信息，一个是账户，另一个表示权重，代表该账户投票的影响力，默认全为1</p>
<p>编辑好的<code>customSpec.json</code>，需要转换其中变更信息为二进制的<code>code中的数据</code>，生成新的配置文件<code>customSpecRaw.json</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">customSpecRaw.json和customSpec.json 可理解的内容都是一样的，是给编辑人看的。但二进制部分是不一样的，这部分是要被节点所识别并使用</span></span><br><span class="line">./target/release/node-template build-spec --chain=customSpec.json --disable-default-bootnode &gt; customSpecRaw.json</span><br></pre></td></tr></table></figure>
<p>在专有网络中，每个节点的原始配置文件是都要一致的，否则链运行期间无法达成一致。</p>
<h2 id="4-启动第一个节点">4. 启动第一个节点</h2>
<ol>
<li>使用上面生成的第一组账户</li>
<li>导入第一组的<code>aura</code>密钥信息：<br>
<code>注意！！！！(基于当前版本)：</code>官方文档中提示要输入<code>--suri</code>的值为助记词，但是实践发现，这里必须输入的是<code> Secret seed</code>，也就是密钥，否则节点启动一直异常</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./target/release/node-template key insert \</span><br><span class="line">  --base-path ./tmp/node01 \</span><br><span class="line">  --chain customSpecRaw.json \</span><br><span class="line">  --scheme sr25519 \</span><br><span class="line">  --suri 0xaefb49a08562b993aa30a8dba6771172914fbffa6f64f15aae9d9720fddd0cec \</span><br><span class="line">  --password-interactive \</span><br><span class="line">  --key-type aura</span><br></pre></td></tr></table></figure>
<p>这里提示输入密码为前面生成密钥的：<code>test</code>，不要输错，否则节点无法启动</p>
<ol start="3">
<li>导入第一组的<code>grandpa</code>密钥信息：<br>
<code>注意！！！！：</code>官方文档中提示要输入<code>--suri</code>的值为助记词，但是实践发现，这里必须输入的是<code> Secret seed</code>，也就是密钥，否则节点启动一直异常</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./target/release/node-template key insert \</span><br><span class="line">  --base-path ./tmp/node01 \</span><br><span class="line">  --chain customSpecRaw.json \</span><br><span class="line">  --scheme ed25519 \</span><br><span class="line">  --suri 0xaefb49a08562b993aa30a8dba6771172914fbffa6f64f15aae9d9720fddd0cec \</span><br><span class="line">  --password-interactive \</span><br><span class="line">  --key-type gran</span><br></pre></td></tr></table></figure>
<p>这里提示输入密码为前面生成密钥的：<code>test</code>，不要输错，否则节点无法启动</p>
<ol start="4">
<li>查看密钥是否导入成功：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls ./tmp/node01/chains/my_custom_testnet/keystore</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>启动节点</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./target/release/node-template \</span><br><span class="line">  --base-path ./tmp/node01 \</span><br><span class="line">  --chain ./customSpecRaw.json \</span><br><span class="line">  --port 30333 \</span><br><span class="line">  --ws-port 9945 \</span><br><span class="line">  --rpc-port 9933 \</span><br><span class="line">  --telemetry-url &quot;wss://telemetry.polkadot.io/submit/ 0&quot; \</span><br><span class="line">  --validator \</span><br><span class="line">  --rpc-methods Unsafe</span><br></pre></td></tr></table></figure>
<p><code>--rpc-methods Unsafe</code> 表示开发环境，非安全通信，方便交互<br>
<code>--name MyNode01</code> 可读性，方便标记</p>
<p>根据启动信息记录下该节点的<code>Local node identity is: 12D3KooWFTdrxUzCZRH9CZh4Ct2tCUJQK2sX6UGARGCW2onAQZBL</code>   后面另一个节点加入需要用到</p>
<h2 id="5-启动第二个节点">5. 启动第二个节点</h2>
<ol>
<li>使用上面生成的第二组账户</li>
<li>导入第二组的<code>aura</code>密钥信息：<br>
<code>注意！！！！：</code>官方文档中提示要输入<code>--suri</code>的值为助记词，但是实践发现，这里必须输入的是<code> Secret seed</code>，也就是密钥，否则节点启动一直异常</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./target/release/node-template key insert \</span><br><span class="line">  --base-path ./tmp/node02 \</span><br><span class="line">  --chain customSpecRaw.json \</span><br><span class="line">  --scheme sr25519 \</span><br><span class="line">  --suri 0x615bdebc756449ecf05112edaf9c2d59660b1a22d15985509f0a4af947479765 \</span><br><span class="line">  --password-interactive \</span><br><span class="line">  --key-type aura</span><br></pre></td></tr></table></figure>
<p>这里提示输入密码为前面生成密钥的：<code>test</code>，不要输错，否则节点无法启动</p>
<ol start="3">
<li>导入第二组的<code>grandpa</code>密钥信息：<br>
<code>注意！！！！：</code>官方文档中提示要输入<code>--suri</code>的值为助记词，但是实践发现，这里必须输入的是<code> Secret seed</code>，也就是密钥，否则节点启动一直异常</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./target/release/node-template key insert \</span><br><span class="line">  --base-path ./tmp/node02 \</span><br><span class="line">  --chain customSpecRaw.json \</span><br><span class="line">  --scheme ed25519 \</span><br><span class="line">  --suri 0x615bdebc756449ecf05112edaf9c2d59660b1a22d15985509f0a4af947479765 \</span><br><span class="line">  --password-interactive \</span><br><span class="line">  --key-type gran</span><br></pre></td></tr></table></figure>
<p>这里提示输入密码为前面生成密钥的：<code>test</code>，不要输错，否则节点无法启动</p>
<ol start="4">
<li>查看密钥是否导入成功：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls ./tmp/node02/chains/my_custom_testnet/keystore</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>启动节点<br>
其中：<code>12D3KooWFTdrxUzCZRH9CZh4Ct2tCUJQK2sX6UGARGCW2onAQZBL</code>为第一个节点启动时候的节点ID</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./target/release/node-template \</span><br><span class="line">  --base-path ./tmp/node02 \</span><br><span class="line">  --chain ./customSpecRaw.json \</span><br><span class="line">  --port 30334 \</span><br><span class="line">  --ws-port 9946 \</span><br><span class="line">  --rpc-port 9934 \</span><br><span class="line">  --telemetry-url &#x27;wss://telemetry.polkadot.io/submit/ 0&#x27; \</span><br><span class="line">  --validator \</span><br><span class="line">  --rpc-methods Unsafe \</span><br><span class="line">  --name MyNode02 \</span><br><span class="line">  --bootnodes /ip4/127.0.0.1/tcp/30333/p2p/12D3KooWFTdrxUzCZRH9CZh4Ct2tCUJQK2sX6UGARGCW2onAQZBL \</span><br><span class="line">  --password-interactive</span><br></pre></td></tr></table></figure>
<p>这里提示输入密码建议输入账户密钥的密码，不要输错，以防万一。<br>
<code>目前发现，即使输错，也可以同步和确认块，最终是否影响收益到账，目前我也说不来。总之，输入密钥生成的密码最保险。</code></p>
<h2 id="6-结果展示">6. 结果展示</h2>
<p>我认为最为关键的一行(根据各自结果找出类似一行)：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Idle (1 peers), best: #35 (0xf99b…64c8), finalized #32 (0x289e…8413), ⬇ 0.8kiB/s ⬆ 0.8kiB/s </span><br></pre></td></tr></table></figure>
<p><code>best</code>表示同步生成的块，<code>finalized</code>表示链上确认了的块。这表示<code>aura共识</code>和<code>grandpa共识</code>的账户等都没有问题</p>
<h2 id="总结">总结</h2>
<p>密钥的导入，也可以通过<code>polkadot-web-app</code>页面来导入，rpc call。本文直接使用命令导入的。</p>
<p>按照本文流程，每个结果都可以复现的，亲自实现的。</p>
<p>流程一句话：预定义的两个节点，每个节点配置需都一样。也就是说，参与验证的节点账户预先写入配置。各个需要启动的节点，导入各自的密钥即可启动节点。</p>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://docs.substrate.io/quick-start/">Substrate官方文档</a><br>
[2] <a href="https://zhuanlan.zhihu.com/p/120344168">Polkadot 中的加密签名库 Schnorrkel</a><br>
[3] <a href="https://stackoverflow.com/questions/68528018/substrate-node-template-private-network-without-using-default-keys">Substrate node-template private network WITHOUT using default keys</a></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Substrate</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Substrate</tag>
      </tags>
  </entry>
  <entry>
    <title>substrate基础(4)-模拟构建两个节点的网络</title>
    <url>/articles/d13fa01d/</url>
    <content><![CDATA[<p>本文依旧基于<a href="https://github.com/substrate-developer-hub/substrate-node-template">substrate-node-template</a> 进行操作.<br>
该项目主要是为了方便开发人员调试和测试，以及初次接触substrate的入门者首选，掌握该项目后，再去接触正式项目，会容易很多<br>
本文假定你已经编译好了这个项目，具体编译可以参考本系列第一篇文章：<a href="https://www.bitxx.top/articles/113dc518/">substrate基础(1)-substrate-node-template编译及部署</a></p>
<span id="more"></span>
<h2 id="1-清除现有网络节点数据">1. 清除现有网络节点数据</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./target/release/node-template purge-chain --base-path ./tmp/alice --chain local</span><br><span class="line">./target/release/node-template purge-chain --base-path ./tmp/bob --chain local -y</span><br></pre></td></tr></table></figure>
<p>执行命令后，根据提示进行操作</p>
<h2 id="2-启动第一个节点：alice">2. 启动第一个节点：alice</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./target/release/node-template \</span><br><span class="line">--base-path ./tmp/alice \</span><br><span class="line">--chain local \</span><br><span class="line">--alice \</span><br><span class="line">--port 30333 \</span><br><span class="line">--ws-port 9945 \</span><br><span class="line">--rpc-port 9933 \</span><br><span class="line">--node-key 0000000000000000000000000000000000000000000000000000000000000001 \</span><br><span class="line">--telemetry-url &quot;wss://telemetry.polkadot.io/submit/ 0&quot; \</span><br><span class="line">--validator</span><br></pre></td></tr></table></figure>
<p>其中，<code>--alice</code>中已经包含了<code>--node-key</code>的属性，这里为了更直观而显示的标记出来<br>
各个参数说明：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>参数</strong></th>
<th style="text-align:center"><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>–base-path</strong></td>
<td style="text-align:center">指定用于存储与此链相关的所有数据的目录</td>
</tr>
<tr>
<td style="text-align:center"><strong>–chain local</strong></td>
<td style="text-align:center">指定要使用的链规范：local、development、staging</td>
</tr>
<tr>
<td style="text-align:center"><strong>–alice</strong></td>
<td style="text-align:center">将帐户的预定义密钥添加到节点的密钥库中。使用此设置，该帐户用于块生产和最终确认</td>
</tr>
<tr>
<td style="text-align:center"><strong>–port 30333</strong></td>
<td style="text-align:center">p2p监听端口</td>
</tr>
<tr>
<td style="text-align:center"><strong>–ws-port 9945</strong></td>
<td style="text-align:center">指定要侦听传入 WebSocket 流量的端口</td>
</tr>
<tr>
<td style="text-align:center"><strong>–rpc-port 9933</strong></td>
<td style="text-align:center">rpc端口</td>
</tr>
<tr>
<td style="text-align:center"><strong>–node-key <key></strong></td>
<td style="text-align:center">指定用于网络的 Ed25519 密钥。应仅将此选项用于开发和测试</td>
</tr>
<tr>
<td style="text-align:center"><strong>–telemetry-url</strong></td>
<td style="text-align:center">指定将节点监测数据发送到的位置</td>
</tr>
<tr>
<td style="text-align:center"><strong>–validator</strong></td>
<td style="text-align:center">指定此节点参与网络的块生成和确认</td>
</tr>
</tbody>
</table>
<p>启动后，节点输入如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2022-07-03 10:35:23 Substrate Node</span><br><span class="line">2022-07-03 10:35:23 ✌️  version 4.0.0-dev-9c89be106cb</span><br><span class="line">2022-07-03 10:35:23 ❤️  by Substrate DevHub &lt;https://github.com/substrate-developer-hub&gt;, 2017-2022</span><br><span class="line">2022-07-03 10:35:23 📋 Chain specification: Local Testnet</span><br><span class="line">2022-07-03 10:35:23 🏷  Node name: Alice</span><br><span class="line">2022-07-03 10:35:23 👤 Role: AUTHORITY</span><br><span class="line">2022-07-03 10:35:23 💾 Database: RocksDb at /tmp/alice/chains/local_testnet/db/full</span><br><span class="line">2022-07-03 10:35:23 ⛓  Native runtime: node-template-100 (node-template-1.tx1.au1)</span><br><span class="line">2022-07-03 10:35:24 🔨 Initializing Genesis block/state (state: 0x7859…17af, header-hash: 0x4ea4…ac68)</span><br><span class="line">2022-07-03 10:35:24 👴 Loading GRANDPA authority set from genesis on what appears to be first startup.</span><br><span class="line">2022-07-03 10:35:25 Using default protocol ID &quot;sup&quot; because none is configured in the chain specs</span><br><span class="line">2022-07-03 10:35:25 🏷  Local node identity is: 12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp</span><br><span class="line">2022-07-03 10:35:25 💻 Operating system: linux</span><br><span class="line">2022-07-03 10:35:25 💻 CPU architecture: x86_64</span><br><span class="line">2022-07-03 10:35:25 💻 Target environment: gnu</span><br><span class="line">2022-07-03 10:35:25 💻 CPU: Intel(R) Xeon(R) CPU E5-2676 v3 @ 2.40GHz</span><br><span class="line">2022-07-03 10:35:25 💻 CPU cores: 16</span><br><span class="line">2022-07-03 10:35:25 💻 Memory: 32110MB</span><br><span class="line">2022-07-03 10:35:25 💻 Kernel: 5.4.0-100-generic</span><br><span class="line">2022-07-03 10:35:25 💻 Linux distribution: Ubuntu 20.04.3 LTS</span><br><span class="line">2022-07-03 10:35:25 💻 Virtual machine: yes</span><br><span class="line">2022-07-03 10:35:25 📦 Highest known block at #0</span><br><span class="line">2022-07-03 10:35:25 〽️ Prometheus exporter started at 127.0.0.1:9615</span><br><span class="line">2022-07-03 10:35:25 Running JSON-RPC HTTP server: addr=127.0.0.1:9933, allowed origins=Some([&quot;http://localhost:*&quot;, &quot;http://127.0.0.1:*&quot;, &quot;https://localhost:*&quot;, &quot;https://127.0.0.1:*&quot;, &quot;https://polkadot.js.org&quot;])</span><br><span class="line">2022-07-03 10:35:25 Running JSON-RPC WS server: addr=127.0.0.1:9945, allowed origins=Some([&quot;http://localhost:*&quot;, &quot;http://127.0.0.1:*&quot;, &quot;https://localhost:*&quot;, &quot;https://127.0.0.1:*&quot;, &quot;https://polkadot.js.org&quot;])</span><br><span class="line">2022-07-03 10:35:25 creating instance on iface 192.168.253.71</span><br><span class="line">2022-07-03 10:35:25 creating instance on iface 172.17.0.1</span><br><span class="line">2022-07-03 10:35:25 creating instance on iface 172.21.0.1</span><br><span class="line">2022-07-03 10:35:30 💤 Idle (0 peers), best: #0 (0x4ea4…ac68), finalized #0 (0x4ea4…ac68), ⬇ 0.3kiB/s ⬆ 0.3kiB/s</span><br><span class="line">2022-07-03 10:35:35 💤 Idle (0 peers), best: #0 (0x4ea4…ac68), finalized #0 (0x4ea4…ac68), ⬇ 22 B/s ⬆ 40 B/s</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ol>
<li>🔨 Initializing Genesis block/state (state: 0x7859…17af, header-hash: 0x4ea4…ac68) 表示:标识节点正在使用的初始块或创世块。启动下一个节点时，请验证这些值是否相同。</li>
<li>🏷  Local node identity is: 12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp 表示：指定唯一标识此节点的字符串。此字符串由用于使用帐户启动节点的 确定。使用此字符串来标识在启动第二个节点时要连接到的节点。–node-keyalice</li>
<li>💤 Idle (0 peers), best: #0 (0x4ea4…ac68), finalized #0 (0x4ea4…ac68), ⬇ 0.3kiB/s ⬆ 0.3kiB/s 表示：网络中没有其他节点，并且没有生成块。另一个节点必须加入网络，然后才能开始生成块。</li>
</ol>
<h2 id="2-启动第二个节点：bob">2. 启动第二个节点：bob</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./target/release/node-template \</span><br><span class="line">--base-path ./tmp/bob \</span><br><span class="line">--chain local \</span><br><span class="line">--bob \</span><br><span class="line">--port 30334 \</span><br><span class="line">--ws-port 9946 \</span><br><span class="line">--rpc-port 9934 \</span><br><span class="line">--telemetry-url &quot;wss://telemetry.polkadot.io/submit/ 0&quot; \</span><br><span class="line">--validator \</span><br><span class="line">--bootnodes /ip4/127.0.0.1/tcp/30333/p2p/12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp</span><br></pre></td></tr></table></figure>
<p>其中<code>bootnodes</code>的节点值为要连接的另一个节点的id<br>
其中，<code>--bob</code>中已经包含了<code>--node-key</code>的属性</p>
<h2 id="3-节点运行信息">3. 节点运行信息</h2>
<p>至此，两个节点开始正常运转了。其中会有一些信息：</p>
<ol>
<li><code>best</code>表示已经产生的块高度</li>
<li><code>finalized</code>表示最终确认的块高度</li>
</ol>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://docs.substrate.io/quick-start/">Substrate官方文档</a></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Substrate</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Substrate</tag>
      </tags>
  </entry>
  <entry>
    <title>substrate基础(3)-基础概念和原理</title>
    <url>/articles/2cac7d84/</url>
    <content><![CDATA[<p>涉及到substrate的概念和基础原理</p>
<span id="more"></span>
<h2 id="1-概述">1. 概述</h2>
<ol>
<li>substrate主要分为两层结构：
<ol>
<li>外部节点(outer node)：用于处理网络活动，例如对等发现、管理事务请求、与对等方达成共识以及响应 RPC 调用。主要由以下部分内容组成：
<ol>
<li>存储：键值存储层来持久化状态演变</li>
<li>p2p网络：使用了rust实现的<a href="https://libp2p.io/">libp2p network stack</a></li>
<li>共识：用于达成一致</li>
<li>远程过程调用RPC API：交互</li>
<li>监测：方便运维检测节点指标，比如<a href="https://prometheus.io/">普罗米修斯系统</a></li>
<li>执行环境：选择<code>WebAssembly</code>或<code>Rust</code>环境，然后将任务派发给<code>运行时(runtime)</code>，比如执行合约。</li>
</ol>
</li>
<li>运行时(Runtime)：包含用于执行区块链的状态转换函数的所有业务逻辑，</li>
</ol>
</li>
</ol>
<h2 id="2-运行时-runtime-开发">2. 运行时(Runtime)开发</h2>
<ol>
<li>运行时包含用于执行事务、保存状态转换以及与外部节点交互的所有业务逻辑。</li>
<li>Substrate的核心主要就是根据自己的业务开发运行时</li>
<li>Runtime通过Api与外部节点进行通信</li>
<li>可以灵活自定义接口<code>sp_api</code> <a href="https://paritytech.github.io/substrate/master/sp_api/macro.impl_runtime_apis.html">impl_runtime_apis</a> 每个自定义的Runtime都必须实现<code>Core</code>和<code>Metadata</code>接口，当然，大多数的Runtime都实现了如下几个接口，可以作为参考：
<ol>
<li><a href="https://paritytech.github.io/substrate/master/sp_block_builder/trait.BlockBuilder.html">BlockBuilder</a> 以获取构建块所需的功能。</li>
<li><a href="https://paritytech.github.io/substrate/master/sp_transaction_pool/runtime_api/trait.TaggedTransactionQueue.html">TaggedTransactionQueue</a> 用于验证交易。</li>
<li><a href="https://paritytech.github.io/substrate/master/sp_offchain/trait.OffchainWorkerApi.html">OffchainWorkerApi</a> 用于启用链下操作。</li>
<li><a href="https://paritytech.github.io/substrate/master/sp_consensus_aura/trait.AuraApi.html">AuraApi</a> 用于使用共识的轮循机制方法进行块创作和验证。</li>
<li><a href="https://paritytech.github.io/substrate/master/sp_session/trait.SessionKeys.html">SessionKeys</a> 用于生成和解码会话密钥。</li>
<li><a href="https://paritytech.github.io/substrate/master/sp_finality_grandpa/trait.GrandpaApi.html">GrandpaApi</a> 用于将块最终确定为运行时。</li>
<li><a href="https://paritytech.github.io/substrate/master/frame_system_rpc_runtime_api/trait.AccountNonceApi.html">AccountNonceApi</a> 用于查询交易索引。</li>
<li><a href="https://paritytech.github.io/substrate/master/pallet_transaction_payment_rpc_runtime_api/trait.TransactionPaymentApi.html">TransactionPaymentApi</a> 用于查询有关事务的信息。</li>
<li><a href="https://paritytech.github.io/substrate/master/frame_benchmarking/trait.Benchmark.html">Benchmark</a> 用于估计和测量完成事务所需的执行时间。</li>
</ol>
</li>
<li>必须实现的核心基础（数据类型等）：
<ol>
<li>Hash：对某些数据的加密摘要进行编码的类型。通常只有 256 位数量。</li>
<li>DigestItem：一种类型，必须能够编码与共识和更改跟踪相关的许多“硬连线”替代方案之一，以及与运行时内的特定模块相关的任意数量的“软编码”变体。</li>
<li>Digest：一系列文摘项目。这将对与轻量级客户端相关的所有信息进行编码，以便在块中拥有这些信息。</li>
<li>Extrinsic：一种类型，表示区块链外部由区块链识别的单个数据。这通常涉及一个或多个签名，以及某种编码指令（例如，用于转移资金所有权或调用智能合约）。</li>
<li>Header：一种代表（加密或其他方式）与块相关的所有信息的类型。它包括父哈希，存储根和外在三根，摘要和块号。</li>
<li>Block：本质上只是一系列s的组合，以及要使用的哈希算法的规范。HeaderExtrinsic</li>
<li>BlockNumber：一种类型，用于对任何有效块具有的祖先总数进行编码。通常为 32 位数量。</li>
</ol>
</li>
<li>Frame(Framework for Runtime Aggregation of Modularized Entities的缩写)，各种不同的库，方便定制化开发
<ol>
<li>官方在frame中预定义了大量的<code>pallet</code>，你也可以自定义</li>
<li>大多数pallet由以下部分组成：
<ol>
<li>导入和依赖项</li>
<li>pallet类型声明</li>
<li>运行时配置特征</li>
<li>运行时存储</li>
<li>运行时事件</li>
<li>应在特定上下文中执行的逻辑的挂钩</li>
<li>可用于执行事务的函数调用</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="3-共识">3. 共识</h2>
<ol>
<li>默认提供了一些常见的共识机制</li>
<li>Substrate的共识分为两个独立阶段：
<ol>
<li>Block authoring：生成一个新的块</li>
<li>Block finalization：用于控制分叉和选择规范链的过程</li>
</ol>
</li>
<li>Substrate默认提供Aura来进行<code>Block authoring(块创建)</code>，<code>GRANDPA</code>来进行<code>finalization(块确认)</code></li>
</ol>
<h3 id="3-1-block-authoring">3.1 Block authoring</h3>
<p>目前Substrate提供了三种用于块创建的共识，具体这三种的工作原理这里就不解释了，需要自行去查找资料：</p>
<ol>
<li>Authority-based round-robin scheduling (Aura)</li>
<li>Blind assignment of blockchain extension (BABE) slot-based scheduling.</li>
<li>Proof of work computation-based scheduling.</li>
</ol>
<h3 id="3-2-finalization-and-forks">3.2 Finalization and forks</h3>
<p>主要是针对分叉的处理，Substrate提供了机制来处理。比如：</p>
<ol>
<li><code>GRANDPA</code>协议，最长链规则来确定哪条是合法的链</li>
<li><code>GHOST</code>协议，构建的块最多的分支来解决的</li>
</ol>
<h3 id="3-3-deterministic-finality">3.3 deterministic finality</h3>
<p>就是一笔交易何时给出结果。这个需要结合共识来考虑</p>
<h3 id="3-4-默认共识">3.4 默认共识</h3>
<p>Substrate默认提供<code>Aura</code>来进行<code>Block authoring(块创建)</code>，<code>GRANDPA</code>来进行<code>finalization(块确认)</code></p>
<h4 id="3-4-1-aura">3.4.1 Aura</h4>
<p>提供的基于插槽的块生成机制，由权威机构轮流生成块</p>
<h4 id="3-4-2-babe">3.4.2 BABE</h4>
<p>BABE使用一组已知的验证器提供基于插槽的块创作，并且通常用于权益证明区块链。与Aura不同，插槽分配基于可验证随机函数（VRF）的评估。为每个验证器分配一个epoch的权重。该epoch被分解为多个槽，验证器在每个槽评估其VRF。对于验证器的VRF输出低于其权重的每个插槽，允许编写一个块。<br>
因为多个验证器可能能够在同一个插槽中生成一个块，所以即使在良好的网络条件下，分叉在BABE中也比在Aura中更常见<br>
Subscriber的BABE实现还有一个回退机制，用于在给定的插槽中没有选择权限。这些辅助插槽分配允许BABE实现恒定的块时间。<br>
可前往此处进一步了解<a href="https://research.web3.foundation/en/latest/polkadot/block-production/Babe.html">BABE算法</a></p>
<h4 id="3-4-3-pow">3.4.3 POW</h4>
<p>烂大街了，这个就不讲了</p>
<h4 id="3-4-4-grandpa-爷爷">3.4.4 GRANDPA(爷爷)</h4>
<p>GRANDPA不会创建块，只是根据创建块的信息进行投票，三分之二投票后，最终决定哪个块合适。最长链规则来决定最终合法的链。<br>
可前往此处进一步了解<a href="https://research.web3.foundation/en/latest/polkadot/finality.html">GRANDPA(爷爷)算法</a></p>
<h2 id="4-交易">4. 交易</h2>
<p>分为3类：<br>
已签名的交易、未签名事务、固有事务</p>
<h3 id="4-1-已签名交易">4.1 已签名交易</h3>
<p>很常见的，比如转账，转账前总得有自己的密钥签名才能执行。执行期间，通常也需要手续费</p>
<h3 id="4-2-未签名交易">4.2 未签名交易</h3>
<p>顾名思义不用签名的交易操作。只能由验证器节点来调用</p>
<h3 id="4-3-固有事务">4.3 固有事务</h3>
<p>只能由创建块的节点将信息插入到块中，不会对外广播。比如某节点将时间戳插入块中，不管准确不准确，反正插入了。该块能不能被别的节点接受，这就是验证器的事了。</p>
<h3 id="4-4-交易生命周期">4.4 交易生命周期</h3>
<ol>
<li>汇总生命周期：
<ol>
<li>本地节点侦听网络上的事务。</li>
<li>每笔交易都经过验证。</li>
<li>有效的事务将放在事务池中。</li>
<li>事务池对相应事务队列中的有效事务进行排序，执行模块调用运行时以开始下一个区块。</li>
<li>执行事务并将状态更改存储在本地内存中。</li>
<li>构造的块将发布到网络。</li>
</ol>
</li>
<li>验证和排队交易
<ol>
<li>验证事务池中的事务 （交易池仅处理交易的有效性以及交易队列中放置的有效交易的排序。）
<ol>
<li>事务索引（也称为事务随机数）是否正确？</li>
<li>用于签署交易的账户是否有足够的资金来支付相关费用？</li>
<li>用于签署交易的签名是否有效？</li>
</ol>
</li>
<li>将有效事务添加到事务队列
<ol>
<li>就绪队列  挂起</li>
<li>未来队列  等待</li>
</ol>
</li>
<li>无效的事务处理
<ol>
<li>事务已包含在块中，因此将从验证队列中删除。</li>
<li>交易的签名无效，因此会立即被拒绝。</li>
<li>交易太大而无法放入当前区块，因此将其放回队列中以进行新的验证轮次。</li>
</ol>
</li>
</ol>
</li>
<li>按优先级排序的交易
<ol>
<li>如果存在一个未签名的事务和另一个已签名的事务，则将未签名的事务放在队列中的第一个。</li>
<li>如果有两笔来自不同发送方的交易，则确定哪笔交易更重要，应首先包含在区块中。</li>
<li>如果有两笔来自同一发送方的交易具有相同的：区块中只能包含一笔交易，因此队列中仅包含费用较高的交易</li>
</ol>
</li>
<li>执行事务和生成区块
<ol>
<li>初始化块</li>
<li>执行事务
<ol>
<li>在区块初始化后，每个有效的交易都按交易优先级的顺序执行。请务必记住，在执行之前不会缓存状态。相反，状态更改在执行期间直接写入存储。如果事务在执行过程中失败，则在失败之前发生的任何状态更改都不会恢复，从而使块处于不可恢复状态。在将任何状态更改提交到存储之前，运行时逻辑应执行所有必要的检查，以确保外部操作成功。</li>
<li>请注意，事件也写入存储。因此，运行时逻辑在执行补充操作之前不应发出事件。如果事务在发出事件后失败，则不会还原该事件。</li>
</ol>
</li>
<li>完成块</li>
</ol>
</li>
</ol>
<h2 id="5-状态转换和存储">5. 状态转换和存储</h2>
<ol>
<li>Substrate使用<code>RocksDB</code>实现其存储。这是一种用于快速存储环境的持久键值存储。它还支持实验奇偶校验数据库.</li>
<li>Trie abstraction
<ol>
<li>使用了改良后的默克尔树，直接访问trie成本很高，一般都是会进行键值缓存</li>
<li>State trie(状态树)
<ol>
<li>树根的hash值放在每个块头部，可以方便验证链状态，并且很容易应用于轻量级客户端</li>
<li>该状态树值存放规范的内容，不存储分叉数据，单独的一个状态数据库来维护它。</li>
</ol>
</li>
<li>Child trie（子树）
<ol>
<li>状态树的节点？</li>
<li>这个没看明白，以后看懂了再说</li>
<li>主要是方便开发人员自己定义trie？</li>
</ol>
</li>
</ol>
</li>
<li>存储查询
<ol>
<li>使用TwoX 128 hash来存储数据</li>
<li>查询的多级key，是合并各级的key的hash来查询的，如下：</li>
</ol>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">twox_128(&quot;Balances&quot;)                                             = &quot;0xc2261276cc9d1f8598ea4b6a74b15c2f&quot;</span><br><span class="line">twox_128(&quot;FreeBalance&quot;)                                          = &quot;0x6482b9ade7bc6657aaca787ba1add3b4&quot;</span><br><span class="line">scale_encode(&quot;5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY&quot;) = &quot;0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d&quot;</span><br><span class="line"></span><br><span class="line">blake2_128_concat(&quot;0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d&quot;) = &quot;0xde1e86a9a8c739864cf3cc5ec2bea59fd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d&quot;</span><br><span class="line"></span><br><span class="line">state_getStorage(&quot;0xc2261276cc9d1f8598ea4b6a74b15c2f6482b9ade7bc6657aaca787ba1add3b4de1e86a9a8c739864cf3cc5ec2bea59fd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d&quot;) = &quot;0x0000a0dec5adc9353600000000000000&quot;</span><br></pre></td></tr></table></figure>
<h2 id="6-帐户-地址和密钥">6. 帐户、地址和密钥</h2>
<ol>
<li>公钥和私钥<br>
没啥好说的。其中公钥可以根据不同的平行链，生成对应格式的地址。也就是说，一个公钥可以派生出不同的地址，方便跟不同的链交互</li>
<li>地址编码和链特定地址
<ol>
<li>默认substrate使用SS58 address format格式，基于 base-58 encoding编码</li>
<li>base-58编码优点：
<ol>
<li>编码的地址由 58 个字母数字字符组成。</li>
<li>字母数字字符串省略了在字符串中难以区分的字符</li>
<li>网络信息（例如，特定于网络的前缀）可以在地址中进行编码</li>
<li>可以使用校验和检测输入错误，以确保正确输入地址。</li>
<li>可以注册一个特定的前缀</li>
</ol>
</li>
</ol>
</li>
<li>frame中的帐户信息
<ol>
<li>从概念上讲，帐户表示具有公钥/私钥对和一个或多个公共地址的标识。但是，在使用 FRAME 构建的运行时中，帐户被定义为具有 32 字节地址标识符和相应帐户信息（如帐户已进行的事务数、依赖于帐户的模块数以及帐户余额）的存储映射。</li>
<li>帐户属性（如 ）可以在模块中一般定义。然后，在运行时实现中将泛型类型解析为特定类型，并最终分配特定值。</li>
</ol>
</li>
<li>专业账户
<ol>
<li>虽然大多数账户用于表示控制资金或执行交易的公钥/私钥对，但Substrate支持一些专用账户来控制如何使用特定的密钥对。例如，你可能拥有需要自定义加密方案、只能用于执行特定功能或只能访问特定plate的帐户。</li>
<li>质押账户和密钥
<ol>
<li>在大多数情况下，专用帐户是在特定 FRAME plate的上下文中实现的。例如，提名权益证明（NPoS）可能要求节点验证者和提名者持有大量代币。为确保这些账户中的余额安全，质押托盘提供了一些账户抽象，用于分离执行特定操作所需的密钥对。</li>
</ol>
</li>
<li>账户区分：
<ol>
<li>存储帐户
<ol>
<li>可以理解为用于质押的账户</li>
</ol>
</li>
<li>控制器帐户
<ol>
<li>理解为控制质押池的账户</li>
</ol>
</li>
<li>会话帐户
<ol>
<li>管理池子的gas消耗等行为的账户</li>
</ol>
</li>
</ol>
</li>
<li>无密钥代理账户
<ol>
<li>没理解，我认为是一个替身账户</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="7-rust-for-substrate">7. Rust for Substrate</h2>
<ol>
<li>对于编写外部节点(客户端)的开发人员，技术要求复杂：需要掌握异步框架<a href="https://rust-lang.github.io/async-book/01_getting_started/01_chapter.html">Asynchronous Rust</a></li>
<li>对于编写运行时的开发人员，专注业务，技术要求普通：<a href="https://rust-unofficial.github.io/patterns/idioms/index.html">Rust idioms</a> <a href="https://docs.rust-embedded.org/book/intro/no-std.html">working with no_std</a>以及<code>宏</code></li>
<li>需要编译为：Wasm。也就是说，某些典型的标准库不能用，需要用专门定制的库来编译，如：asm32-unknown-unknown no_std</li>
<li>宏
<ol>
<li>substrate使用了大量的宏，因此开发人员一定要了解宏的使用</li>
<li>substrate中的宏涉及到两类：<code>派生属性</code>和<code>自定义属性</code></li>
</ol>
</li>
<li>泛型和配置特性</li>
</ol>
<h2 id="8-链下操作">8. 链下操作</h2>
<ol>
<li>Substrate提供了链下操作的机制，调用相应的独立模块，如查询或者进一步处理链上数据：
<ol>
<li>链下工作线程（OCW）</li>
<li>链外存储</li>
<li>链外索引</li>
</ol>
</li>
<li>链下worker，需要实施相应验证机制来约束
<ol>
<li>能够提交交易（有符号或无符号）到链以发布计算结果。</li>
<li>一个功能齐全的 HTTP 客户端，允许工作线程访问和从外部服务获取数据。</li>
<li>访问本地密钥库以对语句或事务进行签名和验证。</li>
<li>另外一个本地键值数据库在所有链下工作者之间共享。</li>
<li>用于随机数生成的安全局部熵源。</li>
<li>访问节点的精确度当地时间.</li>
<li>睡眠和恢复工作的能力。</li>
</ol>
</li>
<li>链下存储</li>
<li>链下索引</li>
</ol>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://docs.substrate.io/quick-start/">Substrate官方文档</a></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Substrate</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Substrate</tag>
      </tags>
  </entry>
  <entry>
    <title>substrate基础(2)-polkadot apps远端访问配置</title>
    <url>/articles/8aab1b7b/</url>
    <content><![CDATA[<p>在一台设备上部署了substrate节点，在别的设备部署<a href="https://github.com/polkadot-js/apps/">polkadot apps</a>或者直接使用官方<a href="https://github.com/polkadot-js/apps/">polkadot apps</a>访问这个节点，需要通过https才可以。也就是说，要有证书才能访问。<br>
本文我以官方的<a href="https://github.com/polkadot-js/apps/">polkadot apps</a>为例，来介绍如果配置并访问远端substrate<br>
本文参考自波卡官方文档：<a href="https://wiki.polkadot.network/docs/maintain-wss">https://wiki.polkadot.network/docs/maintain-wss</a></p>
<span id="more"></span>
<h2 id="1-节点启动">1. 节点启动</h2>
<p>需要带上这个参数：<code>--rpc-cors all</code>，可以参考如下启动命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./target/release/node-template --dev --ws-external --rpc-external --no-telemetry --rpc-cors all</span><br></pre></td></tr></table></figure>
<h2 id="2-生成自签名文件">2. 生成自签名文件</h2>
<p>当然，如果有公网域名或ip，能申请到开放的签名证书，那更好。后面配置起来更容易。<br>
有公共证书的话，那就没必要执行下面这两条命令了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自签名文件、证书</span></span><br><span class="line">sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/ssl/private/nginx-selfsigned.key -out /etc/ssl/certs/nginx-selfsigned.crt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用于确保通信双方安全交换密钥</span></span><br><span class="line">sudo openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048</span><br></pre></td></tr></table></figure>
<h2 id="3-部署并配置nginx">3. 部署并配置nginx</h2>
<p>nginx的部署这里不考虑。自签名的话，如果上面两条命令中没有改动路径，那下面的配置直接复制到nginx的配置文件里即可。<br>
具体配置如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 443 ssl; # 将端口转发为443</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass http://localhost:9944/; # 指向本地服务端口</span><br><span class="line">    proxy_http_version 1.1;</span><br><span class="line">    proxy_read_timeout 120s;</span><br><span class="line">    proxy_redirect off;</span><br><span class="line">    proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">    proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">    proxy_set_header Host $host:$server_port;</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ssl_certificate /etc/ssl/certs/nginx-selfsigned.crt;</span><br><span class="line">  ssl_certificate_key /etc/ssl/private/nginx-selfsigned.key;</span><br><span class="line">  ssl_session_cache shared:cache_nginx_SSL:1m;</span><br><span class="line">  ssl_session_timeout 1440m;</span><br><span class="line">  ssl_ciphers &quot;ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS&quot;;</span><br><span class="line">  ssl_dhparam /etc/ssl/certs/dhparam.pem;</span><br><span class="line">  ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE</span><br><span class="line">  ssl_prefer_server_ciphers on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生效nginx配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检测配置是否正确</span></span><br><span class="line">nginx -t</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">热生效配置</span></span><br><span class="line">nginx -s reload</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者直接重启nginx</span></span><br><span class="line">sudo service nginx restart</span><br></pre></td></tr></table></figure>
<h2 id="4-客户端导入自签名证书">4. 客户端导入自签名证书</h2>
<p>哪台客户端要通过浏览器访问部署好的节点，就在哪个客户端导入自签名证书。这个证书就是前面命令生成的<code>/etc/ssl/certs/nginx-selfsigned.crt</code><br>
具体导入方式，需要去网上找找。这里比如mac系统，只要双击<code>.crt</code>证书，即可导入，导入后，在mac自带的证书工具中，将该证书设置为<code>全部信任</code>即可（一定要设置）。</p>
<h2 id="5-polkadot-apps可视化连接">5. polkadot apps可视化连接</h2>
<p>如果用的自签名证书，需要使用<code>safari浏览器</code>或者<code>火狐浏览器</code>来访问。<code>edge</code>和<code>chrome</code>浏览器不支持自签名证书，因此访问会一直失败。<br>
从上述配置可知，对外开放的是443端口，因此打开官方的<a href="https://github.com/polkadot-js/apps/">polkadot apps</a> 页面后，将里面的节点地址配置为：<code>wss://你的ip或域名地址:443</code><br>
页面即可访问节点</p>
<p>火狐浏览器中，需要设置将部署节点的服务器地址标记为信任，比如你的服务器地址是：192.168.1.2，则需要添加信任：<code>https://192.168.1.2:443</code><br>
火狐浏览器前往设置：设置 - 隐私与安全 - 查看证书 - 服务器  添加：<code>https://192.168.1.2:443</code></p>
<h3 id="5-1-访问失败原因">5.1 访问失败原因</h3>
<ol>
<li>nginx配置的对外访问的端口和你<a href="https://github.com/polkadot-js/apps/">polkadot apps</a> 中自己配置的地址的端口是否一致</li>
<li>防火墙是否开放该端口</li>
<li>目前chrome和edge不支持自签名证书(虽然魔改可以，但不建议，何必如此折腾)，只能使用<code>safari浏览器</code>或<code>火狐浏览器</code>，为此我还专门下了个多年没用过但<code>火狐浏览器</code>。</li>
<li>节点启动时候是否带上参数：<code>--rpc-cors all</code></li>
</ol>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://docs.substrate.io/quick-start/">Substrate官方文档</a><br>
[1] <a href="https://wiki.polkadot.network/docs/maintain-wss">Polkadot官方文档</a></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Substrate</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Substrate</tag>
      </tags>
  </entry>
  <entry>
    <title>substrate基础(1)-substrate-node-template编译及部署</title>
    <url>/articles/113dc518/</url>
    <content><![CDATA[<p><a href="https://github.com/substrate-developer-hub/substrate-node-template">substrate-node-template</a><br>
这个项目为substrate世界的入口，通过它来了解整个运转机制<br>
该项目主要是为了方便开发人员调试和测试，以及初次接触substrate的入门者首选，掌握该项目后，再去接触正式项目，会容易很多</p>
<span id="more"></span>  
<h2 id="快速启动">快速启动</h2>
<ol>
<li>这个项目是在rust的<code>nightly</code>版本下编译的，因此无论什么系统，一定要先安装好这个<code>nightly</code>版本环境（可以参考我早期文章<a href="https://www.bitxx.top/articles/10db6b0/">Rust基础(1)-环境搭建及HelloWorld</a> ）。如果本地有多个rust版本环境，可以如下切换：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装nightly</span></span><br><span class="line">rustup toolchain install nightly</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看有哪些环境</span></span><br><span class="line">rustup toolchain list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换为nightly版</span></span><br><span class="line">rustup default nightly</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>项目根目录下安装其余需要的依赖包：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rustup target add wasm32-unknown-unknown</span><br><span class="line">cargo install wasm-pack </span><br><span class="line">cargo install https</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>项目根目录开始编译：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo b -r</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>验证是否安装完毕</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./target/release/node-template --help</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>查看预定义帐户的帐户信息：alice</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./target/release/node-template key inspect //alice</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>启动开发环境</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./target/release/node-template --dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">稍微复杂点的启动，就是允许wss等对外通信</span></span><br><span class="line">./target/release/node-template --dev --ws-external --rpc-external --no-telemetry --rpc-cors all</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>使用polkadot apps可视化
<ol>
<li>可以使用源码<a href="https://github.com/polkadot-js/apps/">polkadot apps</a>编译前端页面</li>
<li>可以使用官方已经编译并部署好的前端<a href="https://github.com/polkadot-js/apps/">polkadot apps</a>，其中将节点改为自己编译的substrate地址。部署会有坑，建议参考我的另一篇文章 <a href="https://www.bitxx.top/articles/8aab1b7b/">substrate基础(2)-polkadot apps远端访问配置</a></li>
<li>目前具体页面操作请自行琢磨，后续我有可能会详细介绍</li>
</ol>
</li>
<li>使用<code>substrate-front-end-template</code>可视化
<ol>
<li><a href="https://github.com/substrate-developer-hub/substrate-front-end-template">substrate-front-end-template</a> 是官方提供的开发阶段的最简化页面，可以让开发人员很方便的可视化学习操作substrate，具体的编译和使用，请进去自行查看官方文档。很简单，这里就不解释了</li>
<li>简单整理下涉及到的命令：</li>
</ol>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装yarn</span></span><br><span class="line">npm install -g yarn</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载源码</span></span><br><span class="line">git clone https://github.com/substrate-developer-hub/substrate-front-end-template.git</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装依赖</span></span><br><span class="line">cd substrate-front-end-template</span><br><span class="line">yarn install</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动</span> </span><br><span class="line">yarn start</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译（可选）</span></span><br><span class="line">yarn build</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果节点是远端服务器，请先前往项目位置：src/config/development.json 修改节点地址</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nginx的配置文件中，注意：user www www的配置，根据实际情况调整，否则访问不到</span></span><br></pre></td></tr></table></figure>
<ol start="9">
<li>使用键盘<code>ctrl + c</code>停止节点</li>
</ol>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://docs.substrate.io/quick-start/">Substrate官方文档</a></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Substrate</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Substrate</tag>
      </tags>
  </entry>
  <entry>
    <title>tokio异步框架(1)-综合介绍</title>
    <url>/articles/55c9c527/</url>
    <content><![CDATA[<p>根据<a href="https://tokio.rs/tokio/tutorial">官方文档(官方英文)</a> (<a href="https://github.com/dslchd/tokio-cn-doc">官方文档-社区中文翻译</a>)，总结个人理解。<br>
每节标题与官方文档标题相对应</p>
<span id="more"></span>
<h2 id="1-介绍">1. 介绍</h2>
<p>官方通过一个简易版的redis项目<a href="https://github.com/tokio-rs/mini-redis">Mini Redis</a> 来讲解tokio的使用方式和原理<br>
建议先根据文档安装好这个项目</p>
<h2 id="2-hello-tokio">2. Hello Tokio</h2>
<p>启动<code>mini redis</code>，编写客户端代码，实现互通：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> mini_redis::&#123;client, <span class="type">Result</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// 打开链接到mini-redis的链接</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">client</span> = client::<span class="title function_ invoke__">connect</span>(<span class="string">&quot;127.0.0.1:6379&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 &quot;hello&quot; 键的值为 &quot;world&quot;</span></span><br><span class="line">    client.<span class="title function_ invoke__">set</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>.<span class="title function_ invoke__">into</span>()).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取&quot;hello&quot;的值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = client.<span class="title function_ invoke__">get</span>(<span class="string">&quot;hello&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;got value from the server; result=&#123;:?&#125;&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过基础案例，引入<code>async/await</code>概念。其中<code>async</code>将本段代码标记为异步，<code>await</code>执行并将结果和控制权返回到当前线程。也就是说，只有程序调用<code>await</code>时，异步代码才被真正执行。<br>
<code>#[tokio::main]</code>一个特殊的异步入口，为异步环境提供一个运行时环境</p>
<h2 id="3-spawning-产生-创建">3. Spawning(产生、创建)</h2>
<ol>
<li>官方案例中，使用代码来调用启动<code>mini redis</code>的服务器端，通过<code>Spawning</code>来确保可以同时接收并处理多个请求，可以支持存储或读取数据(这块在这一章目前数据不共享，就是说相同的key，客户端不同请求拿到的结果是不相同的，官方在为下一个概念做埋笔)</li>
<li><code>并发和并行不是同一个概念</code>，并发是指多个任务交替执行任务，其实一次只执行一个，只是根据算法高频率交替执行；并行是多个任务各自同时执行，互不干扰。</li>
<li><code>tokio的优点是异步代码可以让你同时处理许多并发任务, 而不必使用普通线程并行处理它们. Tokio可以在单个线程上并发处理许多任务.</code></li>
<li>为确保线程安全，外部变量必须<code>move</code>到异步块中，</li>
<li><code>await</code>会保存异步块中的状态，在异步块中执行的任务（主要是外部传入的变量）需要实现<code>Send</code> trait，如果不实现，则在调用<code>await</code>之前，必须要完成业务逻辑。否则程序会异常。
<ul>
<li>原理，被await的任务，会找别的合适的线程来执行该任务，也就是说该任务中的变量等等，均会被移动到别的线程。如果不实现<code>Send</code>，则该变量不是线程安全的。</li>
</ul>
</li>
</ol>
<h2 id="4-共享状态">4. 共享状态</h2>
<ol>
<li>可以通过两种概念方式来共享数据：
<ol>
<li>互斥锁</li>
<li>通道</li>
</ol>
</li>
<li>这里介绍的是互斥锁，通道后面专门会讲</li>
<li>区分：
<ol>
<li>调用Rust官方的<code>同步互斥锁Mutex</code> - std::sync::Mutex，可以在当前线程调用<code>lock</code>来锁定，请求量不大的时候，使用这个即可
<ol>
<li><code>同步互斥锁Mutex</code>在<code>await</code>前要释放掉，否则会被<code>await</code>移动，造成异常。可以加一个作用域。因为<code>.lock()</code>返回的<code>MutexGuard</code>没有实现<code>Send</code>，无法线程之间传递</li>
<li>最好将该锁放到结构体中，包装一个方法来操作，避免死锁问题</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为Mutex实现了Send，也就是CanIncrement也实现了Send</span></span><br><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CanIncrement</span> &#123;</span><br><span class="line">    mutex: Mutex&lt;<span class="type">i32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">CanIncrement</span> &#123;</span><br><span class="line">    <span class="comment">// 这个函数没有标识为异步函数</span></span><br><span class="line">    <span class="comment">// 方法释放，则lock也释放结束</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">increment</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lock</span> = <span class="keyword">self</span>.mutex.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        *lock += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">increment_and_do_stuff</span>(can_incr: &amp;CanIncrement) &#123;</span><br><span class="line">    can_incr.<span class="title function_ invoke__">increment</span>();</span><br><span class="line">    <span class="title function_ invoke__">do_something_async</span>().<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>tokio的<code>异步互斥锁Mutex</code> - tokio::sync::Mutex，通过调用<code>await</code>在内部后台来锁定，使用成本较高。一般建议用上面的方式。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::sync::Mutex; <span class="comment">// 注意这里是使用的 tokio的 Mutex</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段代码是能编译的</span></span><br><span class="line"><span class="comment">// (但是这种情况下选择重构代码会更好，就是结构体方式)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">increment_and_do_stuff</span>(mutex: &amp;Mutex&lt;<span class="type">i32</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lock</span> = mutex.<span class="title function_ invoke__">lock</span>().<span class="keyword">await</span>;</span><br><span class="line">    *lock += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">do_something_async</span>().<span class="keyword">await</span>;</span><br><span class="line">&#125; <span class="comment">// lock 在这里超出范围</span></span><br></pre></td></tr></table></figure>
<h2 id="5-通道">5. 通道</h2>
<ol>
<li>tokio提供了多种通道：
<ol>
<li>mpsc : 多生产者(multi-producer)单消费者(single-consumer)通道. 可以发送许多的值.</li>
<li>oneshot : 单生产者(single-producer)单消费者(single-consumer)通道. 可以发送单个值.</li>
<li>broadcast : 多生产者多消费者(广播). 可以发送许多值,每一个接收者都能看到每一个值.</li>
<li>watch : 单生产者多消费者. 可以发送许多值,但是不会保留历史记录. 接收者仅能看到最新的值.</li>
</ol>
</li>
<li>如果你需要一个多生产者多消费者通道且仅仅只想让一个消费者看到所有消息, 你可以使用<a href="https://docs.rs/async-channel/">async-channel</a>包</li>
<li>这些通道通过阻塞线程来等待消息, 这在异步代码中是不允许的：std::sync::mpsc 和 crossbeam::channel</li>
<li>rust默认库中，没有上限控制的队列，长时间下去，会占用完系统的所有内存，造成无法预测的后果。但tokio由于<code>await</code>机制，可以避免该问题的产生，一个<code>await</code>执行完后，才会执行下一个。</li>
<li>这一部分，官方使用通道重构了客户端连接<code>mini redis</code>的代码。其中，使用<code>mpsc</code>发送请求给<code>mini redis</code>，使用<code>oneshot</code>接收<code>mini redis</code>返回的响应，具体代码如下：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> bytes::Bytes;</span><br><span class="line"><span class="keyword">use</span> tokio::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> mini_redis::client;</span><br><span class="line"><span class="keyword">use</span> tokio::sync::oneshot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    Get &#123;</span><br><span class="line">        key: <span class="type">String</span>,</span><br><span class="line">        resp: Responder&lt;<span class="type">Option</span>&lt;Bytes&gt;&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">    Set &#123;</span><br><span class="line">        key: <span class="type">String</span>,</span><br><span class="line">        val: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;,</span><br><span class="line">        resp: Responder&lt;()&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Responder</span>&lt;T&gt; = oneshot::Sender&lt;mini_redis::<span class="type">Result</span>&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (<span class="keyword">mut</span> tx, <span class="keyword">mut</span> rx) = mpsc::<span class="title function_ invoke__">channel</span>(<span class="number">32</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">tx2</span> = tx.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t1</span> = tokio::<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (resp_tx, resp_rx) = oneshot::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cmd</span> = Command::Get &#123;</span><br><span class="line">            key: <span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            resp: resp_tx,</span><br><span class="line">        &#125;;</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(cmd).<span class="keyword">await</span>.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">res</span> = resp_rx.<span class="keyword">await</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;GOT = &#123;:?&#125;&quot;</span>, res);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t2</span> = tokio::<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (resp_tx, resp_rx) = oneshot::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cmd</span> = Command::Set &#123;</span><br><span class="line">            key: <span class="string">&quot;foo&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            val: <span class="string">b&quot;bar&quot;</span>.<span class="title function_ invoke__">to_vec</span>(),</span><br><span class="line">            resp: resp_tx,</span><br><span class="line">        &#125;;</span><br><span class="line">        tx2.<span class="title function_ invoke__">send</span>(cmd).<span class="keyword">await</span>.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">res</span> = resp_rx.<span class="keyword">await</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;GOT = &#123;:?&#125;&quot;</span>, res)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// move 关键字用来移动　rx 所有权到task中去</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">manager</span> = tokio::<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="comment">// 建立与Server的链接</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">client</span> = client::<span class="title function_ invoke__">connect</span>(<span class="string">&quot;127.0.0.1:6379&quot;</span>).<span class="keyword">await</span>.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始接收消息</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(cmd) = rx.<span class="title function_ invoke__">recv</span>().<span class="keyword">await</span> &#123;</span><br><span class="line">            <span class="keyword">match</span> cmd &#123;</span><br><span class="line">                Command::Get &#123; key, resp &#125; =&gt; &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">res</span> = client.<span class="title function_ invoke__">get</span>(&amp;key).<span class="keyword">await</span>;</span><br><span class="line">                    <span class="comment">// 忽略错误</span></span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">_</span> = resp.<span class="title function_ invoke__">send</span>(res);</span><br><span class="line">                &#125;</span><br><span class="line">                Command::Set &#123; key, val, resp &#125; =&gt; &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">res</span> = client.<span class="title function_ invoke__">set</span>(&amp;key, val.<span class="title function_ invoke__">into</span>()).<span class="keyword">await</span>;</span><br><span class="line">                    <span class="comment">// 忽略错误</span></span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">_</span> = resp.<span class="title function_ invoke__">send</span>(res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-i-o">6. I/O</h2>
<ol>
<li>异步读写，功能类似于Rust标准库的
<ol>
<li>async fn read()</li>
<li>async fn read_to_end()</li>
<li>async fn write()</li>
<li>async fn write_all()</li>
</ol>
</li>
<li>辅助函数<br>
与 std 包中一样, tokio::io模块也包含了一些有用的实用函数和用于处理标准输入,输出,错误的API. standard input, standard output, standard error . 比如, tokio::io::copy 可以异步将reader中的全部内容复制到writer中去.</li>
<li>通过<code>copy</code>案例，展示I/O的实现</li>
</ol>
<h2 id="7-frame">7. Frame</h2>
<p>这个是通过mini redis的数据解析功能，进一步来展示<code>I/O</code>的使用，没仔细看，<br>
这块的源码需要到：<a href="https://github.com/tokio-rs/mini-redis">Mini Redis</a> 来查看，有兴趣可以了解下Frame的实现</p>
<h2 id="8-深入异步">8. 深入异步</h2>
<ol>
<li>这一节将会深入讲解tokio异步的原理，从根本上解释整个逻辑。</li>
<li>Futures
<ol>
<li>与其它语言实现的future不一样， 一个Rust的future不代表在后台发生的计算，而是Rust的future就是计算本身. future的所有者通过轮询future来推进计算. 这是通过调用 Future::poll来完成的.</li>
<li><code>async</code>返回的是<code>future</code>值，它实现了标准库中的 <code>std::future::Future trait</code></li>
<li>总结
<ol>
<li>Rust的异步操作是惰性的，需要调用者对其进行轮询.</li>
<li>Wakers被传递给future,以将future与调用它的任务联系起来.</li>
<li>当一个资源没有准备好完成时，Poll::Pending被返回并记录任务的唤醒程序(waker).</li>
<li>当一个资源变为就绪状态时，就会通知任务的唤醒程序(waker).</li>
<li>执行器接收到通知并安排任务来执行.</li>
<li>任务再一次被轮询，这一次资源是就绪状态并且任务能够取得进展.</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="9-select">9. Select</h2>
<ol>
<li><code>tokio::select! </code>宏允许等待多个异步计算且当单个计算完成时返回(多个并发或并行异步计算任务，返回最先完成的那个).</li>
<li>select!宏能处理超过2个以上的分支. 当前最大限制64个分支.</li>
<li>tokio::spawn 与 select! 都可以运行并发异步操作. 但是用于运行并发操作的策略有所不同. tokio::spawn 函数传入一个异步操作并产生一个 新的任务去运行它. 任务是一个tokio运行时调度的对象. Tokio独立调度两个不同的任务. 它们可以在不同的操作系统线程上同时运行. 因此产生的任务与 产生的线程都有相同的限制: 不可借用.</li>
<li>select!宏能在同一个任务上同时运行所有分支. 因为select!宏上的所有分支被同一个任务执行，它们永远不会同时运行. select!宏的多路复用 异步操作也在单个任务上运行.</li>
</ol>
<h2 id="10-streams">10. Streams</h2>
<p>流是一个一系列异步值的称呼. 它与Rust的 std::iter::Iterator 异步等效且由 Stream trait表示. 流能在async函数中迭代. 它们也可以使用适配器进行 转换. Tokio在 StreamExt trait上提供了一些通用适配器.</p>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>tokio</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>tokio</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust进阶(15)-宏</title>
    <url>/articles/4c5ddb7/</url>
    <content><![CDATA[<p>宏</p>
<span id="more"></span>
<h2 id="1-概述">1. 概述</h2>
<ol>
<li>Rust中的宏主要有两种，一种是使用macro_rules!的声明宏；一种是过程宏。而过程宏又主要分为3种：
<ol>
<li>自定义宏#[derive]，在结构体、枚举等上指定通过derive属性添加代码</li>
<li>类属性宏，定义可用于任意项的自定义属性</li>
<li>类函数宏，看起来像函数但是作用于作为参数传递的Token</li>
</ol>
</li>
<li>宏和函数
<ol>
<li>宏是一种为写其它代码而写代码的方式。宏对于减少大量编写代码和维护代码非常有用</li>
<li>一个函数标签必须声明函数参数个数和类型，宏只接受可变参数</li>
<li>宏的定义比函数的定义更复杂</li>
<li>在调用宏之前，必须定义并将其引入作用域，而函数则可以在任何地方定义和调用</li>
</ol>
</li>
<li><code>#![xxx]</code>表示应用于整个crate，<code>#[]</code>表示应用于紧接之后的代码块</li>
</ol>
<h2 id="2-声明宏">2. 声明宏</h2>
<p>匹配对应模式然后以另一部分代码替换当前代码</p>
<p>主目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo new mac --lib</span><br><span class="line">cargo new main</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主目录</span></span><br><span class="line">vim Cargo.toml</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加入如下内容：</span></span><br><span class="line">[workspace]</span><br><span class="line">members = [</span><br><span class="line">    &quot;mac&quot;,</span><br><span class="line">    &quot;main&quot;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>lib.rs中：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> my_vec &#123;   <span class="comment">//my_vec! 模仿vec!</span></span><br><span class="line">    ($($x: expr), *) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">temp_vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">            $(</span><br><span class="line">               temp_vec.<span class="title function_ invoke__">push</span>($x);</span><br><span class="line">            )*</span><br><span class="line">            temp_vec</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main.rs中：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> mac;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = mac::my_vec![<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    <span class="comment">//mac::my_vec![1,2,3]等价于</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">temp_vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    temp_vec.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">    temp_vec.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">    temp_vec.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;v = &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;temp_vec = &#123;:?&#125;&quot;</span>, temp_vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-自定义derive宏-过程宏">3. 自定义derive宏（过程宏）</h2>
<ol>
<li>过程宏接收Rust代码作为输入，在这些代码上进行操作，然后产生另一些代码作为输出，而非像声明宏那样匹配对应模式然后以另一部分代码替换当前代码</li>
<li>定义过程宏的函数接受一个TokenStream作为输入并产生一个TokenStream作为输出。这也就死活宏的核心：宏所处理的源代码组成了输入TokenStream，同时宏生成的代码是出入TokenStream。如下格式：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> proc_macro;</span><br><span class="line"><span class="meta">#[some_attribute]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">some_name</span>(input:TokenStream) <span class="punctuation">-&gt;</span> TokenStream&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>项目主目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo new hello_macro --lib</span><br><span class="line">cargo new main</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入heloo_macro目录，创建：</span></span><br><span class="line">cargo new hello_macro_derive --lib</span><br></pre></td></tr></table></figure>
<p>hello_macro的lib：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">HelloMacro</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">hello_macro</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hello_macro_derive中Cargo.toml关键配置：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[lib]</span></span><br><span class="line"><span class="attr">proc-macro</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">syn</span> = <span class="string">&quot;0.14.4&quot;</span></span><br><span class="line"><span class="attr">quote</span> = <span class="string">&quot;0.6.3&quot;</span></span><br></pre></td></tr></table></figure>
<p>hello_macro_derive中lib.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> proc_macro;</span><br><span class="line"><span class="keyword">use</span> crate::proc_macro::TokenStream;</span><br><span class="line"><span class="keyword">use</span> quote::quote;</span><br><span class="line"><span class="keyword">use</span> syn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">impl_hello_macro</span>(ast: &amp;syn::DeriveInput) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = &amp;ast.ident;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">gen</span> = quote! &#123;</span><br><span class="line">        <span class="keyword">impl</span> <span class="title class_">HelloMacro</span> <span class="keyword">for</span> #name&#123;</span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">hello_macro</span>()&#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Hello,in my macro, my name is &#123;&#125;&quot;</span>, <span class="built_in">stringify!</span>(#name));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    gen.<span class="title function_ invoke__">into</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[proc_macro_derive(HelloMacro)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">hello_macro_derive</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ast</span> = syn::<span class="title function_ invoke__">parse</span>(input).<span class="title function_ invoke__">unwrap</span>();  <span class="comment">//D eriveInput</span></span><br><span class="line">    <span class="title function_ invoke__">impl_hello_macro</span>(&amp;ast)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main的Cargo.toml中：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">hello_macro</span> = &#123;path = <span class="string">&quot;../hello_macro&quot;</span>&#125;</span><br><span class="line"><span class="attr">hello_macro_derive</span> = &#123;path = <span class="string">&quot;../hello_macro/hello_macro_derive&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>main的main.rs中：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> hello_macro::HelloMacro;</span><br><span class="line"><span class="keyword">use</span> hello_macro_derive::HelloMacro;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(HelloMacro)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Main</span>;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    Main::<span class="title function_ invoke__">hello_macro</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-类属性宏和类函数宏-过程宏">4. 类属性宏和类函数宏（过程宏）</h2>
<ol>
<li>类属性宏
<ol>
<li>类属性宏与自定义派生宏相似，不同于为derive属性生成代码，它们允许你创建新的属性</li>
<li>类属性宏其它工作方式和自定义derive宏工作方式一致</li>
</ol>
</li>
<li>类函数宏
<ol>
<li>类函数宏定义看起来像函数调用的宏，类似于macro_rules!，它们比函数更灵活</li>
</ol>
</li>
</ol>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://kaisery.github.io/trpl-zh-cn/">Rust 程序设计语言</a><br>
[2] <a href="https://danielkeep.github.io/tlborm/book/README.html">The Little Book of Rust Macros</a></p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust进阶</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust进阶(14)-高级特征、高级函数、闭包</title>
    <url>/articles/51c2efe4/</url>
    <content><![CDATA[<p>高级特征、高级函数、闭包</p>
<span id="more"></span> 
<h2 id="1-高级特征">1. 高级特征</h2>
<h3 id="1-1-关联类型在trait定义中指定占位符类型">1.1 关联类型在trait定义中指定占位符类型</h3>
<ol>
<li>关联类型是一个将类型占位符与trait相关联的方式。使用<code>type xxx</code>定义</li>
<li>trait的实现者会针对特定的实现在这个类型的位置指定相应的具体类型</li>
<li>如此可以定义几个使用多种类型的trait</li>
<li>如下官方迭代器泛型：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用占位符，指定一种类型 u32：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    count: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Counter &#123;</span><br><span class="line">        Counter &#123; count: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">u32</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.count &lt; <span class="number">6</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.count)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = Counter::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">6</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(v) = counter.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;i = &#123;&#125;, v = &#123;&#125;&quot;</span>, i, v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;i = &#123;&#125;, at end&quot;</span>, i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然也可以使用泛型，但对于其中的不同类型数据，需要强制转换，即<code>完全限定语法</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator1</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator1</span>&lt;<span class="type">i32</span>&gt; <span class="keyword">for</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;in i32&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.value &gt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.value += <span class="number">1</span>;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.value)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator1</span>&lt;<span class="type">String</span>&gt; <span class="keyword">for</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">String</span>&gt;&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;in string&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.value &gt;<span class="number">3</span>&#123;</span><br><span class="line">            <span class="keyword">self</span>.value += <span class="number">1</span>;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = A&#123;value:<span class="number">3</span>&#125;;</span><br><span class="line">    &lt;A <span class="keyword">as</span> Iterator1&lt;<span class="type">i32</span>&gt;&gt;::<span class="title function_ invoke__">next</span>(&amp;<span class="keyword">mut</span> a);   <span class="comment">//完全限定语法，带上了具体的类型</span></span><br><span class="line">    &lt;A <span class="keyword">as</span> Iterator1&lt;<span class="type">String</span>&gt;&gt;::<span class="title function_ invoke__">next</span>(&amp;<span class="keyword">mut</span> a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-运算符重载和默认泛型类型参数">1.2 运算符重载和默认泛型类型参数</h3>
<ol>
<li>使用泛型类型参数时，可以为泛型指定一个默认的具体类型</li>
<li>运算符重载是指在特定情况下自定义运算符行为的操作</li>
<li>Rust并不允许创建自定义运算符或者重载的运算符</li>
<li>不过对于std::ops中列出的运算符和相应的trait，我们可以实现运算符相关trait来重载</li>
</ol>
<h4 id="1-2-1-重载运算符">1.2.1 重载运算符</h4>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Add;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, PartialEq)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Add</span> <span class="keyword">for</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Point;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, other: Point) <span class="punctuation">-&gt;</span> Point &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x + other.y,</span><br><span class="line">            y: <span class="keyword">self</span>.y + other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(Point &#123; x: <span class="number">1</span>, y: <span class="number">1</span> &#125; + Point &#123; x: <span class="number">2</span>, y: <span class="number">2</span> &#125;, Point &#123; x: <span class="number">3</span>, y: <span class="number">3</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-2-默认泛型类型参数">1.2.2 默认泛型类型参数</h4>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Add;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Millimeters</span>(<span class="type">u32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Meters</span>(<span class="type">u32</span>);</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Add</span>&lt;Meters&gt; <span class="keyword">for</span> <span class="title class_">Millimeters</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Millimeters;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, other: Meters) <span class="punctuation">-&gt;</span> Millimeters &#123;</span><br><span class="line">        <span class="title function_ invoke__">Millimeters</span>(<span class="keyword">self</span>.<span class="number">0</span> + other.<span class="number">0</span> * <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mi</span> = <span class="title function_ invoke__">Millimeters</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = <span class="title function_ invoke__">Meters</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = mi + m;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r = &#123;:?&#125;&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-完全限定语法">1.3 完全限定语法</h3>
<h4 id="1-3-1-完全限定语法实现">1.3.1 完全限定语法实现</h4>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">baby_name</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dog</span>;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">baby_name</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span>&#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Spot&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Animal</span> <span class="keyword">for</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">baby_name</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;puppy&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;baby_name: &#123;&#125;&quot;</span>,Dog::<span class="title function_ invoke__">baby_name</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;baby_name: &#123;&#125;&quot;</span>,&lt;Dog <span class="keyword">as</span> Animal&gt;::<span class="title function_ invoke__">baby_name</span>());  <span class="comment">//完全限定语法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-2-同名同trait方法调用">1.3.2 同名同trait方法调用</h4>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyType</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">A</span> <span class="keyword">for</span> <span class="title class_">MyType</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print</span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;A trait for MyType&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">B</span> <span class="keyword">for</span> <span class="title class_">MyType</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print</span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;B trait for MyType&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MyType</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print</span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;MyType&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_type</span> = MyType;</span><br><span class="line">    my_type.<span class="title function_ invoke__">print</span>();</span><br><span class="line">    <span class="comment">//等价</span></span><br><span class="line">    MyType::<span class="title function_ invoke__">print</span>(&amp;my_type);</span><br><span class="line"></span><br><span class="line">    A::<span class="title function_ invoke__">print</span>(&amp;my_type);</span><br><span class="line">    B::<span class="title function_ invoke__">print</span>(&amp;my_type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-父trait">1.4 父trait</h3>
<ol>
<li>用于在另一个trait中使用某trait的功能</li>
<li>有时候我们可能会需要某个trait使用另一个trait的功能</li>
<li>在这种情况下，需要能够依赖相关的trait也被实现</li>
<li>这个所需的trait是我们实现的trait的父(超)trait（supertrait）</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">OutPrint</span>: fmt::Display &#123;</span><br><span class="line">    <span class="comment">//要求实现Display trait</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">out_print</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">output</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;output: &#123;&#125;&quot;</span>, output);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">OutPrint</span> <span class="keyword">for</span> <span class="title class_">Point</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;(&#123;&#125;,&#123;&#125;)&quot;</span>, <span class="keyword">self</span>.x, <span class="keyword">self</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-5-nettype模式用以在外部类型上实现外部trait">1.5 nettype模式用以在外部类型上实现外部trait</h3>
<ol>
<li>孤儿规则(orphan rule)：只要trait或类型对于当前crate是本地的话就可以在此类型上实现该trait.</li>
<li>一个绕开这个限制的方法是使用newtype模式(newtype pattern)</li>
<li>即使用<code>Wrapper</code>关键词</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper</span>(<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Wrapper</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>,f:&amp;<span class="keyword">mut</span> fmt::Formatter)<span class="punctuation">-&gt;</span>fmt::<span class="type">Result</span>&#123;</span><br><span class="line">        <span class="built_in">write!</span>(f,<span class="string">&quot;(&#123;&#125;)&quot;</span>,<span class="keyword">self</span>.<span class="number">0</span>.<span class="title function_ invoke__">join</span>(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">w</span> = <span class="title function_ invoke__">Wrapper</span>(<span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>),<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world&quot;</span>)]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;w = &#123;&#125;&quot;</span>,w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-6-类型别名">1.6 类型别名</h3>
<p>类型别名的主要用途是减少重复</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Kilometers</span> = <span class="type">i32</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i32</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>: Kilometers = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span>: <span class="type">i32</span> = x + y;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x +y = &#123;&#125;&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-7-从不返回的never-type">1.7 从不返回的never type</h3>
<p>Rust有一个叫做<code>!</code>的特殊类型，在类型理论术语中，它被称为empty type，因为它没有值。我们更倾向于称为nerver type。在函数不返回的时候充当返回值。</p>
<h2 id="2-高级函数和闭包">2. 高级函数和闭包</h2>
<ol>
<li>函数指针允许我们使用函数作为另一个函数的参数</li>
<li>函数的类型是fn，fn 被称为函数指针。指定参数为函数指针的语法类似于闭包</li>
<li>函数指针实现了Fn、FnMut、FnOnce</li>
</ol>
<h3 id="2-1-函数指针和闭包的基本使用">2.1 函数指针和闭包的基本使用</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add_one</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">do_twice</span>(f: <span class="title function_ invoke__">fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>, val: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>(val) + <span class="title function_ invoke__">f</span>(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">wapper_func</span>&lt;T&gt;(t: T, v: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> <span class="keyword">where</span> T: <span class="title function_ invoke__">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">t</span>(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">func</span>(v: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    v + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = <span class="title function_ invoke__">do_twice</span>(add_one, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r = &#123;&#125;&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">wapper_func</span>(|x| x + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;&#125;&quot;</span>, a);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">wapper_func</span>(func, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-函数指针返回闭包">2.2 函数指针返回闭包</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">return_clo</span>() <span class="punctuation">-&gt;</span><span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>(<span class="type">i32</span>)<span class="punctuation">-&gt;</span><span class="type">i32</span>&gt;&#123;</span><br><span class="line">    <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(|x| x+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">return_clo</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;1 + 1 = &#123;&#125;&quot;</span>,<span class="title function_ invoke__">c</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;1 + 1 = &#123;&#125;&quot;</span>,(*c)(<span class="number">1</span>));  <span class="comment">//解引用多态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://kaisery.github.io/trpl-zh-cn/">Rust 程序设计语言</a></p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust进阶</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust进阶(13)-不安全代码</title>
    <url>/articles/6ea3e8c3/</url>
    <content><![CDATA[<p>不安全代码</p>
<span id="more"></span> 
<h2 id="1-概述">1. 概述</h2>
<ol>
<li>之前介绍的都是安全的Rust，即Rust在编译时会强制执行的内存安全保证。不会强制执行这类内存安全保证的，就是不安全的Rust.</li>
<li>不安全的Rust存在的两大原因：
<ol>
<li>静态分析本质上是保守的，就意味着某些代码可能是合法的，但是Rust也会拒绝。在此情况下，可使用不安全的代码</li>
<li>底层计算机硬件固有的不安全性。如果Rust不允许进行不安全操作，有些任务根本就完成不了</li>
</ol>
</li>
<li>不安全的Rust具有的超级力量，Rust会通过unsafe关键字切换到不安全的Rust。不安全的Rust具有以下超级力量：
<ol>
<li>解引用裸指针，看<code>第2节</code>代码
<ol>
<li>不可变和可变的，分别写作*const T, *mut T
<ol>
<li>允许忽略借用规则，可以同时拥有不可变和可变的指针，或者是多个指向相同位置的可变指针</li>
<li>不保证指向的内存是有效的</li>
<li>允许为空</li>
<li>不能实现任何自动清理的功能</li>
</ol>
</li>
</ol>
</li>
<li>调用不安全的函数或者方法</li>
<li>访问或修改可变静态变量</li>
<li>实现不安全的trait</li>
</ol>
</li>
<li>注意：unsafe并不会关闭借用检查器或禁用任何其它的Rust安全检测规则，它只提供上述几个不被编译器检查内存安全的功能。unsafe也不意味着块中的代码一定就是不ok的，它只是表示由程序员来确保安全的。</li>
</ol>
<h2 id="2-解引用裸指针">2. 解引用裸指针</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//创建不可变和可变的裸指针可以在安全的代码中，只是不能再安全代码块之外解引用裸指针</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;  <span class="comment">//不可变裸指针</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;r1 is: &#123;&#125;&quot;</span>, *r1);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;r2 is: &#123;&#125;&quot;</span>, *r2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">add</span> = <span class="number">0x12345usize</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = add <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-不安全函数以及c语言和rust互调">3. 不安全函数以及C语言和rust互调</h2>
<p>c语言调用rust，这里不考虑<br>
调用不同语言，本身就不安全</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">abs</span>(input:<span class="type">i32</span>)<span class="punctuation">-&gt;</span> <span class="type">i32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">dangerous</span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;do something dengerous&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;*r1 = &#123;&#125;&quot;</span>,*r1);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;*r2 = &#123;&#125;&quot;</span>,*r2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">dangerous</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">foo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用c语言</span></span><br><span class="line">    <span class="keyword">unsafe</span>&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;abs(-3): &#123;&#125;&quot;</span>,<span class="title function_ invoke__">abs</span>(-<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-访问或者修改可变静态变量">4. 访问或者修改可变静态变量</h2>
<ol>
<li>静态变量有一个固定的内存地址（使用这个值总会访问相同的地址），常量则允许在任何被用到的时候复制其数据</li>
<li>静态变量可以是可变的，虽然这可能是不安全（使用unsafe包含）</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> COUNTER: <span class="type">u32</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_counter</span>(inc:<span class="type">u32</span>)&#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        COUNTER += inc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">add_counter</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;counter:&#123;&#125;&quot;</span>,COUNTER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-实现不安全的trait">5. 实现不安全的trait</h2>
<ol>
<li>当至少又一个方法中包含编译器不能验证的不变量时，该trait就是不安全的</li>
<li>在trait之前增加unsafe声明其为不安全的，同时trait的实现也必须用unsafe标记</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">trait</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">foo</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bar</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> <span class="title class_">Foo</span> <span class="keyword">for</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">foo</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">Bar</span>();</span><br><span class="line">    a.<span class="title function_ invoke__">foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://kaisery.github.io/trpl-zh-cn/">Rust 程序设计语言</a></p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust进阶</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust进阶(12)-模式</title>
    <url>/articles/57cee36a/</url>
    <content><![CDATA[<p>模式</p>
<span id="more"></span> 
<h2 id="1-概述">1. 概述</h2>
<ol>
<li>模式是Rust中特殊的语法，模式用来匹配值的结构</li>
<li>模式在使用它的地方并不都是相同的，模式存在不可反驳的和可反驳的
<ol>
<li>refutable(可反驳)和irrefutable(不可反驳)。能匹配任何传递的可能值的模式被称为是不可反驳的。对值进行匹配可能会失败的模式被称为可反驳的</li>
<li>只能接受不可反驳模式的有：函数、let语句、for循环。原因：因为通过不匹配的值程序无法进行有意义的工作</li>
<li>if let和while let表达式被限制为只能接受可反驳的模式，因为它们的定义就是为了处理有可能失败的条件</li>
</ol>
</li>
<li>模式由如下内容组成：
<ol>
<li>字面值</li>
<li>解构的数组、枚举、结构体或者元组</li>
<li>变量</li>
<li>通配符</li>
<li>占位符</li>
</ol>
</li>
</ol>
<h2 id="2-基本使用">2. 基本使用</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">//1. match</span></span><br><span class="line">    <span class="comment">//必须匹配完所有情况</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">match</span> a &#123;</span><br><span class="line">        <span class="number">0</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Zero&quot;</span>),</span><br><span class="line">        <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;One&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;other&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. if let</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">color</span>: <span class="type">Option</span>&lt;&amp;<span class="type">str</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">is_ok</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">age</span>: <span class="type">Result</span>&lt;<span class="type">u8</span>, _&gt; = <span class="string">&quot;33&quot;</span>.<span class="title function_ invoke__">parse</span>();</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(c) = color &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;color: &#123;&#125;&quot;</span>, c);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> is_ok &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;is ok&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Ok</span>(a) = age &#123;</span><br><span class="line">        <span class="keyword">if</span> a &gt; <span class="number">30</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;oh,mature man&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;oh,young man&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;in else&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. while let</span></span><br><span class="line">    <span class="comment">//只要模式匹配就一直执行wihle循环</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stack</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    stack.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">    stack.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">    stack.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(top) = stack.<span class="title function_ invoke__">pop</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;top = &#123;&#125;&quot;</span>, top);</span><br><span class="line">    &#125;<span class="comment">//只要匹配Some(value),就会一直循环</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. for循环</span></span><br><span class="line">    <span class="comment">//在for循环中，模式是直接跟随for关键字的值，例如for x in y，x就是对应的模式</span></span><br><span class="line">    <span class="comment">//此处模式是(index, value)</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> v.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;index: &#123;&#125;, value: &#123;&#125;&quot;</span>, index, value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. let</span></span><br><span class="line">    <span class="comment">//let PATTERN = EXPRESSION</span></span><br><span class="line">    <span class="keyword">let</span> (x, y, z) = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">//(1,2,3)会匹配(x,y,z)，将1绑定x，2绑定y，3绑定z</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, x, y, z);</span><br><span class="line">    <span class="keyword">let</span> (x, .., z) = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, x, y, z);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6. 函数</span></span><br><span class="line">    <span class="comment">//函数的参数也是模式</span></span><br><span class="line">    <span class="comment">//&amp;(3, 5)匹配模式&amp;(x, y)</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = (<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="title function_ invoke__">print_point</span>(&amp;p);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_point</span>(&amp;(x, y): &amp;(<span class="type">i32</span>, <span class="type">i32</span>)) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x: &#123;&#125;, y: &#123;&#125;&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-模式的不可反驳和可反驳">3. 模式的不可反驳和可反驳</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">//错误</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>); <span class="comment">//匹配Some(value),None</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>; <span class="comment">//匹配Some(value),None</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Some</span>(x) = a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if let Some(v) = a &#123;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span>  <span class="variable">v</span> = <span class="number">5</span>&#123;   <span class="comment">//不可反驳模式写在可反驳模式中，会有警告，不建议这么写</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;v &#123;&#125;&quot;</span>,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://kaisery.github.io/trpl-zh-cn/">Rust 程序设计语言</a></p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust进阶</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust进阶(11)-对象</title>
    <url>/articles/aefaeeb0/</url>
    <content><![CDATA[<p>对象</p>
<span id="more"></span> 
<h2 id="1-概述">1. 概述</h2>
<p>对象、封装、继承<br>
对象：数据和操作数据的过程<br>
Rust里面，结构体、枚举类型加上impl块</p>
<p>Rust中没有继承概念，可以通过tait来进行行为共享</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print_name</span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Dog name = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d</span> = Dog&#123;name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;wangcai&quot;</span>)&#125;;</span><br><span class="line">    d.<span class="title function_ invoke__">print_name</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-封装">2. 封装</h2>
<p>默认是私有的，标记<code>pub</code>后才是对外开放公有的<br>
通过以下代码体验封装过程：</p>
<p>项目根目录：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[workspace]</span></span><br><span class="line"><span class="attr">members</span> = [</span><br><span class="line">    <span class="string">&quot;getaver&quot;</span>,</span><br><span class="line">    <span class="string">&quot;main&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>创建<code>main</code>子项目和<code>getaver</code>lib</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo new main</span><br><span class="line">cargo new getaver --lib</span><br></pre></td></tr></table></figure>
<p>在getaver的libs中：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">AverCollect</span> &#123;</span><br><span class="line">    list: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;,</span><br><span class="line">    aver: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">AverCollect</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> AverCollect &#123;</span><br><span class="line">        AverCollect &#123;</span><br><span class="line">            list: <span class="built_in">vec!</span>[],</span><br><span class="line">            aver: <span class="number">0.0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: <span class="type">i32</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.list.<span class="title function_ invoke__">push</span>(value);</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">update_average</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">average</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.aver</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">remove</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">self</span>.list.<span class="title function_ invoke__">pop</span>();</span><br><span class="line">        <span class="keyword">match</span> result &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(value) =&gt; &#123;</span><br><span class="line">                <span class="keyword">self</span>.<span class="title function_ invoke__">update_average</span>();</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(value)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">update_average</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">total</span>: <span class="type">i32</span> = <span class="keyword">self</span>.list.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">sum</span>();</span><br><span class="line">        <span class="keyword">self</span>.aver = total <span class="keyword">as</span> <span class="type">f64</span> / <span class="keyword">self</span>.list.<span class="title function_ invoke__">len</span>() <span class="keyword">as</span> <span class="type">f64</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在main中：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> getaver;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = getaver::AverCollect::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    a.<span class="title function_ invoke__">add</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;average = &#123;&#125;&quot;</span>, a.<span class="title function_ invoke__">average</span>());</span><br><span class="line"></span><br><span class="line">    a.<span class="title function_ invoke__">add</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;average = &#123;&#125;&quot;</span>, a.<span class="title function_ invoke__">average</span>());</span><br><span class="line"></span><br><span class="line">    a.<span class="title function_ invoke__">add</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;average = &#123;&#125;&quot;</span>, a.<span class="title function_ invoke__">average</span>());</span><br><span class="line"></span><br><span class="line">    a.<span class="title function_ invoke__">remove</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;average = &#123;&#125;&quot;</span>, a.<span class="title function_ invoke__">average</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-trait-对象">3.  trait 对象</h2>
<ol>
<li>trait对象动态分发：
<ol>
<li>对泛型类型使用trait bound编译器进行的方式是单态化处理，单态化的代码进行的是静态分发（就是说编译器在编译的时候就知道调用了什么方法）</li>
<li>使用trait对象时，Rust必须使用动态分发。编译器无法知晓所有可能用于trait对象代码的类型，所以它也不知道应该调用哪个类型的哪个方法实现。为此，Rust在运行时使用trait对象中的指针来知晓需要调用哪个方法。</li>
</ol>
</li>
<li>trait对象要求对象安全
<ol>
<li>只有对象安全(object safe)的trait才可以组成trait对象。trait的方法满足以下两条要求才是对象安全的：
<ol>
<li>返回值类型不为self</li>
<li>方法没有任何泛型类型参数</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="3-1-trait对象动态分发">3.1 trait对象动态分发</h3>
<p>备注，下方lib代码需要注意：泛型是单态化，一次性只能识别一种类型。如果components中多种类型，则编译会异常<br>
lib中：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型是单态化，一次性只能识别一种类型。如果components中多种类型，则编译会异常</span></span><br><span class="line"><span class="comment">//因此这里不能使用泛型trait</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> components: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Draw&gt;&gt;,   <span class="comment">//trait对象，使用dyn关键字。这里指传入的类型要实现draw</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">comp</span> <span class="keyword">in</span> <span class="keyword">self</span>.components.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">            comp.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> width: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> height: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> label: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;draw button, width = &#123;&#125;, height = &#123;&#125;, label = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.width, <span class="keyword">self</span>.height, <span class="keyword">self</span>.label);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SelectBox</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> width: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> height: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> option: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">SelectBox</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;draw select, width = &#123;&#125;, height = &#123;&#125;, option = &#123;:?&#125;&quot;</span>, <span class="keyword">self</span>.width, <span class="keyword">self</span>.height, <span class="keyword">self</span>.option);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main中：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> gui::&#123;Screen, Button, SelectBox&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = Screen &#123;</span><br><span class="line">        components: <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Button &#123;</span><br><span class="line">                width: <span class="number">50</span>,</span><br><span class="line">                height: <span class="number">10</span>,</span><br><span class="line">                label: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;ok&quot;</span>),</span><br><span class="line">            &#125;),</span><br><span class="line">            <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(SelectBox &#123;</span><br><span class="line">                width: <span class="number">60</span>,</span><br><span class="line">                height: <span class="number">40</span>,</span><br><span class="line">                option: <span class="built_in">vec!</span>[</span><br><span class="line">                    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yes&quot;</span>),</span><br><span class="line">                    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;No&quot;</span>),</span><br><span class="line">                    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;MayBe&quot;</span>),</span><br><span class="line">                ],</span><br><span class="line">            &#125;),</span><br><span class="line">        ],</span><br><span class="line">    &#125;;</span><br><span class="line">   s.<span class="title function_ invoke__">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-trait对象要求对象安全">3.2 trait对象要求对象安全</h3>
<p>对象安全的trait才能组成对象<code>dyn xxx</code><br>
以下代码会异常，因为Clone对象不安全，具体看前面综述：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line">    <span class="keyword">pub</span> com:<span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="built_in">Clone</span>&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://kaisery.github.io/trpl-zh-cn/">Rust 程序设计语言</a></p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust进阶</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust进阶(10)-多线程、通道、互斥器</title>
    <url>/articles/949f97e4/</url>
    <content><![CDATA[<p>多线程和通道</p>
<span id="more"></span> 
<h2 id="1-多线程">1. 多线程</h2>
<ol>
<li>进程是资源分配的最小单位，线程是CPU调度的最小单位</li>
<li>在使用多线程时，经常会遇到一些问题：
<ol>
<li>竞争状态：多个线程以不一致的顺序访问数据或资源</li>
<li>死锁：两个线程相互等待对方停止使用其所拥有的资源，造成两者都永久等待；</li>
<li>只会发生在特定情况下且难以稳定重现和修复的bug</li>
</ol>
</li>
<li>编程语言提供的线程叫做绿色线程，入golang，在底层实现了M:N的模型，即M个绿色线程对应N个OS线程。但是，Rust标准库只提供1：1的线程模型的实现，即一个Rust线程对应一个0s线程</li>
<li>运行时代表二进制文件中包含的由语言本身提供的代码，这些代码根据语言的不同可大可小，不过非汇编语言都会有一定数量的运行时代码。通常，大家说一个语言&quot;没有运行时&quot;，是指这个语言的&quot;运行时&quot;很小。Rust、c都是几乎没有运行时的。</li>
</ol>
<h3 id="1-1-基本实现">1.1 基本实现</h3>
<p>包括join的使用</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;number &#123;&#125; in spawn thread!&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;number &#123;&#125;&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待线程执行结束，有join的地方先等待线程执行结束，才执行后续内容</span></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-move闭包">1.2 move闭包</h3>
<p>下方代码会报错：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="comment">//线程中借用了外部的变量</span></span><br><span class="line">        <span class="comment">//不确定v的有效期是多久</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;v: &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方案，使用move，子线程获取变量数据所有权：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="comment">//使用move将v的所有权移动到子 线程</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;v: &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-通道">2. 通道</h2>
<ol>
<li>Rust中一个实现消息传递并发的主要工具是通道。通道由两部分组成，一个是发送端，一个是接收端，发送端用来发送消息，接收端用来接收消息。发送者或接受者任一被丢弃时就可以认为通道被关闭了</li>
<li>通道介绍
<ol>
<li>通过mpsc::channel，创建通道，mpsc是多个生产者，单个消费者；</li>
<li>通过spmc::channel，创建通道，spmc是一个生产者，多个消费者；</li>
<li>创建通道后返回的是发送者和消费者，示例：
<ol>
<li>let (tx,rx) = mpsc::channel();</li>
<li>let (tx,rx) = spmc::channel();</li>
</ol>
</li>
</ol>
</li>
<li>重点：
<ol>
<li>发送者的send方法返回的是一个Result&lt;T,E&gt;，如果接收端已经被丢弃了，将没有发送值的目标，此时发送会返回错误</li>
<li>接收者的recv返回值也是一个Result&lt;T,E&gt;，当通道发送端关闭时，返回一个错误值。</li>
<li>这里使用当recv方法，会阻塞到有一个消息到来。我们也可以使用try_recv()，不会阻塞，会立即返回</li>
</ol>
</li>
</ol>
<h3 id="2-1-通道简单实现">2.1 通道简单实现</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> (tx,rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">   thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">      <span class="keyword">let</span> <span class="variable">val</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">      <span class="comment">//发送，会将val的所有权交给通道(move)</span></span><br><span class="line">      tx.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">      <span class="comment">//val的所有权已经交给通道，因此执行下面打印会报错</span></span><br><span class="line">      <span class="comment">//println!(&quot;val = &#123;&#125;&quot;,val);</span></span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="comment">//接收</span></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">received</span> = rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>,received);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-一个生产者连续发送多个值">2.2 一个生产者连续发送多个值</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> (tx,rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">   thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">      <span class="keyword">let</span> <span class="variable">vals</span> = <span class="built_in">vec!</span>[</span><br><span class="line">         <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi&quot;</span>),</span><br><span class="line">         <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;from&quot;</span>),</span><br><span class="line">         <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;the&quot;</span>),</span><br><span class="line">         <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;thread&quot;</span>),</span><br><span class="line">      ];</span><br><span class="line">      <span class="comment">//发送</span></span><br><span class="line">      <span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> vals&#123;</span><br><span class="line">         tx.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">         thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="comment">//接收</span></span><br><span class="line">   <span class="keyword">for</span> <span class="variable">recv</span> <span class="keyword">in</span> rx&#123;</span><br><span class="line">      <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>,recv);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-多个生产者连续发送多个值">2.3 多个生产者连续发送多个值</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx,rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tx1</span> = mpsc::Sender::<span class="title function_ invoke__">clone</span>(&amp;tx);</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">vals</span> = <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;from&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;the&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;thread&quot;</span>),</span><br><span class="line">        ];</span><br><span class="line">        <span class="comment">//发送</span></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> vals&#123;</span><br><span class="line">            tx1.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">vals</span> = <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;A&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;B&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;C&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;D&quot;</span>),</span><br><span class="line">        ];</span><br><span class="line">        <span class="comment">//发送</span></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> vals&#123;</span><br><span class="line">            tx.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">recv</span> <span class="keyword">in</span> rx&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>,recv);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-互斥器">3. 互斥器</h2>
<ol>
<li>即mutex</li>
<li>Mutex<T></li>
<li>通道类似于单所有权的方式，值传递到通道后，发送者就无法再使用这个值</li>
<li>任意时刻，只允许一个线程来访问某些数据</li>
<li>互斥器使用时，需要先获取到锁，使用后需要释放锁</li>
<li>Mutex<T>是一个智能指针，lock调用返回一个叫做MutexGuard的智能指针，内部提供了drop方法，实现当MutexGuard离开作用域时自动释放锁</li>
</ol>
<h3 id="3-1-基本实现">3.1 基本实现</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = m.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        *num = <span class="number">6</span>;</span><br><span class="line">    &#125;<span class="comment">//离开作用域时，自动释放锁</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;m = &#123;:?&#125;&quot;</span>,m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-线程中使用锁">3.2 线程中使用锁</h3>
<p>线程中共享数据：<br>
Rc非线程安全，不得使用；因此使用Arc智能指针,功能类似于Rc，但线程安全。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cnt</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = cnt.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;result = &#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-refcell-t-rc-t-与mutex-t-arc-t-比较">3.3 RefCell<T>/Rc<T> 与Mutex<T>/Arc<T>比较</h3>
<ol>
<li>Mutex<T>提供内部可变性，类似于RefCell</li>
<li>RefCell<T>/Rc<T>非线程安全，Mutex<T>/Arc<T>线程安全</li>
</ol>
<h2 id="4-重点：send和sync-trait介绍">4. 重点：send和sync trait介绍</h2>
<ol>
<li>有两个并发概念内嵌于rust语言中：std:marker中的Sync和Send trait</li>
<li>通过send允许在线程间转移所有权
<ol>
<li>Send标记trait表明类型的所有权可以在线程间传递信息。几乎所有的Rust类型都是Send，但是例外：例如Rc<T>是不能Send的</li>
<li>任何完全由Send类型组成的类型也会自动被标记为Send，就是说，一个结构体中，每个数据类型都有Send，则这个结构体也可以Send</li>
</ol>
</li>
<li>Sync允许多线程访问
<ol>
<li>Sync标记trait表明一个实现了Sync的类型可以安全的在多个线程中拥有其值的引用，即对于任意类型T，如果&amp;T(T的引用)是Send的话，T就是Sync的，这意味着其引用就可以安全的发送到另一个线程。</li>
<li>智能指针Rc<T>也不是Sync的，处于其不是Send的相同原因。RefCell<T>和Cell<T>系列类型不是Sync的。RefCell<T>在运行时所进行的借用检查也不是线程安全的，Mutex<T>是线程安全的</li>
</ol>
</li>
<li>手动实现Send和Sync是不安全的
<ol>
<li>通常并不需要手动实现Send和Sync trait，因为由Send和Sync的类型组成的类型，自动就是Send和Sync的。因为它们是标记trait，甚至都不需要实现任何方法。他们只是用来加强并发相关的不可变性的。</li>
</ol>
</li>
</ol>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://kaisery.github.io/trpl-zh-cn/">Rust 程序设计语言</a></p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust进阶</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust进阶(9)-弱引用</title>
    <url>/articles/a7538cbe/</url>
    <content><![CDATA[<p>弱引用</p>
<span id="more"></span> 
<h2 id="概述">概述</h2>
<p>弱引用Weak<T>   属于Rc包<br>
特点：</p>
<ol>
<li>弱引用通过Rc::downgrade传递Rc实例的引用，调用<code>Rc::downgrade</code>会得到Weak<T>类型的智能指针，同时将weak_count加1（不是将strong_count加1）</li>
<li>区别在于weak_count无需计数为0就能使Rc实例被清理，只要strong_count为0就可以了</li>
<li>可以通过Rc::upgrade方法返回Option&lt;Rc<T>&gt;对象</li>
<li>通俗的讲，弱引用就是：会作为截止标记，不会进一步循环嵌套</li>
</ol>
<h2 id="1-案例-循环引用">1. 案例-循环引用</h2>

<p>问题代码：<br>
tail打印，因为无限循环嵌套Cons，导致无法打印出完整的tail.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">   <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, RefCell&lt;Rc&lt;List&gt;&gt;),</span><br><span class="line">   Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">List</span>&#123;</span><br><span class="line">   <span class="keyword">fn</span> <span class="title function_">tail</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt;&#123;</span><br><span class="line">      <span class="keyword">match</span> <span class="keyword">self</span>&#123;</span><br><span class="line">         <span class="title function_ invoke__">Cons</span>(_, item) =&gt; <span class="title function_ invoke__">Some</span>(item),</span><br><span class="line">         Nil =&gt; <span class="literal">None</span>,</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>,RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(Nil))));</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;1, a rc count = &#123;&#125;&quot;</span>,Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;1, a tail = &#123;:?&#125;&quot;</span>,a.<span class="title function_ invoke__">tail</span>());</span><br><span class="line"></span><br><span class="line">   <span class="comment">//通过clone，将b尾部指向a</span></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>,RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;a))));</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;2, a rc count = &#123;&#125;&quot;</span>,Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;2, b rc count = &#123;&#125;&quot;</span>,Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b));</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;2, b tail = &#123;:?&#125;&quot;</span>,b.<span class="title function_ invoke__">tail</span>());</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(link) = a.<span class="title function_ invoke__">tail</span>()&#123;</span><br><span class="line">      *link.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">clone</span>(&amp;b);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;3, a rc count = &#123;&#125;&quot;</span>,Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;3, b rc count = &#123;&#125;&quot;</span>,Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b));</span><br><span class="line">   <span class="comment">//下面打印的问题：会无限死循环打印相互嵌套的Const</span></span><br><span class="line">   <span class="comment">// println!(&quot;3, a tail = &#123;:?&#125;&quot;,a.tail());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1, a rc count = 1</span><br><span class="line">1, a tail = Some(RefCell &#123; value: Nil &#125;)</span><br><span class="line">2, a rc count = 2</span><br><span class="line">2, b rc count = 1</span><br><span class="line">2, b tail = Some(RefCell &#123; value: Cons(5, RefCell &#123; value: Nil &#125;) &#125;)</span><br><span class="line">3, a rc count = 2</span><br><span class="line">3, b rc count = 2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">a.tail输出死循环</span></span><br></pre></td></tr></table></figure>
<p>解决方式：<br>
弱引用Weak<T></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用弱引用解决上述问题：</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">   <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, RefCell&lt;Weak&lt;List&gt;&gt;),</span><br><span class="line">   Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">List</span>&#123;</span><br><span class="line">   <span class="keyword">fn</span> <span class="title function_">tail</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;RefCell&lt;Weak&lt;List&gt;&gt;&gt;&#123;</span><br><span class="line">      <span class="keyword">match</span> <span class="keyword">self</span>&#123;</span><br><span class="line">         <span class="title function_ invoke__">Cons</span>(_, item) =&gt; <span class="title function_ invoke__">Some</span>(item),</span><br><span class="line">         Nil =&gt; <span class="literal">None</span>,</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::rc::Weak;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>,RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>())));</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;1, a strong count = &#123;&#125;,weak count= &#123;&#125;&quot;</span>,Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a),Rc::<span class="title function_ invoke__">weak_count</span>(&amp;a));</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;1, a tail = &#123;:?&#125;&quot;</span>,a.<span class="title function_ invoke__">tail</span>());</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>,RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>())));</span><br><span class="line">   <span class="comment">//b的尾部指向a</span></span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(link) = b.<span class="title function_ invoke__">tail</span>()&#123;</span><br><span class="line">      *link.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">downgrade</span>(&amp;a);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;2, a strong count = &#123;&#125;,weak count= &#123;&#125;&quot;</span>,Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a),Rc::<span class="title function_ invoke__">weak_count</span>(&amp;a));</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;2, b strong count = &#123;&#125;,weak count= &#123;&#125;&quot;</span>,Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b),Rc::<span class="title function_ invoke__">weak_count</span>(&amp;b));</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;2, b tail = &#123;:?&#125;&quot;</span>,b.<span class="title function_ invoke__">tail</span>());</span><br><span class="line">   <span class="comment">//a的尾部指向b</span></span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(link) = b.<span class="title function_ invoke__">tail</span>()&#123;</span><br><span class="line">      *link.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">downgrade</span>(&amp;b);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;3, a strong count = &#123;&#125;,weak count= &#123;&#125;&quot;</span>,Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a),Rc::<span class="title function_ invoke__">weak_count</span>(&amp;a));</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;3, b strong count = &#123;&#125;,weak count= &#123;&#125;&quot;</span>,Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b),Rc::<span class="title function_ invoke__">weak_count</span>(&amp;b));</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;3, b tail = &#123;:?&#125;&quot;</span>,b.<span class="title function_ invoke__">tail</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1, a strong count = 1,weak count= 0</span><br><span class="line">1, a tail = Some(RefCell &#123; value: (Weak) &#125;)</span><br><span class="line">2, a strong count = 1,weak count= 1</span><br><span class="line">2, b strong count = 1,weak count= 0</span><br><span class="line">2, b tail = Some(RefCell &#123; value: (Weak) &#125;)</span><br><span class="line">3, a strong count = 1,weak count= 0</span><br><span class="line">3, b strong count = 1,weak count= 1</span><br><span class="line">3, b tail = Some(RefCell &#123; value: (Weak) &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="2-案例-树形结构">2. 案例-树形结构</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::&#123;Rc, Weak&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,</span><br><span class="line">    children: RefCell&lt;<span class="type">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">//叶子节点</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">leaf</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]),</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//println!(&quot;leaf parent = &#123;:?&#125;&quot;, leaf.parent.borrow().upgrade());</span></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;1. leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;leaf),</span><br><span class="line">        Rc::<span class="title function_ invoke__">weak_count</span>(&amp;leaf),</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//分支节点</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">branch</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">5</span>,</span><br><span class="line">        parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[Rc::<span class="title function_ invoke__">clone</span>(&amp;leaf)]),</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;2. branch strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;branch),</span><br><span class="line">        Rc::<span class="title function_ invoke__">weak_count</span>(&amp;branch),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    *leaf.parent.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">downgrade</span>(&amp;branch);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;leaf parent = &#123;:?&#125;&quot;</span>, leaf.parent.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">upgrade</span>());</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;2. branch strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;branch),</span><br><span class="line">        Rc::<span class="title function_ invoke__">weak_count</span>(&amp;branch),</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;1. leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;leaf),</span><br><span class="line">        Rc::<span class="title function_ invoke__">weak_count</span>(&amp;leaf),</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. leaf strong = 1, weak = 0</span><br><span class="line">2. branch strong = 1, weak = 0</span><br><span class="line">2. branch strong = 1, weak = 1</span><br><span class="line">1. leaf strong = 2, weak = 0</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://kaisery.github.io/trpl-zh-cn/">Rust 程序设计语言</a></p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust进阶</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust进阶(8)-智能指针</title>
    <url>/articles/a0d1658a/</url>
    <content><![CDATA[<p>智能指针：Box、Rc、Ref</p>
<span id="more"></span>  
<h2 id="1-概述">1. 概述</h2>
<ol>
<li>指针是一个包含内存地址的变量，这个地址指向一些其它的数据
<ol>
<li>智能指针是一类数据结构，它们表现类似于指针，但是也拥有额外的元数据，最明显的，它们拥有一个引用计数。引用计数记录智能指针总共有多少个所有者，并且当没有任何所有者时清除数据。</li>
<li>普通引用和智能指针的一个额外区别是：引用只是借用数据的指针，而智能指针则是拥有它们指向的数据</li>
</ol>
</li>
<li>智能指针通常使用结构体实现。智能指针区别于常规结构体的显著特征在于其实现了Deref和Drop trait
<ol>
<li>Defef trait允许智能指针结构体实例表现的像引用一样，这样就可以编写即 用于引用，又用于智能指针的代码</li>
<li>Drop trait允许我们自定义当智能指针离开作用域时执行的代码</li>
</ol>
</li>
<li>几个标准库中的智能指针
<ol>
<li>Box<T>，用于在堆上分配</li>
<li>Rc<T>，一个引用计数类型，其数据可以有多个所有者</li>
<li>Ref<T>和RefMut<T>，通过RefCell<T>访问，一个在运行时而不是在编译时执行借用规则的类型</li>
</ol>
</li>
</ol>
<h2 id="2-box">2. Box</h2>
<ol>
<li>最简单最直接的智能指针，其类型为Box<T>。box允许将值放在堆而不是栈上，留着栈上的则是指向堆数据的指针。除了数据被存储在堆上外，box没有任何性能损失</li>
<li>box适用于如下场景：
<ol>
<li>当有一个在编译时未知大小的类型，而又需要在确切大小的上下文使用这个类型值的时候；例如：在一个list环境下，存放数据，但是每个元素的大小在编译时又不确定</li>
<li>当有大量数据(数据非常大，拷贝耗性能)并希望在确保数据不被拷贝的情况下转移所有权的时候；</li>
<li>当希望拥有一个值并只关心它的类型是否实现了特定trait而不是其具体类型时</li>
</ol>
</li>
<li>基本使用：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);  <span class="comment">//b存储在栈上，5存储在堆上，b指向5所在的内存</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;&#125;&quot;</span>,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-使用box">2.1 使用Box</h3>
<ol>
<li>当有一个在编译时未知大小的类型，而又需要在确切大小的上下文使用这个类型值的时候；例如：在一个list环境下，存放数据，但是每个元素的大小在编译时又不确定，如下</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> List::Cons;</span><br><span class="line">    <span class="keyword">use</span> List::Nil;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list</span> = <span class="title function_ invoke__">Cons</span>(</span><br><span class="line">        <span class="number">1</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(</span><br><span class="line">            <span class="number">2</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(</span><br><span class="line">                <span class="number">3</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil))))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-解引用">2.2 解引用</h3>
<p>解引用是返回内存地址中对应的对象.<br>
也就是说，解引用就是<code>*</code>标记的</p>
<p>实现Defef trait允许我们重载解引用运算符:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">a</span>: A = A::<span class="title function_ invoke__">new</span>();  <span class="comment">//前提：a类型必须实现Defef trait</span></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">b</span> = &amp;a;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">c</span> = *b; <span class="comment">//解引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用box解引用</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;x;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>,x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>,*y); <span class="comment">//解引用</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//使用box解引用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>,*z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-自定义实现mybox">2.3 自定义实现MyBox</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T) <span class="punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">MyBox</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T&#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = MyBox::<span class="title function_ invoke__">new</span>(x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-解引用多态">2.4 解引用多态</h3>
<p>解引用多态与可变性交互：</p>
<ol>
<li>当T:Deref&lt;Target=U&gt;时，从&amp;T到&amp;U，<code>下方例子为这第一种情况</code></li>
<li>当T:DerefMut&lt;Target=U&gt;时，从&amp;mut T 到 &amp;mut U，即可变之间均可解</li>
<li>当T:Deref&lt;Target=U&gt;时，从&amp;mut T 到 &amp;U，可变到不可变
<ol>
<li>从这里可以看出，<code>不能够从不可变到可变</code></li>
</ol>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T) <span class="punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">MyBox</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T&#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rust&quot;</span>));</span><br><span class="line">    <span class="title function_ invoke__">hello</span>(&amp;m);   <span class="comment">//将MyBox变为&amp;String，再将String的解引用，变为字符串slice。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">hello</span>(name: &amp;<span class="type">str</span>)&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hello, &#123;&#125;&quot;</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-引用计数rc智能指针">3. 引用计数Rc智能指针</h2>
<p>当一个数据需要被多个变量共享时，使用Rc指针，该指针原理其实就是<code>计数</code>，具体解释看<code>3.3小节</code>说明</p>
<h3 id="3-1-为什么要用rc指针">3.1 为什么要用Rc指针</h3>
<p>原因，如下代码，创建了<code>a</code>，然后move到了<code>b</code>；但<code>c</code>又要使用<code>a</code>，导致异常</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>,<span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>,<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>,<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil))));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>,<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>,<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-上面问题正确处理方式">3.2 上面问题正确处理方式</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>,Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>,Rc::<span class="title function_ invoke__">new</span>(Nil)))));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>,Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>,Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">    <span class="comment">//也可以这么写：</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>,a.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>,a.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-原理">3.3 原理</h3>
<ol>
<li>使用到了计数，b使用，则a计数加1；c使用，则a计数再加1；若a或b释放，则减1</li>
<li>通过Rc<T>允许程序的多个部分之间只读的共享数据，因为相同位置的多个可变引用可能会造成数据竞争和不一致</li>
</ol>
<img src="/articles/a0d1658a/1.png" class="" title="Rc智能指针">
<h2 id="4-refcell智能指针">4. RefCell智能指针</h2>
<ol>
<li>内部可变性：允许在使用不可变引用时改变数据(<code>看下方案例</code>)</li>
<li>通过<code>RefCell&lt;T&gt;</code>在运行时检查借用规则（通常情况下，是在编译时检查借用规则），<code>RefCell&lt;T&gt;</code>代表其数据的唯一所有权</li>
<li>类似于<code>Box&lt;T&gt;</code>、<code>Rc&lt;T&gt;</code>只能用于单线程场景</li>
<li>选择<code>Box&lt;T&gt;</code>、<code>Rc&lt;T&gt;</code>或<code>RefCell&lt;T&gt;</code>的理由：
<ol>
<li>均不是线程安全的</li>
<li><code>Rc&lt;T&gt;</code>允许相同数据有多个所有者；<code>Box&lt;T&gt;</code>和<code>RefCell&lt;T&gt;</code>有单一所有者</li>
<li><code>Box&lt;T&gt;</code>允许在编译时执行不可变或可变借用检查；<code>Rc&lt;T&gt;</code>仅允许在编译时执行不可变借用检查；<code>RefCell&lt;T&gt;</code>允许在运行时执行不可变或可变借用检查</li>
<li>因为<code>RefCell&lt;T&gt;</code>允许在运行时执行可变借用检查，所以我们可以在即便<code>RefCell&lt;T&gt;</code>自身不可变的情况下修改其内部的值。</li>
</ol>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(Rc&lt;RefCell&lt;<span class="type">i32</span>&gt;&gt;, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">value</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;value), Rc::<span class="title function_ invoke__">new</span>(Nil)));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">6</span>)), Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">7</span>)), Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a before: &#123;:?&#125;&quot;</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b before: &#123;:?&#125;&quot;</span>, b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c before: &#123;:?&#125;&quot;</span>, c);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;+++++++++++++++++&quot;</span>);</span><br><span class="line">    *value.<span class="title function_ invoke__">borrow_mut</span>() += <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a after: &#123;:?&#125;&quot;</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b after: &#123;:?&#125;&quot;</span>, b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c after: &#123;:?&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://kaisery.github.io/trpl-zh-cn/">Rust 程序设计语言</a></p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust进阶</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust进阶(7)-cargo相关基础</title>
    <url>/articles/6c71cc2/</url>
    <content><![CDATA[<p>cargo相关基础</p>
<span id="more"></span>  
<h2 id="1-构建">1. 构建</h2>
<ol>
<li>生成debug
<ol>
<li>直接使用<code>cargo run</code>或<code>cargo build</code>，生成的是debug模式的可执行文件</li>
</ol>
</li>
<li>生成release
<ol>
<li><code>cargo run --release</code>或<code>cargo build --release</code></li>
</ol>
</li>
</ol>
<h2 id="2-设置优化级别">2. 设置优化级别</h2>
<p>优化级别越高，编译时间越长，级别：0到3<br>
在cargo.toml中：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cargo官方默认即 debug 0, release 3</span></span><br><span class="line"><span class="section">[profile.dev]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">0</span>  <span class="comment"># debug版</span></span><br><span class="line"></span><br><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="3-生成注释文档">3. 生成注释文档</h2>
<p>最好在cargo中操作<br>
使用：<code>///</code>，文档注释<br>
使用： <code>///！</code>，对包说明</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成文档</span></span><br><span class="line">cargo doc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">浏览器打开文档</span></span><br><span class="line">cargo doc --open</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自动测试</span></span><br><span class="line">cargo test</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">///！My Crate</span></span><br><span class="line"><span class="comment">///! &#x27;my_crate&#x27; is a collection of utiltes to make performing certain calcuations more convenient</span></span><br><span class="line"><span class="comment">///！</span></span><br><span class="line"><span class="comment">/// Add one to the number given</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// #Example</span></span><br><span class="line"><span class="comment">/// ```</span></span><br><span class="line"><span class="comment">/// let five = 5;</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// assert_eq!(6,mylib::add_one(5));</span></span><br></pre></td></tr></table></figure>
<h2 id="4-crate发布与撤回">4. crate发布与撤回</h2>
<ol>
<li>创建Crates.io账号：通过Github账户注册，并通过<code>cargo login</code>来登陆</li>
<li>发布前需要在Cargo.toml中增加描述</li>
</ol>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;package_name&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">license</span> = <span class="string">&quot;MIT&quot;</span> <span class="comment"># LINUX 基金会对SPDX列出了可以使用的标识符</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">&quot;your name&quot;</span>]</span><br><span class="line"><span class="attr">description</span> = <span class="string">&quot;some thing descript the package&quot;</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>发布</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo publish </span><br></pre></td></tr></table></figure>
<ol start="4">
<li>撤回指定版本</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo yank --vers 0.1.0</span><br></pre></td></tr></table></figure>
<h2 id="5-工作空间">5. 工作空间</h2>
<ol>
<li>用于管理项目根目录，模块划分。 比如创建主项目，多个lib。</li>
<li>为什么需要 workspace?
<ol>
<li>如果功能和逻辑都被构建在一个crate中，随着项目开发的深入，你可能会发现，crate越来越大，内部结构也越来越复杂。为了提高项目的可重用性，同时降低复杂度。你希望将此crate进一步拆分为多个crate。针对此种情况，Cargo.toml中提供了[workspace]配置。</li>
</ol>
</li>
<li>什么是 workspace?
<ol>
<li>workspace，顾名思义是工作空间。在工作空间中存在多个crate，它们共享Cargo.lock和target输出目录。<br>
cargo.toml</li>
</ol>
</li>
</ol>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[workspace]</span></span><br><span class="line"><span class="attr">members</span> = [</span><br><span class="line">    <span class="string">&quot;addr&quot;</span>,</span><br><span class="line">    <span class="string">&quot;add-one&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>此时执行项目的时候，需要指定项目：<code>cargo run -p adder</code></p>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://kaisery.github.io/trpl-zh-cn/">Rust 程序设计语言</a></p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust进阶</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust进阶(6)-drop、trait清理代码</title>
    <url>/articles/172b553c/</url>
    <content><![CDATA[<p>drop、trait清理代码</p>
<span id="more"></span>  
<h2 id="概述">概述</h2>
<p>Drop trait类似于其它语言中的析构函数，当值离开作用域的时候执行此函数的代码</p>
<h2 id="基本使用">基本使用</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Dog &#123;&#125; leave&quot;</span>, <span class="keyword">self</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Dog &#123; name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;wangcai&quot;</span>) &#125;;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">b</span> = Dog &#123; name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;dahuang&quot;</span>) &#125;;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;0 +++++++++++++&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;1 +++++++++++++&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：<br>
表示作用域执行完，才开始释放</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0 +++++++++++++</span><br><span class="line">Dog dahuang leave</span><br><span class="line">1 +++++++++++++</span><br><span class="line">Dog wangcai leave</span><br></pre></td></tr></table></figure>
<h2 id="drop提前释放">drop提前释放</h2>
<p>不允许显式调用<code>drop</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Dog &#123;&#125; leave&quot;</span>, <span class="keyword">self</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Dog &#123; name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;wangcai&quot;</span>) &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Dog &#123; name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;dahuang&quot;</span>) &#125;;</span><br><span class="line">    <span class="comment">//提前释放</span></span><br><span class="line">    <span class="comment">//b.drop();  //不允许显式调用`drop`,此操作会报错</span></span><br><span class="line">    <span class="title function_ invoke__">drop</span>(b);  <span class="comment">//正确释放</span></span><br><span class="line">    <span class="title function_ invoke__">drop</span>(a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;0 +++++++++++++&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://kaisery.github.io/trpl-zh-cn/">Rust 程序设计语言</a></p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust进阶</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust进阶(5)-迭代器</title>
    <url>/articles/67f1d5da/</url>
    <content><![CDATA[<p>迭代器</p>
<span id="more"></span>  
<h2 id="概述">概述</h2>
<ol>
<li>迭代器负责遍历序列中的每一项和决定序列何时结束的逻辑</li>
<li>创建迭代器：迭代器是惰性的，意思就是在调用方法使用迭代器之前，不会有任何效果</li>
<li>每个迭代器都实现了iterator trait，iterator trait定义在标准库中：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//next是Iterator被要求实现的唯一一个方法，next一次返回一个元素，当迭代器结束时，返回None</span></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;; <span class="comment">//type Item和Self::Item这种用法叫做定义trait的关联类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基本使用">基本使用</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v1_iter</span> = v1.<span class="title function_ invoke__">iter</span>(); <span class="comment">//到目前为止，不会对v1产生任何影响</span></span><br><span class="line">    <span class="comment">/*for val in v1_iter&#123;</span></span><br><span class="line"><span class="comment">        println!(&quot;val = &#123;&#125;&quot;, val)</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(v) = v1_iter.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;v = &#123;&#125;&quot;</span>, v);<span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(v) = v1_iter.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;v = &#123;&#125;&quot;</span>, v);<span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(v) = v1_iter.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;v = &#123;&#125;&quot;</span>, v);<span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(v) = v1_iter.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;v = &#123;&#125;&quot;</span>, v);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;At End&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v2</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v2_iter</span> = v2.<span class="title function_ invoke__">iter_mut</span>();</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(v) = v2_iter.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        *v = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;v2 = &#123;:?&#125;&quot;</span>, v2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费适配器</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1_iter</span> = v1.<span class="title function_ invoke__">iter</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">total</span>: <span class="type">i32</span> = v1_iter.<span class="title function_ invoke__">sum</span>(); <span class="comment">//调用消费适配器sum来求和</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;total = &#123;&#125;&quot;</span>, total);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代适配器</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;v1 = &#123;:?&#125;&quot;</span>, v1);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span>: <span class="type">Vec</span>&lt;_&gt; = v1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|x| x + <span class="number">1</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;v2 = &#123;:?&#125;&quot;</span>, v2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//过滤</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">12</span>, <span class="number">45</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;v1 = &#123;:?&#125;&quot;</span>, v1);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span>: <span class="type">Vec</span>&lt;_&gt; = v1.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">filter</span>(|x| *x&gt;<span class="number">5</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;v2 = &#123;:?&#125;&quot;</span>, v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义迭代器">自定义迭代器</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    count: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Counter &#123;</span><br><span class="line">        Counter &#123; count: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">u32</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.count &lt; <span class="number">6</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.count)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = Counter::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">6</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(v) = counter.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;i = &#123;&#125;, v = &#123;&#125;&quot;</span>, i, v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;i = &#123;&#125;, at end&quot;</span>, i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://kaisery.github.io/trpl-zh-cn/">Rust 程序设计语言</a></p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust进阶</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust进阶(4)-闭包</title>
    <url>/articles/d3896be9/</url>
    <content><![CDATA[<p>闭包</p>
<span id="more"></span>  
<h2 id="闭包">闭包</h2>
<p>闭包是可以保存进变量或作为参数传递给其它函数的匿名函数。闭包和函数不同的是，闭包允许捕获调用者作用域中的值</p>
<h2 id="闭包的基本使用方式">闭包的基本使用方式</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">use_closure</span> = || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;This is a closure!&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">use_closure</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//闭包定义会为每个参数和返回值类型推导一个具体的类型，但是不能推导两次（就是说同一个闭包，只能传入同一种类型）</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">add_one_v2</span> = |x: <span class="type">u32</span>| <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="comment">//推导（就是说同一个闭包，只能传入同一种类型）</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">add_one_v3</span> = |x| &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="comment">//简单函数体可以直接简化实现</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">add_one_v4</span> = |x| x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">add_one_v1</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">add_one_v2</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">add_one_v3</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d</span> = <span class="title function_ invoke__">add_one_v4</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;&#125;, b = &#123;&#125;, c = &#123;&#125;, d = &#123;&#125;&quot;</span>, a, b, c, d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不能推导两次的例子</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">example_closure</span> = |x| x;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">example_closure</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;s = &#123;&#125;&quot;</span>, s);</span><br><span class="line">    <span class="comment">//前面传入的参数已经被推导为String类型，此时传入u32类型，执行会报错</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = <span class="title function_ invoke__">example_closure</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// let n = example_closure(5.to_string());</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;n = &#123;&#125;&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//捕捉环境中的变量，也就是说可以捕获上下文当前环境的变量</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">exe</span> = |x| x +i;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = <span class="title function_ invoke__">exe</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r = &#123;&#125;&quot;</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传统标准函数方式</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_one_v1</span>(x: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="带有泛型和fn-traid特征的闭包">带有泛型和fn traid特征的闭包</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现一个缓存，只处理第一次传入的值并保存</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cacher</span>&lt;T&gt;</span><br><span class="line">    <span class="keyword">where</span> T: <span class="title function_ invoke__">Fn</span>(<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span></span><br><span class="line">&#123;</span><br><span class="line">    calcuation: T,</span><br><span class="line">    value: <span class="type">Option</span>&lt;<span class="type">u32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Cacher&lt;T&gt;</span><br><span class="line">    <span class="keyword">where</span> T: <span class="title function_ invoke__">Fn</span>(<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(calcuation: T) <span class="punctuation">-&gt;</span> Cacher&lt;T&gt; &#123;</span><br><span class="line">        Cacher &#123;</span><br><span class="line">            calcuation,</span><br><span class="line">            value: <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">value</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, arg: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.value &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(v) =&gt; v,</span><br><span class="line">            <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">v</span> = (<span class="keyword">self</span>.calcuation)(arg);</span><br><span class="line">                <span class="keyword">self</span>.value = <span class="title function_ invoke__">Some</span>(v);</span><br><span class="line">                v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = Cacher::<span class="title function_ invoke__">new</span>(|x| x + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = c.<span class="title function_ invoke__">value</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;v1 = &#123;&#125;&quot;</span>, v1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此时传入别的值，返回的依旧是上面的结果</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span> = c.<span class="title function_ invoke__">value</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;v2 = &#123;&#125;&quot;</span>, v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="捕获环境中的值">捕获环境中的值</h2>
<p>闭包可以通过三种功能方式捕获其环境，它们对应函数的三种获取参数的方式，分别是获取所有权、可变借用、不可变借用。<br>
这三种捕获值的方式被编码为如下三个Fn trait：</p>
<ol>
<li>FnOnce消费从周围作用域捕获的变量，闭包周围的作用域被称为其环境。为了消费捕获到的变量，闭包必须获取其所有权并在定义闭包时将其移进闭包。其名称的Once部分代表了闭包不能多次获取相同变量的所有权。</li>
<li>FnMut获取可变的借用值，所以可以改变其环境</li>
<li>Fn从其环境获取不可变的借用值</li>
</ol>
<p>当创建一个闭包时，rust会根据其如何使用环境中的变量来推断我们希望如何引用环境。由于所有闭包都可以被调用至少一次，因此所有闭包都实现了FnOnce。没有移动被捕获变量的所有权到闭包的闭包也实现了FnMut；而不需要对捕获的变量进行可变访问的闭包实现了Fn。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">//例子-1</span></span><br><span class="line">    <span class="comment">/*let x = 4;</span></span><br><span class="line"><span class="comment">    let equal_to_x = |z| z==x;</span></span><br><span class="line"><span class="comment">    let y = 4;</span></span><br><span class="line"><span class="comment">    assert!(equal_to_x(y));*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//例子-2</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">equal_to_x</span> = <span class="keyword">move</span> |z| z==x;  <span class="comment">//x的所有权移入闭包</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;:?&#125;&quot;</span>,x); <span class="comment">//x所有权已被转移</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">assert!</span>(<span class="title function_ invoke__">equal_to_x</span>(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://kaisery.github.io/trpl-zh-cn/">Rust 程序设计语言</a></p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust进阶</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust进阶(3)-生命周期</title>
    <url>/articles/b808aa08/</url>
    <content><![CDATA[<p>生命周期</p>
<span id="more"></span>  
<h2 id="1-概述">1. 概述</h2>
<ol>
<li>主要是针对引用</li>
<li>Rust中每个引用都有其生命周期，也就是引用保持有效的作用域，大部分时候生命周期是隐含并可以推断的，正如大部分时候类型可以推断一样</li>
<li>生命周期的主要目标是避免<code>悬垂引用</code></li>
<li>Rust编译器使用借用检查器来检查生命周期是否有效</li>
<li>生命周期检测基本原理：检测变量的剩余生命周期是否一致，若不一致，则报错。</li>
<li><code>生命周期声明类似于变量类型声明，不会改变对象的真正生命周期。当你声明的生命周期和实际不符合的时候，编译器会报错。</code></li>
<li>声明生命周期：统一生命周期,按照最小生命周期来分析（说白了就是返回结果必须按照最小证明周期来声明，以防结果不安全）</li>
</ol>
<p><code>悬垂引用</code>介绍：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//r在作用域中已经被使用并释放，之后继续使用r，此时编译会异常，这就是垂直引用</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">        r = &amp;x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r = &#123;&#125;&quot;</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-函数中的生命周期">2. 函数中的生命周期</h2>
<p>为避免悬垂引用，需要使用声明<code>'a</code>来标注，确保生命周期一致。<br>
注：因为对于编译器来说，如果不加上<code>'a</code>，运行期间，不确定返回的是x还是y，导致了生命周期的不确定性。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_str</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp; <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法是错误的，r返回后，会被释放，变成悬垂引用</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">a_str</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    r.<span class="title function_ invoke__">as_str</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abcde&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = <span class="title function_ invoke__">longest</span>(s1.<span class="title function_ invoke__">as_str</span>(), s2.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r = &#123;&#125;&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-结构体中生命周期">3. 结构体中生命周期</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&lt;<span class="symbol">&#x27;a</span>&gt;&#123;</span><br><span class="line">    name: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = A&#123;name:&amp;n&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;:#?&#125;   &quot;</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-生命周期省略">4. 生命周期省略</h2>
<ol>
<li>没有生命周期注解却能够编译。原因：早期的rust中必须显式的声明生命周期，后来rust团队将很明确的模式进行了注解的简化</li>
<li>遵守生命周期省略规则的情况下能明确变量的生命周期，则无需明确指定生命周期。函数或者方法的参数的生命周期称为输入生命周期，而返回的生命周期称为输出的生命周期</li>
<li>编译器采用三条规则判断引用何时不需要生命周期注解，当编译器检查完这三条规则后仍然不能计算出引用的生命周期，则会停止并生成错误。</li>
<li>生命周期注解省略规则适用于fn定义以及impl块定义，如：
<ol>
<li>每个引用的参数都有它自己的生命周期参数，例如：
<ol>
<li>一个引用参数的函数，其中有一个生命周期：fn foo&lt;'a&gt;(x:&amp;'a i32)</li>
<li>两个引用参数的函数，则有两个生命周期：fn foo&lt;'a,'b&gt;(x:&amp;'a i32,y: &amp;'b i32)</li>
</ol>
</li>
<li>如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数：
<ol>
<li>fn foo(x: &amp;i32) -&gt; &amp;i32 等价于 fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</li>
</ol>
</li>
<li>如果方法有多个输入生命周期参数，不过其中之一因为方法的缘故为&amp;self或者&amp;mut self，那么self的生命周期被赋予所有输出生命周期参数。（说白了就是，返回的结果要保证最小生命周期）</li>
</ol>
</li>
</ol>
<h2 id="5-方法中的生命周期">5. 方法中的生命周期</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法中的生命周期</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StuA</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    name: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; StuA&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">do_something</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">do_something2</span>(&amp;<span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法异常，因为s的生命周期小于返回的（也就是self的）,为s加上&#x27;a后，即可恢复正常(impl中已经声明，因此这里只需要给s加上&#x27;a即可)</span></span><br><span class="line">    <span class="comment">/*fn do_something3(&amp;self, s: &amp;str) -&gt; &amp;str &#123;</span></span><br><span class="line"><span class="comment">        s</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">do_something3</span>(&amp;<span class="keyword">self</span>, s: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        s</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = StuA &#123; name: &amp;s &#125;;</span><br><span class="line">    <span class="comment">/* let a = StuA &#123; name: &amp;s &#125;;</span></span><br><span class="line"><span class="comment">    println!(&quot;&#123;&#125;&quot;, a.do_something());*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*let s = String::from(&quot;hello&quot;);</span></span><br><span class="line"><span class="comment">    println!(&quot;&#123;&#125;&quot;, a.do_something2(&amp;s));*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello2&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a.<span class="title function_ invoke__">do_something3</span>(&amp;s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-静态生命周期">6. 静态生命周期</h2>
<p>定义方式：<code>'static</code><br>
其生命周期存活于整个程序期间，所有的字符面值都拥有static生命周期<br>
如：<code>let s: &amp;'static str = &quot;hello&quot;;</code></p>
<h2 id="7-综合泛型生命周期">7. 综合泛型生命周期</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function</span>&lt;<span class="symbol">&#x27;a</span>, T: Display&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, ann: T) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;ann is &#123;&#125;&quot;</span>, ann);</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &lt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;i am s1&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;i am s2&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ann</span> = <span class="number">129</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = <span class="title function_ invoke__">function</span>(s1.<span class="title function_ invoke__">as_str</span>(), s2.<span class="title function_ invoke__">as_str</span>(), ann);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r = &#123;&#125;&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://kaisery.github.io/trpl-zh-cn/">Rust 程序设计语言</a></p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust进阶</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust进阶(2)-特征</title>
    <url>/articles/702f0a50/</url>
    <content><![CDATA[<p>特征</p>
<span id="more"></span>  
<h2 id="1-概述">1. 概述</h2>
<p>trait用于定义与其它类型共享的功能，类似于其它语言中的接口：</p>
<ol>
<li>可以通过trait以抽象的方式定义共享的行为</li>
<li>可以使用trait bounds指定泛型是任何拥有特定行为的类型(前面泛型中提到过的，对泛型方法参数的约束：<code>fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T])</code>)</li>
<li>默认实现：可以在定义trait的时候提供默认的行为，trait的类型可以使用默认的行为</li>
</ol>
<h2 id="2-基本定义和实现">2. 基本定义和实现</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义trait</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">GetInformation</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_name</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_age</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//trait默认实现</span></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">SchoolName</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_school_name</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>&#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;HongXingSchool&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现trait</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> name: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> age: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">SchoolName</span> <span class="keyword">for</span> <span class="title class_">Student</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">GetInformation</span> <span class="keyword">for</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_name</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span>&#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_age</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span>&#123;</span><br><span class="line">        <span class="keyword">self</span>.age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Teacher</span>&#123;</span><br><span class="line">    <span class="keyword">pub</span> name: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> age: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> subject: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写默认实现</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">SchoolName</span> <span class="keyword">for</span> <span class="title class_">Teacher</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_school_name</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>&#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;GuangMingSchool&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">GetInformation</span> <span class="keyword">for</span> <span class="title class_">Teacher</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_name</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span>&#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_age</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span>&#123;</span><br><span class="line">        <span class="keyword">self</span>.age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法中传入trait</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_information</span>(item:<span class="keyword">impl</span> <span class="title class_">GetInformation</span>)&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;name = &#123;&#125;&quot;</span>,item.<span class="title function_ invoke__">get_name</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;age = &#123;&#125;&quot;</span>,item.<span class="title function_ invoke__">get_age</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = Student&#123;name:<span class="string">&quot;xiaoming&quot;</span>.<span class="title function_ invoke__">to_string</span>(),age:<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = Teacher&#123;name:<span class="string">&quot;xiaohuang&quot;</span>.<span class="title function_ invoke__">to_string</span>(),age:<span class="number">30</span>,subject: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;math&quot;</span>)&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;student,name = &#123;&#125;,age = &#123;&#125;&quot;</span>,s.<span class="title function_ invoke__">get_name</span>(),s.<span class="title function_ invoke__">get_age</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;teacher,name = &#123;&#125;,age = &#123;&#125;&quot;</span>,t.<span class="title function_ invoke__">get_name</span>(),t.<span class="title function_ invoke__">get_age</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法中传入trait</span></span><br><span class="line">    <span class="comment">/*print_information(s);</span></span><br><span class="line"><span class="comment">    print_information(t);*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s_school_name</span> = s.<span class="title function_ invoke__">get_school_name</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t_school_name</span> = t.<span class="title function_ invoke__">get_school_name</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;student school name = &#123;&#125;&quot;</span>,s_school_name);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;teacher school name = &#123;&#125;&quot;</span>,t_school_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-trait作为方法参数-约束">3. trait作为方法参数（约束）</h2>
<p>结合上面基本实现，将trait传入方法，其实就是强调传入的方法要实现指定的trait，用来约束</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//trait作为方法参数</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_information</span>(item:<span class="keyword">impl</span> <span class="title class_">GetInformation</span>)&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;name = &#123;&#125;&quot;</span>,item.<span class="title function_ invoke__">get_name</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;age = &#123;&#125;&quot;</span>,item.<span class="title function_ invoke__">get_age</span>())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = Student&#123;name:<span class="string">&quot;xiaoming&quot;</span>.<span class="title function_ invoke__">to_string</span>(),age:<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = Teacher&#123;name:<span class="string">&quot;xiaohuang&quot;</span>.<span class="title function_ invoke__">to_string</span>(),age:<span class="number">30</span>,subject: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;math&quot;</span>)&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//trait作为方法参数</span></span><br><span class="line">    <span class="title function_ invoke__">print_information</span>(s);</span><br><span class="line">    <span class="title function_ invoke__">print_information</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-trait的默认实现">4. trait的默认实现</h2>
<p>结合上面基本实现，使用默认实现</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//trait默认实现</span></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">SchoolName</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_school_name</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>&#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;HongXingSchool&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">SchoolName</span> <span class="keyword">for</span> <span class="title class_">Student</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写默认实现</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">SchoolName</span> <span class="keyword">for</span> <span class="title class_">Teacher</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_school_name</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>&#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;GuangMingSchool&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s_school_name</span> = s.<span class="title function_ invoke__">get_school_name</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t_school_name</span> = t.<span class="title function_ invoke__">get_school_name</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;student school name = &#123;&#125;&quot;</span>,s_school_name);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;teacher school name = &#123;&#125;&quot;</span>,t_school_name);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-rait-bounds">5. rait bounds</h2>
<ol>
<li>指定多个trait bound</li>
<li>返回trait类型</li>
</ol>
<h3 id="5-1-指定多个trait-bound">5.1 指定多个trait bound</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">GetName</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_name</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">GetAge</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_age</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_information1</span>&lt;T: GetName + GetAge&gt;(item: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;name = &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">get_name</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;age = &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">get_age</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_information2</span>&lt;T&gt;(item: T)</span><br><span class="line">    <span class="keyword">where</span> T: GetName + GetAge &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;name = &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">get_name</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;age = &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">get_age</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式三，写法麻烦，不推荐</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_information3</span>(item1: <span class="keyword">impl</span> <span class="title class_">GetName</span>, item2: <span class="keyword">impl</span> <span class="title class_">GetAge</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;name = &#123;&#125;&quot;</span>, item1.<span class="title function_ invoke__">get_name</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;age = &#123;&#125;&quot;</span>, item2.<span class="title function_ invoke__">get_age</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> name: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> age: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">GetName</span> <span class="keyword">for</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_name</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">GetAge</span> <span class="keyword">for</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_age</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = Student &#123; name: <span class="string">&quot;xiaoming&quot;</span>.<span class="title function_ invoke__">to_string</span>(), age: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="title function_ invoke__">print_information1</span>(s);</span><br><span class="line">    <span class="title function_ invoke__">print_information1</span>(s);</span><br><span class="line">    <span class="title function_ invoke__">print_information1</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-返回trait类型">5.2. 返回trait类型</h3>
<p>//方法中仅可返回一种实现了trait的确定结构体类型，不能是根据条件返回不同的结构体类型</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> name: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> age: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法中仅可返回一种实现了trait的确定结构体类型，不能是根据条件返回不同的结构体类型</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">GetAge</span> <span class="keyword">for</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_age</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">produce_item_with_age</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">GetAge</span>&#123;</span><br><span class="line">    Student&#123;</span><br><span class="line">        name:<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xiaoming&quot;</span>),</span><br><span class="line">        age:<span class="number">15</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Student和Teacher，一个方法中，仅能出现一种返回类型</span></span><br><span class="line">    <span class="comment">/*Teacher&#123;</span></span><br><span class="line"><span class="comment">        name:String::from(&quot;xiaohuang&quot;),</span></span><br><span class="line"><span class="comment">        age:30,</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">produce_item_with_age</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-使用trait-bound有条件的实现方法">5.3 使用trait bound有条件的实现方法</h3>
<p>即，默认trait实现的方法中，约束了多个传入参数的条件</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">GetName</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_name</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">GetAge</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_age</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PeopleMatchInformation</span>&lt;T, U&gt; &#123;</span><br><span class="line">    master: T,</span><br><span class="line">    student: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T:GetName+GetAge,U:GetName+GetAge&gt;PeopleMatchInformation&lt;T,U&gt;&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print_all_information</span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;master name=&#123;&#125;&quot;</span>,<span class="keyword">self</span>.master.<span class="title function_ invoke__">get_name</span>());</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;master age=&#123;&#125;&quot;</span>,<span class="keyword">self</span>.master.<span class="title function_ invoke__">get_age</span>());</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;student name=&#123;&#125;&quot;</span>,<span class="keyword">self</span>.student.<span class="title function_ invoke__">get_name</span>());</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;student age=&#123;&#125;&quot;</span>,<span class="keyword">self</span>.student.<span class="title function_ invoke__">get_age</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Teacher</span>&#123;</span><br><span class="line">    name:<span class="type">String</span>,</span><br><span class="line">    age:<span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">GetName</span> <span class="keyword">for</span> <span class="title class_">Teacher</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_name</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">        &amp;(<span class="keyword">self</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">GetAge</span> <span class="keyword">for</span> <span class="title class_">Teacher</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_age</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    name:<span class="type">String</span>,</span><br><span class="line">    age:<span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">GetName</span> <span class="keyword">for</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_name</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">        &amp;(<span class="keyword">self</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">GetAge</span> <span class="keyword">for</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_age</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = Student&#123; name:<span class="string">&quot;xiaoming&quot;</span>.<span class="title function_ invoke__">to_string</span>(), age:<span class="number">15</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = Teacher&#123;name:<span class="string">&quot;xiaohuang&quot;</span>.<span class="title function_ invoke__">to_string</span>(),age:<span class="number">30</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = PeopleMatchInformation&#123;master:t,student:s&#125;;</span><br><span class="line">    m.<span class="title function_ invoke__">print_all_information</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-4-对任何实现了特定trait的类型有条件的实现trait">5.4 对任何实现了特定trait的类型有条件的实现trait</h3>
<p>说白了就是：一个结构体先实现了某个trait，才能实现另一个trait;<br>
一个trait的实现，同时也就实现了另一个trait的方法，文字描述很难说清。具体看案例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">GetName</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_name</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">PrintName</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print_name</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T:GetName&gt; PrintName <span class="keyword">for</span> <span class="title class_">T</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print_name</span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;name = &#123;&#125;&quot;</span>,<span class="keyword">self</span>.<span class="title function_ invoke__">get_name</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    name:<span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">GetName</span> <span class="keyword">for</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_name</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">        &amp;(<span class="keyword">self</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = Student&#123;name:<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xiaohuang&quot;</span>)&#125;;</span><br><span class="line">    s.<span class="title function_ invoke__">print_name</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://kaisery.github.io/trpl-zh-cn/">Rust 程序设计语言</a></p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust进阶</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust进阶(1)-在结构体和方法中使用泛型</title>
    <url>/articles/dc91d364/</url>
    <content><![CDATA[<p>在结构体和方法中使用泛型</p>
<span id="more"></span>  
<h2 id="1-概述">1. 概述</h2>
<ol>
<li>泛型是具体类型或者其它属性的抽象替代，用于减少代码重复</li>
<li>在函数定义中使用泛型</li>
<li>在结构体中使用泛型</li>
<li>枚举中的泛型</li>
<li>方法中的泛型</li>
<li>总结：使用泛型并不会造成程序性能上的损失。rust通过在编译时进行泛型代码的单态化来保证效率。单态化时通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程</li>
</ol>
<h2 id="2-函数中使用泛型">2. 函数中使用泛型</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用泛型求最大值</span></span><br><span class="line"><span class="comment">//泛型条件：PartialOrd，可以按照顺序进行比较；Copy，具有copy特征的类型</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T: <span class="built_in">PartialOrd</span>+<span class="built_in">Copy</span>&gt;(list: &amp;[T])<span class="punctuation">-&gt;</span>T&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">larger</span> = list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.<span class="title function_ invoke__">iter</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt;larger &#123;</span><br><span class="line">            larger = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    larger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_list</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">23</span>, <span class="number">34</span>, <span class="number">8</span>, <span class="number">100</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">max_number</span> = <span class="title function_ invoke__">largest</span>(&amp;number_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;max_number = &#123;&#125;&quot;</span>, max_number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">char_list</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">max_char</span> = <span class="title function_ invoke__">largest</span>(&amp;char_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;max_char = &#123;&#125;&quot;</span>,max_char)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-结构体中使用泛型">3. 结构体中使用泛型</h2>
<ol>
<li><code>x</code>和<code>y</code>同一种类型</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体中使用泛型,T只能是一种类型</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt;&#123;</span><br><span class="line">    x:T,</span><br><span class="line">    y:T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">integer</span> = Point&#123;x:<span class="number">1</span>,y:<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>,integer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">float</span> = Point&#123;x:<span class="number">1.1</span>,y:<span class="number">2.2</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,float)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>x</code>和<code>y</code>不同类型</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point2</span>&lt;T,U&gt;&#123;</span><br><span class="line">    x:T,</span><br><span class="line">    y:U,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Point2&#123;x:<span class="number">1.1</span>,y:<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;:?&#125;&quot;</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-枚举中使用泛型">4. 枚举中使用泛型</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Optoin</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T,E&gt;&#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-在方法中使用泛型">5. 在方法中使用泛型</h2>
<ol>
<li>结构体中属性为同种类型</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_x</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_y</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point &#123; x: <span class="number">1</span>, y: <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;&#125;&quot;</span>, p.<span class="title function_ invoke__">get_x</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y = &#123;&#125;&quot;</span>, p.<span class="title function_ invoke__">get_y</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>结构体中属性为不同种类型</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point2</span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T, U&gt; Point2&lt;T, U&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">creat_point</span>&lt;V, W&gt;(<span class="keyword">self</span>, other: Point2&lt;V, W&gt;) <span class="punctuation">-&gt;</span> Point2&lt;T, W&gt; &#123;</span><br><span class="line">        Point2 &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x,</span><br><span class="line">            y: other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = Point2 &#123; x: <span class="number">5</span>, y: <span class="number">1.1</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = Point2 &#123; x: <span class="string">&quot;hello&quot;</span>, y: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p3</span> = p1.<span class="title function_ invoke__">creat_point</span>(p2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p3.x = &#123;&#125;,p3.y = &#123;&#125;&quot;</span>, p3.x, p3.y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://kaisery.github.io/trpl-zh-cn/">Rust 程序设计语言</a></p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust进阶</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust基础(8)-错误处理及测试</title>
    <url>/articles/71719524/</url>
    <content><![CDATA[<p>错误处理及测试</p>
<span id="more"></span>  
<h2 id="1-错误处理">1. 错误处理</h2>
<ul>
<li>rust语言将错误分为两类：可恢复错误和不可恢复错误
<ol>
<li>可恢复错误通常代表向用户报告错误和重试操作是合理的情况，例如未找到文件。rust中使用Result&lt;T,E&gt;来实现</li>
<li>不可恢复错误是bug的同义词，如尝试访问超过数组结尾的位置。rust中通过panic!来实现</li>
</ol>
</li>
</ul>
<h3 id="1-1-panic">1.1 panic!</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;crash here&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-backtrace-1">1.2 BACKTRACE=1</h3>
<p>调试时使用，<code>BACKTRACE</code>非0表示详细打出执行过程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RUST BACKTRACE=1 cargo run</span><br></pre></td></tr></table></figure>
<h3 id="1-3-result-t-e">1.3 RESULT&lt;T,E&gt;</h3>
<p>原型为：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T,E&gt;&#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>案例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;error:&#123;:?&#125;&quot;</span>,error),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-1-简写方式1">1.3.1 简写方式1</h4>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-2-简写方式2">1.3.2 简写方式2</h4>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Filed to open hello.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-传播错误">1.4 传播错误</h3>
<p>当编写一个函数，但是该函数可能会失败，此时除了在函数中处理错误外，还可以将错误传给调用者，让调用者决定如何处理，这被称为传播错误</p>
<h4 id="1-4-1-基本实现">1.4.1 基本实现</h4>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = <span class="title function_ invoke__">read_username_from_file</span>();</span><br><span class="line">    <span class="keyword">match</span> r &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(s) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;s = &#123;&#125;&quot;</span>,s),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;err = &#123;:?&#125;&quot;</span>,e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error ) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(error)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">match</span> f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)&#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(s),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(error),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-4-2-精简实现-推荐">1.4.2 精简实现-推荐</h4>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = <span class="title function_ invoke__">read_username_from_file</span>();</span><br><span class="line">    <span class="keyword">match</span> r &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(s) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;s = &#123;&#125;&quot;</span>,s),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;err = &#123;:?&#125;&quot;</span>,e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-4-3-进一步精简实现-推荐">1.4.3 进一步精简实现-推荐</h4>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = <span class="title function_ invoke__">read_username_from_file</span>();</span><br><span class="line">    <span class="keyword">match</span> r &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(s) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;s = &#123;&#125;&quot;</span>,s),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;err = &#123;:?&#125;&quot;</span>,e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试">测试</h2>
<p>测试目录下执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo test</span><br></pre></td></tr></table></figure>
<p>代码：<br>
创建mod</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> dog&#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">hello</span>()&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;wangwang&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">is_dog</span>() <span class="punctuation">-&gt;</span> <span class="type">bool</span>&#123;</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> cat&#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">hello</span>()&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;miaomiao&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">is_cat</span>() <span class="punctuation">-&gt;</span> <span class="type">bool</span>&#123;</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> animal;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> crate::animal::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(result, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">use_cat</span>()&#123;</span><br><span class="line">        <span class="comment">//cat::hello();</span></span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="literal">true</span>,cat::<span class="title function_ invoke__">is_cat</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">use_dot</span>()&#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="literal">true</span>,dog::<span class="title function_ invoke__">is_dog</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://kaisery.github.io/trpl-zh-cn/">Rust 程序设计语言</a></p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust基础</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust基础(7)-包、模块</title>
    <url>/articles/8fd16b32/</url>
    <content><![CDATA[<p>包、模块</p>
<span id="more"></span>  
<h2 id="概述">概述</h2>
<ol>
<li>包：Cargo的一个功能、允许构建、测试和分享crate(翻译：箱子)</li>
<li>Crate：一个模块的树形结构，形成库或二进制项目</li>
<li>模块：通过use来使用，用来控制作用域和路径的私有性</li>
<li>路径：一个命名例如结构体、函数或模块等项的方式</li>
</ol>
<h2 id="包和crate">包和Crate</h2>
<ol>
<li>crate root是一个源文件，Rust编译器以它为起始点，并构成你的crate的根模块</li>
<li>包提供一系列功能的一个或多个Crate</li>
<li>Crate root是src/main.rs或者是src/lib.rs。说明：如果只有main.rs则说明这个包只有一个crate（main），<a href="http://xn--main-pk1g920aw6qoyf0sc5xb.xn--rslib-ds5hj8pu6pwh3d.rs">如果同时拥有main.rs和其它的lib.rs</a>（不一定是这个名字），则说明拥有多个crate。</li>
<li>crate会将一个作用域的相关功能分组到一起，使得该功能可以很方便的在多个项目之间共享。</li>
</ol>
<h2 id="使用模块控制作用域和私有性">使用模块控制作用域和私有性</h2>
<ol>
<li>创建一个lib可以通过命令cargo new --lib libname来进行创建</li>
<li>默认所有项（函数、方法、结构体、枚举、模块和常量）都是私有的，需要使用pub才能暴露给外部</li>
<li>创建基本的模块：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建模块</span></span><br><span class="line"><span class="comment">//如果不加入pub，mod中的一切都是私有的，无法对外访问</span></span><br><span class="line"><span class="keyword">mod</span> factory&#123;</span><br><span class="line">    <span class="comment">//生产冰箱</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> produce_refrigerator&#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">produce_re</span>()&#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;produce refrigerator!&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产洗衣机</span></span><br><span class="line">    <span class="keyword">mod</span> produce_washing_machine&#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">produce_washing</span>()&#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;produce washing machine!!&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    factory::produce_refrigerator::<span class="title function_ invoke__">produce_re</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>
<p>按文件划分创建模块：<br>
(1). 在项目目录下创建lib：<code>cargo new --lib mylib</code><br>
(2). lib/src中，创建文件：<a href="http://factory.rs">factory.rs</a>，并写入：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生产冰箱</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> produce_refrigerator&#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">produce_re</span>()&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;produce refrigerator!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产洗衣机</span></span><br><span class="line"><span class="keyword">mod</span> produce_washing_machine&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">produce_washing</span>()&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;produce washing machine!!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3). 同目录的<code>lib.rs</code>中，对外开放该lib：<code>pub mod factory;</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> factory;</span><br></pre></td></tr></table></figure>
<p>(4). 项目根目录的Cargo.toml中，引入对mylib的依赖</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">mylib</span> = &#123;path = <span class="string">&quot;./mylib&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>(5). main.rs调用</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> mylib::factory::produce_refrigerator;</span><br><span class="line"><span class="keyword">use</span> mylib::factory::produce_refrigerator <span class="keyword">as</span> A;  <span class="comment">//简化</span></span><br><span class="line"><span class="comment">//use mylib::factory::*;  //全部导入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    mylib::factory::produce_refrigerator::<span class="title function_ invoke__">produce_re</span>();  <span class="comment">//绝对路径</span></span><br><span class="line">    produce_refrigerator::<span class="title function_ invoke__">produce_re</span>();  <span class="comment">//使用use</span></span><br><span class="line">    A::<span class="title function_ invoke__">produce_re</span>();  <span class="comment">//简化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>子mod访问父mod，使用super</p>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> modB &#123;</span><br><span class="line">     <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">print_B</span>()&#123;</span><br><span class="line">         <span class="built_in">println!</span>(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">mod</span> modC&#123;</span><br><span class="line">         <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">print_c</span>()&#123;</span><br><span class="line">             <span class="built_in">println!</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">             super::<span class="title function_ invoke__">print_B</span>();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用外部第三方库">使用外部第三方库</h2>
<ol>
<li><code>Cargo.toml</code>中加入依赖：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">rust-crypto = &quot;0.2&quot;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>main.rs</code>中调用：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> crypto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crypto::digest::Digest;</span><br><span class="line"><span class="keyword">use</span> crypto::sha3::Sha3;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hasher</span> = Sha3::<span class="title function_ invoke__">sha3_256</span>();</span><br><span class="line">    hasher.<span class="title function_ invoke__">input_str</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = hasher.<span class="title function_ invoke__">result_str</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hash = &#123;&#125;&quot;</span>,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>运行<br>
会自动下载依赖的crate，并编译运行</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo run</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://kaisery.github.io/trpl-zh-cn/">Rust 程序设计语言</a></p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust基础</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust基础(6)-vector、String、hashmap</title>
    <url>/articles/8d9df9e5/</url>
    <content><![CDATA[<p>vector、String、hashmap</p>
<span id="more"></span>  
<h2 id="vector">vector</h2>
<ol>
<li>创建空的vector:  Vet<T></li>
<li>创建包含初始值的vector</li>
<li>丢弃vector</li>
<li>读取元素</li>
<li>更新</li>
<li>遍历</li>
<li>使用枚举</li>
<li>补充：不可变引用之后使用了可变引用，则不能再使用原先不可变引用</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">//1. 创建空的vector:  Vet&lt;T&gt;</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="comment">// v.push(1);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建包含初始值的vector</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 丢弃vector</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 读取元素</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">one</span>: &amp;<span class="type">i32</span> = &amp;v[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;one = &#123;&#125;&quot;</span>, one);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;one = &#123;&#125;&quot;</span>, *one);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//推荐使用的方式</span></span><br><span class="line">    <span class="keyword">match</span> v.<span class="title function_ invoke__">get</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(value)=&gt;<span class="built_in">println!</span>(<span class="string">&quot;value = &#123;&#125;&quot;</span>, value),</span><br><span class="line">        _=&gt;<span class="built_in">println!</span>(<span class="string">&quot;do noting&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 更新</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v2</span>:<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    v2.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">    v2.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br><span class="line">    v2.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 遍历</span></span><br><span class="line">    <span class="comment">// 6.1 不可变遍历</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;v2  &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;i = &#123;&#125;&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.2 可变遍历</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v2  &#123;</span><br><span class="line">        *i +=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;i = &#123;&#125;&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 使用枚举</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Context</span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">Text</span>(<span class="type">String</span>),</span><br><span class="line">        <span class="title function_ invoke__">Float</span>(<span class="type">f32</span>),</span><br><span class="line">        <span class="title function_ invoke__">Int</span>(<span class="type">i32</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        Context::<span class="title function_ invoke__">Text</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;string&quot;</span>)),</span><br><span class="line">        Context::<span class="title function_ invoke__">Int</span>(-<span class="number">1</span>),</span><br><span class="line">        Context::<span class="title function_ invoke__">Float</span>(<span class="number">0.001</span>)</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8. 补充</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first</span> = &amp;v[<span class="number">0</span>];  <span class="comment">//不可变引用</span></span><br><span class="line">    v.<span class="title function_ invoke__">push</span>(<span class="number">6</span>);  <span class="comment">//可变引用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;first = &#123;&#125;&quot;</span>,first)  <span class="comment">//此时使用不可变引用，会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="string">String</h2>
<ol>
<li>创建一个空String</li>
<li>通过字面值创建一个String
<ol>
<li>使用String::from()</li>
<li>使用str的方式</li>
</ol>
</li>
<li>更新String
<ol>
<li>push_str</li>
<li>push</li>
<li>使用&quot;+&quot;合并字符串</li>
<li>使用format</li>
</ol>
</li>
<li>String索引</li>
<li>str索引</li>
<li>遍历
<ol>
<li>chars</li>
<li>bytes</li>
</ol>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">//1. 创建一个空String</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s0</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    s0.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s0 = &#123;&#125;&quot;</span>, s0);</span><br><span class="line">    <span class="comment">// 2. 通过字面值创建一个String</span></span><br><span class="line">    <span class="comment">//    1. 使用String::from()</span></span><br><span class="line">    <span class="comment">//    2. 使用str的方式</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;init some thing&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;&#125;&quot;</span>, s1);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="string">&quot;init some thing&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;&#125;&quot;</span>, s1);</span><br><span class="line">    <span class="comment">// 3. 更新String</span></span><br><span class="line">    <span class="comment">//    1. push_str</span></span><br><span class="line">    <span class="comment">//    2. push</span></span><br><span class="line">    <span class="comment">//    3. 使用&quot;+&quot;合并字符串</span></span><br><span class="line">    <span class="comment">//    4. 使用format</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    s2.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ss</span> = <span class="string">&quot; !&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    s2.<span class="title function_ invoke__">push_str</span>(&amp;ss);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tea&quot;</span>);</span><br><span class="line">    s2.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;m&#x27;</span>);  <span class="comment">//push只能添加一个字符</span></span><br><span class="line">    <span class="comment">//s2.push(&#x27;mms&#x27;);  //push只能添加一个字符</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = s1 + &amp;s2;</span><br><span class="line">    <span class="comment">// println!(&quot;s1 = &#123;&#125;&quot;,s1); //s1不能再使用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s3 = &#123;&#125;&quot;</span>, s3);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s2 = &#123;&#125;&quot;</span>, s2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s341</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s342</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tac&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s343</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;toe&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s344</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, s341, s342, s343);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s344 = &#123;&#125;&quot;</span>, s344);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s341 = &#123;&#125;&quot;</span>, s341);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s342 = &#123;&#125;&quot;</span>, s342);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s343 = &#123;&#125;&quot;</span>, s343);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. String索引</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s4</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    <span class="comment">// lets41 = s4[0];  //错误，String不能被索引，因为使用的utf8编码，不能逐个索引，无法解析</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//slice方式可以索引</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hello</span> = <span class="string">&quot;你好&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">h5</span> = &amp;hello[<span class="number">0</span>..<span class="number">3</span>];  <span class="comment">//边界要取对，否则解析依旧异常</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;h5 = &#123;&#125;&quot;</span>, h5);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. str索引</span></span><br><span class="line">    <span class="comment">//同上</span></span><br><span class="line">    <span class="comment">// 6. 遍历</span></span><br><span class="line">    <span class="comment">//    1. chars</span></span><br><span class="line">    <span class="comment">//    2. bytes</span></span><br><span class="line">    <span class="comment">//chars</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> s4.<span class="title function_ invoke__">chars</span>()&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;c = &#123;&#125;&quot;</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//byte</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> s4.<span class="title function_ invoke__">bytes</span>()&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;&#125;&quot;</span>, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hashmap">HashMap</h2>
<ol>
<li>引入：use std::collections::HashMap;</li>
<li>HashMap&lt;K,V&gt;</li>
<li>创建HashMap</li>
<li>读取</li>
<li>遍历</li>
<li>更新</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">//3. 创建HashMap</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span>: HashMap&lt;<span class="type">String</span>, <span class="type">i32</span>&gt; = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Red&quot;</span>), <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用vector创建</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">keys</span> = <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Red&quot;</span>)];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">values</span> = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">20</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">scores</span>: HashMap&lt;_, _&gt; = keys.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">zip</span>(values.<span class="title function_ invoke__">iter</span>()).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">k</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(v) = scores.<span class="title function_ invoke__">get</span>(&amp;k) &#123;<span class="comment">// v = 10; 返回的是Option</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;v = &#123;&#125;&quot;</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = scores.<span class="title function_ invoke__">get</span>(&amp;k);</span><br><span class="line">    <span class="keyword">match</span> v&#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(value) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;v = &#123;&#125;&quot;</span>,value),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;None&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历，会以任意的顺序遍历</span></span><br><span class="line">    <span class="keyword">for</span> (key,value) <span class="keyword">in</span> &amp;scores&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>,key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接插入值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ss</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    ss.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;one&quot;</span>),<span class="number">1</span>);</span><br><span class="line">    ss.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;two&quot;</span>),<span class="number">2</span>);</span><br><span class="line">    ss.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;three&quot;</span>),<span class="number">3</span>);</span><br><span class="line">    ss.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;one&quot;</span>),<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//键值不存在才插入</span></span><br><span class="line">    ss.<span class="title function_ invoke__">entry</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;two&quot;</span>)).<span class="title function_ invoke__">or_insert</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,ss);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据旧值来更新一个值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;hello world wonderful world&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">word</span> <span class="keyword">in</span> text.<span class="title function_ invoke__">split_whitespace</span>()&#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">count</span> = map.<span class="title function_ invoke__">entry</span>(word).<span class="title function_ invoke__">or_insert</span>(<span class="number">0</span>);</span><br><span class="line">        *count +=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;map = &#123;:?&#125;&quot;</span>,map)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>已编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://kaisery.github.io/trpl-zh-cn/">Rust 程序设计语言</a></p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust基础</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust基础(5)-枚举与模式匹配</title>
    <url>/articles/af2afb7b/</url>
    <content><![CDATA[<p>枚举与模式匹配</p>
<span id="more"></span> 
<h2 id="1-基础-枚举和match">1. 基础-枚举和match</h2>
<ol>
<li>类似于c语言的方式定义</li>
<li>rust语言提倡的方式定义</li>
<li>可以是不同类型</li>
<li>经典用法</li>
<li>枚举类型的方法以及match<br>
6.备注：
<ol>
<li>match类似于别的语言的switch，也可以用if替代</li>
</ol>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 类似于c语言的方式定义</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddKind</span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    kind: IpAddKind,</span><br><span class="line">    address: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. rust语言提倡的方式定义</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr2</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 可以是不同类型</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr3</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 经典用法</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Change</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--等同于</span></span><br><span class="line"><span class="comment">//struct QuitMessage; //类单元结构体</span></span><br><span class="line"><span class="comment">//struct MoveMessage&#123;</span></span><br><span class="line"><span class="comment">//    x:i32,</span></span><br><span class="line"><span class="comment">//    y:i32,</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//struct WriteMessage(String)</span></span><br><span class="line"><span class="comment">//struct Change(i32,i32,i32)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 枚举类型的方法以及match</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">prin</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            Message::Quit =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Quit&quot;</span>),</span><br><span class="line">            Message::Move&#123;x, y&#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Move x = &#123;&#125;,y = &#123;&#125;&quot;</span>, x, y),</span><br><span class="line">            Message::<span class="title function_ invoke__">Change</span>(a, b, c) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;change a = &#123;&#125;, b = &#123;&#125;, c = &#123;&#125;&quot;</span>, a, b, c),</span><br><span class="line">            <span class="comment">//默认，类似default语句</span></span><br><span class="line">            <span class="comment">// _ =&gt; println!(&quot;Write&quot;),</span></span><br><span class="line">            Message:: <span class="title function_ invoke__">Write</span>(&amp;s) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Write = &#123;&#125;&quot;</span>, s) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 1. 类似于c语言的方式定义</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i1</span> = IpAddr &#123;</span><br><span class="line">        kind: IpAddKind::V4,</span><br><span class="line">        address: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;127.0.0.1&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i2</span> = IpAddr &#123;</span><br><span class="line">        kind: IpAddKind::V6,</span><br><span class="line">        address: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. rust语言提倡的方式定义</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i1</span> = IpAddr2::<span class="title function_ invoke__">V4</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;127.0.0.1&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i2</span> = IpAddr2::<span class="title function_ invoke__">V6</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 可以是不同类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i1</span> = IpAddr3::<span class="title function_ invoke__">V4</span>(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i2</span> = IpAddr3::<span class="title function_ invoke__">V6</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>));</span><br><span class="line">    <span class="comment">// 4. 经典用法</span></span><br><span class="line">    <span class="comment">// Message结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 枚举类型的方法以及match</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">quit</span> = Message::Quit;</span><br><span class="line">    quit.<span class="title function_ invoke__">prin</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mo</span> = Message::Move &#123;x:<span class="number">10</span>,y:<span class="number">20</span>&#125;;</span><br><span class="line">    mo.<span class="title function_ invoke__">prin</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">wri</span> = Message::<span class="title function_ invoke__">Write</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    wri.<span class="title function_ invoke__">prin</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">change</span> = Message::<span class="title function_ invoke__">Change</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    change.<span class="title function_ invoke__">prin</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-option-重点掌握">2. Option(重点掌握)</h2>
<p>Option是标准库定义的一个枚举。<br>
主要用法：</p>
<ul>
<li>初始化值</li>
<li>作为在整个输入范围内没有定义的函数的返回值</li>
<li>作为返回值，用None表示出现的简单错误</li>
<li>作为结构体的可选字段</li>
<li><code>作为结构体中可借出或者可载入的字段</code>，下方有使用案例</li>
<li>作为函数的可选参数</li>
<li>代表空指针</li>
<li>用作复杂情况的返回值</li>
</ul>
<h3 id="2-1-基本使用">2.1 基本使用</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Option是标准库定一个的一个枚举，标准库定义格式如下：</span></span><br><span class="line"><span class="comment">//enum Option&lt;T&gt;&#123;</span></span><br><span class="line"><span class="comment">//  Some(T),</span></span><br><span class="line"><span class="comment">//  None,</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">// match时，Option的所有类型都要匹配到</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_number</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="title function_ invoke__">Some</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;a string&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">absent_numer</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i32</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">temp</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">match</span> y &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; &#123; temp = i &#125;</span><br><span class="line">        <span class="literal">None</span> =&gt; &#123; <span class="built_in">println!</span>(<span class="string">&quot;do notiong&quot;</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span> = x + temp;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;sum = &#123;&#125;&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">plus_one</span>(y);</span><br><span class="line">    <span class="keyword">match</span> result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;result = &#123;&#125;&quot;</span>,i),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;nothing&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以用if来判断</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(value) = <span class="title function_ invoke__">plus_one</span>(y)&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;value = &#123;&#125;&quot;</span>,value)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  <span class="comment">//处理None</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;do noting&quot;</span> )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(x) =&gt; <span class="title function_ invoke__">Some</span>(x + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-基本使用">2.2 基本使用</h3>
<p>作为结构体中可借出或者可载入的字段：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    <span class="comment">// thread: thread::JoinHandle&lt;()&gt;,</span></span><br><span class="line">    thread: <span class="type">Option</span>&lt;thread::JoinHandle&lt;()&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Worker &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">thread</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;start work 10 secs ...&quot;</span>);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">10</span>));</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;start work 10 finish ...&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Worker &#123; thread:<span class="title function_ invoke__">Some</span>(thread)  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    workers: <span class="type">Vec</span>&lt;Worker&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(size: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> ThreadPool &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(size &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">workers</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(size);</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">            workers.<span class="title function_ invoke__">push</span>(Worker::<span class="title function_ invoke__">new</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        ThreadPool&#123;workers&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">worker</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.workers &#123;</span><br><span class="line">            <span class="comment">// worker.thread.join().unwrap();</span></span><br><span class="line">            <span class="comment">// println!(&quot;worker thread finished&quot;);</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(thread) = worker.thread.<span class="title function_ invoke__">take</span>()&#123;</span><br><span class="line">                thread.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;worker thread finished&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pool</span> = ThreadPool::<span class="title function_ invoke__">new</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-常用方法">2.3 常用方法</h3>
<ol>
<li>take()：将数据移出赋值给指定变量Some(x )，自身变为None。就是上面案例，将thread从可变数据中移出</li>
<li>copied()：从Option&lt;&amp;T&gt;得到Option<T>（通过复制实现）</li>
<li>cloned()：从Option&lt;&amp;T&gt;得到Option<T>（通过clone实现）</li>
<li>is_some()：当Option中有值，返回true</li>
<li>is_none()：当Option为None，返回true</li>
<li>contains()：属于<code>nightly</code>版本特性，当Option中包含指定值，则返回true</li>
<li>as_ref()：将&amp;Option<T>转换为Option&lt;&amp;T&gt; ，将外部引用转换为内部引用。说白了就是直接指向了内部的T：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span>:<span class="type">Option</span>&lt;<span class="type">String</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="string">&quot;Hello,world!&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text_length</span>: <span class="type">Option</span>&lt;<span class="type">usize</span>&gt; = text.<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">map</span>(|s| s.<span class="title function_ invoke__">len</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;still can print text:&#123;:?&#125;&quot;</span>,text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>已编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://kaisery.github.io/trpl-zh-cn/">Rust 程序设计语言</a></p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust基础</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust基础(4)-结构体和方法</title>
    <url>/articles/cc28adac/</url>
    <content><![CDATA[<p>结构体和方法</p>
<span id="more"></span> 
<h2 id="结构体">结构体</h2>
<ol>
<li>定义结构体</li>
<li>创建结构体实例</li>
<li>修改结构体字段</li>
<li>参数名字和字段名字同名的简写方法</li>
<li>从其它结构体创建实例</li>
<li>元组结构体</li>
<li>没有任何字段的类单元结构体</li>
<li>打印结构体</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">//1. 定义结构体</span></span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        name: <span class="type">String</span>,</span><br><span class="line">        count: <span class="type">String</span>,</span><br><span class="line">        nonce: <span class="type">u64</span>,</span><br><span class="line">        active: <span class="type">bool</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 创建结构体实例</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">xiaoming</span> = User &#123;</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xiaoming&quot;</span>),</span><br><span class="line">        count: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;80001000&quot;</span>),</span><br><span class="line">        nonce: <span class="number">10000</span>,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//3. 修改结构体字段</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">xiaohuang</span> = User &#123;</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xiaohuang&quot;</span>),</span><br><span class="line">        count: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;80001000&quot;</span>),</span><br><span class="line">        nonce: <span class="number">10000</span>,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    xiaohuang.nonce = <span class="number">20000</span>;</span><br><span class="line">    <span class="comment">//4. 参数名字和字段名字同名的简写方法</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xiaoxiao&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;89077777&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">active</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">nonce</span> = <span class="number">30000</span>;</span><br><span class="line">    <span class="comment">/*let user1 = User&#123;  //太繁琐</span></span><br><span class="line"><span class="comment">        name: name,</span></span><br><span class="line"><span class="comment">        count:count,</span></span><br><span class="line"><span class="comment">        nonce:nonce,</span></span><br><span class="line"><span class="comment">        active:active,</span></span><br><span class="line"><span class="comment">    &#125;;*/</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;   <span class="comment">//简写</span></span><br><span class="line">        name,</span><br><span class="line">        count,</span><br><span class="line">        nonce,</span><br><span class="line">        active,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//5. 从其它结构体创建实例</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">        ..user1   <span class="comment">//user1被移动，之后不能再使用 user1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;name = &#123;&#125;&quot;</span>, user2.name);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user3</span> = User &#123;</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;user3&quot;</span>),</span><br><span class="line">        ..user2</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;name = &#123;&#125;&quot;</span>, user3.name);</span><br><span class="line">    <span class="comment">//6. 元组结构体</span></span><br><span class="line">    <span class="comment">//6.1 字段没有名字</span></span><br><span class="line">    <span class="comment">//6.2 圆括号</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">Point</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Point</span>(<span class="number">30</span>, <span class="number">11</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a.x = &#123;&#125;,a.y = &#123;&#125;&quot;</span>, a.<span class="number">0</span>, a.<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//7. 没有任何字段的类单元结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line">    <span class="comment">//8. 打印结构体</span></span><br><span class="line">    <span class="comment">//结构体上方加上：#[derive(Debug)]</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;xiaoming = &#123;:?&#125;&quot;</span>, xiaoming);</span><br><span class="line">    <span class="comment">//可自动换行</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;xiaoming = &#123;:#?&#125;&quot;</span>, xiaoming);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法">方法</h2>
<ol>
<li>方法可以写在不同的impl语句块</li>
<li>可以对外静态方法，需要通过：Dog::show()方式调用</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    weight: <span class="type">f32</span>,</span><br><span class="line">    height: <span class="type">f32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_name</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        &amp;(<span class="keyword">self</span>.name[..])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_weight</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.weight</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此方法没有传入self，类似对外的静态方法，需要用 Dog::show()调用</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">show</span>()&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;oh oh oh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_height</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">dog</span> = Dog &#123;</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;wangcai&quot;</span>),</span><br><span class="line">        weight: <span class="number">100.0</span>,</span><br><span class="line">        height: <span class="number">70.5</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;dog = &#123;:#?&#125;&quot;</span>,dog);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;name = &#123;&#125;&quot;</span>,dog.<span class="title function_ invoke__">get_name</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;weight = &#123;&#125;&quot;</span>,dog.<span class="title function_ invoke__">get_weight</span>());</span><br><span class="line">    Dog::<span class="title function_ invoke__">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>已编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://kaisery.github.io/trpl-zh-cn/">Rust 程序设计语言</a></p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust基础</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust基础(3)-所有权、引用、slice</title>
    <url>/articles/bd0110d7/</url>
    <content><![CDATA[<p>这些内容突出了rust对安全的关注，和别的语法差别有点大，需要多了解</p>
<span id="more"></span>  
<h2 id="所有权">所有权</h2>
<ol>
<li>rust通过所有权机制来管理内存，编译器在编译就会根据所有权规则对内存的使用进行检查</li>
<li>堆和栈
<ol>
<li>编译时，数据的类型大小是固定的，就分配在栈上</li>
<li>编译时数据类型大小不固定，就分配在堆上</li>
</ol>
</li>
<li>作用域
<ol>
<li>{} 表示</li>
</ol>
</li>
<li>string内存回收
<ol>
<li>string指针在栈，数据在堆</li>
<li>离开作用域会自动调用drop方法释放</li>
</ol>
</li>
<li>移动
<ol>
<li>堆数据移动，会释放旧的；</li>
<li>栈数据移动，叫做数据拷贝，不会释放原先的</li>
</ol>
</li>
<li>clone
<ol>
<li>主要是堆数据的拷贝</li>
</ol>
</li>
<li>栈上数据拷贝
<ol>
<li>使用copy</li>
<li>常用的具有copy的有：所有整型、浮点型、布尔值、字符类型、元组</li>
</ol>
</li>
<li>函数和作用域
<ol>
<li>定义的堆变量，传入函数，相当于移动，执行完后，会被释放</li>
<li>定义的栈变量，传入函数，相当于拷贝，执行完后，还能继续使用</li>
</ol>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="comment">//3. 作用域，定义的变量只在作用域内有效，以下程序作用域外部打印y执行会失败</span></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i32</span> = <span class="number">1</span>;</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">i32</span> = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;&#125;&quot;</span>, x);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// println!(&quot;y = &#123;&#125;&quot;, y);</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//4. string内存回收</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">//定义在堆上</span></span><br><span class="line">      <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">      s1.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; world&quot;</span>);</span><br><span class="line">      <span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;&#125;&quot;</span>, s1);</span><br><span class="line">      <span class="comment">//离开作用域会自动调用drop方法释放</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//5. 移动，s2拷贝s1后，s1会被释放，无法再打印</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">      <span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;&#125;&quot;</span>, s1);</span><br><span class="line">      <span class="keyword">let</span> <span class="variable">s2</span> = s1;    <span class="comment">//s1 move到s2</span></span><br><span class="line">      <span class="built_in">println!</span>(<span class="string">&quot;s2 = &#123;&#125;&quot;</span>, s2);</span><br><span class="line">      <span class="comment">// println!(&quot;s1 = &#123;&#125;&quot;, s1);</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//6. clone</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">      <span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;&#125;&quot;</span>, s1);</span><br><span class="line">      <span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();    <span class="comment">//s1 move到s2</span></span><br><span class="line">      <span class="built_in">println!</span>(<span class="string">&quot;s2 = &#123;&#125;&quot;</span>, s2);</span><br><span class="line">      <span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;&#125;&quot;</span>, s1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//7. 栈上数据拷贝</span></span><br><span class="line">   <span class="comment">//常用的具有copy的有：所有整型、浮点型、布尔值、字符类型、元组</span></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">b</span> = a;</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;&#125;, b = &#123;&#125;&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//8 函数和作用域</span></span><br><span class="line">   <span class="comment">//堆的s在函数作用域被释放，不可再使用</span></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">   <span class="title function_ invoke__">takes_ownership</span>(s);</span><br><span class="line">   <span class="comment">// println!(&quot;s = &#123;&#125;&quot;, s);   //s不可再使用</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">   <span class="title function_ invoke__">makes_copy</span>(x);</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;&#125;&quot;</span>, x);   <span class="comment">//分配在栈上，拷贝，因此x可以继续使用</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_ownership</span>(some_string: <span class="type">String</span>)&#123;</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">makes_copy</span>(i: <span class="type">i32</span>)&#123;</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;i = &#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="引用和借用">引用和借用</h2>
<ol>
<li>引用：使用符号&amp;，类似golang 。让我们创建一个指向值的应用，但是并不拥有它，因为不拥有这个值，所以，当引用离开其值指向的作用域后也不会被丢弃
<ol>
<li>&amp;s1</li>
</ol>
</li>
<li>借用，相当于新变量指向了旧变量；借用之后，新旧变量只能使用一个
<ol>
<li>let ms = &amp;mut s1;  //借用之后，以下两行只能同时存在一行
<ol>
<li>println!(“s1 = {}”, s1);</li>
<li>println!(“ms = {}”,ms);</li>
</ol>
</li>
</ol>
</li>
<li>总结：
<ol>
<li>在任意给定时间，有了可变引用之后不能再有不可变引用</li>
<li>引用必须有效（如下面案例最后，方法返回了无效引用）</li>
</ol>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives_ownership</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;&#125;&quot;</span>, s1);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">takes_and_gives_back</span>(s2);</span><br><span class="line">    <span class="comment">// println!(&quot;s2 = &#123;&#125;&quot;, s2);  //s2被借用，已被释放，不可继续使用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s3 = &#123;&#125;&quot;</span>, s3);</span><br><span class="line">    s2 = <span class="title function_ invoke__">takes_and_gives_back</span>(s3);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s2 = &#123;&#125;&quot;</span>, s2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//引用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calcute_leght</span>(&amp;s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;&#125;&quot;</span>,s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;len = &#123;&#125;&quot;</span>, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//引用不可直接修改内容，编译直接报错</span></span><br><span class="line">    <span class="comment">//modify_s(&amp;s1);</span></span><br><span class="line">    <span class="comment">//如果要修改引用的内容，则需要用到借用 &amp;mut</span></span><br><span class="line">    <span class="title function_ invoke__">modify_s_mut</span>(&amp;<span class="keyword">mut</span> s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;&#125;&quot;</span>,s1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ms</span> = &amp;<span class="keyword">mut</span> s1;  <span class="comment">//借用，借用后可修改，相当于 修改了s1</span></span><br><span class="line">    <span class="title function_ invoke__">modify_s_mut</span>(ms);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;&#125;&quot;</span>, s1);  <span class="comment">//s1被借用后，s1和ms不能同时使用</span></span><br><span class="line">    <span class="comment">// println!(&quot;ms = &#123;&#125;&quot;,ms);  //若打印了ms，则不能再打印s1。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法返回被释放的变量的引用会报错</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ref_s</span> = <span class="title function_ invoke__">dangle</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_and_gives_back</span>(s: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用：读取</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calcute_leght</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span>&#123;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用：修改，修改会失败，编译都通不过</span></span><br><span class="line"><span class="comment">/*fn modify_s(s:&amp;String)&#123;</span></span><br><span class="line"><span class="comment">    s.push_str(&quot; world&quot;);</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引用：修改，修改会成功</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">modify_s_mut</span>(s:&amp;<span class="keyword">mut</span> <span class="type">String</span>)&#123;</span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用：返回被释放的变量的引用会报错（编译就会报错），堆已经被释放了</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &amp;s  <span class="comment">//无效引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="slice">slice</h2>
<ol>
<li>字符串slice是String中一部分值的引用</li>
<li>字面值就是slice</li>
<li>其它类型的slice</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">h</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line">    <span class="comment">//let h = &amp;s[0..=4]; //和上面同一种表示方法</span></span><br><span class="line">    <span class="comment">//let h = &amp;s[..5];  //和上面同一种表示方法</span></span><br><span class="line">    <span class="comment">//let h = &amp;s[..=4]; //和上面同一种表示方法</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;h = &#123;&#125;&quot;</span>,h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">w</span> = &amp;s[<span class="number">6</span>..<span class="number">11</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;w = &#123;&#125;&quot;</span>,w);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ww</span> = &amp;s[..];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;ww = &#123;&#125;&quot;</span>,ww);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字面值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="string">&quot;hh&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s3 = &#123;&#125;&quot;</span>,s3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sss</span> = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;sss = &#123;&#125;&quot;</span>,sss[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>已编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://kaisery.github.io/trpl-zh-cn/">Rust 程序设计语言</a></p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust基础</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust基础(2)-通用编程概念和操作符</title>
    <url>/articles/d1f5c252/</url>
    <content><![CDATA[<p>Rust中涉及到的一些基本概念，以下演示都是基于前面一章helloworld方式生成的项目。为了方便，这里只展示关键代码</p>
<span id="more"></span>  
<h2 id="1-变量-常量">1-变量、常量</h2>
<ol>
<li>变量
<ol>
<li>可变性：定义变量用let，如果变量没有用mut，那么是不可变的</li>
<li>隐藏性：后面变量隐藏前面变量</li>
</ol>
</li>
<li>常量
<ol>
<li>关键词：const</li>
</ol>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MAX_POINT: <span class="type">u32</span> = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">//1. 变量可变性</span></span><br><span class="line">    <span class="comment">//不可变变量</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>: <span class="type">u32</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//可变变量</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">bb</span>: <span class="type">u32</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;&#125;&quot;</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;&#125;&quot;</span>, b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;bb = &#123;&#125;&quot;</span>, bb);</span><br><span class="line">    bb = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;bb = &#123;&#125;&quot;</span>, bb);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 变量隐藏，后面变量隐藏前面变量</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span>: <span class="type">u32</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c = &#123;&#125;&quot;</span>, c);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span>: <span class="type">f32</span> = <span class="number">1.1</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c = &#123;&#125;&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 常量</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;MAX_POINTS = &#123;&#125;&quot;</span>, MAX_POINT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-数据类型">2-数据类型</h2>
<ol>
<li>rust是静态类型语言，也就是说编译时必须知道素有变量的类型</li>
<li>编译器具有自动推导的能力</li>
</ol>
<h3 id="2-1-基础数据类型">2.1-基础数据类型</h3>
<p>bool、char、u32、数字类型、数组、自适应类型</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="comment">//1. bool</span></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">is_true</span>: <span class="type">bool</span> = <span class="literal">true</span>;</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;is_true = &#123;&#125;&quot;</span>, is_true);</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">is_false</span> = <span class="literal">false</span>;</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;is_false = &#123;&#125;, &#123;&#125;&quot;</span>, is_false, is_true);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2. char 在rust里面，char是32位的，字符汉字均可</span></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">a</span> = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;&#125;&quot;</span>, a);</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">b</span> = <span class="string">&#x27;你&#x27;</span>;</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;&#125;&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3. 数字类型 i8, i16, i32, i64, u8, u16, u32, u64, f32, f64</span></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">c</span>: <span class="type">i8</span> = -<span class="number">111</span>;</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;c = &#123;&#125;&quot;</span>, c);</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">d</span>: <span class="type">f32</span> = <span class="number">0.0001</span>;</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;d = &#123;&#125;&quot;</span>, d);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//4. 自适应类型，根据不同系统平台，打印位数长度不同：isize（有符号），usize（无符号），</span></span><br><span class="line">   <span class="comment">//无符号最大长度</span></span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;max = &#123;&#125;&quot;</span>, <span class="type">usize</span>::<span class="title function_ invoke__">max_value</span>());</span><br><span class="line"></span><br><span class="line">   <span class="comment">//5. 数组[type; size]这是一个整体，是一个类型，也就是size不同，则数组也是不同的类型</span></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">u32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;arr[0] = &#123;&#125;&quot;</span>, arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-集合数据类型">2.2-集合数据类型</h3>
<p>元组、结构体、枚举</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="comment">//1. 元组</span></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f32</span>, <span class="type">char</span>) = (-<span class="number">3</span>, <span class="number">3.69</span>, <span class="string">&#x27;好&#x27;</span>);</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, tup.<span class="number">0</span>);</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">tup</span> = (-<span class="number">3</span>, <span class="number">3.69</span>, <span class="string">&#x27;好&#x27;</span>);</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, tup.<span class="number">1</span>);</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, tup.<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> (x,y,z) = tup;</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, y);</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-字符串">2.3-字符串</h3>
<h2 id="3-rust控制流">3-Rust控制流</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">//if else 和golang等一样</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> y == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;y = 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//let中使用if</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">condition</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="keyword">if</span> condition &#123;</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="number">6</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;&#125;&quot;</span>, x);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//loop, 无限循环</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;in loop&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">20</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;result = &#123;&#125;&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//while</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> i != <span class="number">10</span> &#123;</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;i = &#123;&#125;&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">u32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">element</span> <span class="keyword">in</span> arr.<span class="title function_ invoke__">iter</span>() &#123; </span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;element = &#123;&#125;&quot;</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">element</span> <span class="keyword">in</span> &amp;arr &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;element = &#123;&#125;&quot;</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-函数">4-函数</h2>
<p>直接看代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">other_fun</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;这是一个方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">other_fun1</span>(a: <span class="type">i32</span>, b: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;&#125;, b = &#123;&#125;&quot;</span>, a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">other_fun2</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = a + b;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化返回</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">other_fun3</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = a + b;</span><br><span class="line">    result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化返回</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">other_fun4</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">other_fun</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>: <span class="type">i32</span> = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>: <span class="type">u32</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="title function_ invoke__">other_fun1</span>(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span>: <span class="type">i32</span> = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span>: <span class="type">i32</span> = <span class="title function_ invoke__">other_fun2</span>(a, c);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r = &#123;&#125;&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cc</span>: <span class="type">i32</span> = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rr</span>: <span class="type">i32</span> = <span class="title function_ invoke__">other_fun3</span>(a, cc);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rr = &#123;&#125;&quot;</span>, rr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ccc</span>: <span class="type">i32</span> = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rrr</span>: <span class="type">i32</span> = <span class="title function_ invoke__">other_fun4</span>(a, ccc);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rrr = &#123;&#125;&quot;</span>, rrr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语句是执行一些操作，但是不返回值的指令</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">1</span>; <span class="comment">//语句，不返回值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//表达式会计算一些值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line">        x +<span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y = &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-操作符">5-操作符</h2>
<h3 id="5-1-问号-操作符">5.1-问号(?)操作符</h3>
<p>为了让Result&lt;T,E&gt;类型的处理更加方便简洁，Rust中引入了<code>?</code>操作符。<br>
问号操作符是针对<code>Result&lt;T,E&gt;</code>类型的一个语法糖，<code>?</code>操作符内部被展开成一段类似如下match匹配的代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果Result是一个E类型的错误值，则提前返回错误，结束当前函数。</span></span><br><span class="line"><span class="comment">//如果Result是一个T类型的正确值，则提取出值，方便后续进行链式调用。</span></span><br><span class="line"><span class="keyword">match</span> result &#123;</span><br><span class="line">  <span class="title function_ invoke__">Ok</span>(v) =&gt; v,</span><br><span class="line">  <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e.<span class="title function_ invoke__">into</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，<code>?</code>操作符可以方便地对Result&lt;T,E&gt;进行值提取（Ok(v) =&gt; v），或者返回一个错误类型值，提前结束当前函数。</p>
<p>注意：</p>
<ol>
<li>?操作符只能使用在以Option或者Result作为返回值的函数体中。</li>
<li>如果要在main()中使用?操作符。那么首先是要求main()返回值是Option或者Result类型（满足第一条）；其次，还要求返回值是要实现<code>std::process::Termination trait</code>的类型。</li>
<li>简单说，?等价于Result，简写</li>
</ol>
<h3 id="5-2-static">5.2-'static</h3>
<ol>
<li>'static，拥有该生命周期的引用可以和整个程序活得一样久。</li>
<li>实在遇到解决不了的生命周期标注问题，可以尝试 T: 'static，有时候它会给你奇迹</li>
<li>参考：<a href="https://www.zhihu.com/question/515953625/answer/2343571646">如何理解Rust语言中的 'static 生命周期?</a></li>
</ol>
<h2 id="总结">总结</h2>
<p>已编辑完毕</p>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://kaisery.github.io/trpl-zh-cn/">Rust 程序设计语言</a></p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust基础</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust基础(1)-环境搭建及HelloWorld</title>
    <url>/articles/10db6b0/</url>
    <content><![CDATA[<p>一门专注于安全的语言</p>
<span id="more"></span>  
<h2 id="1-环境安装">1. 环境安装</h2>
<h3 id="1-1-mac安装rust">1.1 mac安装rust</h3>
<p>直接使用官方推荐的rustup工具，这个是用来管理Rust版本和相关工具的命令行工具。别的安装方式不用考虑，聚焦主流。<br>
这里根据我的情况，只介绍mac下的安装方式：</p>
<ol>
<li>配置环境变量（不配置的话，安装工具就自己找默认位置去了）：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加入如下内容</span></span><br><span class="line">export RUSTUP_HOME=/自定义rustup安装目录/.rustup</span><br><span class="line">export CARGO_HOME=/自定义rust包管理目录/.cargo</span><br><span class="line">export PATH=$CARGO_HOME/bin:$PATH</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">环境变量配置完后，记得执行下面<span class="built_in">source</span>命令生效，或者重启命令行</span></span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>先安装mac的工具，确保版本新的，已安装的可忽略：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>命令行下操作<br>
该命令会安装rustup的同时安装最新版的rust，此处需要科学上网</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --proto &#x27;=https&#x27; --tlsv1.2 https://sh.rustup.rs -sSf | sh</span><br></pre></td></tr></table></figure>
<p>安装完成后，会提示：<code>Rust is installed now. Great!</code></p>
<ol start="4">
<li>检测是否安装成功</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rustc --version</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此处我的显示：rustc 1.60.0 (7737e0b5c 2022-04-04)</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-windos10安装rust">1.2 windos10安装rust</h3>
<p>这里只讲解和mac安装不一样的地方：<br>
rust官网下载rust程序并打开后，若选择1，则会提示安装virsual code c++以来环境，这个体积太大（8G左右），如果不是搞vc++开发，这里推荐选3，先安装完rust。<br>
此时还缺少编译环境，命令行执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载编译工具</span></span><br><span class="line">rustup toolchain install stable-x86_64-pc-windows-gnu </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置默认的编译工具，必须，因为默认的使用哪个virsual code c++</span></span><br><span class="line">rustup default stable-x86_64-pc-windows-gnu  </span><br></pre></td></tr></table></figure>
<p>剩下的就是macos的一样了</p>
<h2 id="2-rustup安装镜像地址配置">2. rustup安装镜像地址配置</h2>
<ol>
<li>默认官方镜像地址下载很慢，一般使用国内地址</li>
<li>环境变量配置：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup</span><br><span class="line">export RUSTUP_DIST_SERVER=http://mirrors.ustc.edu.cn/rust-static</span><br></pre></td></tr></table></figure>
<h2 id="3-cargo-crate镜像地址配置">3. cargo crate镜像地址配置</h2>
<p>项目需要使用的依赖，使用的是字节跳动的，速度会很快</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若没有该目录，则自动创建</span></span><br><span class="line">vi ~/.cargo/config</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以下为加入的内容</span></span><br><span class="line">[source.crates-io]</span><br><span class="line">replace-with = &#x27;rsproxy&#x27;</span><br><span class="line"></span><br><span class="line">[source.rsproxy]</span><br><span class="line">registry = &quot;https://rsproxy.cn/crates.io-index&quot;</span><br><span class="line"></span><br><span class="line">[registries.rsproxy]</span><br><span class="line">index = &quot;https://rsproxy.cn/crates.io-index&quot;</span><br><span class="line"></span><br><span class="line">[net]</span><br><span class="line">git-fetch-with-cli = true</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4-helloworld">4. HelloWorld</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir learn_rust</span><br><span class="line">cd learn_rust</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时项目初始化生成了helloworld</span></span><br><span class="line">cargo new helloworld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">项目根目录或者src目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行</span></span><br><span class="line">cargo run</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译，成功后，在target的debug目录会有生成的可执行程序</span></span><br><span class="line">cargo build</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查语法</span></span><br><span class="line">cargo check</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">交叉编译</span> </span><br><span class="line">rustup target list   # 查看支持哪些平台编译</span><br><span class="line">rustup target add x86_64-unknown-linux-gnu  # linux 一般使用gnu</span><br><span class="line">cargo build --release --target x86_64-unknown-linux-gnu </span><br></pre></td></tr></table></figure>
<h2 id="5-总结">5. 总结</h2>
<p>已编辑完毕</p>
<h2 id="6-参考">6. 参考</h2>
<p>[1] <a href="https://kaisery.github.io/trpl-zh-cn/">Rust 程序设计语言</a></p>
]]></content>
      <categories>
        <category>基础技术</category>
        <category>rust基础</category>
      </categories>
      <tags>
        <tag>开发语言</tag>
        <tag>rust基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Phala设备配置总结</title>
    <url>/articles/3f77a80d/</url>
    <content><![CDATA[<p>phala基于了polkadot的pos共识机制，更多依赖了cpu的可信计算，对能源的消耗比起别的链要降低了太多。<br>
本文针对单机模式和集群模式的设备配置方式的整理。这里只考虑使用家用主机。</p>
<span id="more"></span>
<h2 id="单机模式">单机模式</h2>
<p>单机模式，顾名思义，从节点同步到worker mining，全部在一台主机上完成。</p>
<ol>
<li>优点
<ol>
<li>只有少数几台主机时，每台完全独立，作为管理员管理简单，也好维护</li>
<li>官方提供单机模式的部署脚本，并且不断迭代完善。可以很快完成部署。</li>
<li>脚本会的到官方维护，每次升级只要按照官方提示升级每台主机的脚本即可</li>
</ol>
</li>
<li>缺点
<ol>
<li>当有十几台，甚至几十台主机时，每台设备都是完全独立的，维护起来立马会几何倍数提升。</li>
<li>每台主机需要同步一个数据节点，带宽占用多。每台主机都有相同的1t左右的节点数据，冗余大，维护困难。</li>
<li>一台主机数据同步服务会占用cpu，导致worker mining效率会有所下降</li>
</ol>
</li>
<li>建议：
<ul>
<li>该模式下，如果想简化管理，质押池账户和gas账户可共用一个，创建一个质押池，所有worker公钥都加入到该质押池</li>
</ul>
</li>
<li>主要配置参考（最优，当然还有更好的，但整体来说，以下配置已经足够了）</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>设备名称</strong></th>
<th style="text-align:center"><strong>型号</strong></th>
<th style="text-align:center"><strong>规格</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">内存条</td>
<td style="text-align:center">金士顿ddr4</td>
<td style="text-align:center">16g 3200频率</td>
<td>最好两根8g</td>
</tr>
<tr>
<td style="text-align:center">固态硬盘 x 2块</td>
<td style="text-align:center">金士顿 nvme</td>
<td style="text-align:center">m2-2T固态硬盘（SSD），读写速度3500转</td>
<td>需要两块 ，一定是nvme的</td>
</tr>
<tr>
<td style="text-align:center">主板</td>
<td style="text-align:center">华硕z490-p</td>
<td style="text-align:center">支持sgx</td>
<td>华硕z490 可以插入两块nvme硬盘 或者别的主板，，但确保一定支持sgx，需要前往bios设置中查看。主板不得支持11代及以上酷睿cpu.</td>
</tr>
<tr>
<td style="text-align:center">cpu</td>
<td style="text-align:center">cpu intel i9-10900k</td>
<td style="text-align:center">10核，仅支持intel处理器</td>
<td>cpu优先：i9-10900k 备选：i7-10700k或i5-10600K  ，intel酷睿系列：5~10代以内，i9最佳，需确保支持sgx，可前往该网站检测（即检测项包含：Yes with Intel® ME）：<a href="https://ark.intel.com/content/www/cn/zh/ark.html#@PanelLabel122139">https://ark.intel.com/content/www/cn/zh/ark.html#@PanelLabel122139</a></td>
</tr>
<tr>
<td style="text-align:center">系统</td>
<td style="text-align:center">ubuntu 20.04</td>
<td style="text-align:center">ubuntu 20.04命令行版</td>
<td>一定要命令行版，减少资源占用，需要用UEFI模式安装系统，也就是在BIOS中需要先设置为UEFI启动模式</td>
</tr>
</tbody>
</table>
<p><code>说明</code>：这里使用了三块硬盘，两个固态硬盘，一个机械硬盘。这是基于成本和便捷性考虑的。如果资源和成本有限，可以将两块固态硬盘合并为一块1T的硬盘。  也就是说，折中一块固态硬盘和一块机械硬盘。<br>
<code>如果实力雄厚，直接一块4T的固态硬盘，机械硬盘都不用考虑</code></p>
<h2 id="集群模式-单机模式改造">集群模式-单机模式改造</h2>
<p>当管理10台以上主机时，单机模式管理已经无法满足，为此基于上一章节单机模式的不足，这里提供一种简单的思路：<br>
<code>通过改造官方部署脚本，满足：一台主机用来同步数据，剩余多个worker都指向该主机</code></p>
<ol>
<li>优点
<ol>
<li>基于官方脚本改造，后期维护简单</li>
<li>节点和worker分离，worker主机的性能利用会更加充分</li>
<li>官方提供的脚本，部署相对会容易很多</li>
<li>节省成本，节点机不需要强制高性能cpu；worker机不需要大容量磁盘</li>
</ol>
</li>
<li>缺点
<ol>
<li>需要手动改造官方脚本，升级变化大的话，需要做大量改造</li>
<li>一个节点主机下面，最多挂载不能超过10台worker主机</li>
<li>节点和worker之间通信效率低，但worker挂载不超过10台，影响不大</li>
</ol>
</li>
<li>建议
<ol>
<li>一台节点主机下面，为确保网络通信等，建议挂载5-8台worker即可</li>
<li>如果有多个节点，一个节点对应一个质押池，方便管理。</li>
</ol>
</li>
<li>节点主机配置参考（最优，当然还有更好的，但整体来说，以下配置已经足够了）</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>设备名称</strong></th>
<th style="text-align:center"><strong>型号</strong></th>
<th style="text-align:center"><strong>规格</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">内存条</td>
<td style="text-align:center">金士顿ddr4</td>
<td style="text-align:center">32g</td>
<td>两根16g    双通道</td>
</tr>
<tr>
<td style="text-align:center">固态硬盘</td>
<td style="text-align:center">金士顿 x 2块</td>
<td style="text-align:center">nvme 读写速度3500转</td>
<td>基于成本考虑，2块2T的，主板要支持2块nvme插槽</td>
</tr>
<tr>
<td style="text-align:center">cpu</td>
<td style="text-align:center">cpu intel i7-10700k</td>
<td style="text-align:center">8核，建议intel处理器</td>
<td>该机器对处理器没有硬性要求，不需要支持sgx，主流的i7处理器即可</td>
</tr>
<tr>
<td style="text-align:center">系统</td>
<td style="text-align:center">ubuntu 20.04</td>
<td style="text-align:center">ubuntu 20.04命令行版</td>
<td>一定要命令行版，减少资源占用，需要用UEFI模式安装系统，也就是在BIOS中需要先设置为UEFI启动模式</td>
</tr>
</tbody>
</table>
<p><code>说明</code>：固态硬盘可以根据自身情况来选择不同方式，表中给出的是折中后的最优方式。比如，<code>如果资金实力雄厚，直接一块4T的固态硬盘，别的盘都不用考虑</code></p>
<ol start="5">
<li>worker主机配置参考（最优，当然还有更好的，但整体来说，以下配置已经足够了）</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>设备名称</strong></th>
<th style="text-align:center"><strong>型号</strong></th>
<th style="text-align:center"><strong>规格</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">内存条</td>
<td style="text-align:center">金士顿ddr4</td>
<td style="text-align:center">16g 3200频率</td>
<td>两根8g</td>
</tr>
<tr>
<td style="text-align:center">固态硬盘</td>
<td style="text-align:center">金士顿A2000/NV1</td>
<td style="text-align:center">nvme协议 m2-128G固态硬盘（SSD）</td>
<td>系统盘</td>
</tr>
<tr>
<td style="text-align:center">主板</td>
<td style="text-align:center">华硕z490-p</td>
<td style="text-align:center">支持sgx</td>
<td>华硕z490 或者别的主板，但确保一定支持sgx，需要前往bios设置中查看。主板不得支持11代及以上酷睿cpu.</td>
</tr>
<tr>
<td style="text-align:center">cpu</td>
<td style="text-align:center">cpu intel i9-10900k</td>
<td style="text-align:center">10核</td>
<td>仅支持intel处理器</td>
</tr>
<tr>
<td style="text-align:center">系统</td>
<td style="text-align:center">ubuntu 20.04</td>
<td style="text-align:center">ubuntu 20.04命令行版</td>
<td>一定要命令行版，减少资源占用，需要用UEFI模式安装系统，也就是在BIOS中需要先设置为UEFI启动模式</td>
</tr>
</tbody>
</table>
<p><code>说明</code>：<br>
内存：如果要控制成本，内存条可以降到8G<br>
cpu优先：i9-10900k 备选：i7-10700k或i5-10600K  ，intel酷睿系列：5~10代以内，i9最佳，需确保支持sgx，可前往该网站检测（即检测项包含：Yes with Intel® ME）：<a href="https://ark.intel.com/content/www/cn/zh/ark.html#@PanelLabel122139">https://ark.intel.com/content/www/cn/zh/ark.html#@PanelLabel122139</a></p>
<h2 id="集群模式-官方prb">集群模式-官方prb</h2>
<p>使用官方单机脚本改造集群的方式，对应的缺点，上面已经提到。其中最大的问题是，规模化worker(百台)接入节点，为了解决这些问题，官方提供了一个<a href="https://wiki.phala.network/en-us/mine/prb2/2.0-release-note/">Runtime Bridge v2技术</a>，用它取代了单机的pherry和pRuntime的两个独立服务。</p>
<ol>
<li>优点
<ol>
<li>官方提供，有保障</li>
<li>支持大规模化部署，单个节点机器，可以接入200台worker</li>
<li>各服务通信稳定</li>
</ol>
</li>
<li>缺点
<ol>
<li>维护复杂度高，</li>
<li>部署比起单机模式，复杂度也增大了很多，如果不是大规模部署，基于成本考虑，不建议使用该方式集群化部署</li>
</ol>
</li>
<li>设备配置
<ol>
<li>直接参考前面的<code>集群模式-单机模式改造</code>设备配置方式即可</li>
</ol>
</li>
</ol>
<h2 id="总结">总结</h2>
<p>本文编辑已完毕</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Phala</category>
        <category>应用</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Phala</tag>
      </tags>
  </entry>
  <entry>
    <title>Phala质押及奖罚规则和操作</title>
    <url>/articles/cd595645/</url>
    <content><![CDATA[<p>本文主要介绍质押和获取收益的相关操作，属于Phala的应用层业务</p>
<span id="more"></span>  
<h2 id="1-收益规则">1. 收益规则</h2>
<p>节点正常运行后，先对规则做一定的了解，然后再考虑如何操作<br>
分为APR指标计算、质押池所有者收益估算、质押人收益估算<br>
<code>备注</code>：<br>
worker定期开采代币，至少每两天一次，也就是每两天能收到一次奖励，pos机制，随缘<br>
挖出的token优先分配给质押池账户，剩余的按上述规则分配给质押人<br>
一个质押池中，可以绑定多个worker；一个质押池只有一个拥有者</p>
<h3 id="1-1-apr指标">1.1 APR指标</h3>
<p>这个<code>APR</code>是用来表示一个质押池实力的指标，公式如下：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>P</mi><mi>R</mi><mo>=</mo><mfrac><mrow><mi>P</mi><mi>o</mi><mi>o</mi><mi>l</mi><mi>R</mi><mi>e</mi><mi>w</mi><mi>a</mi><mi>r</mi><mi>d</mi><mi>P</mi><mi>e</mi><mi>r</mi><mi>H</mi><mi>o</mi><mi>u</mi><mi>r</mi><mo>×</mo><mn>24</mn><mo>×</mo><mn>365</mn><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>T</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>s</mi><mi>u</mi><mi>r</mi><mi>y</mi><mi>R</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>C</mi><mi>o</mi><mi>m</mi><mi>m</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><mrow><mi>D</mi><mi>e</mi><mi>l</mi><mi>e</mi><mi>g</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">APR = \frac{ PoolRewardPerHour \times 24 \times 365 \times ( 1 - TreasuryRatio ) \times ( 1 - Commission ) }{ Delegated }
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.30744em;vertical-align:-0.8804400000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">3</span><span class="mord">6</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>其中：</p>
<ol>
<li><code>PoolRewardPerHour</code>：是根据质押池状态对下一小时开采的token数量的理论估计;</li>
<li><code>TreasuryRatio</code>: 翻译过来是财政部，这个值是固定的<code>20%</code>，也就是说，挖出来的token中，要按这个比例需要交给Treasury，可以理解成是链上治理的一种税收</li>
<li><code>Commission</code>：就是创建质押池输入的那个比例，质押池账户要分配到的收益比例</li>
<li><code>Delegated</code>：质押池中总共质押的token</li>
</ol>
<h3 id="1-2-质押池所有者收益估算">1.2 质押池所有者收益估算</h3>
<p><code>OwnerReward</code>，就是创建质押池的账户能获取到的收益，公式如下：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mi>w</mi><mi>n</mi><mi>e</mi><mi>r</mi><mi>R</mi><mi>e</mi><mi>w</mi><mi>a</mi><mi>r</mi><mi>d</mi><mo>=</mo><mi>P</mi><mi>o</mi><mi>o</mi><mi>l</mi><mi>M</mi><mi>i</mi><mi>n</mi><mi>e</mi><mi>d</mi><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>T</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>s</mi><mi>u</mi><mi>r</mi><mi>y</mi><mi>R</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mo stretchy="false">)</mo><mo>×</mo><mi>C</mi><mi>o</mi><mi>m</mi><mi>m</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">OwnerReward = PoolMined \times ( 1 - TreasuryRatio ) \times Commission
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span></span></p>
<p>其中：</p>
<ol>
<li><code>PoolMined</code>：本次总共挖取到的token</li>
<li><code>TreasuryRatio</code>: 翻译过来是财政部，这个值是固定的<code>20%</code>，也就是说，挖出来的token中，要按这个比例需要交给Treasury，可以理解成是链上治理的一种税收</li>
<li><code>Commission</code>：就是创建质押池输入的那个比例，质押池账户要分配到的收益比例</li>
</ol>
<h3 id="1-3-质押池所有者收益估算">1.3 质押池所有者收益估算</h3>
<p><code>DelegatorReward</code>，就是该质押人在当前质押池中的账户能获取到的收益，公式如下：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>e</mi><mi>l</mi><mi>e</mi><mi>g</mi><mi>a</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>R</mi><mi>e</mi><mi>w</mi><mi>a</mi><mi>r</mi><mi>d</mi><mo>=</mo><mi>P</mi><mi>o</mi><mi>o</mi><mi>l</mi><mi>M</mi><mi>i</mi><mi>n</mi><mi>e</mi><mi>d</mi><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>T</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>s</mi><mi>u</mi><mi>r</mi><mi>y</mi><mi>R</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>C</mi><mi>o</mi><mi>m</mi><mi>m</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">)</mo><mo>×</mo><mfrac><mrow><mi>U</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>D</mi><mi>e</mi><mi>l</mi><mi>e</mi><mi>g</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow><mrow><mi>D</mi><mi>e</mi><mi>l</mi><mi>e</mi><mi>g</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">DelegatorReward = PoolMined \times ( 1 - TreasuryRatio ) \times ( 1 - Commission ) \times \frac{ UserDelegated }{ Delegated }
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.25188em;vertical-align:-0.8804400000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>其中：</p>
<ol>
<li><code>PoolMined</code>：本次总共挖取到的token</li>
<li><code>TreasuryRatio</code>: 翻译过来是财政部，这个值是固定的<code>20%</code>，也就是说，挖出来的token中，要按这个比例需要交给Treasury，可以理解成是链上治理的一种税收</li>
<li><code>Commission</code>：就是创建质押池输入的那个比例，质押池账户要分配到的收益比例</li>
<li><code>UserDelegated</code>：就是该质押人在当前质押池中总共质押的token数量</li>
<li><code>Delegated</code>：质押池中总共质押的token</li>
</ol>
<h2 id="2-收益提取规则">2. 收益提取规则</h2>
<ol>
<li>每个矿工挖矿会锁定质押池中的token</li>
<li>如果质押池中的可用token（无锁定部分）大于质押人要提取的数量，则可以额立即到账</li>
<li>如果质押池中的可用token（无锁定部分）小于质押人要提取的数量，则可用部分的token立即到账给质押人，剩余部分进入待提取队列，等待满足以下要求后，才会到账：
<ol>
<li>有新的token加入质押池，根据加入的数量和待提取的数量，立即释放给要提取的质押人</li>
<li>7天内，质押池拥有人可以停止某些矿工，停止后，释放在质押池到的可用token如果满足质押人提取数额，则7天后，可到账至质押人账户</li>
<li>7天内，质押池拥有人可以停止某些矿工，停止7天后，释放在质押池到的可用token如果仍然不满足质押人提取数额，则所有矿工将被迫全部停止，再等7天后，质押人账户到账提取数额。</li>
<li><code>疑问,待确认</code>：14天后，是质押池都所有质押币都原路返回给了各个质押人？</li>
</ol>
</li>
</ol>
<h2 id="3-操作">3. 操作</h2>
<p>操作还是看文档吧，有了入门基础，看文档也容易，实在写不动了<br>
<a href="https://wiki.phala.network/en-us/general/applications/phala-app/">质押及奖励获取</a><br>
<a href="https://wiki.phala.network/en-us/general/applications/reward-calculation/">估算你的收益</a></p>
<h2 id="总结">总结</h2>
<p>本文编辑中</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Phala</category>
        <category>应用</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Phala</tag>
      </tags>
  </entry>
  <entry>
    <title>Phala常用命令</title>
    <url>/articles/942171b7/</url>
    <content><![CDATA[<p>这里主要汇总一些phala常用的脚本命令以及rpc命令</p>
<span id="more"></span>  
<h2 id="脚本命令">脚本命令</h2>
<p>主体命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">数据同步，这条命令貌似有问题，可以跳过不执行它，直接执行下一条start命令</span></span><br><span class="line">sudo phala presync</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">该命令会安装docker 、同步数据、启动节点运行等(俗称挖矿)，后台执行</span></span><br><span class="line">sudo phala start</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">期间可以通过docker执行查看各个docker服务等日志，docker命令这里就不讲解了，网上很多</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看phala链、同步信息</span></span><br><span class="line">sudo phala status</span><br></pre></td></tr></table></figure>
<p>参考命令：</p>
<ol>
<li>挖矿</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动挖矿程序</span></span><br><span class="line">sudo phala start node</span><br><span class="line">sudo phala start pruntime</span><br><span class="line">sudo phala start pherry</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">start命令跟上debug可输出程序部署日志</span></span><br><span class="line">sudo phala start node debug</span><br><span class="line">sudo phala start pruntime debug</span><br><span class="line">sudo phala start pherry debug</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止挖矿程序</span></span><br><span class="line">sudo phala stop node</span><br><span class="line">sudo phala stop pruntime</span><br><span class="line">sudo phala stop pherry</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>更新</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">仅更新</span></span><br><span class="line">sudo phala update</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删库并更新</span></span><br><span class="line">sudo phala update clean</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自动更新脚本</span></span><br><span class="line">sudo phala update script</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查三件套状态</span></span><br><span class="line">sudo phala status</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出各容器的日志</span></span><br><span class="line">sudo phala logs node</span><br><span class="line">sudo phala logs pruntime</span><br><span class="line">sudo phala logs pherry</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>检查挖矿程序的配置信息</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看配置文件</span></span><br><span class="line">sudo phala config show</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置节点</span></span><br><span class="line">sudo phala config set</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行自我诊断程序</span></span><br><span class="line">sudo phala install</span><br><span class="line">sudo phala sgx-test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取主板得分</span></span><br><span class="line">sudo phala score_test [需要使用的核心数量]</span><br></pre></td></tr></table></figure>
<h2 id="rpc命令">RPC命令</h2>
<p>注意，以下命令中：<code>9933 端口获取到的结果是 khala 链节点的状态，使用 9934 端口获取到的结果是kusama 链节点的状态</code></p>
<h3 id="1-区块节点数据服务phala-node的rpc命令">1. 区块节点数据服务phala-node的RPC命令</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询节点健康状态</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回结果：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">peers 代表节点的对等点的数量，上限为 50，如果为 0 请检查网络是否畅通或者端口是否开放。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isSyncing 代表节点是否在同步中的状态，如果 peers 不为 0 的状态下，为 <span class="literal">false</span> 并不是没在同步，而是代表同步完成。</span></span><br><span class="line">curl -sH &quot;Content-Type: application/json&quot; -d &#x27;&#123;&quot;id&quot;:1, &quot;jsonrpc&quot;:&quot;2.0&quot;, &quot;method&quot;: &quot;system_health&quot;, &quot;params&quot;:[]&#125;&#x27; http://localhost:9933 | jq &#x27;.result&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询节点的版本号</span></span><br><span class="line">curl -sH &quot;Content-Type: application/json&quot; -d &#x27;&#123;&quot;id&quot;:1, &quot;jsonrpc&quot;:&quot;2.0&quot;, &quot;method&quot;: &quot;system_version&quot;, &quot;params&quot;:[]&#125;&#x27; http://localhost:9933 | jq &#x27;.result&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询节点的区块高度</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">currentBlock 代表节点已同步到的当前高度，同步完成后，正常状态下该值与最高高度应该差距在 2 以内。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">highestBlock 代表节点所获取到的链最高高度，同步完成后，正常状态下该值与当前高度应该差距在 2 以内。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">startingBlock 代表节点本次启动的区块高度，重启节点会更新该值到节点最新高度。</span></span><br><span class="line">curl -sH &quot;Content-Type: application/json&quot; -d &#x27;&#123;&quot;id&quot;:1, &quot;jsonrpc&quot;:&quot;2.0&quot;, &quot;method&quot;: &quot;system_syncState&quot;, &quot;params&quot;:[]&#125;&#x27; http://localhost:9933 | jq &#x27;.result&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="2-挖矿服务phala-pruntime的rpc命令">2. 挖矿服务phala-pruntime的RPC命令</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pruntime 运行状况</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回结果：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">blocknum 为 pruntime 目前同步到的 khala 链高度</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">headernum 为 pruntime 目前同步到的 kusama 链高度</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">para_headernum 为 pruntime 目前正在同步 khala 链的目标高度，同步过程中该值会比 blocknum 高几百。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">public_key 为本机器的公钥，用来给链上添加进矿池使用，该公钥必须在同步完成后才能链上添加矿机，否则链上操作会失败。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">registered 为机器是否已在链上注册的布尔值，为 <span class="literal">true</span> 代表可以进行链上添加操作</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">score 为机器的本地评分，会与链上评分有一定差距，并且链上评分的更新会需要几个小时左右。刚注册完成的矿机能添加进矿池，但无法进行挖矿的原因大部分是因为链上评分尚未更新</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">version 为 pruntime 的版本号，更新 pruntime 持久化功能前的最后一个版本为 0.1.3。截至 2022/2/23 的最新版本为 0.2.0，有持久化功能</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -X POST -sH <span class="string">&quot;Content-Type: application/json&quot;</span> -d <span class="string">&#x27;&#123;&quot;input&quot;: &#123;&#125;, &quot;nonce&quot;: &#123;&#125;&#125;&#x27;</span> http://localhost:8000/get_info | jq <span class="string">&#x27;.payload|fromjson&#x27;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>/home/fil/phala/data/chains:/root/data/chains</p>
</li>
<li>
<p>/data/phala/data/polkadot:/root/data/polkadot</p>
</li>
<li>
<p>/home/fil/phala/data/khala-pruntime-data:/root/data<br>
chattr -i</p>
</li>
</ul>
<h2 id="总结">总结</h2>
<p>后续若有新的命令，将会逐步加入</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Phala</category>
        <category>应用</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Phala</tag>
      </tags>
  </entry>
  <entry>
    <title>Phala单机部署(2)-配置、启动、更新节点</title>
    <url>/articles/e0e01ad6/</url>
    <content><![CDATA[<p>环境部署好后，接着就该准备账户、启动节点了</p>
<span id="more"></span>  
<h2 id="期间涉及网站汇总">期间涉及网站汇总</h2>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>序号</strong></th>
<th style="text-align:center"><strong>地址</strong></th>
<th style="text-align:center"><strong>介绍</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"><a href="https://bitcube.pro/">https://bitcube.pro/</a></td>
<td style="text-align:center">可app端管理pha代币，目前只有android版</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"><a href="https://polkadot.js.org/extension/">https://polkadot.js.org/extension/</a></td>
<td style="text-align:center">chrome/edge浏览器钱包插件（需安装）</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"><a href="https://app.phala.network/">https://app.phala.network/</a></td>
<td style="text-align:center">phala钱包操作、抵押等所有行为均离不开它</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center"><a href="https://phala.one/stake/">https://phala.one/stake/</a></td>
<td style="text-align:center">用于便捷计算质押值</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center"><a href="https://wiki.phala.network/">https://wiki.phala.network/</a></td>
<td style="text-align:center">phala 官方开发者文档</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center"><a href="https://forum.phala.network/c/cn-simplified/9">https://forum.phala.network/c/cn-simplified/9</a></td>
<td style="text-align:center">phala中文论坛</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center"><a href="https://github.com/wowvwow/Phala-Network">https://github.com/wowvwow/Phala-Network</a></td>
<td style="text-align:center">phala节点源码</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center"><a href="https://github.com/zozyo/phala-guide">https://github.com/zozyo/phala-guide</a></td>
<td style="text-align:center">第三方提供的部署phala的工具和方案</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center"><a href="https://khala.subscan.io/">https://khala.subscan.io/</a></td>
<td style="text-align:center">khala区块链浏览器</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center"><a href="https://kusama.subscan.io/">https://kusama.subscan.io/</a></td>
<td style="text-align:center">kusama的区块链浏览器                  ｜</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center"><a href="https://kusama.subscan.io/parachain/2004">https://kusama.subscan.io/parachain/2004</a></td>
<td style="text-align:center">khala在kusama的平行链简介             ｜</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center"><a href="https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkhala.api.onfinality.io%2Fpublic-ws#/explorer">https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkhala.api.onfinality.io%2Fpublic-ws#/explorer</a></td>
<td style="text-align:center">khala在polkadot中的区块链浏览器</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center"><a href="https://github.com/wowvwow/Phala-Network">https://github.com/wowvwow/Phala-Network</a></td>
<td style="text-align:center">第三方提供的便捷部署脚本和解决方案</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center"><a href="https://github.com/zozyo/phala-guide">https://github.com/zozyo/phala-guide</a></td>
<td style="text-align:center">第三方提供的矿工指导教程</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center"><a href="https://github.com/suugee/phala-prb">https://github.com/suugee/phala-prb</a></td>
<td style="text-align:center">集群部署包括prb</td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center"><a href="https://github.com/Phala-Network/solo-mining-scripts">https://github.com/Phala-Network/solo-mining-scripts</a></td>
<td style="text-align:center">solo模式部署</td>
</tr>
</tbody>
</table>
<p>以上网站中，至少需要预先安装好<code>第2项</code>中指定第插件，该插件的使用方式，请自行去网上查找，记得在插件中将账户地址格式显示成Phala网络的。<br>
该插件可以用来创建phala钱包账户。</p>
<h2 id="账户管理">账户管理</h2>
<p>正常情况下，我们需要准备4个账户地址，分别为：</p>
<ol>
<li>gas账户，用于节点运行期间矿工燃烧使用，里面余额需大于0，建议在10个左右，以防矿工烧的gas不够用了出问题。</li>
<li>质押池账户，顾名思义，质押专用，初始时，一个左右，够操作的时候交gas就行。这个账户也是用来创建和管理矿工的。</li>
<li>个人账户，自行管理pha余额使用，根据需要给不同账户充币</li>
<li>质押人账户，这是个可选账户，当你池子建好后，这些外部的质押账户就可以将币质押给你的池子。上面提到的<code>质押池账户</code>也可以用作质押人账户。</li>
</ol>
<p>虽然说可以公用一个账户，但处于安全考虑，最好划分成这三个账号来各司其职。<br>
另外，保管好这三个账户的私钥、助记词等，毕竟这是你的私有财产。</p>
<h2 id="phala配置">Phala配置</h2>
<p>节点是在docker中运行的，因此，期间有一些配置需要我们结合实际来变更。</p>
<h3 id="变更节点数据存储位置">变更节点数据存储位置</h3>
<p>节点数据我们一般都会存到大容量磁盘目录下，但默认情况下，phala会将同步的节点数据保存到：<code>/var/data</code>目录，这个目录不一定符合需要，因此，可以通过如下操作来变更：<br>
前往：<code>/opt/phala/.env</code>文件，将<code>NODE_VOLUMES</code>和<code>PRUNTIME_VOLUMES</code>的主机目录(冒号左方)变为你需要指向的目录。</p>
<p><code>20220406备注：</code><br>
如果<code>khala</code>和<code>kusama</code>数据要分别存到固态硬盘和机械硬盘的话，需要手动到<code>docker-compose.yml</code>中手动映射目录：<code>chains</code>和<code>polkadot</code>，当前官方脚本暂不支持<code>.env</code>，从反馈看，后续会支持的，静待。<br>
强烈建议<code>khala</code>数据放到固态硬盘下，否则后面校验数据速度会抓狂，我这里速度相差了十几倍</p>
<h3 id="节点信息配置">节点信息配置</h3>
<p>有专门的命令来引导配置，这里需要强调的是，引导的配置，其实都是在<code>/opt/phala/.env</code>文件中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置账户信息</span></span><br><span class="line">sudo phala config set</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">按照引导完成配置，其中，gas账户余额必须大于0。这些配置都很简单，也很明确，这里就不阐述了</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看配置信息</span></span><br><span class="line">sudo phala config show</span><br></pre></td></tr></table></figure>
<h2 id="启动节点">启动节点</h2>
<p>执行以下命令后，会启动三个docker服务：<code>挖矿程序phala-pruntime</code>、<code>中转组件phala-pherry</code>、<code>区块节点数据phala-node</code>，本小结后面专门介绍这三个服务的概念<br>
三者之间的关系如下图：</p>
<img src="/articles/e0e01ad6/2.png" class="" title="三者服务关系图">
<h3 id="1-启动命令">1. 启动命令</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">数据同步，这条命令貌似有问题，可以跳过不执行它，直接执行下一条start命令</span></span><br><span class="line">sudo phala presync</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">该命令会安装docker 、同步数据、启动节点运行等(俗称挖矿)，后台执行</span></span><br><span class="line">sudo phala start</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查三个docker服务是否都在UP状态，若有异常，则排查原因</span></span><br><span class="line">sudo docker ps -a</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">期间可以通过docker执行查看各个docker服务等日志，docker命令这里就不讲解了，网上很多</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看phala链、同步信息，每分钟刷新一次</span></span><br><span class="line">sudo phala status</span><br></pre></td></tr></table></figure>
<p>启动后，会先同步khala和kusama数据，这两个同步完成后，才开始同步，pherry。同步完成后，开始注册矿机，并显示一个矿机的公钥地址，这个地址用来后续给抵押池中使用。</p>
<h3 id="2-区块节点数据服务phala-node">2. 区块节点数据服务phala-node</h3>
<p>该服务只是用来同步节点数据的，不使用SGX<br>
节点数据保存地点为<code>[指定的主机目录]/khala-dev-node</code>，其中 khala 链数据保存在<code>chains</code>子文件夹下，kusama 链数据保存在<code>polkadot</code>子文件夹下<br>
数据同步会占用部分CPU，如果有条件，可以单独一台性能良好的主机部署该服务（不需要SGX）</p>
<h3 id="3-中转服务phala-pherry">3. 中转服务phala-pherry</h3>
<p>该服务只是用来中转数据的，不使用SGX<br>
中转组件是一个无状态的转换机，只起到传话筒的作用。重启中转组件只会导致很短暂的 pruntime 的暂停同步。<br>
有时官方可能会有链上升级，会有通知重启中转组件，建议保持关注官方的技术交流群，以免造成损失。<br>
<code>pherry服务</code>会占用部分CPU，如果有条件，可以单独一台性能良好的主机部署该服务（不需要SGX）</p>
<h3 id="4-挖矿服务phala-pruntime">4. 挖矿服务phala-pruntime</h3>
<p>pruntime（挖矿程序）作为最关键的组件，必须在支持 SGX 的设备上运行，并且 phala config set 命令里面唯一对其生效的参数只有核心数量。<br>
运行 pruntime 并且链上开始挖矿时，会有 ./app 的程序占用 100% 的 CPU，这是正常情况。<br>
PHA 挖矿需要满负载 CPU， 建议设备使用较好的散热器以获得高评分。</p>
<h2 id="节点更新">节点更新</h2>
<p>当需要更新节点时，执行如下操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">务必先停止服务</span></span><br><span class="line">sudo phala stop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新节点</span></span><br><span class="line">sudo phala update</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者更新并清除原有保存的所有信息，谨慎操作该命令</span></span><br><span class="line">sudo phala update clean</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新启动服务</span></span><br><span class="line">sudo phala start</span><br></pre></td></tr></table></figure>
<h2 id="phala-app操作">phala app操作</h2>
<p>前往地址：<a href="https://app.phala.network/">https://app.phala.network/</a></p>
<h2 id="抵押机制">抵押机制</h2>
<p>官方针对抵押机制，有个简洁版的说明：<br>
<a href="https://wiki.phala.network/en-us/general/applications/stakepool/">质押机制</a><br>
<a href="https://wiki.phala.network/en-us/general/applications/delegation-example/">质押示例</a></p>
<p>英文版的，这里我做个简单说明。</p>
<h3 id="创建抵押池">创建抵押池</h3>
<p>该步骤需要使用抵押账户来创建，抵押账户余额至少需要够交手续费，手续费很少：</p>
<img src="/articles/e0e01ad6/1.png" class="" title="创建抵押池">
<h3 id="设置抵押上限和佣金率">设置抵押上限和佣金率</h3>
<p>如下图：<br>
Set Commission 抵押池费率：0-100，100表示所有收益均归抵押池所有，0表示所有收益均亏质押人所有。一般要吸引人的话，设置个50左右<br>
Set Cap 抵押上限，默认无上限，设置一个上限，主要的目的是可以防止外人任意抵押。<br>
上限这个值可以根据矿工最小质押只和来考虑，最起码要大于矿工要求的最小质押（这个等后面步骤添加了矿工后，会有一个最小和最大质押额度，这个最大质押额度是针对矿工的），总之，这个质押池的上限要大于最终所有矿工质押的数量。具体参考依据可以看下面<code>挖矿前各个账户余额准备以及质押池质押余额准备</code>中介绍的</p>
<img src="/articles/e0e01ad6/3.png" class="" title="创建抵押池">
<h3 id="添加worker">添加Worker</h3>
<p>看上图<br>
<code>Add Worker</code>：将worker和抵押池绑定。这个worker是输入节点同步结束后，注册成功的那个系统给的矿工公钥地址。<br>
这里也可以看出：</p>
<ol>
<li>要先等节点数据同步完毕</li>
<li>一个质押池可以绑定多个worker</li>
<li>只有质押池创建者才能添加worker</li>
</ol>
<img src="/articles/e0e01ad6/3.png" class="" title="质押池操作">
<img src="/articles/e0e01ad6/4.png" class="" title="矿工公钥">
<h3 id="挖矿前各个账户余额准备以及质押池质押余额准备">挖矿前各个账户余额准备以及质押池质押余额准备</h3>
<ol>
<li>下方矿工启动前，页面会提示至少质押数额（如下图）；另外根据下面公式，可以估算出最少要质押的数量：</li>
</ol>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Limit controls must follow a math operator at position 2: S\̲n̲o̲l̲i̲m̲i̲t̲s̲_min = k \sqrt{…'>S\nolimits_min = k \sqrt{P}
</p>
<p>其中，<br>
<code>P</code>为<code>矿工评分</code>，这个就是节点同步完，矿工注册后，显示的那个p评分，如上图所示；<br>
<code>k</code>为系数，目前官方舍弟khala和phala网络均为<code>50</code></p>
<img src="/articles/e0e01ad6/5.png" class="" title="页面估算质押数量">
<ol start="2">
<li>根据计算出的质押数量，估算该质押池质押上限（或者根据业务需要选择是否设置上限），并设置</li>
<li>通过质押页面，找到pid，将token(数额要大于上面计算的最少质押数量)质押到指定的质押池，具体质押多少，根据业务决定。质押操作如下图</li>
</ol>
<img src="/articles/e0e01ad6/6.png" class="" title="找到质押池并质押">
<h3 id="开始挖矿">开始挖矿</h3>
<p>点击开始挖矿，会显示启动该矿工需要的最少质押和最大质押，根据前面质押池已经质押的数量，输入一个最少和最大之间的数（这个数不能大于你质押池的数，当然越大挖矿效率越高），然后就能启动矿工挖矿了，这里需要注意的是，此处启动需要输入的数，只是将质押池的对应数量的token锁定给矿工，并不是要从你账户里再扣除这个数。</p>
<p>以上步骤操作完成后，点击开始挖矿，当挖到收益后，就会按比例将收益划分给指定用户(抵押人账户和抵押池账户)<br>
目前看，20秒左右可以出一个块（快的时候12秒左右就能出块）；但貌似要两天左右才能轮到挖出一次</p>
<h3 id="质押及奖励获取">质押及奖励获取</h3>
<p>这里需要知道：挖出来的20%是要给<code>Treasury</code>，也就是国库，相当于是税收<br>
官方这里讲解的很详细，直接看吧：<br>
<a href="https://wiki.phala.network/en-us/general/applications/phala-app/">质押及奖励获取</a><br>
<a href="https://wiki.phala.network/en-us/general/applications/reward-calculation/">估算你的收益</a><br>
后面我也会结合官方的操作来写出自己的操作方式和心得</p>
<h2 id="总结">总结</h2>
<p>至此，该篇结束，单机从部署到产生收益整个流程已经可以走通。</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Phala</category>
        <category>应用</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Phala</tag>
      </tags>
  </entry>
  <entry>
    <title>Phala单机部署(1)-设备和系统准备</title>
    <url>/articles/97c9f4fc/</url>
    <content><![CDATA[<p>波卡生态本来就很绕人，刚接触Phala也很难了解如何下手，本文作为开篇，从部署开始，逐步引导深入了解Phala<br>
Phala预备主网搭建的基本步骤，结合了官网wiki和个人总结。<br>
本系列只考虑单机部署Phala节点</p>
<span id="more"></span>  
<h2 id="设备准备">设备准备</h2>
<p>Phala对设备比较挑剔，务必先完成该步骤，再考虑后续操作，少走弯路。<br>
这里有官方给出的最低配置：<a href="https://wiki.phala.network/en-us/mine/khala-mining/1-0-hardware-requirements/">设备配置</a><br>
别的内存硬盘就不阐述了，可以参考这个主播给出的配置<a href="https://www.iqiyi.com/v_x1c5ien504.html">视频</a>，其中最关键的两个必要条件一定要满足：</p>
<ol>
<li><code>intel处理器</code>且<code>必须支持sgx</code>  （sgx是干什么用的，现在没必要了解，后面节点跑起来，该知道的时候自然就知道了）</li>
<li>bios也就是主板，必须支持sgx配置</li>
<li>内存16g以上</li>
<li>硬盘有这几种搭配方式：
<ol>
<li>128g固态硬盘安装系统+4T机械硬盘用来存储节点运行的数据
<ol>
<li>缺点，khala校验到第45万块之后，因为块变大，机械硬盘上速度会非常慢</li>
</ol>
</li>
<li>128g固态硬盘安装系统+2T固态硬盘装khala节点数据+4T机械硬盘装kusama数据
<ol>
<li>这种方案，khala数据会放在固态硬盘上，效率会更高，因为后续khala数据会频繁读写</li>
<li>强烈推荐该方案</li>
</ol>
</li>
<li>注：以上固态硬盘，优先选择<code>NVMe协议</code>的，效率会高很多</li>
</ol>
</li>
<li>系统为ubuntu 20.04，不想踩坑，就老老实实用这个版本</li>
</ol>
<h3 id="检测intel处理器是否支持sgx">检测intel处理器是否支持sgx</h3>
<ol>
<li>先说明，让搭建减少搜索范围：家用处理器，仅酷睿5-10代支持sgx；服务器志强E系列，新版均支持，E5 E7系列均不支持</li>
<li>前往<a href="https://ark.intel.com/content/www/cn/zh/ark.html#@Processors">intel官网</a>,找到自己的cpu型号</li>
<li>CPU详情页面，有如下图红色区域内容即表示cpu支持sgx，内容：<code>英特尔® Software Guard Extensions Yes with Intel® ME</code></li>
</ol>
<img src="/articles/97c9f4fc/1.png" class="" title="检测intel cpu是否支持sgx">
<h3 id="检测主板是否支持sgx">检测主板是否支持sgx</h3>
<ol>
<li>为减少搜索范围，这里先给大家参考：家用主板，凡事支持11代以上cpu(包括11代)的主板，均不支持sgx，可参考华硕或技嘉z490-h</li>
<li>在bios中，安全模块下查找，是否有开启sgx的功能，主板正常默认都是关闭的，</li>
<li>问客服</li>
</ol>
<h2 id="bios设置">BIOS设置</h2>
<p>以下两点一定要设置：</p>
<ol>
<li>开启SGX支持，一般在boot的高级选项里，优先选 Enabled，如果没有则选 Software Controlled</li>
<li>将<code>Secure Boot</code>关闭，一般都叫这个名字，设置为disable</li>
<li>Boot Mode (启动模式) 里 启动 UEFI</li>
</ol>
<h2 id="系统初始化">系统初始化</h2>
<p>系统安装完毕后，建议使用第三方提供的脚本优化系统，提高系统效率<br>
脚本地址：<a href="https://github.com/wowvwow/Phala-Network/tree/main/scripts/init">系统优化脚本</a><br>
初始化完成后，建议提前安装好<code>docker环境</code>，包括<code>docker-compose</code></p>
<h2 id="检测设备并检测安全等级">检测设备并检测安全等级</h2>
<p>对应官方文档<a href="https://wiki.phala.network/en-us/mine/solo/1-1-installing-phala-mining-tools/">脚本安装</a><br>
对应官方文档<a href="https://wiki.phala.network/en-us/mine/solo/1-2-confidential-level-evaluation/">信任等级检测</a><br>
该过程其实已经进入phala的具体部署过程了，但是，这一步骤其实也是对设备是否支持的进一步确认，因此，我将该过程放在这里：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新源</span></span><br><span class="line">sudo apt update</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装zip解压工具</span></span><br><span class="line">sudo apt install wget unzip</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载用于检测对源文件</span></span><br><span class="line">wget https://github.com/Phala-Network/solo-mining-scripts/archive/refs/heads/main.zip</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压源文件</span></span><br><span class="line">unzip main.zip</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启sgx，同时也可以从软件层面检测该设备是否支持sgx</span></span><br><span class="line">cd ./solo-mining-scripts-main/tools</span><br><span class="line">sudo chmod +x sgx_enable</span><br><span class="line">sudo ./sgx_enable</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果提示重启，则执行该命令重启设备</span></span><br><span class="line">sudo reboot</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同样目录下安装phala工具  en表示英文说明指令，cn表示中文</span></span><br><span class="line">cd ./solo-mining-scripts-main</span><br><span class="line">chmod +x ./phala.sh</span><br><span class="line">sudo ./phala.sh install</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检测安全等级，期间，如果提示驱动不存在等问题，则优先检查BIOS中的`Secure Boot`是否关闭</span></span><br><span class="line">sudo phala sgx-test</span><br></pre></td></tr></table></figure>
<p>以上检查结束后，界面会反馈一个安全等级。简单来说，1、2、3级被认为是最佳安全级别；4、5级认为安全性较低。等级越高、执行的任务也就越高。获得的收益也就越大。如下参考：<br>
<a href="https://zhuanlan.zhihu.com/p/385473461">等级解释</a></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1级：最高等级也是最安全的。可以运行最高安全性的隐私计算任务</span><br><span class="line">2级：具备和1级相同的安全性，也可以运行等级最高的安全性的隐私计算任务</span><br><span class="line">3级：可以运行最高安全性的隐私计算任务</span><br><span class="line">2级和3级：必须使用Inter提供的最新版本的SGX SDK以及PSW等才可以运行最高的任务</span><br><span class="line">4级和5级：不可执行最高等级任务</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>至此，系统初始化完毕</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Phala</category>
        <category>应用</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>Phala</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊常用命令和操作</title>
    <url>/articles/9cf12955/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>以太坊中，常用的一些命令和操作</p>
<span id="more"></span>
<h2 id="一-geth启动命令">一、geth启动命令</h2>
<h3 id="1-连接命令">1.连接命令</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">部署以太坊节点ropsten，同步数据 snap</span></span><br><span class="line">nohup ./geth --ropsten --datadir ./ropsten_data/ --syncmode snap --cache=1024 --http --http.api &quot;eth,net,web3,personal,admin&quot; --http.addr 0.0.0.0 --http.corsdomain &#x27;*&#x27;  --maxpeers 32 --allow-insecure-unlock &gt;&gt; ropsten-log.out &amp;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">geth客户端连接</span></span><br><span class="line">./geth attach http://localhost:8545</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">部署以太坊节点rinkeby，同步数据 snap</span></span><br><span class="line">nohup ./geth --rinkeby --datadir ./rinkeby_data/ --syncmode snap --cache=1024 --port 40303 --http --http.api &quot;eth,net,web3,personal,admin&quot; --http.addr 0.0.0.0 --http.port 9545 --http.corsdomain &#x27;*&#x27;  --maxpeers 32 --allow-insecure-unlock &gt;&gt; rinkeby-log.out &amp;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">geth客户端连接</span></span><br><span class="line">./geth attach http://localhost:9545</span><br></pre></td></tr></table></figure>
<h2 id="二-geth环境启动后命令">二、geth环境启动后命令</h2>
<h3 id="1-eth命令">1. eth命令</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看数据同步状态</span></span><br><span class="line">eth.syncing</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看账户余额</span></span><br><span class="line">eth.getBalance(&quot;0xc99d160ad804Ee5B7ac9552bEF3B25f53E659d79&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="2-net命令">2. net命令</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是否在监听节点</span></span><br><span class="line">net.listening</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">连接的节点数</span></span><br><span class="line">net.peerCount</span><br></pre></td></tr></table></figure>
<h3 id="3-admin命令">3. admin命令</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看节点</span></span><br><span class="line">admin.peers</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看自身节点信息</span></span><br><span class="line">admin.nodeInfo</span><br></pre></td></tr></table></figure>
<h3 id="4-web3命令">4. web3命令</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看账户余额</span></span><br><span class="line">web3.fromWei(eth.getBalance(&quot;0xc99d160ad804Ee5B7ac9552bEF3B25f53E659d79&quot;), &quot;ether&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="clef命令">clef命令</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化硬件钱包</span></span><br><span class="line">./clef --configdir ./conf/clef/ init</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建账号 0xcDa104CB9412e6cdd1a2b576e115E0a8e27Cd5F0</span></span><br><span class="line">./clef --keystore ./account/ newaccount</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动服务 Ropsten</span></span><br><span class="line">./clef --keystore ./account --configdir ./conf/clef/ --chainid 3</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>综合</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>fabric应用-ca官方文档编译及发布</title>
    <url>/articles/eabb4b3e/</url>
    <content><![CDATA[<p>官方发布的 <a href="https://hyperledger-fabric-ca.readthedocs.io">CA文档</a> 非常陈旧，但是<a href="https://github.com/hyperledger/fabric-ca">CA文档源</a>的内容却一直在更新，为了能即时了解最新的文档动向，还是需要自己根据官方提供的文档源码，编译一份可阅读的文档。<br>
但官方文档使用的是<code>sphinx</code>生成的，而按照官方提供的方式，无法直接编译，为此本文记录一下实际编译流程。</p>
<span id="more"></span>
<h2 id="简介">简介</h2>
<p>为了避免污染主机环境，本文将使用docker编译官方的<code>CA文档源码</code>。</p>
<h2 id="下载脚本">下载脚本</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/bitxx/docker_bash.git</span><br><span class="line">cd docker_bash</span><br></pre></td></tr></table></figure>
<p>我将常用的一些docker镜像都集成到上面的脚本中了，下载后，有兴趣可以看看，在这里主要就是关注<code>python</code>在docker-compose.yml中的编排</p>
<h2 id="启动python容器">启动python容器</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./main.sh start python</span><br></pre></td></tr></table></figure>
<p>该操作可以通过docker-compose将python容器启动</p>
<h3 id="编译文档">编译文档</h3>
<ol>
<li>将ca文档源码根目录<code>docs</code>中的所有内容，直接拷贝到上述python容器映射的主机目录<code>$ROOT_PATH/data-server/$&#123;CONTAINER_PYTHON&#125;/data/</code>下</li>
<li>进入容器，并进入指定映射目录</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./main.sh exec python </span><br><span class="line">cd /docs</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>虽然ca文档源码中官方提供了<code>requirements.txt</code>，但是你会发现如果直接使用，不管用哪个版本的python，都无法成功编译，因此需要手动执行加入以下依赖包，默认使用最新版的包：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install sphinx</span><br><span class="line">pip install sphinx_rtd_theme</span><br><span class="line">pip install recommonmark</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>编译生成html文档</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make html</span><br></pre></td></tr></table></figure>
<p>build/html/中会有编译后的文档，这就是最终完整的编译内容，之后只要用nginx等服务器部署该静态文档即可。</p>
<h2 id="停止sphinx容器">停止sphinx容器</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./main.sh release python</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文主要记录了编译官方CA文档源码的流程，方便后续参考。</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Hyperledger Fabric</category>
      </categories>
      <tags>
        <tag>Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>fabric基础-Fabric-CA应用案例</title>
    <url>/articles/69fa33db/</url>
    <content><![CDATA[<p>通过一套案例，演示Fabric CA在fabric网络中的应用</p>
<span id="more"></span>
<h2 id="拓扑结构">拓扑结构</h2>
<p>本次案例拓扑结构：</p>
<ol>
<li>总共3各组织，一个Orderer组织，两个Peer组织</li>
<li>1个根CA和3个隶属于根CA的中间CA</li>
<li>3个中间CA分别负责一个组织的证书生成等。<br>
具体拓扑图如下所示</li>
</ol>
<img src="/articles/69fa33db/1.png" class="" title="拓扑结构">
<h2 id="端口号分配">端口号分配</h2>
<p>其中，tls表示为安全通信提供CA证书服务，可选，生产环境一般必须使用；operations.listenAddress为运维监听接口，用于监听维护ca节点：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1. RootCA：            prot：7054    operations.listenAddress：127.0.0.1:9443</span><br><span class="line">2. IntermediaCA1：     prot：7055    operations.listenAddress：127.0.0.1:9444</span><br><span class="line">3. IntermediaCAtls1：  prot：8055    operations.listenAddress：127.0.0.1:9445</span><br><span class="line">4. IntermediaCA2：     prot：7056    operations.listenAddress：127.0.0.1:9446</span><br><span class="line">5. IntermediaCAtls2：  prot：8056    operations.listenAddress：127.0.0.1:9447</span><br><span class="line">6. IntermediaCA3：     prot：7057    operations.listenAddress：127.0.0.1:9448</span><br><span class="line">7. IntermediaCAtls3：  prot：8057    operations.listenAddress：127.0.0.1:9449</span><br></pre></td></tr></table></figure>
<h2 id="ca服务初始化并启动">CA服务初始化并启动</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">RootCA初始化并启动（默认端口7054，运维监听127.0.0.1:9443）</span></span><br><span class="line">./fabric-ca-server init -b admin:adminpw --home ./rootca</span><br><span class="line">./fabric-ca-server start -b admin:adminpw --home ./rootca --cfg.affiliations.allowremove --cfg.identities.allowremove</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ca1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># IntermediaCA1初始化并启动（配置文件改端口为7055，运维监听127.0.0.1:9444）,中间CA通过-u关联根CA</span></span></span><br><span class="line">./fabric-ca-server init -b admin1:adminpw1 --home ./intermediaca1 -u http://admin:adminpw@localhost:7054</span><br><span class="line">./fabric-ca-server start -b admin1:adminpw1 --home ./intermediaca1 --cfg.affiliations.allowremove --cfg.identities.allowremove</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># IntermediaCAtls1初始化并启动（配置文件改端口为8055，运维监听127.0.0.1:9445）</span></span></span><br><span class="line">./fabric-ca-server init -b admin1:adminpw1 --home ./intermediacatls1 -u http://admin:adminpw@localhost:7054</span><br><span class="line">./fabric-ca-server start -b admin1:adminpw1 --home ./intermediacatls1 --cfg.affiliations.allowremove --cfg.identities.allowremove</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ca2</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># IntermediaCA2初始化并启动（配置文件改端口为7056，运维监听127.0.0.1:9446）</span></span></span><br><span class="line">./fabric-ca-server init -b admin2:adminpw2 --home ./intermediaca2 -u http://admin:adminpw@localhost:7054</span><br><span class="line">./fabric-ca-server start -b admin2:adminpw2 --home ./intermediaca2 --cfg.affiliations.allowremove --cfg.identities.allowremove</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># IntermediaCAtls2初始化并启动（配置文件改端口为8056，运维监听127.0.0.1:9447）</span></span></span><br><span class="line">./fabric-ca-server init -b admin2:adminpw2 --home ./intermediacatls2 -u http://admin:adminpw@localhost:7054</span><br><span class="line">./fabric-ca-server start -b admin2:adminpw2 --home ./intermediacatls2 --cfg.affiliations.allowremove --cfg.identities.allowremove</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ca3</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># IntermediaCA3初始化并启动（配置文件改端口为7057，运维监听127.0.0.1:9448）</span></span></span><br><span class="line">./fabric-ca-server init -b admin3:adminpw3 --home ./intermediaca3 -u http://admin:adminpw@localhost:7054</span><br><span class="line">./fabric-ca-server start -b admin3:adminpw3 --home ./intermediaca3 --cfg.affiliations.allowremove --cfg.identities.allowremove</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># IntermediaCAtls3初始化并启动（配置文件改端口为8057，运维监听127.0.0.1:9449）</span></span></span><br><span class="line">./fabric-ca-server init -b admin3:adminpw3 --home ./intermediacatls3 -u http://admin:adminpw@localhost:7054</span><br><span class="line">./fabric-ca-server start -b admin3:adminpw3 --home ./intermediacatls3 --cfg.affiliations.allowremove --cfg.identities.allowremove</span><br></pre></td></tr></table></figure>
<h2 id="ca客户端生成证书">CA客户端生成证书</h2>
<p>每个组织证书生成类似，这里以orderer组织的IntermediaCA1和IntermediaCAtls1生成的证书为例。</p>
<h3 id="1-intermediaca1生成证书">1. IntermediaCA1生成证书</h3>
<ol>
<li>生成jason.com的MSP</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登记账户</span></span><br><span class="line">./fabric-ca-client enroll -u http://admin1:adminpw1@localhost:7055 --home ./intermedia1  -M ./crypto_config/ordererOrganizations/jason.com/msp </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看组织</span></span><br><span class="line">./fabric-ca-client  affiliation list -u http://admin1:adminpw1@localhost:7055 --home ./intermedia1  -M ./crypto_config/ordererOrganizations/jason.com/msp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除旧默认组织(org1 org2)</span></span><br><span class="line">./fabric-ca-client  affiliation remove --force org1 -u http://admin1:adminpw1@localhost:7055 --home ./intermedia1  -M ./crypto_config/ordererOrganizations/jason.com/msp</span><br><span class="line">./fabric-ca-client  affiliation remove --force org2 -u http://admin1:adminpw1@localhost:7055 --home ./intermedia1  -M ./crypto_config/ordererOrganizations/jason.com/msp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加组织(com com.jason)</span></span><br><span class="line">fabric-ca-client affiliation add com -u http://admin1:adminpw1@localhost:7055 --home ./intermedia1  -M ./crypto_config/ordererOrganizations/jason.com/msp</span><br><span class="line">fabric-ca-client affiliation add com.jason -u http://admin1:adminpw1@localhost:7055 --home ./intermedia1  -M ./crypto_config/ordererOrganizations/jason.com/msp</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>生成Admin@jason.com的MSP</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注册Admin@jason.com</span></span><br><span class="line">./fabric-ca-client register -u http://admin1:adminpw1@localhost:7055 --id.name Admin@jason.com --id.type client --id.affiliation &quot;com.jason&quot; --id.attrs &#x27;&quot;hf.Registrar.Roles=client,orderer,peer,user&quot;,&quot;hf.Registrar.DelegateRoles=client,orderer,peer,user&quot;,hf.Registrar.Attributes=*,hf.GenCRL=true,hf.Revoker=true,hf.AffiliationMgr=true,hf.IntermediateCA=true,role=admin:ecert&#x27; --id.secret=123456 --csr.cn=jason.com --csr.hosts=&#x27;jason.com&#x27; --home ./intermedia1  -M ./crypto_config/ordererOrganizations/jason.com/msp </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登记Admin@jason.com</span></span><br><span class="line">./fabric-ca-client enroll -u http://Admin@jason.com:123456@localhost:7055 --csr.cn=jason.com --csr.hosts=&#x27;jason.com&#x27; --home ./intermedia1  -M ./crypto_config/ordererOrganizations/jason.com/users/Admin@jason.com/msp </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为Admin@jason.com生成msp，就是专门为admin建立一份证书存放位置</span></span><br><span class="line">mkdir ./intermedia1/crypto_config/ordererOrganizations/jason.com/users/Admin@jason.com/msp/admincerts</span><br><span class="line">cp ./intermedia1/crypto_config/ordererOrganizations/jason.com/users/Admin@jason.com/msp/signcerts/cert.pem ./intermedia1/crypto_config/ordererOrganizations/jason.com/users/Admin@jason.com/msp/admincerts/</span><br><span class="line">mkdir ./intermedia1/crypto_config/ordererOrganizations/jason.com/msp/admincerts</span><br><span class="line">cp ./intermedia1/crypto_config/ordererOrganizations/jason.com/users/Admin@jason.com/msp/signcerts/cert.pem ./intermedia1/crypto_config/ordererOrganizations/jason.com/msp/admincerts/</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>生成orderer0.jason.com的MSP</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注册orderer0.jason.com</span></span><br><span class="line">./fabric-ca-client register -u http://admin1:adminpw1@localhost:7055 --id.name orderer0.jason.com --id.type orderer --id.affiliation &quot;com.jason&quot; --id.attrs &#x27;&quot;role=orderer&quot;,ecert=true&#x27; --id.secret=123456 --csr.cn=orderer0.jason.com --csr.hosts=&#x27;orderer0.jason.com&#x27; --home ./intermedia1  -M ./crypto_config/ordererOrganizations/jason.com/msp </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登记orderer0.jason.com</span></span><br><span class="line">./fabric-ca-client enroll -d -u http://orderer0.jason.com:123456@localhost:7055 --csr.cn=orderer0.jason.com --csr.hosts=&#x27;orderer0.jason.com&#x27; --home ./intermedia1  -M ./crypto_config/ordererOrganizations/jason.com/orderers/orderer0.jason.com/msp </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成MSP</span></span><br><span class="line">mkdir ./intermedia1/crypto_config/ordererOrganizations/jason.com/orderers/orderer0.jason.com/msp/admincerts</span><br><span class="line">cp ./intermedia1/crypto_config/ordererOrganizations/jason.com/users/Admin@jason.com/msp/signcerts/cert.pem ./intermedia1/crypto_config/ordererOrganizations/jason.com/orderers/orderer0.jason.com/msp/admincerts/</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>生成orderer1.jason.com的MSP<br>
同上第3步，orderer0，只是将0变为1</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注册orderer1.jason.com</span></span><br><span class="line">./fabric-ca-client register -u http://admin1:adminpw1@localhost:7055 --id.name orderer1.jason.com --id.type orderer --id.affiliation &quot;com.jason&quot; --id.attrs &#x27;&quot;role=orderer&quot;,ecert=true&#x27; --id.secret=123456 --csr.cn=orderer1.jason.com --csr.hosts=&#x27;orderer1.jason.com&#x27; --home ./intermedia1  -M ./crypto_config/ordererOrganizations/jason.com/msp </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登记orderer1.jason.com</span></span><br><span class="line">./fabric-ca-client enroll -d -u http://orderer1.jason.com:123456@localhost:7055 --csr.cn=orderer1.jason.com --csr.hosts=&#x27;orderer1.jason.com&#x27; --home ./intermedia1  -M ./crypto_config/ordererOrganizations/jason.com/orderers/orderer1.jason.com/msp </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成MSP</span></span><br><span class="line">mkdir ./intermedia1/crypto_config/ordererOrganizations/jason.com/orderers/orderer1.jason.com/msp/admincerts</span><br><span class="line">cp ./intermedia1/crypto_config/ordererOrganizations/jason.com/users/Admin@jason.com/msp/signcerts/cert.pem ./intermedia1/crypto_config/ordererOrganizations/jason.com/orderers/orderer1.jason.com/msp/admincerts/</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>生成orderer2.jason.com的MSP<br>
同上第3步，orderer0，只是将0变为2</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注册orderer2.jason.com</span></span><br><span class="line">./fabric-ca-client register -u http://admin1:adminpw1@localhost:7055 --id.name orderer2.jason.com --id.type orderer --id.affiliation &quot;com.jason&quot; --id.attrs &#x27;&quot;role=orderer&quot;,ecert=true&#x27; --id.secret=123456 --csr.cn=orderer2.jason.com --csr.hosts=&#x27;orderer2.jason.com&#x27; --home ./intermedia1  -M ./crypto_config/ordererOrganizations/jason.com/msp </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登记orderer2.jason.com</span></span><br><span class="line">./fabric-ca-client enroll -d -u http://orderer2.jason.com:123456@localhost:7055 --csr.cn=orderer2.jason.com --csr.hosts=&#x27;orderer2.jason.com&#x27; --home ./intermedia1  -M ./crypto_config/ordererOrganizations/jason.com/orderers/orderer2.jason.com/msp </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成MSP</span></span><br><span class="line">mkdir ./intermedia1/crypto_config/ordererOrganizations/jason.com/orderers/orderer2.jason.com/msp/admincerts</span><br><span class="line">cp ./intermedia1/crypto_config/ordererOrganizations/jason.com/users/Admin@jason.com/msp/signcerts/cert.pem ./intermedia1/crypto_config/ordererOrganizations/jason.com/orderers/orderer2.jason.com/msp/admincerts/</span><br></pre></td></tr></table></figure>
<h3 id="2-intermediacatls1生成证书">2. IntermediaCAtls1生成证书</h3>
<ol>
<li>生成jason.com的MSP</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登记账户</span></span><br><span class="line">./fabric-ca-client enroll -u http://admin1:adminpw1@localhost:8055 --home ./intermedia1  -M ./crypto_config/ordererOrganizations/jason.com/tlstmp </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看组织</span></span><br><span class="line">./fabric-ca-client  affiliation list -u http://admin1:adminpw1@localhost:8055 --home ./intermedia1  -M ./crypto_config/ordererOrganizations/jason.com/tlstmp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除旧默认组织(org1 org2)</span></span><br><span class="line">./fabric-ca-client  affiliation remove --force org1 -u http://admin1:adminpw1@localhost:8055 --home ./intermedia1  -M ./crypto_config/ordererOrganizations/jason.com/tlstmp</span><br><span class="line">./fabric-ca-client  affiliation remove --force org2 -u http://admin1:adminpw1@localhost:8055 --home ./intermedia1  -M ./crypto_config/ordererOrganizations/jason.com/tlstmp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加组织(com com.jason)</span></span><br><span class="line">./fabric-ca-client affiliation add com -u http://admin1:adminpw1@localhost:8055 --home ./intermedia1  -M ./crypto_config/ordererOrganizations/jason.com/tlstmp</span><br><span class="line">./fabric-ca-client affiliation add com.jason -u http://admin1:adminpw1@localhost:8055 --home ./intermedia1  -M ./crypto_config/ordererOrganizations/jason.com/tlstmp</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>生成Admin@jason.com的TLS</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注册Admin@jason.com</span></span><br><span class="line">./fabric-ca-client register -u http://admin1:adminpw1@localhost:8055 --id.name Admin@jason.com --id.type client --id.affiliation &quot;com.jason&quot; --id.attrs &#x27;&quot;hf.Registrar.Roles=client,orderer,peer,user&quot;,&quot;hf.Registrar.DelegateRoles=client,orderer,peer,user&quot;,hf.Registrar.Attributes=*,hf.GenCRL=true,hf.Revoker=true,hf.AffiliationMgr=true,hf.IntermediateCA=true,role=admin:ecert&#x27; --id.secret=123456 --csr.cn=jason.com --csr.hosts=&#x27;jason.com&#x27; --home ./intermedia1  -M ./crypto_config/ordererOrganizations/jason.com/tlstmp</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登记Admin@jason.com</span></span><br><span class="line">./fabric-ca-client enroll -d --enrollment.profile tls -u http://Admin@jason.com:123456@localhost:8055 --csr.cn=jason.com --csr.hosts=&#x27;jason.com&#x27; --home ./intermedia1  -M ./crypto_config/ordererOrganizations/jason.com/users/Admin@jason.com/tlstmp </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为Admin@jason.com生成tls，就是专门为admin建立一份证书存放位置。需要注意，tls证书需要从根ca中拷贝出ca-chain.pem到中间ca的指定位置</span></span><br><span class="line">mkdir ./intermedia1/crypto_config/ordererOrganizations/jason.com/users/Admin@jason.com/tls</span><br><span class="line">cp ../intermediacatls1/ca-chain.pem ./intermedia1/crypto_config/ordererOrganizations/jason.com/users/Admin@jason.com/tls/ca.crt</span><br><span class="line">cp ./intermedia1/crypto_config/ordererOrganizations/jason.com/users/Admin@jason.com/tlstmp/signcerts/cert.pem ./intermedia1/crypto_config/ordererOrganizations/jason.com/users/Admin@jason.com/tls/client.crt</span><br><span class="line">cp ./intermedia1/crypto_config/ordererOrganizations/jason.com/users/Admin@jason.com/tlstmp/keystore/2c67df27fc1e0cb607d7195fe0938ae31aae4e9cfb2828c78f051495b5305d81_sk ./intermedia1/crypto_config/ordererOrganizations/jason.com/users/Admin@jason.com/tls/client.key</span><br><span class="line">cp -r ./intermedia1/crypto_config/ordererOrganizations/jason.com/users/Admin@jason.com/tlstmp/tlscacerts ./intermedia1/crypto_config/ordererOrganizations/jason.com/msp</span><br><span class="line">cp -r ./intermedia1/crypto_config/ordererOrganizations/jason.com/users/Admin@jason.com/tlstmp/tlsintermediatecerts ./intermedia1/crypto_config/ordererOrganizations/jason.com/msp</span><br><span class="line">rm -rf ./intermedia1/crypto_config/ordererOrganizations/jason.com/users/Admin@jason.com/tlstmp</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>生成orderer0.jason.com的TLS</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注册orderer0.jason.com</span></span><br><span class="line">./fabric-ca-client register -u http://admin1:adminpw1@localhost:8055 --id.name orderer0.jason.com --id.type orderer --id.affiliation &quot;com.jason&quot; --id.attrs &#x27;&quot;role=orderer&quot;,ecert=true&#x27; --id.secret=123456 --csr.cn=orderer0.jason.com --csr.hosts=&#x27;orderer0.jason.com&#x27; --home ./intermedia1  -M ./crypto_config/ordererOrganizations/jason.com/tlstmp </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登记orderer0.jason.com</span></span><br><span class="line">./fabric-ca-client enroll -d --enrollment.profile tls -u http://orderer0.jason.com:123456@localhost:8055 --csr.cn=orderer0.jason.com --csr.hosts=&#x27;orderer0.jason.com&#x27; --home ./intermedia1  -M ./crypto_config/ordererOrganizations/jason.com/users/orderer0@jason.com/tlstmp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成MSP</span></span><br><span class="line">mkdir ./intermedia1/crypto_config/ordererOrganizations/jason.com/users/orderer0.jason.com/tls</span><br><span class="line">cp ./intermediacatls1/ca-chain.pem ./fabric_ca_client/crypto_config/ordererOrganizations/jason.com/users/orderer0.jason.com/tls/ca.crt</span><br><span class="line">cp ./fabric_ca_client/crypto_config/ordererOrganizations/jason.com/users/orderer0.jason.com/tlstmp/signcerts/cert.pem ./fabric_ca_client/crypto_config/ordererOrganizations/jason.com/users/orderer0.jason.com/tls/client.crt</span><br><span class="line">cp ./fabric_ca_client/crypto_config/ordererOrganizations/jason.com/users/orderer0.jason.com/tlstmp/keystore/xxxxxxxx_sk ./fabric_ca_client/crypto_config/ordererOrganizations/jason.com/users/orderer0.jason.com/tls/client.key</span><br><span class="line">cp -r ./fabric_ca_client/crypto_config/ordererOrganizations/jason.com/users/orderer0.jason.com/tlstmp/tlscacerts ./fabric_ca_client/crypto_config/ordererOrganizations/jason.com/msp</span><br><span class="line">cp -r ./fabric_ca_client/crypto_config/ordererOrganizations/jason.com/users/orderer0.jason.com/tlstmp/tlsintermediatecerts ./fabric_ca_client/crypto_config/ordererOrganizations/jason.com/msp</span><br><span class="line">rm -rf ./fabric_ca_client/crypto_config/ordererOrganizations/jason.com/users/orderer0.jason.com/tlstmp</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>
<p>生成orderer1.jason.com的TLS<br>
同上第3步，orderer0，只是将0变为1</p>
</li>
<li>
<p>生成orderer2.jason.com的TLS<br>
同上第3步，orderer0，只是将0变为2</p>
</li>
</ol>
<h2 id="总结">总结</h2>
<p>本文根据网路拓扑展示了一个拥有中间CA的认证中心的部署方式，这里虽然只列了Orderer组织的CA部署方式，但其余组织的操作也基本都一样。</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Hyperledger Fabric</category>
      </categories>
      <tags>
        <tag>Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>fabric基础-Fabric CA介绍及使用</title>
    <url>/articles/342ca2c8/</url>
    <content><![CDATA[<p>Fabric网络中，身份信息文件、TLS通信文件，都需要有专门的模块来管理。通常测试时，为了方便，我们可以使用Fabric官方提供的<code>crypto</code>工具来快速生成需要到证书等。但真正的生产环境中，必须要有一个中心证书机构同一管理和维护证书，合理的规划CA层级，使得新组织加入时不会影响正在使用的证书，并且具有良好的扩展性。官方提供的<code>Fabric CA</code>本身就是为了解决这个问题而生的，是一个完全独立的模块。随着Fabric网络规模的扩大，CA中心由简单的一两个节点，可能会逐步扩充为一个集群等。作为Fabric的入口，很有必要掌握<code>Fabric CA</code>的一些原理和应用。</p>
<span id="more"></span>
<h2 id="1-fabric-ca整体架构">1、Fabric CA整体架构</h2>
<img src="/articles/342ca2c8/1.png" class="" title="Fabric架构">
<ol>
<li>Fabric CA根证书服务：建议在正是环境中只存在一个根证书，当然根据具体情况也可以有多个。该证书不用于具体CA证书颁发，具体的颁发行为交由中间CA来处理。该服务重要是用于统一管理中间证书。</li>
<li>Fabric CA中间证书服务：每个中间证书都隶属于根证书，或隶属于其它中间证书，在正式环境中，建议每个组织对应一个中间证书，由该中间证书负责处理该组织的全部节点和成员的证书颁发。</li>
<li>Fabric CA服务器集群：可以把中间证书服务通过HA Proxy实现Fabric CA服务器集群。将流量负载平衡到一个Fabric CA集群成员。各汲取成员生成的证书保存到同一个数据库中，方便查询身份和证书。</li>
<li>Fabric CA客户端：负责登记、注册、销毁证书。</li>
<li>两种方式和CA服务器交互：直接使用CA客户端、通过SDK调用</li>
</ol>
<h3 id="1-1-主要功能">1.1 主要功能</h3>
<ol>
<li>各实体的身份注册和登记</li>
<li>给各实体发放登记证书(ECerts)</li>
<li>给各实体发放交易证书(TCerts)</li>
<li>各颁发证书的更新和销毁</li>
</ol>
<h2 id="2-下载与安装">2、下载与安装</h2>
<ol>
<li>可直接下载官方相应系统最新编译好的二进制文件，下载入口：<a href="https://github.com/hyperledger/fabric-ca/releases">fabric-ca可执行程序</a> 或者使用源码编译生成可执行程序，源码仓库：<a href="https://github.com/hyperledger/fabric-ca">fabric-ca源码</a><br>
二进制程序。</li>
<li>这里建议直接使用官方已编译好的，本文使用的是<code>v1.5.0</code>版本</li>
<li>二进制可执行程序分为两个：<br>
服务器端：<code>fabric-ca-server</code>，顾名思义，用于提供CA服务，需要放到指定服务器<br>
客户端：<code>fabric-ca-client</code>，用于连接CA服务，可以客户端操作和测试CA服务，放在你想放的地方即可。</li>
<li>为方便操作，建议设置环境变量，这个过程不阐述。</li>
</ol>
<h2 id="3-fabric-ca-server使用">3、fabric-ca-server使用</h2>
<h3 id="3-1-初始化">3.1 初始化</h3>
<p>这个过程只是生成启动前的初始化文件，其实下一个步骤<code>启动</code>已经包含了这个过程，根据实际需要可选择是否要跳过该步骤；<br>
设置工作主目录，这里有这样一个规则，优先级由上至下：</p>
<ol>
<li>命令行设置<code>-home</code></li>
<li>配置环境变量：<code>FABRIC_CA_SERVER_HOME</code></li>
<li>配置环境变量：<code>FABRIC_CA_HOME</code></li>
<li>配置环境变量：<code>FABRIC_CFG_PATH</code></li>
<li>使用当前二进制所在目录</li>
</ol>
<p>初始化命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./fabric-ca-server init -b admin:adminpw --home ./fabric_ca_server</span><br></pre></td></tr></table></figure>
<p><code>-b</code>：设置默认管理员的账户和密码<br>
<code>--home</code>：设置默认工作目录<br>
命令执行后，会有一系列的日志，记录了整个执行过程，这个日志在这里就不贴上来了。<br>
执行后，会在工作目录下生成如下文件：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── IssuerPublicKey                  # 身份混合器会用到（零知识证明）</span><br><span class="line">├── IssuerRevocationPublicKey        # 身份混合器会用到（零知识证明）</span><br><span class="line">├── ca-cert.pem                      # 自签名CA根证书，用于验证其它证书的有效性</span><br><span class="line">├── fabric-ca-server-config.yaml     # CA服务端配置文件，服务启动时会读取这里的配置信息，因此建议启动前先配置好该文件</span><br><span class="line">├── fabric-ca-server.db              # 用于存储注册用户和证书的数据库，这里默认用的是sqlite</span><br><span class="line">└── msp                              # 存放CA中心生成的个人身份的私钥文件，用于生成根证书和其他证书，生成的文件格式为_sk</span><br><span class="line">    └── keystore</span><br><span class="line">        ├── 41a1416624e186b4f5f19ae643c8e2b2493f5175226b49668fb34dfa7cc2bd9e_sk</span><br><span class="line">        ├── IssuerRevocationPrivateKey</span><br><span class="line">        └── IssuerSecretKey</span><br></pre></td></tr></table></figure>
<p>其中，<code>fabric-ca-server-config.yaml</code>涉及到一系列CA服务器的配置属性，需要根据了解逐步去配置，里面官方给每个属性都配有说明。这块如果展开说，篇幅不够的，后续根据需要看是否需要开专门一篇文章来讲解这个配置文件的内容；建议启动前先配置好该文件。</p>
<h3 id="3-2-启动">3.2 启动</h3>
<p>启动时，会生成一系列检测信息，<code>启动过程本身就包含了初始化过程，如果先前没有初始化，或者没有指定配置文件，则该过程会自动生成新的初始化文件</code>。<br>
启动后，默认端口号是：<code>7054</code>，用来监听客户端的请求。要改别的端口号，则前往配置设置。<br>
启动命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./fabric-ca-server start -b admin:adminpw --home ./fabric_ca_server --cfg.affiliations.allowremove --cfg.identities.allowremove</span><br></pre></td></tr></table></figure>
<p><code>--cfg.affiliations.allowremove</code>：指定允许删除联盟<br>
<code>--cfg.identities.allowremove</code>：指定允许删除用户</p>
<h3 id="3-3-sqlite-db">3.3 sqlite db</h3>
<p>默认使用的是sqlite数据库，ca server初始化完成后，会生成<code>fabric-ca-server.db</code>，使用navicat打开后，会发现里面总共7张表，分别为：</p>
<ol>
<li><code>affiliations</code>：存储机构组织</li>
<li><code>certificates</code>：客户端登录账号会在此处有一个记录</li>
<li><code>credentials</code>：</li>
<li><code>nonces</code>：</li>
<li><code>properties</code>：</li>
<li><code>revocation_authority_info</code>：</li>
<li><code>users</code>：用户账户</li>
</ol>
<h2 id="4-fabric-ca-client使用">4、fabric-ca-client使用</h2>
<ol>
<li>
<p>这个是ca客户端，主要用来和ca服务器端的交互，主要涉及到以下几个命令：<br>
<code>register</code>：注册用户身份<br>
<code>enroll</code>：登记用户身份<br>
<code>reenroll</code>：重新登记用户身份<br>
<code>revoke</code>：注销已签发的用户证书<br>
<code>affiliation list</code>：列举组织关系<br>
<code>affiliation remove</code>：移除组织关系<br>
<code>affiliation add</code>：添加组织关系</p>
</li>
<li>
<p>注：务必先启动ca服务器端</p>
</li>
<li>
<p>默认启动的ca server，数据库里组织是没什么用的，需要删除掉，然后重新添加一个需要的组织，然后为该组织注册一个账号。这整个操作流程，正好满足ca客户端的基本使用，为此按照这个思路，讲解以下流程</p>
</li>
<li>
<p>以下操作建议为ca客户端配置一个根目录<code>FABRIC_CA_CLIENT_HOME</code>，取代<code>--home</code>参数</p>
</li>
</ol>
<h3 id="4-1-登记账号">4.1 登记账号</h3>
<p>CA客户端要操作任何内容，都需要先登记相应的账号，这里我们登记管理员账号admin。<br>
登记的目的是获取签名证书，这样之后只要用相应账号密码连接ca服务即可操作相应功能</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./fabric-ca-client enroll -d --enrollment.profile tls -u http://admin:adminpw@localhost:7054 --home ./fabric_ca_client  -M ./crypto_config/ordererOrganizations/msp </span><br></pre></td></tr></table></figure>
<h3 id="4-2-查看现有组织">4.2 查看现有组织</h3>
<p>可以直观返回当前ca数据库组织关系</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./fabric-ca-client  affiliation list -u http://admin:adminpw@localhost:7054 --home ./fabric_ca_client  -M ./crypto_config/ordererOrganizations/msp</span><br></pre></td></tr></table></figure>
<p>返回默认组织关系</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">affiliation: .</span><br><span class="line">   affiliation: org2</span><br><span class="line">      affiliation: org2.department1</span><br><span class="line">   affiliation: org1</span><br><span class="line">      affiliation: org1.department1</span><br><span class="line">      affiliation: org1.department2</span><br></pre></td></tr></table></figure>
<h3 id="4-3-删除组织">4.3 删除组织</h3>
<p>需要admin账户拥有删除组织的权限。默认自带的组织并没有什么用，可以逐个删除，比如删除org1组织</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除组织1</span></span><br><span class="line">./fabric-ca-client  affiliation remove --force org1 -u http://admin:adminpw@localhost:7054 --home ./fabric_ca_client  -M ./crypto_config/ordererOrganizations/msp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除组织2</span></span><br><span class="line">./fabric-ca-client  affiliation remove --force org2 -u http://admin:adminpw@localhost:7054 --home ./fabric_ca_client  -M ./crypto_config/ordererOrganizations/msp</span><br></pre></td></tr></table></figure>
<p><code>--force</code>：可以强制删除组织和其子组织</p>
<h3 id="4-4-添加组织">4.4 添加组织</h3>
<p>组织添加有规则限制，比如组织格式为：com.jason.org1，需要先添加组织<code>com</code>，然后添加<code>com.jason</code>，最后添加<code>com.jason.org1</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加组织com</span></span><br><span class="line">fabric-ca-client affiliation add com -u http://admin:adminpw@localhost:7054 --home ./fabric_ca_client  -M ./crypto_config/ordererOrganizations/msp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加组织com.jason</span></span><br><span class="line">fabric-ca-client affiliation add com.jason -u http://admin:adminpw@localhost:7054 --home ./fabric_ca_client  -M ./crypto_config/ordererOrganizations/msp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加组织com.jason.org1</span></span><br><span class="line">fabric-ca-client affiliation add com.jason.org1 -u http://admin:adminpw@localhost:7054 --home ./fabric_ca_client  -M ./crypto_config/ordererOrganizations/msp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加组织com.jason.org2</span></span><br><span class="line">fabric-ca-client affiliation add com.jason.org2 -u http://admin:adminpw@localhost:7054 --home ./fabric_ca_client  -M ./crypto_config/ordererOrganizations/msp</span><br></pre></td></tr></table></figure>
<p>通过查看可知，当前ca数据库中，组织关系为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">affiliation: com</span><br><span class="line">   affiliation: com.jason</span><br><span class="line">      affiliation: com.jason.org1</span><br><span class="line">      affiliation: com.jason.org2</span><br></pre></td></tr></table></figure>
<h3 id="4-5-获取ca证书信息">4.5 获取ca证书信息</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fabric-ca-client getcainfo -u http://admin:adminpw@localhost:7054 --home ./fabric_ca_client  -M ./crypto_config/organizations/msp</span><br></pre></td></tr></table></figure>
<h3 id="4-6-注册用户身份">4.6 注册用户身份</h3>
<p>需要记住的是，注册完成之后，要及时登记(enroll)，否则该账号依旧无法做任何操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注册</span></span><br><span class="line">./fabric-ca-client register -u http://admin:adminpw@localhost:7054 --id.name orderer.jason.com --id.type orderer --id.affiliation &quot;com.jason&quot; --id.attrs &#x27;&quot;hf.Registrar.Roles=client,orderer,peer,user&quot;,&quot;hf.Registrar.DelegateRoles=client,orderer,peer,user&quot;,hf.Registrar.Attributes=*,hf.GenCRL=true,hf.Revoker=true,hf.AffiliationMgr=true,hf.IntermediateCA=true,role=admin:ecert&#x27; --id.secret=123456 --home ./fabric_ca_client  -M ./crypto_config/ordererOrganizations/msp </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登记</span></span><br><span class="line">./fabric-ca-client enroll -u http://orderer.jason.com:123456@localhost:7054 --home ./fabric_ca_client  -M ./crypto_config/ordererOrganizations/users/orderer.jason.com/msp </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-7-重新登记用户身份">4.7 重新登记用户身份</h3>
<p>比如证书快到期了，或者想要更换证书，则重新登记</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./fabric-ca-client reenroll -u http://admin:adminpw@localhost:7054 --home ./fabric_ca_client  -M ./crypto_config/ordererOrganizations/msp </span><br></pre></td></tr></table></figure>
<h3 id="4-8-注销已签发的证书">4.8 注销已签发的证书</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./fabric-ca-client revoke -e &quot;orderer.jason.com&quot; -r &quot;注销原因：xxxx&quot; -u http://admin:adminpw@localhost:7054 --home ./fabric_ca_client  -M ./crypto_config/ordererOrganizations/msp </span><br></pre></td></tr></table></figure>
<p><code>-e</code>：用户账号<br>
<code>-r</code>：注销原因</p>
<h2 id="总结">总结</h2>
<p>本文主要介绍了CA服务端和客户端的操作以及执行原理</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Hyperledger Fabric</category>
      </categories>
      <tags>
        <tag>Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>IPFS基础-高级操作</title>
    <url>/articles/6ebd6fe7/</url>
    <content><![CDATA[<p>本文主要讲IPFS的一些高级应用，虽说高级，但依旧属于IPFS基础中尽可能掌握的内容。主要讲解IPFS网络中如何持久保存数据、如何发布消息、命名空间怎样使用等。</p>
<span id="more"></span>
<h2 id="ipfs中发布动态内容">IPFS中发布动态内容</h2>
<p>从IPFS原理可知，每上传一个文件，都有唯一的一个地址指向这个文件，假如我发布了一篇博客，此时得到一个地址<code>A</code>，如果我对博客内容做了一点改动，重新发布后，得到的地址变为了<code>B</code>， 这样会对博客浏览者造成很大困惑，无法通过一个稳定的地址来访问我的这篇博客。针对此类问题，IPFS推出了一个新的技术，叫<code>IPNS（星际文件命名系统）</code>，其实这技术也不算新了，很多年前就已经推出了。 使用该技术，会为一个文件提供一个稳定的命名空间或者叫地址（姑且这么理解），无论文件改变多少次，该地址始终都会指向最新改动后的文件。也就是说，无论我的博客修改并发布多少次，<code>IPNS</code>的地址始终指向我最后一次修改后的博客。</p>
<h3 id="先新建一个文件-并上传到ipfs">先新建一个文件，并上传到IPFS</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;hello jason&quot; &gt; test.txt</span><br><span class="line">ipfs add test.txt</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">added QmcMR7dqXvUxgCXpwmKHyeu4mbwGAfvd5zoa7fY4UYmtPP test.txt</span><br></pre></td></tr></table></figure>
<h3 id="通过rsa公钥绑定文件内容">通过RSA公钥绑定文件内容</h3>
<ol>
<li>查看当前IPFS节点的所有公钥</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs key list -l</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">k51qzi5uqu5dmd05ublqz4hxj2iuyy888cihg06pzda9lm4qghxnwrnwywaup0 self </span><br></pre></td></tr></table></figure>
<p>表示当前IPFS节点只有一个公钥key，且其别名为<code>self</code>，表示属于节点ID的，就是说该公钥唯一对应到IPFS的节点ID<br>
2. 创建新的RSA公钥</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs key gen --type=rsa --size=2048 newkey</span><br></pre></td></tr></table></figure>
<p>生成新的公钥：<code>k2k4r8pp1pt90mojqe0xgerxyjum439xhob526rvmhd5iambe7ri60f1</code><br>
也就是说，此时该IPFS节点有两个公钥了，用上面的命令<code>ipfs key list -l</code>查看:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">k51qzi5uqu5dmd05ublqz4hxj2iuyy888cihg06pzda9lm4qghxnwrnwywaup0 self   </span><br><span class="line">k2k4r8pp1pt90mojqe0xgerxyjum439xhob526rvmhd5iambe7ri60f1       newkey</span><br></pre></td></tr></table></figure>
<p>发现新加了一个公钥匙，对应别称为<code>newkey</code><br>
3. 将文件CID挂载到<code>newkey</code>的公钥地址上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs name publish --key=newkey QmcMR7dqXvUxgCXpwmKHyeu4mbwGAfvd5zoa7fY4UYmtPP</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Published to k2k4r8pp1pt90mojqe0xgerxyjum439xhob526rvmhd5iambe7ri60f1: /ipfs/QmcMR7dqXvUxgCXpwmKHyeu4mbwGAfvd5zoa7fY4UYmtPP</span><br></pre></td></tr></table></figure>
<p>输出表明已经将文件CID关联到指定公钥了，即绑定了固定的一个地址，也就是IPNS地址<br>
4. 浏览器访问：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/ipns/k51qzi5uqu5dmd05ublqz4hxj2iuyy888cihg06pzda9lm4qghxnwrnwywaup0</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>以后每次改动文件后，重复执行上面的步骤，最终都可以用同一个公钥来访问这个文件最新状态，其实也就是，每次公钥绑定了哪个CID，就能通过公钥(IPNS)在浏览器中看到对应CID的文件内容</li>
</ol>
<h3 id="通过当前节点绑定文件内容">通过当前节点绑定文件内容</h3>
<p>看了上面的内容，其实很容易理解这个节点绑定文件内容的逻辑，也就是说<code>ipfs name publish</code>的时候，不要指定<code>--key</code>，则会默认将CID绑定到节点的<code>self</code>的公钥上，这个公钥本来就是关联节点ID的，因此文件就直接和节点绑定了，这样的坏处是，整个节点只能指向一个文件，很不灵活，因此一般不会在生产环境中使用这种方式。这里就不详细说明了（没啥好讲的，都是同一回事）。</p>
<h2 id="持久保存ipfs网络数据">持久保存IPFS网络数据</h2>
<p>如果文件存储在别人的IPFS节点上，直接在自己节点<code>ipfs cat 文件</code>，虽然能够读取到远程节点的这个文件，但这个文件只会临时缓存到自己的节点上，一段时间后，自己节点的缓存机制（<code>手动命令：ipfs repo gc</code>）会自动将这个文件给删除掉，造成下次从自己节点再次读取该文件的时，还得重新缓存的问题，严重影响了体验。<br>
为此，需要一个方式，能够永久保留下从远程节点读取到的文件。这里需要用到的命令是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs pin add QmcMR7dqXvUxgCXpwmKHyeu4mbwGAfvd5zoa7fY4UYmtPP</span><br></pre></td></tr></table></figure>
<p>如此可以将远程文件永久保存在自己节点上</p>
<h3 id="查看当前节点有哪些永久保存的文件和目录">查看当前节点有哪些永久保存的文件和目录</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs pin ls --type=all</span><br></pre></td></tr></table></figure>
<h3 id="资源手动回收">资源手动回收</h3>
<p>也就是手动清除缓存，释放资源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs repo gc</span><br></pre></td></tr></table></figure>
<h3 id="强制删除本地的某个文件目录及其子文件">强制删除本地的某个文件目录及其子文件</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs pin rm -r QmejvEPop4D7YUadeGqYWmZxHhLc4JBUCzJJHWMzdcMe2y</span><br></pre></td></tr></table></figure>
<h2 id="操作ipfs-merkle-dag">操作IPFS Merkle DAG</h2>
<p>IPFS的两个核心概念：默克尔树（Merkle）和有向无环图（DAG）。数据的存储结构大部分是Merkle DAG形式构成。理论部分不在这里介绍，本文主要介绍Merkle DAG的操作。<br>
之所以介绍，是因为在操作<code>分布式数据库</code>、<code>分布式版本控制软件</code>时，非常重要。 更通俗的说，就是操作一个文件的子块数据时，是需要掌握这部分内容的<br>
关于块和对象的裂变理论部分，本文不作详述。只要记着：<code>Block超过256Kb，就会生成新的Block；Object的Links数量超过174个，就会生成新的Object</code></p>
<h3 id="创建merkle-dag结构">创建Merkle DAG结构</h3>
<p>通过<code>ipfs add</code>上传的文件，本身就是为文件创建Merkle DAG对象</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs add test.txt</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">added QmWJgfUvpjNN7ycjYac86kogRPmS1Bj33gH2LRMA9dPW1j test.txt</span><br></pre></td></tr></table></figure>
<p>查看结构信息和子对象信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs object links -v QmWJgfUvpjNN7ycjYac86kogRPmS1Bj33gH2LRMA9dPW1j</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Hash                                           Size   Name</span><br><span class="line">QmZCxwMMGar8RDc4ckezyL1uNS2ACKKyUvh6kDc6g2urHP 262158 </span><br><span class="line">QmVp79sgyHbzvpF8cdB7pmpbBYEkNoKUEBajTzpv9HhdqV 19869 </span><br></pre></td></tr></table></figure>
<p>可以看出有两个地址来管理这个<code>test.txt</code>文件，第一个地址：<code>QmZCxwMMGar8RDc4ckezyL1uNS2ACKKyUvh6kDc6g2urHP</code>对应文件的256kb文件块，另一个地址：<code>QmVp79sgyHbzvpF8cdB7pmpbBYEkNoKUEBajTzpv9HhdqV</code>对应文件的剩余大小。也就是说，一个文件是按照256kb来切分文件块的。<br>
使用如下命令即可查看每个子块的信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs cat QmZCxwMMGar8RDc4ckezyL1uNS2ACKKyUvh6kDc6g2urHP</span><br><span class="line">ipfs cat QmVp79sgyHbzvpF8cdB7pmpbBYEkNoKUEBajTzpv9HhdqV</span><br></pre></td></tr></table></figure>
<h3 id="组装子块数据">组装子块数据</h3>
<p>该命令可以将文件的指定子块合并成一个新文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs cat QmZCxwMMGar8RDc4ckezyL1uNS2ACKKyUvh6kDc6g2urHP QmVp79sgyHbzvpF8cdB7pmpbBYEkNoKUEBajTzpv9HhdqV &gt; test2.txt</span><br></pre></td></tr></table></figure>
<p>这是Merkle DAG的一种应用。该应用同时也可以用于身份校验，比如某两个子块合并后校验权限A，某三个子块合并后校验权限B，这个扩展应用根据需要灵活考虑。</p>
<h3 id="块和对象的区别">块和对象的区别</h3>
<ol>
<li>块：代表的是文件分割后的一部分，可以通过如下命令查看块信息，只有hash和对应的大小：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs block stat QmZCxwMMGar8RDc4ckezyL1uNS2ACKKyUvh6kDc6g2urHP</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Key: QmZCxwMMGar8RDc4ckezyL1uNS2ACKKyUvh6kDc6g2urHP</span><br><span class="line">Size: 262158</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>对象：一般代表的是在IPFS中存储的一个完整文件，当然，块也可以理解是一个对象。查看信息，比如块hash用如下命令查看：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs object stat QmZCxwMMGar8RDc4ckezyL1uNS2ACKKyUvh6kDc6g2urHP</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NumLinks:       0</span><br><span class="line">BlockSize:      262158</span><br><span class="line">LinksSize:      4      # 链接本身也是有容量等</span><br><span class="line">DataSize:       262154 </span><br><span class="line">CumulativeSize: 262158</span><br></pre></td></tr></table></figure>
<p>可以看出输出结果明显比用块查看多出很多信息，入链接数、块大小、对象大小等</p>
<h3 id="操作block">操作Block</h3>
<p>对于小的文件(小于256Kb)，可以直接使用block来操作，能够提高处理效率。</p>
<ol>
<li>block存储小数据</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;hello jason block&quot; | ipfs block put</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">QmQbQ6mZ79dj7VSXUZWDfLavVvwEYkRrhbpELMDP3J4CtY</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>block读取小数据</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs block get QmQbQ6mZ79dj7VSXUZWDfLavVvwEYkRrhbpELMDP3J4CtY</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hello jason block</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>查看block信息</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs block stat QmQbQ6mZ79dj7VSXUZWDfLavVvwEYkRrhbpELMDP3J4CtY</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Key: QmQbQ6mZ79dj7VSXUZWDfLavVvwEYkRrhbpELMDP3J4CtY</span><br><span class="line">Size: 18</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>删除</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs block rm QmQbQ6mZ79dj7VSXUZWDfLavVvwEYkRrhbpELMDP3J4CtY</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">removed QmQbQ6mZ79dj7VSXUZWDfLavVvwEYkRrhbpELMDP3J4CtY</span><br></pre></td></tr></table></figure>
<h3 id="操作object">操作Object</h3>
<ol>
<li>创建IPFS DAG对象</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;hello jason object&quot; | ipfs add</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">added QmZU1y9z8WxQJLAxQHrqFDrQsmLrLYuHiCfMYhbLFP8S43 QmZU1y9z8WxQJLAxQHrqFDrQsmLrLYuHiCfMYhbLFP8S43</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>返回对象数据，输出JSON格式</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs object get QmZU1y9z8WxQJLAxQHrqFDrQsmLrLYuHiCfMYhbLFP8S43</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;&quot;Links&quot;:[],&quot;Data&quot;:&quot;\u0008\u0002\u0012\u0013hello jason object\n\u0018\u0013&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出返回两个字段：Links子块链接和Data数据<br>
3. 返回解码后的数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs object data QmZU1y9z8WxQJLAxQHrqFDrQsmLrLYuHiCfMYhbLFP8S43</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hello jason object</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>为已有数据追加新数据</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;patch info&quot; &gt; ./patch.txt</span><br><span class="line">ipfs object patch append-data QmZU1y9z8WxQJLAxQHrqFDrQsmLrLYuHiCfMYhbLFP8S43 ./patch.txt</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">QmfDtGvBafCPCoR6hNetXAgBZ2kg4Y2CPpfHL2RRGU38z2</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>解析新内容</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs object data QmfDtGvBafCPCoR6hNetXAgBZ2kg4Y2CPpfHL2RRGU38z2</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hello jason object</span><br><span class="line">patch info</span><br></pre></td></tr></table></figure>
<h2 id="ipfs消息发布">IPFS消息发布</h2>
<p>该功能当前属于实验功能(<code>记忆从0.4版本到今天0.8版本这个功能一直处于实验阶段</code>)，需要在启动IPFS节点的时候，带入如下参数，开启消息功能：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs daemon --enable-pubsub-experiment</span><br></pre></td></tr></table></figure>
<h3 id="相关主要命令">相关主要命令</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出本节点订阅的全部主题</span></span><br><span class="line">ipfs pubsub ls</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出与本节点相连接的开通pubsub功能的节点</span></span><br><span class="line">ipfs pubsub peers</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发布数据到相应的主题</span></span><br><span class="line">ipfs pubsub pub &lt;topic&gt;&lt;data&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">订阅主题</span></span><br><span class="line">ipfs pubsub sub &lt;topic&gt;</span><br></pre></td></tr></table></figure>
<h3 id="实际操作">实际操作</h3>
<p>多节点模拟主题发布与订阅，需先确保各个节点的私有环境，排除外界其余关联节点的干扰。比如A、B两个节点，将B节点关联到A节点</p>
<ol>
<li>在A节点订阅主题<code>topic-A</code>，如此凡是发往这个这个主题的消息，都会被A接收</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs pubsub sub topic-A</span><br></pre></td></tr></table></figure>
<p>此时A处于接收状态<br>
2. 在B节点对主题<code>topic-A</code>发布消息<code>Hello Jason</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs pubsub pub topic-A &quot;Hello Jason&quot;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>
<p>此时A节点收到B节点发来的信息：<code>Hello Jason</code></p>
</li>
<li>
<p>扩展：消息可以通过中间节点转发：A-&gt;C-&gt;B，就是说即使C不订阅任何主题，只要B订阅了A的主题，依旧能经过C来接收到</p>
</li>
</ol>
<h3 id="应用场景">应用场景</h3>
<ol>
<li>可以用于及时通信</li>
<li>可用于分布式数据库</li>
</ol>
<h2 id="总结">总结</h2>
<p>本文综合介绍了IPFS的一些高级操作，能够更深的了解一些IPFS的应用层的技术逻辑，对后续业务层应用会起到一定的帮助。</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ipfs</category>
        <category>ipfs基础</category>
      </categories>
      <tags>
        <tag>ipfs</tag>
      </tags>
  </entry>
  <entry>
    <title>IPFS主要命令汇总</title>
    <url>/articles/5ce15195/</url>
    <content><![CDATA[<p>本文主要是汇总一些IPFS常用的命令，方便查询。</p>
<span id="more"></span>
<h2 id="配置ipfs存储目录">配置IPFS存储目录</h2>
<p>设置IPFS_PATH环境命令，默认值为：~/.ipfs</p>
<h2 id="根命令">根命令</h2>
<table>
<thead>
<tr>
<th>选项标识</th>
<th>选项类型</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c,-config</td>
<td>string</td>
<td>指定配置文件所在路径</td>
</tr>
<tr>
<td>-D,-debug</td>
<td>bool</td>
<td>以debug模式操作，缺省为false</td>
</tr>
<tr>
<td>-help</td>
<td>bool</td>
<td>展示完整的命令帮助文档，缺省为false</td>
</tr>
<tr>
<td>-h</td>
<td>bool</td>
<td>展示精简命令帮助文档，缺省为false</td>
</tr>
<tr>
<td>-L,-local</td>
<td>bool</td>
<td>在本地运行命令，缺省为false</td>
</tr>
<tr>
<td>-api</td>
<td>string</td>
<td>使用具体的API实例（缺省为/ip4/127.0.0.1/tcp/5001）</td>
</tr>
</tbody>
</table>
<h2 id="子命令">子命令</h2>
<h3 id="基础命令">基础命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>init</td>
<td>初始化IPFS本地配置</td>
</tr>
<tr>
<td>add(path)</td>
<td>添加一个文件到IPFS</td>
</tr>
<tr>
<td>cat(ref)</td>
<td>展示IPFS对象数据</td>
</tr>
<tr>
<td>get(ref)</td>
<td>下载IPFS对象</td>
</tr>
<tr>
<td>ls(ref)</td>
<td>从一个对象中列出链接</td>
</tr>
<tr>
<td>Refs(ref)</td>
<td>从一个对象中列出链接哈希</td>
</tr>
</tbody>
</table>
<h3 id="ipfs数据结构命令">IPFS数据结构命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>block</td>
<td>与数据存储中的原始块交互</td>
</tr>
<tr>
<td>object</td>
<td>与原始DAG节点交互</td>
</tr>
<tr>
<td>fils</td>
<td>将对象抽象为UNIX文件系统，并与对象交互</td>
</tr>
<tr>
<td>dag</td>
<td>与IPLD文件交互（<code>是否已上线？</code>）</td>
</tr>
</tbody>
</table>
<h3 id="ipfs高级命令">IPFS高级命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>daemon</td>
<td>开启IPFS运行后台进程</td>
</tr>
<tr>
<td>mount</td>
<td>挂载一个IPFS只读的挂载点</td>
</tr>
<tr>
<td>resolve</td>
<td>解析多类型CID名称</td>
</tr>
<tr>
<td>name</td>
<td>发布并解析IPNS名字</td>
</tr>
<tr>
<td>key</td>
<td>发布并列出IPNS名字密钥对</td>
</tr>
<tr>
<td>dns</td>
<td>解析DNS链接</td>
</tr>
<tr>
<td>pin</td>
<td>将对象锁定到本地存储</td>
</tr>
<tr>
<td>repo</td>
<td>操作IPFS仓库</td>
</tr>
<tr>
<td>stats</td>
<td>各种操作状态</td>
</tr>
<tr>
<td>filestore</td>
<td>管理文件仓库(实验中)</td>
</tr>
</tbody>
</table>
<h3 id="ipfs网络通信命令表">IPFS网络通信命令表</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>展示IPFS节点信息</td>
</tr>
<tr>
<td>bootstrap</td>
<td>添加或删除引导节点</td>
</tr>
<tr>
<td>swarm</td>
<td>管理P2P网络链接</td>
</tr>
<tr>
<td>dht</td>
<td>请求有关值或节点的分布式哈希表</td>
</tr>
<tr>
<td>ping</td>
<td>测量一个连接的延迟</td>
</tr>
<tr>
<td>diag</td>
<td>打印诊断信息</td>
</tr>
</tbody>
</table>
<h3 id="ipfs工具命令命令">IPFS工具命令命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>config</td>
<td>管理配置</td>
</tr>
<tr>
<td>version</td>
<td>展示IPFS版本信息</td>
</tr>
<tr>
<td>update</td>
<td>下载并应用go-ipfs更新</td>
</tr>
<tr>
<td>commands</td>
<td>列出所有可用命令</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ipfs</category>
        <category>ipfs基础</category>
      </categories>
      <tags>
        <tag>ipfs</tag>
      </tags>
  </entry>
  <entry>
    <title>IPFS基础-基础操作</title>
    <url>/articles/600687bc/</url>
    <content><![CDATA[<p>本文主要是综合的介绍IPFS的命令行使用方式，掌握对文件的基本操作，同时从整体上对IPFS有一个初步的了解。</p>
<span id="more"></span>
<h2 id="ipfs初始化">IPFS初始化</h2>
<h3 id="初始化">初始化</h3>
<p>首次使用IPFS时，需要执行该命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化IPFS仓库，会在~/.ipfs目录中生成初始化文件，</span></span><br><span class="line">ipfs init</span><br></pre></td></tr></table></figure>
<p>该命令执行后，会被周围的公共节点发现该节点，如果不想被发现，或者在私有服务器使用IPFS，可以执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs init --profile server</span><br></pre></td></tr></table></figure>
<h3 id="初始化文件说明">初始化文件说明</h3>
<p>在<code>~/.ipfs</code>中，会生成如下几个文件：</p>
<ol>
<li><code>blocks</code>：本地仓库存储的CID文件块链接目录</li>
<li><code>keystore</code>：密钥对文件存储目录</li>
<li><code>datastore</code>：LevelDB数据文件目录</li>
<li><code>config</code>：配置文件(非目录),json格式</li>
<li><code>version</code>：文件，记录当前IPFS的版本号</li>
</ol>
<h3 id="ipfs存储文件目录设置">IPFS存储文件目录设置</h3>
<p>在环境变量中，设置<code>$IPFS_PATH</code>，docker镜像的默认地址设置为了：<code>/data/ipfs/</code>，其余默认一般为：<code>~/.ipfs</code></p>
<h3 id="config配置文件说明">config配置文件说明</h3>
<p>配置文件无疑是当前最关心的内容，后续可根据需要来调整配置，具体内容如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;API&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>   <span class="comment">//节点API配置</span></span><br><span class="line">    <span class="attr">&quot;HTTPHeaders&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Addresses&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>   <span class="comment">//节点网络通信multiaddress配置</span></span><br><span class="line">    <span class="attr">&quot;API&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/ip4/0.0.0.0/tcp/5001&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Announce&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Gateway&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/ip4/0.0.0.0/tcp/8080&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;NoAnnounce&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Swarm&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;/ip4/0.0.0.0/tcp/4001&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;/ip6/::/tcp/4001&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;/ip4/0.0.0.0/udp/4001/quic&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;/ip6/::/udp/4001/quic&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;AutoNAT&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Bootstrap&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>   <span class="comment">//中继节点multiaddress配置</span></span><br><span class="line">    <span class="string">&quot;/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;/ip4/104.131.131.82/tcp/4001/p2p/QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;/ip4/104.131.131.82/udp/4001/quic/p2p/QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Datastore&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  <span class="comment">//存储配置</span></span><br><span class="line">    <span class="attr">&quot;BloomFilterSize&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;GCPeriod&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1h&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;HashOnRead&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Spec&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;mounts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;child&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;blocks&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;shardFunc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/repo/flatfs/shard/v1/next-to-last/2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;sync&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;flatfs&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;mountpoint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/blocks&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;flatfs.datastore&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;measure&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;child&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;compression&quot;</span><span class="punctuation">:</span> <span class="string">&quot;none&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;datastore&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;levelds&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;mountpoint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;leveldb.datastore&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;measure&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mount&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;StorageGCWatermark&quot;</span><span class="punctuation">:</span> <span class="number">90</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;StorageMax&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10GB&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Discovery&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  <span class="comment">//LibP2P Discovery配置</span></span><br><span class="line">    <span class="attr">&quot;MDNS&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Interval&quot;</span><span class="punctuation">:</span> <span class="number">10</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Experimental&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>   <span class="comment">//实验功能开关配置</span></span><br><span class="line">    <span class="attr">&quot;FilestoreEnabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;GraphsyncEnabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Libp2pStreamMounting&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;P2pHttpProxy&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ShardingEnabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;StrategicProviding&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;UrlstoreEnabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Gateway&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>   <span class="comment">//HTTP 网关配置</span></span><br><span class="line">    <span class="attr">&quot;APICommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;HTTPHeaders&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Access-Control-Allow-Headers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;X-Requested-With&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;Range&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Access-Control-Allow-Methods&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;GET&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Access-Control-Allow-Origin&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;*&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;NoDNSLink&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;NoFetch&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;PathPrefixes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;PublicGateways&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;RootRedirect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Writable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Identity&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  <span class="comment">//节点身份信息</span></span><br><span class="line">    <span class="attr">&quot;PeerID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;12D3KooWSVzdPE1nXHAh9CyqAayFA8psJ9n6DwTkByiD8gWnm9b1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;PrivKey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CAESQMQL3NrWkdjsQ++yxdWvlnCSaltDpYTKRA4+CRZhibgQ9+Hd9lslOXRd0pF4dqCtOIMHMpgtbTVaqba5bfOqYeQ=&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Ipns&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>   <span class="comment">//Ipns配置</span></span><br><span class="line">    <span class="attr">&quot;RecordLifetime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;RepublishPeriod&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ResolveCacheSize&quot;</span><span class="punctuation">:</span> <span class="number">128</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Mounts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  <span class="comment">//文件系统挂载配置</span></span><br><span class="line">    <span class="attr">&quot;FuseAllowOther&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;IPFS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/ipfs&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;IPNS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/ipns&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Peering&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Peers&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Pinning&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;RemoteServices&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Plugins&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Provider&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Strategy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Pubsub&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;DisableSigning&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Router&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Reprovider&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Interval&quot;</span><span class="punctuation">:</span> <span class="string">&quot;12h&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Strategy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;all&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Routing&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dht&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Swarm&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  <span class="comment">//P2P Swarm配置</span></span><br><span class="line">    <span class="attr">&quot;AddrFilters&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ConnMgr&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;GracePeriod&quot;</span><span class="punctuation">:</span> <span class="string">&quot;20s&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;HighWater&quot;</span><span class="punctuation">:</span> <span class="number">900</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;LowWater&quot;</span><span class="punctuation">:</span> <span class="number">600</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;basic&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;DisableBandwidthMetrics&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;DisableNatPortMap&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;EnableAutoRelay&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;EnableRelayHop&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Transports&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Multiplexers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Network&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Security&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="加入ipfs网络环境">加入IPFS网络环境</h2>
<h3 id="接入网络">接入网络</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs daemon</span><br></pre></td></tr></table></figure>
<p>通过该命令，可以将本机的IPFS连接到公网的IPFS网络，同时启动了HTTP网关服务，方便后续HTTP WEB交互</p>
<h3 id="查看对等方ipfs节点信息">查看对等方IPFS节点信息</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs swarm peers</span><br></pre></td></tr></table></figure>
<p>执行后，可以看到有大量节点地址</p>
<h2 id="与ipfs进行交互">与IPFS进行交互</h2>
<h3 id="添加文件">添加文件</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;hello jason&quot; &gt; test.txt</span><br><span class="line">ipfs add test.txt </span><br></pre></td></tr></table></figure>
<p>此时控制台返回结果：<code>added QmcMR7dqXvUxgCXpwmKHyeu4mbwGAfvd5zoa7fY4UYmtPP test.txt</code><br>
表示<code>test.txt</code>文件在IPFS的hash地址(CID)为：<code>QmcMR7dqXvUxgCXpwmKHyeu4mbwGAfvd5zoa7fY4UYmtPP</code></p>
<h3 id="读取文件">读取文件</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs cat QmcMR7dqXvUxgCXpwmKHyeu4mbwGAfvd5zoa7fY4UYmtPP</span><br></pre></td></tr></table></figure>
<p>读出的内容和<code>test.txt</code>中完全一致：<code>hello jason</code></p>
<h3 id="验证内容唯一性">验证内容唯一性</h3>
<p>只要文件内容不变，则CID不变</p>
<h3 id="写入文件的名称和目录信息">写入文件的名称和目录信息</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs add -w test.txt</span><br></pre></td></tr></table></figure>
<p>返回两个<code>CID</code>，具体输出结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">added QmcMR7dqXvUxgCXpwmKHyeu4mbwGAfvd5zoa7fY4UYmtPP test.txt</span><br><span class="line">added QmY8utLB2d9KKpjaR3mhTngqYc1grAZDnTaXgMfMzUsXGT </span><br></pre></td></tr></table></figure>
<p>其中第一条问文件内容的CID；第二条指向的是一个目录（即 <code>IPFS Wrapped</code>），记录了文件内容的文件内容的CID、文件名、文件大小、</p>
<h3 id="读取ipfs-wrapped获取文件信息">读取IPFS Wrapped获取文件信息</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs ls -v QmY8utLB2d9KKpjaR3mhTngqYc1grAZDnTaXgMfMzUsXGT</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Hash                                           Size Name</span><br><span class="line">QmcMR7dqXvUxgCXpwmKHyeu4mbwGAfvd5zoa7fY4UYmtPP 12   test.txt</span><br></pre></td></tr></table></figure>
<p><code>IPFS Wrapped</code>的CID为目录，因此只能用<code>ls</code>命令，不能用<code>cat</code>命令，<code>-v</code>是将字段描述展示出来。</p>
<h3 id="通过父目录来获取文件内容">通过父目录来获取文件内容</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs cat QmY8utLB2d9KKpjaR3mhTngqYc1grAZDnTaXgMfMzUsXGT/test.txt</span><br></pre></td></tr></table></figure>
<p>地址就是那个<code>IPFS Wrapped</code>的CID</p>
<h3 id="查看哪些节点存储了指定文件">查看哪些节点存储了指定文件</h3>
<p>这里通过<code>test.txt</code>的CID来查看有哪些节点存储了这个文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs dht findprovs QmcMR7dqXvUxgCXpwmKHyeu4mbwGAfvd5zoa7fY4UYmtPP</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">12D3KooWSVzdPE1nXHAh9CyqAayFA8psJ9n6DwTkByiD8gWnm9b1</span><br></pre></td></tr></table></figure>
<p>可以看出，输出的是本机的节点地址，也就是当前只有本机节点存储了这个文件</p>
<h2 id="与http-web交互">与HTTP Web交互</h2>
<h3 id="前提要求">前提要求</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一定要先启动守护进程</span></span><br><span class="line">ipfs daemon</span><br></pre></td></tr></table></figure>
<h3 id="从本地http网关中获取ipfs数据">从本地HTTP网关中获取IPFS数据</h3>
<p>在浏览器地址中输入如下内容，地址可以是localhost，也可以是远端的指定地址。默认是8080端口为web端口，我用的是自己的docker镜像，将端口映射为了8081</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://localhost:8081/ipfs/QmcMR7dqXvUxgCXpwmKHyeu4mbwGAfvd5zoa7fY4UYmtPP</span><br></pre></td></tr></table></figure>
<p>页面输出的就是<code>test.txt</code>的内容：<code>hello jason</code></p>
<h3 id="从公共http网关获取ipfs数据">从公共HTTP网关获取IPFS数据</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://ipfs.io/ipfs/QmcMR7dqXvUxgCXpwmKHyeu4mbwGAfvd5zoa7fY4UYmtPP</span><br><span class="line">http://ipfs.infura.io/ipfs/QmcMR7dqXvUxgCXpwmKHyeu4mbwGAfvd5zoa7fY4UYmtPP</span><br></pre></td></tr></table></figure>
<p>基于IPFS的特点，既然我的IPFS节点已经和公共网络的连接上了，那在别的公共节点上，也应该能通过CID读取到我的<code>test.txt</code>内容，也就是说，以上两个链接也能访问到<code>test.txt</code>的内容。</p>
<h3 id="ipfs-web控制台">IPFS Web控制台</h3>
<p>IPFS自带一个web控制台，界面很简单，能够满足基础操作，端口号默认为<code>5001</code>，具体如下浏览器访问：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://localhost:5001/webui</span><br></pre></td></tr></table></figure>
<p>在启动<code>ipfs daemon</code>的情况下，默认的IPFS是无法远程访问web控制台的，或者不允许跨域请求，因此需要在节点上配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs config --json API.HTTPHeaders.Access-Control-Allow-Origin &#x27;[&quot;http://xx.xx.xx.xx:5001&quot;, &quot;http://localhost:3000&quot;, &quot;http://127.0.0.1:5001&quot;, &quot;https://webui.ipfs.io&quot;]&#x27;</span><br><span class="line">ipfs config --json API.HTTPHeaders.Access-Control-Allow-Methods &#x27;[&quot;PUT&quot;, &quot;POST&quot;]&#x27;</span><br></pre></td></tr></table></figure>
<p>具体IP和端口号需要自己根据实际情况调整。<br>
若依旧无法访问，检查下自己的接口是不是被防火墙拦截了，以下是我启动后的一张图示：</p>
<img src="/articles/600687bc/1.jpg" class="" title="IPFS Web控制台">
<img src="/articles/600687bc/2.jpg" class="" title="已存储文件">
<h2 id="在线调试工具">在线调试工具</h2>
<p>ipfs官方提供了一个线上环境，不用部署IPFS即可操作相关命令，线上环境地址：<code>https://ipfs.docs.apiary.io</code></p>
<h2 id="总结">总结</h2>
<p>本文只讲了IPFS的基础命令，而IPFS还有大量高级命令，需要自己根据官方文档逐步去了解。相信在此处，对IPFS的应用已经有了一定的基础。</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ipfs</category>
        <category>ipfs基础</category>
      </categories>
      <tags>
        <tag>ipfs</tag>
      </tags>
  </entry>
  <entry>
    <title>IPFS开篇-简单部署和私有环境部署</title>
    <url>/articles/25678954/</url>
    <content><![CDATA[<p>2018年也曾有一段时间在研究IPFS并在项目中应用，也写了一篇类似文章：<a href="/articles/7987f3ac/index.html">ipfs私有环境搭建</a>，一晃眼已经3年了，<br>
兜兜转转，我又重新拿起了IPFS，因为这三年的经历以及现在所处的工作环境让我明白，它的价值是毋庸置疑的。现在的IPFS也非曾经的IPFS，很有必要在重新掌握一遍。</p>
<span id="more"></span>
<h2 id="简介">简介</h2>
<p>IPFS的安装有多种方式，早前我<a href="/articles/7987f3ac/index.html">ipfs私有环境搭建</a>文中是通过docker来安装部署的，今天在测试环境下，为了确保环境干净，我依旧选择docker，<br>
但不同的是，这次选择使用<code>docker</code>+<code>docker-compose</code>方式，尽可能简化安装过程，毕竟，我的目的是要了解其内部具体工作流程，不要把太多精力花在安装部署上。<br>
因此，首先确保你的环境安装有docker和docker-compose</p>
<h2 id="单机部署">单机部署</h2>
<h3 id="下载脚本">下载脚本</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/bitxx/docker_bash.git</span><br><span class="line">cd docker_bash</span><br></pre></td></tr></table></figure>
<p>我将常用的一些docker镜像都集成到上面的脚本中了，下载后，有兴趣可以看看，在这里主要就是关注IPFS在docker-compose.yml中的编排</p>
<h3 id="启动ipfs容器">启动IPFS容器</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./main.sh start ipfs</span><br></pre></td></tr></table></figure>
<p>该操作可以通过docker-compose将IPFS启动</p>
<h3 id="进入ipfs容器">进入IPFS容器</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./main.sh exec ipfs</span><br></pre></td></tr></table></figure>
<ol>
<li>该操作可以直接进入到IPFS容器中，然后操作ipfs的各种命令，比如第一条命令，查看版本号：<code>ipfs --version</code></li>
<li>在容器内部，ipfs实例已运行，也就是<code>ipfs init</code>在容器启动前就已经完成了，文件默认存储位置在<code>/data/ipfs/</code></li>
</ol>
<h3 id="停止ipfs容器">停止IPFS容器</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./main.sh release ipfs</span><br></pre></td></tr></table></figure>
<p>该操作将会停止并清除IPFS容器，当然，映射出来的文件依旧存在，下次重新启动后，依旧可以继续读取先前保存的内容。</p>
<h2 id="私有环境部署">私有环境部署</h2>
<p>最好熟悉IPFS基本操作之后，回头在考虑私有环境多节点部署。<br>
默认节点启动后，会根据内置默认的关联信息，去连接公网的IPFS节点。如果要建立私有环境，需要删除关联节点信息，逐个加入指定节点，并且这些节点使用相同的私钥。这里就不详细说明部署过程了，后期根据思路逐步来部署。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs bootstrap rm all</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>官方也提供了IPFS的多种安装方式，有直接安装二进制命令行的，有可视化安装本地客户端的等等，都可以试试。本文我只是根据自己情况，为简化流程，<br>
使用自己封装的脚本来运行IPFS。一个节点启动后，后续即可用于掌握命令或者掌握程序对接和调用。</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ipfs</category>
        <category>ipfs基础</category>
      </categories>
      <tags>
        <tag>ipfs</tag>
      </tags>
  </entry>
  <entry>
    <title>fabric基础-综合简介</title>
    <url>/articles/4636a38c/</url>
    <content><![CDATA[<p>fabric的背景、作用等等，这里就不介绍了，网上一搜一大堆。本文主要从技术层面来讲解fabric的特点、主要概念以及架构，从而能够快速对fabric能有一个整体上的认知。</p>
<span id="more"></span>
<h2 id="总体架构">总体架构</h2>
<img src="/articles/4636a38c/1.png" class="" title="Fabric架构">
<p>图中可知主要分为：网络层、核心层、接口层。</p>
<ol>
<li>
<p>网络层<br>
负责P2P网络的实现，取保区块链分布式存储的一致性。使用了gRPC协议以及Gossip协议。</p>
</li>
<li>
<p>接口层<br>
给第三方提供API、可通过Events监控事件，方便第三方应用调用和处理</p>
</li>
<li>
<p>核心层</p>
<ol>
<li>成员服务：包括注册、登记、申请证书等，为保证联盟成员数据的安全性，必须获得证书才能加入链中。</li>
<li>区块链服务：负责账本的计算和存储、节点的排序服务、背书验证管理以及账本存储方式等功能等实现</li>
<li>链码服务：智能合约，用于支撑业务</li>
</ol>
</li>
</ol>
<h2 id="交易流程">交易流程</h2>
<ol>
<li>交易流程是Fabric的核心运行机制以及整体运行原理，很有必要去完整掌握。</li>
<li>Fabric中，并不是像公链那样一个节点集中处理各种问题，而是根据功能到不同，划分为了不同的节点和角色。大体上节点分为：处理业务的Peer节点以及用于达成排序共识的Order节点，其中Peer节点根据不同功能，还可具体划分为不同角色的节点，如背书节点Peer、提交节点Peer。关于节点概念、功能和细节，后续逐步会去详细讲解，在此只要有个大概了解即可。</li>
<li>在Fabric中，处理每笔交易都需要都需要对交易信息进行权限校验，确保上链的数据是经过授权允许的。</li>
</ol>
<h3 id="流程描述-重点掌握">流程描述（重点掌握）</h3>
<img src="/articles/4636a38c/3.png" class="" title="Fabric交易流程">
<ol>
<li>应用程序客户端通过SDK调用成员服务，进行注册、登记并获取身份证书</li>
<li>应用程序客户端通过SDK向区块链网络发起一个交易提案(Proposal)，交易提案把本次交易要调用的合约标识，合约方法和参数信息以及客户端签名等信息发送给背书节点。</li>
<li>背书节点收到交易提案后，验证签名并确定交易者是否有权执行操作，同时根据背书策略模拟执行智能合约，并将结果及各自的CA证书签名返回给应用程序客户端。</li>
<li>应用程序客户端收到背书节点返回的信息后，判断提案结果是否一致，以及是否参照指定的背书策略执行。如果没有足够的背书，则终止处理；否则，应用程序客户端把数据打包到一起，组成一个交易并签名，发送给排序节点（角色）。</li>
<li>排序节点（角色）对接收到的交易进行共识排序，然后按照区块生成策略，将一批交易打包到一起，生成新的区块，发送给提交节点(Peer)。</li>
<li>提交节点收到区块后，会对区块中的每笔交易进行校验，检查交易依赖的输入输出是否符合当前区块链的状态，完成后将区块追加到本地的区块链，并修改世界状态(即确保参数为最新值)</li>
</ol>
<h2 id="关键技术">关键技术</h2>
<p>Fabric的关键技术主要分为：<code>账本</code>、<code>智能合约</code>、<code>通道</code>、<code>节点</code>、<code>排序</code>、<code>接口</code>，通过这六部分底层内容的了解，可以很好的了解Fabric的运行机制</p>
<h3 id="1-账本-ledger">1. 账本(Ledger)</h3>
<p>主要是区块本身以及世界状态的存储，有序、防篡改。</p>
<img src="/articles/4636a38c/2.png" class="" title="Fabric交易流程">
<ol>
<li>本地文件系统<br>
将区块存储于文件系统的硬盘中，每个区块中保存区块头(Block Header)、区块数据(Block Data)、区块元数据(Block Metadata，<code>配置相关信息?</code>)，通过区块头中的前一个区块的哈希值指向前一个区块区块的当前哈希值。</li>
<li>状态数据库<br>
存储在链交易中出现的所有键值对的最新值，调用链码执行交易可改变状态数据。为了高效执行联码调用，最新值都保存在状态数据库中。默认状态数据库为LevelDB（特点：简单的KV），可选择Couchdb作为数据库（特点：富文本查询）。</li>
<li>账本索引数据库<br>
文件系统中保存区块时，会在数据库(LevelDB)中保存索引。提高查询区块交易信息的速度。<code>注意这里跟状态数据库无关，状态数据库更多的是链码对应的业务数据。</code></li>
<li>历史状态数据库<br>
一个键值更改后，更改的历史记录是保存在数据库中的。同样可以使用LevelDB或CouchDB，查询状态的时候，也可以查看值的历史更改记录。</li>
</ol>
<h3 id="2-智能合约-chaincode">2. 智能合约(Chaincode)</h3>
<p>用于处理业务的代码，稍微了解区块链的人应该都明白这个概念，只是Fabric中，更喜欢用<code>链码</code>来表达智能合约的意思。由于Fabric的授权机制，<code>链码</code>的生命周期较为复杂，其中1.4版和2.0版的生命周期差异很大，从打包、签名到最终安装、发布，涉及的细节较多，后续会专门来讲解这部分内容，这里有个了解即可。后续更多的是以2.0版为主来讲解。</p>
<h3 id="3-通道-channel">3. 通道(Channel)</h3>
<ol>
<li>一条channel可以理解为是一条独立的区块链，在其中拥有独立的创世区块以及智能合约。它是Peer之间通信的私有空间，channel内交易的数据与外部环境隔绝，保证channel内部数据安全。一条channel内部参与交易的成员，都需要经过身份验证和授权。</li>
<li>Fabric网络是多通道设计，也就是说，一个Peer节点可以同时加入不同的channel。</li>
<li>每个Channel都有自己的锚节点，通过锚节点可以与其它通道进行交互（比如合约内，可以通过锚节点访问另一个通道的某个参数），但本身通道的账本是隔绝的。</li>
</ol>
<h3 id="4-peer节点">4. Peer节点</h3>
<ol>
<li>是区块链交易处理和账本维护的主体，主要负责参与共识过程和通过执行链码实现对账本的读写操作。</li>
<li>Peer节点根据功能不同可以划分为：<code>背书节点(Endorser Peer)</code>、<code>提交节点(Committer Peer)</code>
<ol>
<li>背书节点(Endorser Peer)：根据事先设定好的策略对交易进行签名背书，在链码实例化的时候设置背书策略，指定哪些节点用于背书。当客户端向节点发起交易背书时，该节点才能有背书功能，否则只是普通的记账节点。</li>
<li>提交节点(Committer Peer)：也是普通的记账节点，负责维护状态数据和账本的副本。</li>
</ol>
</li>
<li>Peer节点根据通信不同可以划分为：<code>锚节点(Anchor Peer)</code>、<code>主节点(Leading Peer)</code>
<ol>
<li>锚节点(Anchor Peer)：随channel存在的，是能被其它channel发现的节点，每个channel上有一个或多个锚节点。</li>
<li>主节点(Leading Peer)：负责与Order通信，把共识后的区块传输到其它节点。</li>
</ol>
</li>
</ol>
<h3 id="5-order排序">5. Order排序</h3>
<p>对区块链网络中不同通道产生的交易进行排序，并广播给Peer。排序算法Fabric支持多种，如：Solo、Kafka、Raft等，Fabric2.0后，以Raft为主。</p>
<h3 id="6-api接口">6. API接口</h3>
<p>方便第三方调用账本、chaincode、channel、节点、排序等</p>
<h2 id="总结">总结</h2>
<p>本文主要介绍了Fabric的几个核心概念，通过这些概念能够对运行机制和原理有一个初步的了解。为后续深入掌握奠定了一个比较好的基础。</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Hyperledger Fabric</category>
      </categories>
      <tags>
        <tag>Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>fabric-samples基本使用（3）- 合约部署及操作</title>
    <url>/articles/b7ef0ae1/</url>
    <content><![CDATA[<p>前面两个章节，已经搭建好了一个基本的fabric测试网络，在已有基础上，本文在其中加入智能合约，也就是<code>chaincode</code>，如此一条用于测试的fabric联盟链就算完整了。后续就可以在该测试链基础上研究fabric的具体细节了。</p>
<span id="more"></span>
<h2 id="前述">前述</h2>
<ol>
<li>请先看<a href="/articles/79376746/index.html">fabric-samples基本使用（1）- 下载准备</a>以及<a href="/articles/3b7f5326/index.html">fabric-samples基本使用（2）- 启动测试网络</a></li>
<li><code>chaincode</code>目前支持goalng、java来实现，考虑到技术栈和远期规划，这里我还是以golang为主，本文测试网络将会调用官方提供的demo合约。</li>
</ol>
<h2 id="使用方式">使用方式</h2>
<p>先确保网络已经正常启动</p>
<h3 id="1-发布合约">1. 发布合约</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里使用官方测试案例fabcar</span></span><br><span class="line">./network.sh deployCC -ccn fabcar -ccp ../chaincode/fabcar/go/ -ccl go</span><br></pre></td></tr></table></figure>
<p>在官方测试网络提供的脚本中，只有这一条命令即可发布一条合约，早前版本的脚本，如果不传入参数，会默认调用官方的<code>fabCar</code>合约来发布，但当前最新版脚本强制要求指定合约，<br>
应该是为了让脚本更加通用。<br>
这里强制要求最少传入三个参数：<code>合约名称 -ccn</code>、<code>合约路径 -ccp</code>、<code>合约开发语言 -ccl</code>，其余可选参数，如策略等，若不传入，则使用官方提供的默认值。</p>
<h3 id="2-合约发布期间产生的日志">2. 合约发布期间产生的日志</h3>
<p>在fabric2.0，对合约的生命周期有了更细的划分，以下是<code>fabcar</code>合约发布整个流程的日志(无删减)，通过日志可以很快了解一个合约发布需要涉及到的主要步骤，这里每个步骤我在其中加入了描述</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 合约发布的环境描述，在&#x27;mychannel&#x27;中发布</span><br><span class="line">deploying chaincode on channel &#x27;mychannel&#x27;</span><br><span class="line">executing with the following</span><br><span class="line">- CHANNEL_NAME: mychannel</span><br><span class="line">- CC_NAME: fabcar</span><br><span class="line">- CC_SRC_PATH: ../chaincode/fabcar/go/</span><br><span class="line">- CC_SRC_LANGUAGE: go</span><br><span class="line">- CC_VERSION: 1.0</span><br><span class="line">- CC_SEQUENCE: 1</span><br><span class="line">- CC_END_POLICY: NA</span><br><span class="line">- CC_COLL_CONFIG: NA</span><br><span class="line">- CC_INIT_FCN: NA</span><br><span class="line">- DELAY: 3</span><br><span class="line">- MAX_RETRY: 5</span><br><span class="line">- VERBOSE: false</span><br><span class="line"></span><br><span class="line">2. 根据合约代码中go.mod描述的依赖，下载相关依赖</span><br><span class="line">Vendoring Go dependencies at ../chaincode/fabcar/go/</span><br><span class="line">~/go/src/github.com/hyperledger/fabric-samples/chaincode/fabcar/go ~/go/src/github.com/hyperledger/fabric-samples/test-network</span><br><span class="line">go: downloading github.com/hyperledger/fabric-contract-api-go v1.1.0</span><br><span class="line">go: downloading github.com/hyperledger/fabric-chaincode-go v0.0.0-20200424173110-d7076418f212</span><br><span class="line">go: downloading github.com/hyperledger/fabric-protos-go v0.0.0-20200424173316-dd554ba3746e</span><br><span class="line">go: downloading github.com/golang/protobuf v1.3.2</span><br><span class="line">go: downloading google.golang.org/grpc v1.23.0</span><br><span class="line">go: downloading github.com/xeipuuv/gojsonschema v1.2.0</span><br><span class="line">go: downloading github.com/go-openapi/spec v0.19.4</span><br><span class="line">go: downloading github.com/gobuffalo/packr v1.30.1</span><br><span class="line">go: downloading github.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415</span><br><span class="line">go: downloading github.com/go-openapi/jsonpointer v0.19.3</span><br><span class="line">go: downloading github.com/go-openapi/jsonreference v0.19.2</span><br><span class="line">go: downloading github.com/go-openapi/swag v0.19.5</span><br><span class="line">go: downloading github.com/gobuffalo/envy v1.7.0</span><br><span class="line">go: downloading github.com/gobuffalo/packd v0.3.0</span><br><span class="line">go: downloading golang.org/x/net v0.0.0-20190827160401-ba9fcec4b297</span><br><span class="line">go: downloading google.golang.org/genproto v0.0.0-20180831171423-11092d34479b</span><br><span class="line">go: downloading github.com/xeipuuv/gojsonpointer v0.0.0-20180127040702-4e3ac2762d5f</span><br><span class="line">go: downloading github.com/PuerkitoBio/purell v1.1.1</span><br><span class="line">go: downloading github.com/mailru/easyjson v0.0.0-20190626092158-b2ccc519800e</span><br><span class="line">go: downloading gopkg.in/yaml.v2 v2.2.8</span><br><span class="line">go: downloading github.com/joho/godotenv v1.3.0</span><br><span class="line">go: downloading github.com/rogpeppe/go-internal v1.3.0</span><br><span class="line">go: downloading golang.org/x/sys v0.0.0-20190710143415-6ec70d6a5542</span><br><span class="line">go: downloading github.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578</span><br><span class="line">go: downloading golang.org/x/text v0.3.2</span><br><span class="line">~/go/src/github.com/hyperledger/fabric-samples/test-network</span><br><span class="line">Finished vendoring Go dependencies</span><br><span class="line"></span><br><span class="line">3. 打包合约，将合约打包为*.tar.gz压缩包，里面是包含合约源码和上一步骤下载的依赖</span><br><span class="line">+ peer lifecycle chaincode package fabcar.tar.gz --path ../chaincode/fabcar/go/ --lang golang --label fabcar_1.0</span><br><span class="line">+ res=0</span><br><span class="line">Chaincode is packaged</span><br><span class="line"></span><br><span class="line">4-1. 为org1的peer0安装合约</span><br><span class="line">Installing chaincode on peer0.org1...</span><br><span class="line">Using organization 1</span><br><span class="line">+ peer lifecycle chaincode install fabcar.tar.gz</span><br><span class="line">+ res=0</span><br><span class="line">2021-04-22 12:37:21.229 CST [cli.lifecycle.chaincode] submitInstallProposal -&gt; INFO 001 Installed remotely: response:&lt;status:200 payload:&quot;\nKfabcar_1.0:b41ab9af76a078ae8af2b9897c51f6a0c401e4c6c777414d766698b1b7fac00a\022\nfabcar_1.0&quot; &gt; </span><br><span class="line">2021-04-22 12:37:21.229 CST [cli.lifecycle.chaincode] submitInstallProposal -&gt; INFO 002 Chaincode code package identifier: fabcar_1.0:b41ab9af76a078ae8af2b9897c51f6a0c401e4c6c777414d766698b1b7fac00a</span><br><span class="line">Chaincode is installed on peer0.org1</span><br><span class="line"></span><br><span class="line">4-2. 为org2的peer0安装合约</span><br><span class="line">Install chaincode on peer0.org2...</span><br><span class="line">Using organization 2</span><br><span class="line">+ peer lifecycle chaincode install fabcar.tar.gz</span><br><span class="line">+ res=0</span><br><span class="line">2021-04-22 12:37:43.834 CST [cli.lifecycle.chaincode] submitInstallProposal -&gt; INFO 001 Installed remotely: response:&lt;status:200 payload:&quot;\nKfabcar_1.0:b41ab9af76a078ae8af2b9897c51f6a0c401e4c6c777414d766698b1b7fac00a\022\nfabcar_1.0&quot; &gt; </span><br><span class="line">2021-04-22 12:37:43.850 CST [cli.lifecycle.chaincode] submitInstallProposal -&gt; INFO 002 Chaincode code package identifier: fabcar_1.0:b41ab9af76a078ae8af2b9897c51f6a0c401e4c6c777414d766698b1b7fac00a</span><br><span class="line">Chaincode is installed on peer0.org2</span><br><span class="line"></span><br><span class="line">5. 检查org1的peer0安装了哪些合约，这里可以看出成功安装了fabcar_1.0</span><br><span class="line">Using organization 1</span><br><span class="line">+ peer lifecycle chaincode queryinstalled</span><br><span class="line">+ res=0</span><br><span class="line">Installed chaincodes on peer:</span><br><span class="line">Package ID: fabcar_1.0:b41ab9af76a078ae8af2b9897c51f6a0c401e4c6c777414d766698b1b7fac00a, Label: fabcar_1.0</span><br><span class="line">Query installed successful on peer0.org1 on channel</span><br><span class="line"></span><br><span class="line">6-1. 在org1的peer0授权合约，就是说合约规则默认要求多个组织确认后，才可以上链，可以理解为多签。</span><br><span class="line">Using organization 1</span><br><span class="line">+ peer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile /root/go/src/github.com/hyperledger/fabric-samples/test-network/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem --channelID mychannel --name fabcar --version 1.0 --package-id fabcar_1.0:b41ab9af76a078ae8af2b9897c51f6a0c401e4c6c777414d766698b1b7fac00a --sequence 1</span><br><span class="line">+ res=0</span><br><span class="line">2021-04-22 12:37:46.658 CST [chaincodeCmd] ClientWait -&gt; INFO 001 txid [cbc8814b90142b71153fba5cd3aa276b25365d43bfbc07ec05f573094889933a] committed with status (VALID) at localhost:7051</span><br><span class="line">Chaincode definition approved on peer0.org1 on channel &#x27;mychannel&#x27;</span><br><span class="line"></span><br><span class="line">6-2. org1的peer0授权合约后，在org1的peer0检查合约在各组织的授权是否成功</span><br><span class="line">Using organization 1</span><br><span class="line">Checking the commit readiness of the chaincode definition on peer0.org1 on channel &#x27;mychannel&#x27;...</span><br><span class="line">Attempting to check the commit readiness of the chaincode definition on peer0.org1, Retry after 3 seconds.</span><br><span class="line">+ peer lifecycle chaincode checkcommitreadiness --channelID mychannel --name fabcar --version 1.0 --sequence 1 --output json</span><br><span class="line">+ res=0</span><br><span class="line">&#123;</span><br><span class="line">	&quot;approvals&quot;: &#123;</span><br><span class="line">		&quot;Org1MSP&quot;: true,</span><br><span class="line">		&quot;Org2MSP&quot;: false</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Checking the commit readiness of the chaincode definition successful on peer0.org1 on channel &#x27;mychannel&#x27;</span><br><span class="line"></span><br><span class="line">6-3. org1的peer0授权合约后，在org2的peer0检查合约在各组织的授权是否成功</span><br><span class="line">Using organization 2</span><br><span class="line">Checking the commit readiness of the chaincode definition on peer0.org2 on channel &#x27;mychannel&#x27;...</span><br><span class="line">Attempting to check the commit readiness of the chaincode definition on peer0.org2, Retry after 3 seconds.</span><br><span class="line">+ peer lifecycle chaincode checkcommitreadiness --channelID mychannel --name fabcar --version 1.0 --sequence 1 --output json</span><br><span class="line">+ res=0</span><br><span class="line">&#123;</span><br><span class="line">	&quot;approvals&quot;: &#123;</span><br><span class="line">		&quot;Org1MSP&quot;: true,</span><br><span class="line">		&quot;Org2MSP&quot;: false</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Checking the commit readiness of the chaincode definition successful on peer0.org2 on channel &#x27;mychannel&#x27;</span><br><span class="line"></span><br><span class="line">6-4. 在org2的peer0授权合约，就是说合约规则默认要求多个组织确认后，才可以上链，可以理解为多签。</span><br><span class="line">Using organization 2</span><br><span class="line">+ peer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile /root/go/src/github.com/hyperledger/fabric-samples/test-network/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem --channelID mychannel --name fabcar --version 1.0 --package-id fabcar_1.0:b41ab9af76a078ae8af2b9897c51f6a0c401e4c6c777414d766698b1b7fac00a --sequence 1</span><br><span class="line">+ res=0</span><br><span class="line">2021-04-22 12:37:55.389 CST [chaincodeCmd] ClientWait -&gt; INFO 001 txid [42c8e7326c69c7859d77ccdb9509d71ff3a3fbeeb98619972c3633b9dfff338e] committed with status (VALID) at localhost:9051</span><br><span class="line">Chaincode definition approved on peer0.org2 on channel &#x27;mychannel&#x27;</span><br><span class="line"></span><br><span class="line">6-5. org2的peer0授权合约后，在org1的peer0检查合约在各组织的授权是否成功</span><br><span class="line">Using organization 1</span><br><span class="line">Checking the commit readiness of the chaincode definition on peer0.org1 on channel &#x27;mychannel&#x27;...</span><br><span class="line">Attempting to check the commit readiness of the chaincode definition on peer0.org1, Retry after 3 seconds.</span><br><span class="line">+ peer lifecycle chaincode checkcommitreadiness --channelID mychannel --name fabcar --version 1.0 --sequence 1 --output json</span><br><span class="line">+ res=0</span><br><span class="line">&#123;</span><br><span class="line">	&quot;approvals&quot;: &#123;</span><br><span class="line">		&quot;Org1MSP&quot;: true,</span><br><span class="line">		&quot;Org2MSP&quot;: true</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Checking the commit readiness of the chaincode definition successful on peer0.org1 on channel &#x27;mychannel&#x27;</span><br><span class="line"></span><br><span class="line">6-6. org2的peer0授权合约后，在org2的peer0检查合约在各组织的授权是否成功</span><br><span class="line">Using organization 2</span><br><span class="line">Checking the commit readiness of the chaincode definition on peer0.org2 on channel &#x27;mychannel&#x27;...</span><br><span class="line">Attempting to check the commit readiness of the chaincode definition on peer0.org2, Retry after 3 seconds.</span><br><span class="line">+ peer lifecycle chaincode checkcommitreadiness --channelID mychannel --name fabcar --version 1.0 --sequence 1 --output json</span><br><span class="line">+ res=0</span><br><span class="line">&#123;</span><br><span class="line">	&quot;approvals&quot;: &#123;</span><br><span class="line">		&quot;Org1MSP&quot;: true,</span><br><span class="line">		&quot;Org2MSP&quot;: true</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Checking the commit readiness of the chaincode definition successful on peer0.org2 on channel &#x27;mychannel&#x27;</span><br><span class="line"></span><br><span class="line">7. 前面的合约已安装、授权（多签）完毕，这里开始在org1的peer0和org2的peer0提交定义合约，可以理解为初始化出一个合约模板，这也是fabric2.0的一个特性，同一个合约可以重复使用</span><br><span class="line">Using organization 1</span><br><span class="line">Using organization 2</span><br><span class="line">+ peer lifecycle chaincode commit -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile /root/go/src/github.com/hyperledger/fabric-samples/test-network/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem --channelID mychannel --name fabcar --peerAddresses localhost:7051 --tlsRootCertFiles /root/go/src/github.com/hyperledger/fabric-samples/test-network/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses localhost:9051 --tlsRootCertFiles /root/go/src/github.com/hyperledger/fabric-samples/test-network/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt --version 1.0 --sequence 1</span><br><span class="line">+ res=0</span><br><span class="line">2021-04-22 12:38:04.422 CST [chaincodeCmd] ClientWait -&gt; INFO 001 txid [abfb67fbeaff552237a982020350063d98ad9620ad0a72e1505aa650fd55eb2c] committed with status (VALID) at localhost:9051</span><br><span class="line">2021-04-22 12:38:04.422 CST [chaincodeCmd] ClientWait -&gt; INFO 002 txid [abfb67fbeaff552237a982020350063d98ad9620ad0a72e1505aa650fd55eb2c] committed with status (VALID) at localhost:7051</span><br><span class="line">Chaincode definition committed on channel &#x27;mychannel&#x27;</span><br><span class="line"></span><br><span class="line">8-1 在org1的peer0检查合约定义成功与否</span><br><span class="line">Using organization 1</span><br><span class="line">Querying chaincode definition on peer0.org1 on channel &#x27;mychannel&#x27;...</span><br><span class="line">Attempting to Query committed status on peer0.org1, Retry after 3 seconds.</span><br><span class="line">+ peer lifecycle chaincode querycommitted --channelID mychannel --name fabcar</span><br><span class="line">+ res=0</span><br><span class="line">Committed chaincode definition for chaincode &#x27;fabcar&#x27; on channel &#x27;mychannel&#x27;:</span><br><span class="line">Version: 1.0, Sequence: 1, Endorsement Plugin: escc, Validation Plugin: vscc, Approvals: [Org1MSP: true, Org2MSP: true]</span><br><span class="line">Query chaincode definition successful on peer0.org1 on channel &#x27;mychannel&#x27;</span><br><span class="line"></span><br><span class="line">8-2 在org2的peer0检查合约定义成功与否</span><br><span class="line">Using organization 2</span><br><span class="line">Querying chaincode definition on peer0.org2 on channel &#x27;mychannel&#x27;...</span><br><span class="line">Attempting to Query committed status on peer0.org2, Retry after 3 seconds.</span><br><span class="line">+ peer lifecycle chaincode querycommitted --channelID mychannel --name fabcar</span><br><span class="line">+ res=0</span><br><span class="line">Committed chaincode definition for chaincode &#x27;fabcar&#x27; on channel &#x27;mychannel&#x27;:</span><br><span class="line">Version: 1.0, Sequence: 1, Endorsement Plugin: escc, Validation Plugin: vscc, Approvals: [Org1MSP: true, Org2MSP: true]</span><br><span class="line">Query chaincode definition successful on peer0.org2 on channel &#x27;mychannel&#x27;</span><br><span class="line"></span><br><span class="line">8-3 如果脚本传入了初始化方法，则调用合约初始化函数，如果没传入，则不执行</span><br><span class="line">Chaincode initialization is not required</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>至此，《fabric-samples基本使用》三部曲已经完成，走完整个流程，对fabric整体会有一个大概的了解，明显能感觉到，联盟链对理念和架构明显比公链复杂很多。<br>
当然，<code>fabric-samples</code>内容远远不止于此，如果有时间，建议最好详细读一下整套脚本，配合官方文档，先对fabric有个全局观。<br>
后续将会梳理一些fabric偏原理、架构类的内容，逐步深入。</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Hyperledger Fabric</category>
      </categories>
      <tags>
        <tag>Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>fabric-samples基本使用（2）- 启动测试网络</title>
    <url>/articles/3b7f5326/</url>
    <content><![CDATA[<p>fabric-samples中的<code>test-network</code>提供了一个简单的demo测试网络，方便新人学习的同时也方便开发人员测试合约和一些网络组合。<br>
本文主要介绍该测试网络的启动，包括channel的部署等。</p>
<span id="more"></span>
<h2 id="前述">前述</h2>
<ol>
<li>请先看<a href="/articles/79376746/index.html">fabric-samples基本使用（一）- 下载准备</a></li>
<li><code>test-network</code>网络中，默认提供了一个<code>order</code>以及两个<code>peer</code>，peer分别属于org1和org2两个组织，这两个组织均在同一个channel中</li>
</ol>
<h2 id="使用方式">使用方式</h2>
<h3 id="步骤1-启动网络">步骤1-启动网络</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./network.sh up -s couchdb</span><br></pre></td></tr></table></figure>
<p>该命令将启动一个order和两个peer节点，每个节点各自生成自己对组织文件（包含MSP、账户、tls等），fabric默认使用的是leveldb存储数据存储状态数据，如果要对数据做富文本查询，建议用<code>-s couchdb</code>来启用couchdb，<br>
创建联盟选择好数据库后，以后则不可再更换数据库（基于当前规则）。<br>
<code>注意</code>：账户、证书的生成，这里是用的fabric自带的工具生成的，这个仅仅适用于测试环境，在真正的生产环境，是需要有专门的CA中心来统一管理证书发放。</p>
<h3 id="步骤2-创建通道">步骤2-创建通道</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./network.sh createChannel</span><br></pre></td></tr></table></figure>
<p>该命令将创建一条名为<code>mychannel</code>的channel，一条channel就可以理解为是一条链，创建channel的过程就是初始化一条链的过程。主要经历以下过程：</p>
<ol>
<li>channel初始化配置文件生成，</li>
<li>org1组织根据上一步生成的配置文件，创建<code>mychannel</code>并提交给order（需要order签名文件授权），order确认后，<code>mychannel</code>创建成功</li>
<li>分别将org1和org2加入<code>mychannel</code></li>
<li>分别为org1和org2设置锚节点，每个组织至少要有一个锚节点，主要用于更新普通channel，通道间通信</li>
</ol>
<h3 id="步骤3-关闭清除网络">步骤3-关闭清除网络</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./network.sh down</span><br></pre></td></tr></table></figure>
<p>若部署操作有异常，或者要清除已有环境，可使用该命令停止和清除测试网络相关文件，包括docker容器等。</p>
<h3 id="完成">完成</h3>
<p>至此，一条基本的fabric测试联盟链搭建完成。一个order、2个peer组成一个联盟，在这个联盟中，总共只有一条通道mychannel。</p>
<h2 id="总结">总结</h2>
<p>本文主要是<code>fabric-samples</code>节点网络的创建以及channel的生成，大概讲了下操作流程，具体细节需要自己去<code>network.sh</code>脚本中查看。<br>
接触fabric之后，你会发现，整个使用过程你都是在围绕着账户签名和证书来进行的，fabric在区块链领域中最大的特点就是<code>鉴权</code>。</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Hyperledger Fabric</category>
      </categories>
      <tags>
        <tag>Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>fabric-samples基本使用（1）- 下载准备</title>
    <url>/articles/79376746/</url>
    <content><![CDATA[<p>超级账本这些年一直在零零碎碎的学习和使用着，也做过一些项目。在此打算将已有的笔记和一些新的学习心得梳理出来。<br>
姑且不说Fabric是什么，相信我，比起<a href="https://hyperledger-fabric.readthedocs.io">官方文档</a>，官方提供的 <a href="https://github.com/hyperledger/fabric-samples">测试网络 fabric-samples</a> 一定是最好的入门教程，结合本系列文章对其使用的介绍，相信很快就能了解到Fabric到底是什么。</p>
<span id="more"></span>
<h2 id="说明">说明</h2>
<p>本文基于<code>fabric 2.3.1</code>以及<code>fabric-ca 1.5</code>，需要环境<code>docker以及docker-compose.yml</code>。</p>
<h2 id="下载相关内容">下载相关内容</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一步 下载代码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/hyperledger/fabric-samples</span><br><span class="line"><span class="built_in">cd</span> fabric-samples</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步 下载可执行程序和配置，解压后，确保conf目录和bin目录在fabric-samples的根目录中</span></span><br><span class="line">方式1（境外网站，没特殊手段下载会很慢）：使用官方脚本：curl -sSL https://bit.ly/2ysbOFE | bash -s  若打不开，本文下一节有该脚本供参考</span><br><span class="line">方式2：前往：https://github.com/hyperledger/fabric/releases/ 下载可执行程序并解压</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三步 下载ca可执行程序，放在第二步的bin目录下</span></span><br><span class="line">https://github.com/hyperledger/fabric-ca/releases</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最终目录结构如下：</span></span><br><span class="line">.</span><br><span class="line">└── fabric-samples</span><br><span class="line">    ├── bin</span><br><span class="line">    │ ├── configtxgen</span><br><span class="line">    │ ├── configtxlator</span><br><span class="line">    │ ├── cryptogen</span><br><span class="line">    │ ├── discover</span><br><span class="line">    │ ├── fabric-ca-client</span><br><span class="line">    │ ├── fabric-ca-server</span><br><span class="line">    │ ├── idemixgen</span><br><span class="line">    │ ├── orderer</span><br><span class="line">    │ ├── osnadmin</span><br><span class="line">    │ └── peer</span><br><span class="line">    ├── config</span><br><span class="line">    │ ├── configtx.yaml</span><br><span class="line">    │ ├── core.yaml</span><br><span class="line">    │ └── orderer.yaml</span><br><span class="line">    ├── asset-transfer-abac</span><br><span class="line">    ├── asset-transfer-basic</span><br><span class="line">    ├── asset-transfer-events</span><br><span class="line">    ├── asset-transfer-ledger-queries</span><br><span class="line">    ├── asset-transfer-private-data</span><br><span class="line">    ├── asset-transfer-sbe</span><br><span class="line">    ├── asset-transfer-secured-agreement</span><br><span class="line">    ├── auction</span><br><span class="line">    ├── chaincode</span><br><span class="line">    ├── CHANGELOG.md</span><br><span class="line">    ├── ci</span><br><span class="line">    ├── CODE_OF_CONDUCT.md</span><br><span class="line">    ├── CODEOWNERS</span><br><span class="line">    ├── commercial-paper</span><br><span class="line">    ├── CONTRIBUTING.md</span><br><span class="line">    ├── fabcar</span><br><span class="line">    ├── high-throughput</span><br><span class="line">    ├── interest_rate_swaps</span><br><span class="line">    ├── LICENSE</span><br><span class="line">    ├── MAINTAINERS.md</span><br><span class="line">    ├── off_chain_data</span><br><span class="line">    ├── README.md</span><br><span class="line">    ├── scripts</span><br><span class="line">    ├── SECURITY.md</span><br><span class="line">    ├── test-application</span><br><span class="line">    ├── test-network  </span><br><span class="line">    ├── token-erc-20</span><br><span class="line">    ├── token-erc-721</span><br><span class="line">    └── token-utxo</span><br><span class="line">以上目录，test-network是启动测试网络需要的脚本等，而其余目录主要是chaincode案例</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第4步 fabric相关docker镜像下载</span></span><br><span class="line">建议使用官方脚本</span><br><span class="line">curl -sSL https://bit.ly/2ysbOFE | bash -s</span><br><span class="line">可一次性将镜像、二进制等下载，并且目录自动解压，唯一缺点是，墙外网络，你懂的。参考下一章节的镜像下载部分的脚本</span><br></pre></td></tr></table></figure>
<h2 id="下载脚本">下载脚本</h2>
<p>官方提供的资源下载脚本，可参考，根据需要去资源原站手动下载，速度感觉会快一些。<br>
脚本结尾部分的三段功能，分别是下载<code>samples</code>、<code>镜像</code>、<code>二进制</code>，可根据需要来选择使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Copyright IBM Corp. All Rights Reserved.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># SPDX-License-Identifier: Apache-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if version not passed in, default to latest released version</span></span><br><span class="line">VERSION=2.3.1</span><br><span class="line"><span class="comment"># if ca version not passed in, default to latest released version</span></span><br><span class="line">CA_VERSION=1.4.9</span><br><span class="line">ARCH=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(uname -s|tr &#x27;[:upper:]&#x27; &#x27;[:lower:]&#x27;|sed &#x27;s/mingw64_nt.*/windows/&#x27;)</span>-<span class="subst">$(uname -m | sed &#x27;s/x86_64/amd64/g&#x27;)</span>&quot;</span>)</span><br><span class="line">MARCH=$(<span class="built_in">uname</span> -m)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">printHelp</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Usage: bootstrap.sh [version [ca_version]] [options]&quot;</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;options:&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;-h : this help&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;-d : bypass docker image download&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;-s : bypass fabric-samples repo clone&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;-b : bypass download of platform-specific binaries&quot;</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;e.g. bootstrap.sh 2.3.1 1.4.9 -s&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;will download docker images and binaries for Fabric v2.3.1 and Fabric CA v1.4.9&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># dockerPull() pulls docker images from fabric and chaincode repositories</span></span><br><span class="line"><span class="comment"># note, if a docker image doesn&#x27;t exist for a requested release, it will simply</span></span><br><span class="line"><span class="comment"># be skipped, since this script doesn&#x27;t terminate upon errors.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">dockerPull</span></span>() &#123;</span><br><span class="line">    <span class="comment">#three_digit_image_tag is passed in, e.g. &quot;1.4.7&quot;</span></span><br><span class="line">    three_digit_image_tag=<span class="variable">$1</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line">    <span class="comment">#two_digit_image_tag is derived, e.g. &quot;1.4&quot;, especially useful as a local tag for two digit references to most recent baseos, ccenv, javaenv, nodeenv patch releases</span></span><br><span class="line">    two_digit_image_tag=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$three_digit_image_tag</span>&quot;</span> | <span class="built_in">cut</span> -d<span class="string">&#x27;.&#x27;</span> -f1,2)</span><br><span class="line">    <span class="keyword">while</span> [[ <span class="variable">$#</span> -gt 0 ]]</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        image_name=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;====&gt; hyperledger/fabric-<span class="variable">$image_name</span>:<span class="variable">$three_digit_image_tag</span>&quot;</span></span><br><span class="line">        docker pull <span class="string">&quot;hyperledger/fabric-<span class="variable">$image_name</span>:<span class="variable">$three_digit_image_tag</span>&quot;</span></span><br><span class="line">        docker tag <span class="string">&quot;hyperledger/fabric-<span class="variable">$image_name</span>:<span class="variable">$three_digit_image_tag</span>&quot;</span> <span class="string">&quot;hyperledger/fabric-<span class="variable">$image_name</span>&quot;</span></span><br><span class="line">        docker tag <span class="string">&quot;hyperledger/fabric-<span class="variable">$image_name</span>:<span class="variable">$three_digit_image_tag</span>&quot;</span> <span class="string">&quot;hyperledger/fabric-<span class="variable">$image_name</span>:<span class="variable">$two_digit_image_tag</span>&quot;</span></span><br><span class="line">        <span class="built_in">shift</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">cloneSamplesRepo</span></span>() &#123;</span><br><span class="line">    <span class="comment"># clone (if needed) hyperledger/fabric-samples and checkout corresponding</span></span><br><span class="line">    <span class="comment"># version to the binaries and docker images to be downloaded</span></span><br><span class="line">    <span class="keyword">if</span> [ -d first-network ]; <span class="keyword">then</span></span><br><span class="line">        <span class="comment"># if we are in the fabric-samples repo, checkout corresponding version</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;==&gt; Already in fabric-samples repo&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> [ -d fabric-samples ]; <span class="keyword">then</span></span><br><span class="line">        <span class="comment"># if fabric-samples repo already cloned and in current directory,</span></span><br><span class="line">        <span class="comment"># cd fabric-samples</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;===&gt; Changing directory to fabric-samples&quot;</span></span><br><span class="line">        <span class="built_in">cd</span> fabric-samples</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;===&gt; Cloning hyperledger/fabric-samples repo&quot;</span></span><br><span class="line">        git <span class="built_in">clone</span> -b master https://github.com/hyperledger/fabric-samples.git &amp;&amp; <span class="built_in">cd</span> fabric-samples</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> GIT_DIR=.git git rev-parse v<span class="variable">$&#123;VERSION&#125;</span> &gt;/dev/null 2&gt;&amp;1; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;===&gt; Checking out v<span class="variable">$&#123;VERSION&#125;</span> of hyperledger/fabric-samples&quot;</span></span><br><span class="line">        git checkout -q v<span class="variable">$&#123;VERSION&#125;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;fabric-samples v<span class="variable">$&#123;VERSION&#125;</span> does not exist, defaulting master&quot;</span></span><br><span class="line">        git checkout -q master</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># This will download the .tar.gz</span></span><br><span class="line"><span class="function"><span class="title">download</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> BINARY_FILE=<span class="variable">$1</span></span><br><span class="line">    <span class="built_in">local</span> URL=<span class="variable">$2</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;===&gt; Downloading: &quot;</span> <span class="string">&quot;<span class="variable">$&#123;URL&#125;</span>&quot;</span></span><br><span class="line">    curl -L --retry 5 --retry-delay 3 <span class="string">&quot;<span class="variable">$&#123;URL&#125;</span>&quot;</span> | tar xz || rc=$?</span><br><span class="line">    <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$rc</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;==&gt; There was an error downloading the binary file.&quot;</span></span><br><span class="line">        <span class="built_in">return</span> 22</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;==&gt; Done.&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">pullBinaries</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;===&gt; Downloading version <span class="variable">$&#123;FABRIC_TAG&#125;</span> platform specific fabric binaries&quot;</span></span><br><span class="line">    download <span class="string">&quot;<span class="variable">$&#123;BINARY_FILE&#125;</span>&quot;</span> <span class="string">&quot;https://github.com/hyperledger/fabric/releases/download/v<span class="variable">$&#123;VERSION&#125;</span>/<span class="variable">$&#123;BINARY_FILE&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">if</span> [ $? -eq 22 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;------&gt; <span class="variable">$&#123;FABRIC_TAG&#125;</span> platform specific fabric binary is not available to download &lt;----&quot;</span></span><br><span class="line">        <span class="built_in">echo</span></span><br><span class="line">        <span class="built_in">exit</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;===&gt; Downloading version <span class="variable">$&#123;CA_TAG&#125;</span> platform specific fabric-ca-client binary&quot;</span></span><br><span class="line">    download <span class="string">&quot;<span class="variable">$&#123;CA_BINARY_FILE&#125;</span>&quot;</span> <span class="string">&quot;https://github.com/hyperledger/fabric-ca/releases/download/v<span class="variable">$&#123;CA_VERSION&#125;</span>/<span class="variable">$&#123;CA_BINARY_FILE&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">if</span> [ $? -eq 22 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;------&gt; <span class="variable">$&#123;CA_TAG&#125;</span> fabric-ca-client binary is not available to download  (Available from 1.1.0-rc1) &lt;----&quot;</span></span><br><span class="line">        <span class="built_in">echo</span></span><br><span class="line">        <span class="built_in">exit</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">pullDockerImages</span></span>() &#123;</span><br><span class="line">    <span class="built_in">command</span> -v docker &gt;&amp; /dev/null</span><br><span class="line">    NODOCKER=$?</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;NODOCKER&#125;</span>&quot;</span> == 0 ]; <span class="keyword">then</span></span><br><span class="line">        FABRIC_IMAGES=(peer orderer ccenv tools)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$VERSION</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">        2.*)</span><br><span class="line">            FABRIC_IMAGES+=(baseos)</span><br><span class="line">            <span class="built_in">shift</span></span><br><span class="line">            ;;</span><br><span class="line">        <span class="keyword">esac</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;FABRIC_IMAGES:&quot;</span> <span class="string">&quot;<span class="variable">$&#123;FABRIC_IMAGES[@]&#125;</span>&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;===&gt; Pulling fabric Images&quot;</span></span><br><span class="line">        dockerPull <span class="string">&quot;<span class="variable">$&#123;FABRIC_TAG&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;FABRIC_IMAGES[@]&#125;</span>&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;===&gt; Pulling fabric ca Image&quot;</span></span><br><span class="line">        CA_IMAGE=(ca)</span><br><span class="line">        dockerPull <span class="string">&quot;<span class="variable">$&#123;CA_TAG&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;CA_IMAGE[@]&#125;</span>&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;===&gt; List out hyperledger docker images&quot;</span></span><br><span class="line">        docker images | grep hyperledger</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;=========================================================&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Docker not installed, bypassing download of Fabric images&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;=========================================================&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DOCKER=<span class="literal">true</span></span><br><span class="line">SAMPLES=<span class="literal">true</span></span><br><span class="line">BINARIES=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Parse commandline args pull out</span></span><br><span class="line"><span class="comment"># version and/or ca-version strings first</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ] &amp;&amp; [ <span class="string">&quot;<span class="variable">$&#123;1:0:1&#125;</span>&quot;</span> != <span class="string">&quot;-&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    VERSION=<span class="variable">$1</span>;<span class="built_in">shift</span></span><br><span class="line">    <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]  &amp;&amp; [ <span class="string">&quot;<span class="variable">$&#123;1:0:1&#125;</span>&quot;</span> != <span class="string">&quot;-&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        CA_VERSION=<span class="variable">$1</span>;<span class="built_in">shift</span></span><br><span class="line">        <span class="keyword">if</span> [ -n  <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ] &amp;&amp; [ <span class="string">&quot;<span class="variable">$&#123;1:0:1&#125;</span>&quot;</span> != <span class="string">&quot;-&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            THIRDPARTY_IMAGE_VERSION=<span class="variable">$1</span>;<span class="built_in">shift</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># prior to 1.2.0 architecture was determined by uname -m</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$VERSION</span> =~ ^1\.[0-1]\.* ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">export</span> FABRIC_TAG=<span class="variable">$&#123;MARCH&#125;</span>-<span class="variable">$&#123;VERSION&#125;</span></span><br><span class="line">    <span class="built_in">export</span> CA_TAG=<span class="variable">$&#123;MARCH&#125;</span>-<span class="variable">$&#123;CA_VERSION&#125;</span></span><br><span class="line">    <span class="built_in">export</span> THIRDPARTY_TAG=<span class="variable">$&#123;MARCH&#125;</span>-<span class="variable">$&#123;THIRDPARTY_IMAGE_VERSION&#125;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment"># starting with 1.2.0, multi-arch images will be default</span></span><br><span class="line">    : <span class="string">&quot;<span class="variable">$&#123;CA_TAG:=&quot;$CA_VERSION&quot;&#125;</span>&quot;</span></span><br><span class="line">    : <span class="string">&quot;<span class="variable">$&#123;FABRIC_TAG:=&quot;$VERSION&quot;&#125;</span>&quot;</span></span><br><span class="line">    : <span class="string">&quot;<span class="variable">$&#123;THIRDPARTY_TAG:=&quot;$THIRDPARTY_IMAGE_VERSION&quot;&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">BINARY_FILE=hyperledger-fabric-<span class="variable">$&#123;ARCH&#125;</span>-<span class="variable">$&#123;VERSION&#125;</span>.tar.gz</span><br><span class="line">CA_BINARY_FILE=hyperledger-fabric-ca-<span class="variable">$&#123;ARCH&#125;</span>-<span class="variable">$&#123;CA_VERSION&#125;</span>.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># then parse opts</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> <span class="string">&quot;h?dsb&quot;</span> opt; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$opt</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">        h|\?)</span><br><span class="line">            printHelp</span><br><span class="line">            <span class="built_in">exit</span> 0</span><br><span class="line">            ;;</span><br><span class="line">        d)  DOCKER=<span class="literal">false</span></span><br><span class="line">            ;;</span><br><span class="line">        s)  SAMPLES=<span class="literal">false</span></span><br><span class="line">            ;;</span><br><span class="line">        b)  BINARIES=<span class="literal">false</span></span><br><span class="line">            ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$SAMPLES</span>&quot;</span> == <span class="string">&quot;true&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Clone hyperledger/fabric-samples repo&quot;</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    cloneSamplesRepo</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$BINARIES</span>&quot;</span> == <span class="string">&quot;true&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Pull Hyperledger Fabric binaries&quot;</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    pullBinaries</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$DOCKER</span>&quot;</span> == <span class="string">&quot;true&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Pull Hyperledger Fabric docker images&quot;</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    pullDockerImages</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>至此，<code>fabric-samples</code>相关文件下载并准备工作完毕，后续操作请看下一篇讲解。</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Hyperledger Fabric</category>
      </categories>
      <tags>
        <tag>Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>lotus应用第1讲-2k扇区开发环境部署和应用</title>
    <url>/articles/1c05114c/</url>
    <content><![CDATA[<p>基于环境限制，使用2k扇区测试和校验lotus功能。<br>
此环境的部署和使用，官方文档也有提供，但讲的太过简洁，传送门在这里：<a href="https://docs.filecoin.io/build/local-devnet/#devnet-with-vanilla-lotus-binaries">Run a Filecoin local devnet</a><br>
本文主要是细化官方文档中的描述，加入个人理解和使用心得。</p>
<span id="more"></span>
<h2 id="简介">简介</h2>
<p>关于lotus的编译和部署，可以参考我整理的脚本：<a href="https://github.com/bitxx/filecoin-doc">filecoin-doc</a><br>
本文直接从编译后的使用过程开始讲解。<br>
ps: <code>后续根据对lotus的深入了解，会逐步完善本文一些描述不清、不准确的地方</code></p>
<h2 id="步骤">步骤</h2>
<p>文件下载或者数据同步失败一般就是网路访问问题，目前的解决方式就是用vpn或者代理</p>
<h3 id="步骤1-下载2k扇区封装所需的证明文件">步骤1-下载2k扇区封装所需的证明文件</h3>
<p>该文件用于后续扇区封装时的校验，具体用途还不明了，下载耗时久，大概1G文件需要下载。<br>
不用代理的话，国内网络下载很慢，可能得等十几个小时</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">./lotus fetch-params 2048</span><br></pre></td></tr></table></figure>
<h3 id="步骤2-设置预封装扇区">步骤2-设置预封装扇区</h3>
<p>按我理解就是节点发布前通过程序预先封装好2个扇区（就是预先认证确认），每个扇区2kb。<br>
用模拟数据封装的，执行后，会生成对应的minner账户（密钥）、文件等信息<br>
这一步骤纯粹就是为了测试而生成的。</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">./lotus-seed pre-seal --sector-size 2KiB --num-sectors 2</span><br></pre></td></tr></table></figure>
<p>执行后，会生成如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── cache                       缓存</span><br><span class="line">├── pre-seal-t01000.json        minner信息</span><br><span class="line">├── pre-seal-t01000.key         minner私钥</span><br><span class="line">├── sealed                      已经封装好的两个扇区（2个文件）</span><br><span class="line">├── sectorstore.json            封装配置信息</span><br><span class="line">└── unsealed                    空文件，应该是存放尚未被封装的</span><br></pre></td></tr></table></figure>
<h3 id="步骤3-生成创世块配置文件">步骤3-生成创世块配置文件</h3>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">./lotus-seed genesis new localnet.json</span><br></pre></td></tr></table></figure>
<h3 id="步骤4-将预封装生成的minner信息-加入到创世配置文件中">步骤4-将预封装生成的minner信息，加入到创世配置文件中</h3>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">./lotus-seed genesis add-miner localnet.json ~/.genesis-sectors/pre-seal-t01000.json</span><br></pre></td></tr></table></figure>
<p>加入后，再去看<code>localnet.json</code>，里面多了个minner的信息</p>
<h3 id="步骤5-启动lotus守护进程">步骤5-启动lotus守护进程</h3>
<p>根据前面生成的<code>localnet.json</code>，启动lotus守护进程。<br>
根据在源码中查阅，这里需要注意的是：<code>--lotus-make-genesis</code>和<code>--genesis-template</code>这两个参数应该仅是测试和开发时使用，在命令行列表中本身是不对外展示的。<br>
其中：</p>
<ol>
<li><code>--lotus-make-genesis</code>是用来生成car压缩文件，目前猜测是创世相关内容，具体作用未知。</li>
<li><code>--genesis-template</code>用来指定创世配置，就是前面生成的。</li>
<li><code>--bootstrap</code>是否监听或者同步别的节点（猜的）</li>
</ol>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">./lotus daemon --lotus-make-genesis=devgen.car --genesis-template=localnet.json --bootstrap=false</span><br></pre></td></tr></table></figure>
<h3 id="步骤6-为lotus导入默认的minner私钥">步骤6-为lotus导入默认的minner私钥</h3>
<p>保持<code>第5步</code>运行窗口，使用新的命令行窗口。<br>
就是lotus当前节点默认钱包账户（私钥可对应生成账户）<br>
该私钥在<code>第二步</code>中已生成</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">./lotus wallet import --as-default ~/.genesis-sectors/pre-seal-t01000.key</span><br></pre></td></tr></table></figure>
<h3 id="步骤7-为lotus-miner初始化配置minner信息">步骤7 为lotus-miner初始化配置minner信息</h3>
<p>配置均是基于<code>步骤2</code>生成的文件来操作的</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">./lotus-miner init --genesis-miner --actor=t01000 --sector-size=2KiB --pre-sealed-sectors=~/.genesis-sectors --pre-sealed-metadata=~/.genesis-sectors/pre-seal-t01000.json --nosync</span><br></pre></td></tr></table></figure>
<h3 id="执行开挖">执行开挖</h3>
<p>这一步消耗资源严重，谨慎操作，启动后，一个完整的节点运行案例就形成了。</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">./lotus-miner run --nosync</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>区块链</category>
        <category>Lotus</category>
      </categories>
      <tags>
        <tag>Filecoin</tag>
        <tag>Lotus</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊dpos共识改造-实现dpos算法（1）</title>
    <url>/articles/2092aa9f/</url>
    <content><![CDATA[<p>dpos是什么，为什么要改造成dpos，这些问题小编就不解释了。可参考：<a href="/articles/bbe43e3f">委托股权证明原理(DPOS)–翻译及解读</a><br>
对以太坊做dpos共识改造，从0开始是不可能的，这里小编参考了<a href="https://github.com/meitu/go-ethereum">美图以太坊dpos改造</a>。美图实验室的改造相比较来说更加直观，网上这方面对信息不多，为此，小编参考该项目重头敲了一遍这个共识。收益颇多，也发现了很多不足的地方。</p>
<span id="more"></span>
<p>美图官方发布的改造教程解说并不多，讲述的内容也很简洁。为此，小编通过这篇文章详细解释下dpos在以太坊中的改造细节。自我总结的同时，希望能对大家有所帮助。<br>
美图是在ethereum1.7.4上改造dpos的，而小编是在1.8.20上改造的，会有一些差异，但影响不大。<br>
本文最后会介绍这次改造中的不足之处，后续会逐步完善。</p>
<h2 id="本文源码下载">本文源码下载</h2>
<p>本文是在以太坊基础上改造的，整个源码迟些时候会放在github上，其实这源码就是美图官方的，只是小编根据自己的想法做了一些改动。<br>
每个阶段的改动，都会单独切换一个分支。<br>
分阶段实现，更容易理解这次改造的过程。<br>
dpos相关源码位置都有对应的单元测试，可快速验证每个方法。<br>
关键地方，小编都加入了中文注释。</p>
<h2 id="dpos整体框架">dpos整体框架</h2>
<p>小编先前在<a href="/articles/3673b530">以太坊源码解读-第6.1讲-共识模块入口设计</a>以及<a href="/articles/231042d1">以太坊源码解读-第6.2讲-pow共识算法实现</a>中解释过，<br>
实现一套共识算法，是需要在以太坊提供的共识引擎之下完成。<br>
这里先说一下本文dpos的全局参数：</p>
<ol>
<li>每隔10秒钟生成一个块，</li>
<li>每一天（24小时）进行一轮新的选举</li>
<li>验证人有21个</li>
<li>验证人最小人数为15人（计算方式：21*2/3+1）</li>
</ol>
<p>美图DPOS的实现方案如下图所示：</p>
<img src="/articles/2092aa9f/1.png" class="" title="Dpos算法整体结构">
<p>注意区分候选人和验证人，<code>验证人是候选人之一，但候选人不一定是验证人</code><br>
从上图可以看出，分成三大部分，这里简述一下其中每部分的作用：</p>
<ol>
<li>dpos_context和dpos_context_pro：用来存储和操作验证人、投票、候选人等信息，是通过trie来将这些信息存储在leveldb中。这些信息主要分为5部分：
<ol>
<li>EpochTrie：记录当前周期的验证人列表</li>
<li>DelegateTrie：记录每个候选人对应的投票人，一个候选人有不同的投票人</li>
<li>VoteTrie：记录投票人对应的候选人，每个投票人只能对应一个候选人</li>
<li>MintCntTrie：记录验证人在当前周期内的出块数</li>
<li>CandidateTrie：候选人集合，其中包含了验证人</li>
</ol>
</li>
<li>epoch_context：dpos验证阶段的处理，图中可知，主要完成四部分内容：
<ol>
<li>CountVotes:获取候选人及其对应投票数（积分）</li>
<li>KickoutValidator：踢除不合格的验证人</li>
<li>LookupValidator：获取当前验证人，就是确定应该由哪个验证人来出块</li>
<li>TryElec：发起新一轮选举，从候选人中选出验证人</li>
</ol>
</li>
<li>Dpos：实现共识引擎，dpos的主体</li>
</ol>
<p>来看看dpos算在在以太坊中的结构：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">|____params.go</span><br><span class="line">|____context</span><br><span class="line">| |____dpos_context.go</span><br><span class="line">| |____dpos_context_proto.go</span><br><span class="line">|____dpos_test.go</span><br><span class="line">|____api.go</span><br><span class="line">|____epoch_context_test.go</span><br><span class="line">|____epoch_context.go</span><br><span class="line">|____dpos.go</span><br></pre></td></tr></table></figure>
<p>正对应上面提到的3部分内容。</p>
<p>整个实现过程，小编也建议按照上面1、2、3的顺序来实现。下面小编就按照这个步骤来一一讲解。</p>
<h2 id="dpos-context和dpos-context-pro">dpos_context和dpos_context_pro</h2>
<p>上面小编说过，dpos选举的数据信息都会以trie的形式保存在以太坊的leveldb之中。dpos_context和dpos_context_pro就是用来处理这一过程的。<br>
就是说，这一过程是对trie树的操作过程<br>
小编想要说的是dpos_context_pro是为了方便外部对接而通过gencodec将dpos_context自动转换生成的。也就是说真正的核心是dpos_context。<br>
理解dpos_context.go中内容尤为重要。</p>
<p>先来看看结构体其结构体和重要参数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	epochPrefix     = []<span class="type">byte</span>(<span class="string">&quot;epoch-&quot;</span>)</span><br><span class="line">	delegatePrefix  = []<span class="type">byte</span>(<span class="string">&quot;delegate-&quot;</span>)</span><br><span class="line">	votePrefix      = []<span class="type">byte</span>(<span class="string">&quot;vote-&quot;</span>)</span><br><span class="line">	candidatePrefix = []<span class="type">byte</span>(<span class="string">&quot;candidate-&quot;</span>)</span><br><span class="line">	mintCntPrefix   = []<span class="type">byte</span>(<span class="string">&quot;mintCnt-&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DposContext <span class="keyword">struct</span> &#123;</span><br><span class="line">	EpochTrie     *trie.Trie <span class="comment">//记录每个周期的验证人列表</span></span><br><span class="line">	DelegateTrie  *trie.Trie <span class="comment">//记录候选人-&gt;投票人</span></span><br><span class="line">	VoteTrie      *trie.Trie <span class="comment">//记录投票人-&gt;候选人</span></span><br><span class="line">	CandidateTrie *trie.Trie <span class="comment">//记录候选人列表</span></span><br><span class="line">	MintCntTrie   *trie.Trie <span class="comment">//记录验证人在周期内的出块数目</span></span><br><span class="line"></span><br><span class="line">	db ethdb.Database</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很直观，dpos的五个前缀，后续操作的数据将会在这些前缀之后保存，索引很容易找到结果。<br>
以太坊trie树是一种kv类型对，上面提到的五种trie，具体数据是如下格式来保存：</p>
<ol>
<li>EpochTrie数据格式：<br>
key：epoch-validator<br>
value：xxxxxxxxxxxxxxx (<code>ps</code>：xxxxxxxxxxxxxxx表示经过rlp序列化的所有验证人地址)</li>
<li>DelegateTrie数据格式：<br>
key：delegate-候选人地址-投票人地址<br>
value：投票人地址</li>
<li>VoteTrie数据格式：<br>
key：vote-投票人地址<br>
value：候选人地址</li>
<li>CandidateTrie数据格式：<br>
key：candidate-候选人地址<br>
value；候选人地址</li>
<li>MintCntTrie数据格式：<br>
key；mintCnt-周期数（2进制）-验证人<br>
value：当前验证人本周期总共挖块数（2进制å）<br>
<code>ps</code>：此处是小编自己理解，可能不正确：<code>其中，第5个加入周期数的目的：若不加入周期数，则这五棵trie经过rlp生成的hash，每一轮有可能都一样，对其签名会造成很大困扰</code></li>
</ol>
<p>接着看看DposContext的几个重要方法：</p>
<h3 id="copy-复制当前dpos状态">Copy():复制当前dpos状态</h3>
<p>将当前DposContext对象复制出来，其实就是复制出当前Dpos状态，一般用于快照操作。拿到某时刻的状态。</p>
<h3 id="snapshot-快照-同上">Snapshot():快照，同上</h3>
<p>快照。其实就是调用了上面提到的Copy()方法。</p>
<h3 id="reverttosnapshot-：快照读取">RevertToSnapShot()：快照读取</h3>
<p>这个其实就是将快照信息转移到主体DposContext中，描述不好理解，贴代码，一目了然：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DposContext)</span></span> RevertToSnapShot(snapshot *DposContext) &#123;</span><br><span class="line">	d.EpochTrie = snapshot.EpochTrie</span><br><span class="line">	d.DelegateTrie = snapshot.DelegateTrie</span><br><span class="line">	d.CandidateTrie = snapshot.CandidateTrie</span><br><span class="line">	d.VoteTrie = snapshot.VoteTrie</span><br><span class="line">	d.MintCntTrie = snapshot.MintCntTrie</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="kickoutcandidate-：踢除候选人">KickoutCandidate()：踢除候选人</h3>
<p>该方法用于踢掉某个候选人（候选人有可能是验证人）<br>
该方法在这里就不贴具体代码了，<br>
删除某个候选人，需要涉及到三个trie：</p>
<ol>
<li>CandidateTrie：删掉对应候选人</li>
<li>DelegateTrie：删掉候选人何其对应的投票人</li>
<li>VoteTrie：删掉投票人对应的候选人</li>
</ol>
<p>从中也可以看出：<code>一个候选人可以有不同的投票人；一个投票人只能为一个候选人投票</code></p>
<h3 id="becomecandidate-：成为候选人">BecomeCandidate()：成为候选人</h3>
<p>任何拥有以太坊账户的人，都可以成为候选人。<br>
当然，真正线上的这一过程，是需要严格控制的。</p>
<h3 id="delegate-：为某候选人投票">Delegate()：为某候选人投票</h3>
<p>每轮选举，一个投票人只能为一个候选人投票，若该投票人已经为某候选人投票，想要再给新的候选人投票，则会覆盖原先旧的投票记录</p>
<h3 id="undelegate-：取消某投票人投票记录">UnDelegate()：取消某投票人投票记录</h3>
<ol>
<li>判断投票人是否已经投过票，以及给谁投的票</li>
<li>投票人不是给候选人candidate投的票，则不可以做取消操作</li>
<li>将候选人对应投票人删除</li>
<li>将投票人对应候选人删除</li>
</ol>
<h3 id="getvalidators-：获取验证人列表">GetValidators()：获取验证人列表</h3>
<p>获取当前验证人列表</p>
<h3 id="setvalidators-：设置当前验证人">SetValidators()：设置当前验证人</h3>
<p>设置当前验证人</p>
<h3 id="不足之处">不足之处</h3>
<ol>
<li>dpos_context和dpos_context_pro很容易让人感到凌乱，这是因为要跟别的模块交互的缘故，毕竟header只有hash，并没有具体块数据来支撑trie。<br>
后期如何将两者融合，或者用新的解决方案来处理，这是需要考虑的一个问题。</li>
<li>整体的数据操作方法没问题，但并没有做太大约束，比如成为候选人的条件等，当然，这属于dpos细节设计过程，这需要自行根据需要来设计。</li>
</ol>
<h3 id="小节">小节</h3>
<p>这一部分的实现，小编没有给出具体源码，主要是考虑到篇幅，另外一个原因是实现本身并没有太复杂的逻辑。<br>
定义了db中要存储的前缀和具体数据。这部分内容还是很容易理解的。<br>
trie由于新增了前缀操作，为此做了一些改动，这个改动在本文最后给出。</p>
<h2 id="epoch-context">epoch_context</h2>
<p>这一部分属于对验证人的操作过程，比如统计投票数、踢除不合格验证人等操作。属于dpos最重要的一部分。目前提供了以下几个方法，这里一一来详细说明</p>
<h3 id="countvotes-统计投票数">CountVotes() 统计投票数</h3>
<p>一个候选人会拥有多个投票人，该方法目的就是统计出所有候选人中，每个候选人分别拥有多少投票数。<br>
目前是这样进行统计的：</p>
<ol>
<li>通过candidateTrie获取所有候选人</li>
<li>通过delegateTrie检测某候选人是否有投票（备注：delegateTrie表示候选人对应的投票人，也就是只要检测该候选人是否有投票人即可）</li>
<li>一个候选人有多个投票人，将该候选人所有的投票人的账户余额相加的结果，就是当前候选人的投票数，比如每个投票人当前账户分别拥有1000wei，该候选人有5个投票人，则该候选人的投票数就是5000，将<code>候选人-&gt;投票数</code>记录在map</li>
<li>将map结果返回，其中就是所有候选人投票数</li>
</ol>
<h3 id="kickoutvalidator-踢除不合格验证人">KickoutValidator() 踢除不合格验证人</h3>
<p>踢除当前周期内不合格的验证人，<br>
如果一个周期内，一个验证人的出块数不够50%，则将其踢出。比如：一周期是24小时（86400秒），每隔10秒产生一个块，总共有21个验证人，则86400/10/21*0.5=206块，就是说，一个验证人一个周期生成的块数不足206块，则该验证人在新的一轮选举中被踢除。<br>
要确保踢出验证人后，剩余的所有候选人的人数在一个安全阈值内，一般是要满足总验证人的2/3</p>
<h3 id="lookupvalidator-获取当前验证人-也就是调度验证人">LookupValidator() 获取当前验证人,也就是调度验证人</h3>
<p>该方法是根据当前周期以及出块时间从验证人列表中选择一个正确的验证人。</p>
<h3 id="tryelect-开始选举验证人">TryElect() 开始选举验证人</h3>
<p>该过程用于从候选人中选择验证人。</p>
<ol>
<li>若上一个块的周期和当前块的周期不是同一周期，则触发选举</li>
<li>获取上一周期验证人以及对应的出块数</li>
<li>踢除上一周期不合格的验证人</li>
<li>获取所有候选人及其对应的投票数，选择最高21位作为验证人</li>
<li>将21位验证人顺序随机打乱</li>
</ol>
<h3 id="不足之处">不足之处</h3>
<p>候选人数量需要限制</p>
<h3 id="小节">小节</h3>
<p>本小节主要是对验证人的操作，目的就是踢掉不合格的验证人，选择新的验证人。<br>
这些都属于dpos内部逻辑。</p>
<h2 id="dpos">Dpos</h2>
<p>这个模块是用来实现以太坊共识引擎接口的。<br>
需要知道，dpos中，不需要叔块概念、不需要难度概念。<br>
先来看看Dpos的结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Dpos <span class="keyword">struct</span> &#123;</span><br><span class="line">	config *DposConfig</span><br><span class="line">	db     ethdb.Database <span class="comment">//存储验证人相关信息</span></span><br><span class="line"></span><br><span class="line">	signer common.Address <span class="comment">//打包人</span></span><br><span class="line">	signFn SignerFn</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ARCCache是一个线程安全的固定大小的自适应替换缓存工具。</span></span><br><span class="line">	<span class="comment">//ARC是对标准LRU缓存的一种改进，它跟踪使用的频率和最近情况。</span></span><br><span class="line">	<span class="comment">//这样就避免了对新条目的突然访问，无法将经常使用的旧条目逐出。</span></span><br><span class="line">	<span class="comment">//它为标准的LRU缓存增加了一些额外的跟踪开销，计算上它大约是成本的2倍，并且额外的内存开销与缓存的大小成线性关系。</span></span><br><span class="line">	<span class="comment">//ARC已获得IBM专利，但类似于需要设置参数的TwoQueueCache（2Q,双队列缓存).</span></span><br><span class="line">	signatures           *lru.ARCCache <span class="comment">//等待验签的块</span></span><br><span class="line">	confirmedBlockHeader *types.Header <span class="comment">//被确认了的块头部</span></span><br><span class="line">	mu   sync.RWMutex</span><br><span class="line">	stop <span class="keyword">chan</span> <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要的方法如下所示。</p>
<h3 id="verifyheader-验证头部">VerifyHeader() 验证头部</h3>
<p>验证块头部信息。<br>
这里重要的一点是<code>header.Extra</code>数据，其中包含有ecp256k1签名信息，需要确保其中该信息。</p>
<h3 id="verifyseal-验证块签名信息">VerifySeal() 验证块签名信息</h3>
<ol>
<li>创世块不验证</li>
<li>根据块的生成时间，获取该块的验证人地址，判断该验证人是否为块的签名人</li>
<li>另外重要的一点是：updateConfirmedBlockHeader()，这一步要更新待确认块的位置，让用户知道，当前哪些块被确认了，哪些块还没有。</li>
</ol>
<h3 id="prepare-初始化准备">Prepare() 初始化准备</h3>
<p>对头部信息设置</p>
<h3 id="finalize-奖励分发并进行新的选举">Finalize() 奖励分发并进行新的选举</h3>
<ol>
<li>为块生成者分发奖励</li>
<li>若父块和当前块是同一周期，则不选举；否则进行选举</li>
</ol>
<h3 id="seal-打包签名">Seal() 打包签名</h3>
<p>对当前块进行签名<br>
签名信息保存在header.extra中</p>
<h3 id="sealhash-返回head头部hash">SealHash() 返回head头部hash</h3>
<p>这个方法是用来生成一个块头部的hash，来看看源码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dpos)</span></span> SealHash(header *types.Header) (hash common.Hash) &#123;</span><br><span class="line">	hasher := sha3.NewLegacyKeccak256()</span><br><span class="line">	rlp.Encode(hasher, []<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">		header.ParentHash,</span><br><span class="line">		header.UncleHash,</span><br><span class="line">		header.Validator,</span><br><span class="line">		header.Coinbase,</span><br><span class="line">		header.Root,</span><br><span class="line">		header.TxHash,</span><br><span class="line">		header.ReceiptHash,</span><br><span class="line">		header.Bloom,</span><br><span class="line">		header.Difficulty,</span><br><span class="line">		header.Number,</span><br><span class="line">		header.GasLimit,</span><br><span class="line">		header.GasUsed,</span><br><span class="line">		header.Time,</span><br><span class="line">		header.Extra[:<span class="built_in">len</span>(header.Extra)<span class="number">-65</span>], <span class="comment">//这里记录签名信息</span></span><br><span class="line">		header.MixDigest,</span><br><span class="line">		header.Nonce,</span><br><span class="line">		header.DposContext.Root(),</span><br><span class="line">	&#125;)</span><br><span class="line">	hasher.Sum(hash[:<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">return</span> hash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用rlp编码，然后生成一个hash，这个就代表一个head，其中dpos部分，发现这样一行代码：<code>header.DposContext.Root()</code>，这表示dpos中的五棵trie被编码为一个hash存入其中。</p>
<h3 id="checkvalidator-检测验证人是否有效">CheckValidator() 检测验证人是否有效</h3>
<ol>
<li>上一个块和当前块时间是否正确<br>
2.根据块当前时间获取验证人，然后跟header.signer比较是否一致</li>
</ol>
<h3 id="小节">小节</h3>
<p>这一部分主要就是实现共识引擎的接口，相比较于pow，dpos的实现要容易很多</p>
<h2 id="trie数据存储">trie数据存储</h2>
<p>以太坊的trie是什么东西，小编原先讲解过，并对其源码也做过深入分析<br>
前面小编说过，dpos的五个trie是需要保存在db，以太坊原先的方式并不能满足这一需要，为此需要对现有的trie做一些改造。在现有trie模块的基础上，加入了如下两个文件：</p>
<ol>
<li>prefix_trie.go</li>
<li>prefix_trie_iterator.go</li>
</ol>
<h3 id="prefix-trie-go">prefix_trie.go</h3>
<p>这个文件中是对Trie结构体方法的扩充，加入了前缀后，trie的更新插入等操作有了些许变化，代码不多，都贴出来了，这里就不做注释，很简单：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTrieWithPrefix</span><span class="params">(root common.Hash, prefix []<span class="type">byte</span>, db ethdb.Database)</span></span> (*Trie, <span class="type">error</span>) &#123;</span><br><span class="line">	trie, err := New(root, NewDatabase(db))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	trie.prefix = prefix</span><br><span class="line">	<span class="keyword">return</span> trie, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> NodeIteratorWithPrefix(start []<span class="type">byte</span>) NodeIterator &#123;</span><br><span class="line">	<span class="keyword">if</span> t.prefix != <span class="literal">nil</span> &#123;</span><br><span class="line">		start = <span class="built_in">append</span>(t.prefix, start...)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newNodeIterator(t, start)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> PrefixIterator(prefix []<span class="type">byte</span>) NodeIterator &#123;</span><br><span class="line">	<span class="keyword">if</span> t.prefix != <span class="literal">nil</span> &#123;</span><br><span class="line">		prefix = <span class="built_in">append</span>(t.prefix, prefix...)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newPrefixIterator(t, prefix)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> UpdateWithPrefix(key, value []<span class="type">byte</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> err := t.TryUpdateWithPrefix(key, value); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Error(fmt.Sprintf(<span class="string">&quot;Unhandled trie error: %v&quot;</span>, err))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> TryUpdateWithPrefix(key, value []<span class="type">byte</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t.prefix != <span class="literal">nil</span> &#123;</span><br><span class="line">		key = <span class="built_in">append</span>(t.prefix, key...)</span><br><span class="line">	&#125;</span><br><span class="line">	k := keybytesToHex(key)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(value) != <span class="number">0</span> &#123;</span><br><span class="line">		_, n, err := t.insert(t.root, <span class="literal">nil</span>, k, valueNode(value))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		t.root = n</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		_, n, err := t.<span class="built_in">delete</span>(t.root, <span class="literal">nil</span>, k)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		t.root = n</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> GetWithPrefix(key []<span class="type">byte</span>) []<span class="type">byte</span> &#123;</span><br><span class="line">	res, err := t.TryGetWithPrefix(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Error(fmt.Sprintf(<span class="string">&quot;Unhandled trie error: %v&quot;</span>, err))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> TryGetWithPrefix(key []<span class="type">byte</span>) ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> t.prefix != <span class="literal">nil</span> &#123;</span><br><span class="line">		key = <span class="built_in">append</span>(t.prefix, key...)</span><br><span class="line">	&#125;</span><br><span class="line">	key = keybytesToHex(key)</span><br><span class="line">	value, newroot, didResolve, err := t.tryGet(t.root, key, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; didResolve &#123;</span><br><span class="line">		t.root = newroot</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> value, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> TryDeleteWithPrefix(key []<span class="type">byte</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t.prefix != <span class="literal">nil</span> &#123;</span><br><span class="line">		key = <span class="built_in">append</span>(t.prefix, key...)</span><br><span class="line">	&#125;</span><br><span class="line">	k := keybytesToHex(key)</span><br><span class="line">	_, n, err := t.<span class="built_in">delete</span>(t.root, <span class="literal">nil</span>, k)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	t.root = n</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="prefix-trie-iterator-go">prefix_trie_iterator.go</h3>
<p>对dpos各种trie需要进行遍历，而这个文件就是用来解决这一问题的。整个过程就是根据前缀来查找结果的。代码本身也不复杂，并且也不多，直接上代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> prefixIterator <span class="keyword">struct</span> &#123;</span><br><span class="line">	prefix       []<span class="type">byte</span></span><br><span class="line">	nodeIterator NodeIterator</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPrefixIterator</span><span class="params">(trie *Trie, prefix []<span class="type">byte</span>)</span></span> NodeIterator &#123;</span><br><span class="line">	<span class="keyword">if</span> trie.Hash() == emptyState &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">new</span>(prefixIterator)</span><br><span class="line">	&#125;</span><br><span class="line">	nodeIt := newNodeIterator(trie, prefix)</span><br><span class="line">	prefix = keybytesToHex(prefix)</span><br><span class="line">	<span class="keyword">return</span> &amp;prefixIterator&#123;</span><br><span class="line">		nodeIterator: nodeIt,</span><br><span class="line">		prefix:       prefix[:<span class="built_in">len</span>(prefix)<span class="number">-1</span>],</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *prefixIterator)</span></span> hasPrefix() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> bytes.HasPrefix(it.nodeIterator.Path(), it.prefix)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *prefixIterator)</span></span> Next(descend <span class="type">bool</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> it.nodeIterator.Next(descend) &#123;</span><br><span class="line">		<span class="keyword">if</span> it.hasPrefix() &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *prefixIterator)</span></span> Error() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> it.nodeIterator.Error()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *prefixIterator)</span></span> Hash() common.Hash &#123;</span><br><span class="line">	<span class="keyword">if</span> it.hasPrefix() &#123;</span><br><span class="line">		<span class="keyword">return</span> it.nodeIterator.Hash()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> common.Hash&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *prefixIterator)</span></span> Parent() common.Hash &#123;</span><br><span class="line">	<span class="keyword">if</span> it.hasPrefix() &#123;</span><br><span class="line">		it.nodeIterator.Parent()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> common.Hash&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *prefixIterator)</span></span> Path() []<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> it.hasPrefix() &#123;</span><br><span class="line">		<span class="keyword">return</span> it.nodeIterator.Path()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *prefixIterator)</span></span> Leaf() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> it.hasPrefix() &#123;</span><br><span class="line">		<span class="keyword">return</span> it.nodeIterator.Leaf()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *prefixIterator)</span></span> LeafKey() []<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> it.hasPrefix() &#123;</span><br><span class="line">		<span class="keyword">return</span> it.nodeIterator.LeafKey()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *prefixIterator)</span></span> LeafBlob() []<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> it.hasPrefix() &#123;</span><br><span class="line">		<span class="keyword">return</span> it.nodeIterator.LeafBlob()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *prefixIterator)</span></span> LeafProof() [][]<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="comment">//TODO 该方法暂时未用到</span></span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;implement me&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ol>
<li>以太坊的理念是，每个功能都模块化，但是dpos的改造，将其中的内容都被扩散到不同的模块，耦合度过高。</li>
<li>本文中，更多描述的是dpos在以太坊共识模块中的实现，这个过程相对来说要好理解，但是，如果将以太坊切换为dpos，这才是工程中的难点，这个过程小编也正在验证，后续会发出新的文章来专门讲解这一过程。</li>
<li>补充一下，上面提到的每个模块，都有对应的单元测试，可以快速验证每个方法。</li>
</ol>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>综合</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊源码解读-第9讲-blockchain</title>
    <url>/articles/a749acc8/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>多条链分叉时候，如何选择？链中的块如何验证？每个块是如何组合的？怎样插入？还原？。。。<br>
要理清这些问题，就必须了解<code>core-&gt;blockchain.go</code>其中的原理</p>
<span id="more"></span>
<p>这里代表的就是区块链的精髓，会牵涉到多个文件，我们一一来介绍。</p>
<h2 id="先来看blockchain结构体">先来看blockchain结构体</h2>
<p>描述了一条链的结构，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> BlockChain <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">//硬分叉的一些配置</span></span><br><span class="line">	chainConfig *params.ChainConfig</span><br><span class="line">	<span class="comment">//主要是trie节点的缓存配置，其中包括是否允许缓存、trie最多允许缓存的容量(MB)、缓存刷新到磁盘的时间</span></span><br><span class="line">	cacheConfig *CacheConfig       </span><br><span class="line">	<span class="comment">//用来存储最终数据的地方</span></span><br><span class="line">	db     ethdb.Database </span><br><span class="line">	<span class="comment">//根据块号优先级来对其中的trie树进行gc</span></span><br><span class="line">	triegc *prque.Prque</span><br><span class="line">	<span class="comment">// trie进行gc前的延时</span></span><br><span class="line">	gcproc time.Duration  </span><br><span class="line">	<span class="comment">//一条链的头部信息，这个是非线程安全的，具体后面再来分析</span></span><br><span class="line">	hc            *HeaderChain</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 下面几个个是一些事件，后面再来补充</span></span><br><span class="line">	rmLogsFeed    event.Feed</span><br><span class="line">	chainFeed     event.Feed</span><br><span class="line">	chainSideFeed event.Feed</span><br><span class="line">	chainHeadFeed event.Feed</span><br><span class="line">	logsFeed      event.Feed</span><br><span class="line">	scope         event.SubscriptionScope</span><br><span class="line">	<span class="comment">//创世区块</span></span><br><span class="line">	genesisBlock  *types.Block</span><br><span class="line"></span><br><span class="line">	<span class="comment">//全局的一个读写锁，用来锁定链的操作</span></span><br><span class="line">	mu      sync.RWMutex </span><br><span class="line">	<span class="comment">//插入锁</span></span><br><span class="line">	chainmu sync.RWMutex </span><br><span class="line">	<span class="comment">//待定</span></span><br><span class="line">	procmu  sync.RWMutex</span><br><span class="line"></span><br><span class="line">	<span class="comment">//下面这些后面再来解释</span></span><br><span class="line">	checkpoint       <span class="type">int</span></span><br><span class="line">	<span class="comment">//当前的区块头    </span></span><br><span class="line">	currentBlock     atomic.Value</span><br><span class="line">	<span class="comment">// 当前的快速同步的区块头. </span></span><br><span class="line">	currentFastBlock atomic.Value </span><br><span class="line"></span><br><span class="line">	<span class="comment">//处理块和编码使用一些缓存</span></span><br><span class="line">	stateCache    state.Database </span><br><span class="line">	bodyCache     *lru.Cache     </span><br><span class="line">	bodyRLPCache  *lru.Cache     </span><br><span class="line">	receiptsCache *lru.Cache     </span><br><span class="line">	blockCache    *lru.Cache </span><br><span class="line">	<span class="comment">//暂时还不能插入的区块存放位置</span></span><br><span class="line">	futureBlocks  *lru.Cache     </span><br><span class="line"></span><br><span class="line">	<span class="comment">//链推出管道</span></span><br><span class="line">	quit    <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; </span><br><span class="line">	<span class="comment">//原子操作，暂时不确定要干嘛</span></span><br><span class="line">	running <span class="type">int32</span> </span><br><span class="line">	<span class="comment">//用于中断块处理过程        </span></span><br><span class="line">	procInterrupt <span class="type">int32</span></span><br><span class="line">	<span class="comment">//等待链的关闭          </span></span><br><span class="line">	wg            sync.WaitGroup </span><br><span class="line"></span><br><span class="line">	<span class="comment">//共识引擎</span></span><br><span class="line">	engine    consensus.Engine</span><br><span class="line">	<span class="comment">//用于处理块的接口</span></span><br><span class="line">	processor Processor </span><br><span class="line">	<span class="comment">//块和状态验证接口</span></span><br><span class="line">	validator Validator </span><br><span class="line">	vmConfig  vm.Config</span><br><span class="line"></span><br><span class="line">	<span class="comment">//错误块的缓存</span></span><br><span class="line">	badBlocks      *lru.Cache</span><br><span class="line">	<span class="comment">//一个方法，用来判断是否需要保留某个块              </span></span><br><span class="line">	shouldPreserve <span class="function"><span class="keyword">func</span><span class="params">(*types.Block)</span></span> <span class="type">bool</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链的构建过程">链的构建过程</h2>
<p>生成一个全节点的链的入口，这是使用数据库里面的信息来构造的，来看看这个方法具体做了哪些内容：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlockChain</span><span class="params">(db ethdb.Database, cacheConfig *CacheConfig, chainConfig *params.ChainConfig, engine consensus.Engine, vmConfig vm.Config, shouldPreserve <span class="keyword">func</span>(block *types.Block)</span></span> <span class="type">bool</span>) (*BlockChain, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> cacheConfig == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">//设置默认的缓存参数</span></span><br><span class="line">		cacheConfig = &amp;CacheConfig&#123;</span><br><span class="line">			<span class="comment">//默认节点256T</span></span><br><span class="line">			TrieNodeLimit: <span class="number">256</span> * <span class="number">1024</span> * <span class="number">1024</span>,</span><br><span class="line">			<span class="comment">//将缓存刷新到磁盘的时间</span></span><br><span class="line">			TrieTimeLimit: <span class="number">5</span> * time.Minute,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//初始化缓存</span></span><br><span class="line">	bodyCache, _ := lru.New(bodyCacheLimit)</span><br><span class="line">	bodyRLPCache, _ := lru.New(bodyCacheLimit)</span><br><span class="line">	receiptsCache, _ := lru.New(receiptsCacheLimit)</span><br><span class="line">	blockCache, _ := lru.New(blockCacheLimit)</span><br><span class="line">	futureBlocks, _ := lru.New(maxFutureBlocks)</span><br><span class="line">	badBlocks, _ := lru.New(badBlockLimit)</span><br><span class="line">	<span class="comment">//链结构体赋值</span></span><br><span class="line">	bc := &amp;BlockChain&#123;</span><br><span class="line">		chainConfig:    chainConfig,</span><br><span class="line">		cacheConfig:    cacheConfig,</span><br><span class="line">		db:             db,</span><br><span class="line">		triegc:         prque.New(<span class="literal">nil</span>),</span><br><span class="line">		stateCache:     state.NewDatabase(db),</span><br><span class="line">		quit:           <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		shouldPreserve: shouldPreserve,</span><br><span class="line">		bodyCache:      bodyCache,</span><br><span class="line">		bodyRLPCache:   bodyRLPCache,</span><br><span class="line">		receiptsCache:  receiptsCache,</span><br><span class="line">		blockCache:     blockCache,</span><br><span class="line">		futureBlocks:   futureBlocks,</span><br><span class="line">		engine:         engine,</span><br><span class="line">		vmConfig:       vmConfig,</span><br><span class="line">		badBlocks:      badBlocks,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置验证机制，这里会调用block_validator.go文件中的内容</span></span><br><span class="line">	bc.SetValidator(NewBlockValidator(chainConfig, bc, engine))</span><br><span class="line">	<span class="comment">//设置处理块机制，这里会调用state_processor.go文件中的内容</span></span><br><span class="line">	bc.SetProcessor(NewStateProcessor(chainConfig, bc, engine))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	<span class="comment">//链的头部，这块牵涉到headerchain.go文件</span></span><br><span class="line">	bc.hc, err = NewHeaderChain(db, chainConfig, engine, bc.getProcInterrupt)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创世块的设置</span></span><br><span class="line">	bc.genesisBlock = bc.GetBlockByNumber(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> bc.genesisBlock == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, ErrNoGenesis</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//加载最新状态</span></span><br><span class="line">	<span class="keyword">if</span> err := bc.loadLastState(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 手动检查链中是否有坏块，BadHashes中手动存入一些坏块地址，一般硬分叉使用</span></span><br><span class="line">	<span class="keyword">for</span> hash := <span class="keyword">range</span> BadHashes &#123;</span><br><span class="line">		<span class="keyword">if</span> header := bc.GetHeaderByHash(hash); header != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">//获取规范的区块链上面同样高度的区块头,</span></span><br><span class="line">			<span class="comment">//如果这个区块头确实是在我们的规范的区块链上的话,我们需要回滚到这个区块头的高度 - 1，此时高度为最新块</span></span><br><span class="line">			<span class="comment">//要确保规范块里没有坏块（硬分叉的块、非法块）</span></span><br><span class="line">			<span class="comment">//header.Number指向当前最新块</span></span><br><span class="line">			headerByNumber := bc.GetHeaderByNumber(header.Number.Uint64())</span><br><span class="line">			<span class="keyword">if</span> headerByNumber != <span class="literal">nil</span> &amp;&amp; headerByNumber.Hash() == header.Hash() &#123;</span><br><span class="line">				log.Error(<span class="string">&quot;Found bad hash, rewinding chain&quot;</span>, <span class="string">&quot;number&quot;</span>, header.Number, <span class="string">&quot;hash&quot;</span>, header.ParentHash)</span><br><span class="line">				<span class="comment">//会一直往上一个块回滚，直到稳定</span></span><br><span class="line">				bc.SetHead(header.Number.Uint64() - <span class="number">1</span>) </span><br><span class="line">				log.Error(<span class="string">&quot;Chain rewind was successful, resuming normal operation&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//异步，将未来块（就是还在缓存中暂时没加入的块）加入到规范链中</span></span><br><span class="line">	<span class="comment">//其中会涉及到一个块的插入概念</span></span><br><span class="line">	<span class="keyword">go</span> bc.update() </span><br><span class="line">	<span class="keyword">return</span> bc, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面最重要的几个部分：</p>
<ol>
<li>坏块的检查，</li>
<li>是从db中加载最新状态的过程，也就是<code>bc.loadLastState()</code>这个方法，</li>
<li>块的插入，<code>InsertChain()</code>方法</li>
</ol>
<p>接下来一一介绍这几部分内容</p>
<h3 id="坏块的检查">坏块的检查</h3>
<p>BadHashes 可以手工禁止接受一些区块的hash值.在blocks.go里面.<br>
可以避免一些硬分叉问题，保证链的正统性。</p>
<h3 id="bc-loadlaststate-加载最新状态">bc.loadLastState()加载最新状态</h3>
<p>从db中加载链的最新状态，这部分代码量也非常大，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> loadLastState() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 获取最新一个块的hash头部</span></span><br><span class="line">	head := rawdb.ReadHeadBlockHash(bc.db)</span><br><span class="line">	<span class="keyword">if</span> head == (common.Hash&#123;&#125;) &#123;</span><br><span class="line">		log.Warn(<span class="string">&quot;Empty database, resetting chain&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> bc.Reset() <span class="comment">//使用创世块初始化链</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 根据块的hash获取当前块</span></span><br><span class="line">	currentBlock := bc.GetBlockByHash(head)</span><br><span class="line">	<span class="keyword">if</span> currentBlock == <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Warn(<span class="string">&quot;Head block missing, resetting chain&quot;</span>, <span class="string">&quot;hash&quot;</span>, head)</span><br><span class="line">		<span class="keyword">return</span> bc.Reset() <span class="comment">//使用创世块初始化链</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 看当前块的hash和db中记录能否联系上，不能则一直回滚</span></span><br><span class="line">	<span class="keyword">if</span> _, err := state.New(currentBlock.Root(), bc.stateCache); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Warn(<span class="string">&quot;Head state missing, repairing chain&quot;</span>, <span class="string">&quot;number&quot;</span>, currentBlock.Number(), <span class="string">&quot;hash&quot;</span>, currentBlock.Hash())</span><br><span class="line">		<span class="comment">//repair，会一直回滚，直到能够获取到状态的树</span></span><br><span class="line">		<span class="keyword">if</span> err := bc.repair(&amp;currentBlock); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 设置最新块</span></span><br><span class="line">	bc.currentBlock.Store(currentBlock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置当前链head</span></span><br><span class="line">	currentHeader := currentBlock.Header()</span><br><span class="line">	<span class="keyword">if</span> head := rawdb.ReadHeadHeaderHash(bc.db); head != (common.Hash&#123;&#125;) &#123;</span><br><span class="line">		<span class="keyword">if</span> header := bc.GetHeaderByHash(head); header != <span class="literal">nil</span> &#123;</span><br><span class="line">			currentHeader = header</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	bc.hc.SetCurrentHeader(currentHeader)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置轻量级的块</span></span><br><span class="line">	bc.currentFastBlock.Store(currentBlock)</span><br><span class="line">	<span class="keyword">if</span> head := rawdb.ReadHeadFastBlockHash(bc.db); head != (common.Hash&#123;&#125;) &#123;</span><br><span class="line">		<span class="keyword">if</span> block := bc.GetBlockByHash(head); block != <span class="literal">nil</span> &#123;</span><br><span class="line">			bc.currentFastBlock.Store(block)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 日志展示</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="insertchain-块的插入">InsertChain()，块的插入</h3>
<p>插入区块链尝试把给定的区块插入到规范的链条,或者是创建一个分叉. 如果发生错误,那么会返回错误发生时候的index和具体的错误信息.<br>
先来看插入块的入口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是一个总的方法，分为两部分，一部分用于插入多个块，</span></span><br><span class="line"><span class="comment">//另一部分属于累计的事件，将会被触发</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> InsertChain(chain types.Blocks) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	n, events, logs, err := bc.insertChain(chain)</span><br><span class="line">	bc.PostChainEvents(events, logs)</span><br><span class="line">	<span class="keyword">return</span> n, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入部分的实现，这部分代码量有点大，但必须理解（插入的块必须连续）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//insertChain方法会执行区块链插入,并收集事件信息. 因为需要使用defer来处理解锁,所以把这个方法作为一个单独的方法.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> insertChain(chain types.Blocks) (<span class="type">int</span>, []<span class="keyword">interface</span>&#123;&#125;, []*types.Log, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(chain) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 做一个完整性检查，提供的链实际上是有序的和相互链接的</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(chain); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> chain[i].NumberU64() != chain[i<span class="number">-1</span>].NumberU64()+<span class="number">1</span> || chain[i].ParentHash() != chain[i<span class="number">-1</span>].Hash() &#123;</span><br><span class="line">			<span class="comment">//不满足基本规范，直接返回</span></span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;为节省篇幅，这个描述改动。表示：链不规范&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 锁机制</span></span><br><span class="line">	bc.wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">defer</span> bc.wg.Done()</span><br><span class="line"></span><br><span class="line">	bc.chainmu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> bc.chainmu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用队列来处理事件，这效果通常比用互斥锁的机制要快很多</span></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		<span class="comment">//起始时间，以太坊使用mclock.Now()来计算程序执行时间，这个更加精确</span></span><br><span class="line">		stats         = insertStats&#123;startTime: mclock.Now()&#125;  </span><br><span class="line">		<span class="comment">//事件长度和待加入的块数一致</span></span><br><span class="line">		events        = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, <span class="built_in">len</span>(chain))</span><br><span class="line">		lastCanon     *types.Block</span><br><span class="line">		coalescedLogs []*types.Log</span><br><span class="line">	)</span><br><span class="line">	<span class="comment">//先检测这些块的合法性</span></span><br><span class="line">	headers := <span class="built_in">make</span>([]*types.Header, <span class="built_in">len</span>(chain))</span><br><span class="line">	seals := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(chain))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, block := <span class="keyword">range</span> chain &#123;</span><br><span class="line">		headers[i] = block.Header()</span><br><span class="line">		seals[i] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	abort, results := bc.engine.VerifyHeaders(bc, headers, seals)</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(abort)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这行不太理解，这是新版加入的一行代码，原先是没有的，可能是减少分叉带来的一些问题吧</span></span><br><span class="line">	<span class="comment">// 从一批块中恢复发件人，并将它们缓存回相同的数据结构中。</span></span><br><span class="line">	<span class="comment">// 没有进行验证，也没有对无效签名作出任何反应。这取决于稍后调用代码。</span></span><br><span class="line">	<span class="comment">// 签名人会在分叉转换上碰碰运气。为避免问题，将所有交易都打上同一个签名？</span></span><br><span class="line">	senderCacher.recoverFromBlocks(types.MakeSigner(bc.chainConfig, chain[<span class="number">0</span>].Number()), chain)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理每个块</span></span><br><span class="line">	<span class="keyword">for</span> i, block := <span class="keyword">range</span> chain &#123;</span><br><span class="line">		<span class="comment">// 如果这些块正在终止，则停止往后执行</span></span><br><span class="line">		<span class="keyword">if</span> atomic.LoadInt32(&amp;bc.procInterrupt) == <span class="number">1</span> &#123;</span><br><span class="line">			log.Debug(<span class="string">&quot;Premature abort during blocks processing&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果有坏块，则停止处理之后的每个块，估计是尝试硬分叉吧</span></span><br><span class="line">		<span class="keyword">if</span> BadHashes[block.Hash()] &#123;</span><br><span class="line">			bc.reportBlock(block, <span class="literal">nil</span>, ErrBlacklistedHash)</span><br><span class="line">			<span class="keyword">return</span> i, events, coalescedLogs, ErrBlacklistedHash</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 开始验证块</span></span><br><span class="line">		bstart := time.Now()</span><br><span class="line">		<span class="comment">//结果输出</span></span><br><span class="line">		err := &lt;-results</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">//验证块</span></span><br><span class="line">			err = bc.Validator().ValidateBody(block)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> err == ErrKnownBlock:</span><br><span class="line">			<span class="comment">//如果待插入的块比当前块的块号小，则忽略</span></span><br><span class="line">			<span class="keyword">if</span> bc.CurrentBlock().NumberU64() &gt;= block.NumberU64() &#123;</span><br><span class="line">				stats.ignored++</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> err == consensus.ErrFutureBlock:</span><br><span class="line">			<span class="comment">//如果该块的时间超过了当前时间+30s，则返回错误日志</span></span><br><span class="line">			max := big.NewInt(time.Now().Unix() + maxTimeFutureBlocks)</span><br><span class="line">			<span class="keyword">if</span> block.Time().Cmp(max) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> i, events, coalescedLogs, fmt.Errorf(<span class="string">&quot;future block: %v &gt; %v&quot;</span>, block.Time(), max)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//若满足要求，则放入futureBlocks中，等待后续处理</span></span><br><span class="line">			bc.futureBlocks.Add(block.Hash(), block)</span><br><span class="line">			stats.queued++</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> err == consensus.ErrUnknownAncestor &amp;&amp; bc.futureBlocks.Contains(block.ParentHash()):</span><br><span class="line">		<span class="comment">//块祖先不确定，并且缓存中有该块，则更新</span></span><br><span class="line">			bc.futureBlocks.Add(block.Hash(), block)</span><br><span class="line">			stats.queued++</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> err == consensus.ErrPrunedAncestor:<span class="comment">//块状态无效，状态树问题</span></span><br><span class="line">			currentBlock := bc.CurrentBlock()</span><br><span class="line">			<span class="comment">//当前链的总难度</span></span><br><span class="line">			localTd := bc.GetTd(currentBlock.Hash(), currentBlock.NumberU64())</span><br><span class="line">			<span class="comment">//新的链的总难度</span></span><br><span class="line">			externTd := <span class="built_in">new</span>(big.Int).Add(bc.GetTd(block.ParentHash(), block.NumberU64()<span class="number">-1</span>), block.Difficulty())</span><br><span class="line">			<span class="comment">//如果当前链难度大于新的链的难度，则将其加入db</span></span><br><span class="line">			<span class="keyword">if</span> localTd.Cmp(externTd) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">//这是用来构造竞争的分叉，直到他们超过了标准的总难度。</span></span><br><span class="line">				<span class="keyword">if</span> err = bc.WriteBlockWithoutState(block, externTd); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> i, events, coalescedLogs, err</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">var</span> winner []*types.Block</span><br><span class="line">			<span class="comment">//获取block的父块</span></span><br><span class="line">			parent := bc.GetBlock(block.ParentHash(), block.NumberU64()<span class="number">-1</span>)</span><br><span class="line">			<span class="comment">//检查状态trie是否完全存在于数据库中。</span></span><br><span class="line">			<span class="comment">//parent.Root表示的是状态树（账户），并不是每个块都有状态</span></span><br><span class="line">			<span class="keyword">for</span> !bc.HasState(parent.Root()) &#123;</span><br><span class="line">				winner = <span class="built_in">append</span>(winner, parent)</span><br><span class="line">				parent = bc.GetBlock(parent.ParentHash(), parent.NumberU64()<span class="number">-1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//有状态树的被放在第一个，</span></span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(winner)/<span class="number">2</span>; j++ &#123;</span><br><span class="line">				winner[j], winner[<span class="built_in">len</span>(winner)<span class="number">-1</span>-j] = winner[<span class="built_in">len</span>(winner)<span class="number">-1</span>-j], winner[j]</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 将该组block加入</span></span><br><span class="line">			bc.chainmu.Unlock()</span><br><span class="line">			_, evs, logs, err := bc.insertChain(winner)</span><br><span class="line">			bc.chainmu.Lock()</span><br><span class="line">			events, coalescedLogs = evs, logs</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> i, events, coalescedLogs, err</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> err != <span class="literal">nil</span>:</span><br><span class="line">			<span class="comment">//其余错误直接返回日志</span></span><br><span class="line">			bc.reportBlock(block, <span class="literal">nil</span>, err)</span><br><span class="line">			<span class="keyword">return</span> i, events, coalescedLogs, err</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//获取父块</span></span><br><span class="line">		<span class="keyword">var</span> parent *types.Block</span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">			parent = bc.GetBlock(block.ParentHash(), block.NumberU64()<span class="number">-1</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			parent = chain[i<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//返回一个状态树</span></span><br><span class="line">		state, err := state.New(parent.Root(), bc.stateCache)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> i, events, coalescedLogs, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 使用状态树处理待加入的块</span></span><br><span class="line">		receipts, logs, usedGas, err := bc.processor.Process(block, state, bc.vmConfig)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			bc.reportBlock(block, receipts, err)</span><br><span class="line">			<span class="keyword">return</span> i, events, coalescedLogs, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 验证待加入的块的状态信息</span></span><br><span class="line">		err = bc.Validator().ValidateState(block, parent, state, receipts, usedGas)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			bc.reportBlock(block, receipts, err)</span><br><span class="line">			<span class="keyword">return</span> i, events, coalescedLogs, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//处理截止时间</span></span><br><span class="line">		proctime := time.Since(bstart)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 写入区块和状态</span></span><br><span class="line">		status, err := bc.WriteBlockWithState(block, receipts, state)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> i, events, coalescedLogs, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> status &#123;</span><br><span class="line">		<span class="keyword">case</span> CanonStatTy: <span class="comment">//插入了新区块</span></span><br><span class="line">			log.Debug(<span class="string">&quot;Inserted new block&quot;</span>, <span class="string">&quot;number&quot;</span>, block.Number(), <span class="string">&quot;hash&quot;</span>, block.Hash(), <span class="string">&quot;uncles&quot;</span>, <span class="built_in">len</span>(block.Uncles()),</span><br><span class="line">				<span class="string">&quot;txs&quot;</span>, <span class="built_in">len</span>(block.Transactions()), <span class="string">&quot;gas&quot;</span>, block.GasUsed(), <span class="string">&quot;elapsed&quot;</span>, common.PrettyDuration(time.Since(bstart)))</span><br><span class="line"></span><br><span class="line">			coalescedLogs = <span class="built_in">append</span>(coalescedLogs, logs...)</span><br><span class="line">			blockInsertTimer.UpdateSince(bstart)</span><br><span class="line">			events = <span class="built_in">append</span>(events, ChainEvent&#123;block, block.Hash(), logs&#125;)</span><br><span class="line">			lastCanon = block</span><br><span class="line"></span><br><span class="line">			bc.gcproc += proctime</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> SideStatTy:  <span class="comment">// 插入了一个forked 区块</span></span><br><span class="line">			log.Debug(<span class="string">&quot;Inserted forked block&quot;</span>, <span class="string">&quot;number&quot;</span>, block.Number(), <span class="string">&quot;hash&quot;</span>, block.Hash(), <span class="string">&quot;diff&quot;</span>, block.Difficulty(), <span class="string">&quot;elapsed&quot;</span>,</span><br><span class="line">				common.PrettyDuration(time.Since(bstart)), <span class="string">&quot;txs&quot;</span>, <span class="built_in">len</span>(block.Transactions()), <span class="string">&quot;gas&quot;</span>, block.GasUsed(), <span class="string">&quot;uncles&quot;</span>, <span class="built_in">len</span>(block.Uncles()))</span><br><span class="line"></span><br><span class="line">			blockInsertTimer.UpdateSince(bstart)</span><br><span class="line">			events = <span class="built_in">append</span>(events, ChainSideEvent&#123;block&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		stats.processed++</span><br><span class="line">		stats.usedGas += usedGas</span><br><span class="line"></span><br><span class="line">		cache, _ := bc.stateCache.TrieDB().Size()</span><br><span class="line">		stats.report(chain, i, cache)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 事件加入</span></span><br><span class="line">	<span class="keyword">if</span> lastCanon != <span class="literal">nil</span> &amp;&amp; bc.CurrentBlock().Hash() == lastCanon.Hash() &#123;</span><br><span class="line">		events = <span class="built_in">append</span>(events, ChainHeadEvent&#123;lastCanon&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>, events, coalescedLogs, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中牵涉到两个重要的方法：<code>WriteBlockWithState()</code>以及<code>reorg()</code>，建议也去阅读下，里面会具体判断应该使用哪条链。难度高的和难度低的链如何处理等问题。时间和精力有限，本文暂时就分析到这里。</p>
<h2 id="总结">总结</h2>
<p>这一部分，链的初始化，其中加入了大量的检测，最终目的就是要有一个规范的链生成，当出现异常块时，会一直往前回滚，直到找到正常的块为止。也就是找一个最新的正常块。</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊源码解读-第8讲-块(block)</title>
    <url>/articles/10e60082/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p><code>块</code>贯穿了这个区块链的始终，前面的几篇文章总讲到块的生成，但具体到底怎么一回事，一直没提。<br>
因此，小编认为还是有必要把一个block的细节梳理一下，本文主要是讲<code>core-&gt;types-&gt;block.go</code>文件中的内容。</p>
<span id="more"></span>
<p>先来看看一个块有哪些内容：</p>
 
<p>从图中，我们大体将一个块分为两部分，左半部分为Head，又半部分为Body.<br>
Header相对轻量，涵盖了Block的所有属性，包括特征标示，前向指针，和内部数据集的验证哈希值等；body相对重量，持有内部数据集。每个Block的Header部分，Body部分，以及一些特征属性，都以[k,v]形式单独存储在底层数据库中。</p>
<h2 id="block">Block</h2>
<p>上面大概提到Body中有两部分内容，但真实的实现中，还有一些别的内容，如下结构。</p>

<p>下面是一个完整块的结构体描述，我们来看看一个块中具体到底有哪些内容：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">//头部</span></span><br><span class="line">	header       *Header</span><br><span class="line">	<span class="comment">//叔块</span></span><br><span class="line">	uncles       []*Header</span><br><span class="line">	<span class="comment">//交易信息</span></span><br><span class="line">	transactions Transactions</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 缓存数据操作</span></span><br><span class="line">	hash atomic.Value</span><br><span class="line">	size atomic.Value</span><br><span class="line"></span><br><span class="line">	<span class="comment">//难度值相关，具体使用不明确，后面再来补坑</span></span><br><span class="line">	td *big.Int</span><br><span class="line"></span><br><span class="line">	<span class="comment">//内部使用，暂不明确，后面再来补坑</span></span><br><span class="line">	ReceivedAt   time.Time</span><br><span class="line">	ReceivedFrom <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第一种生成块的方式">第一种生成块的方式</h3>
<p>根据传入信息生成一个完整块，<br>
这里会看到交易树和收据树的处理，而状态树是在header中生成一个roothash，这个有兴趣可以单独去看，后面涉及到再专门去讲。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入的header信息会随着传入的txs和receipts发生改变</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlock</span><span class="params">(header *Header, txs []*Transaction, uncles []*Header, receipts []*Receipt)</span></span> *Block &#123;</span><br><span class="line">	<span class="comment">//可以看出此处是拷贝的一个header，而td直接为0</span></span><br><span class="line">	b := &amp;Block&#123;header: CopyHeader(header), td: <span class="built_in">new</span>(big.Int)&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(txs) == <span class="number">0</span> &#123;</span><br><span class="line">		b.header.TxHash = EmptyRootHash <span class="comment">//空的hash,rlp空的时候生成的</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//这里可以看出，只要有一笔交易被篡改，交易树的hash就会变</span></span><br><span class="line">		b.header.TxHash = DeriveSha(Transactions(txs)) <span class="comment">//根据传入的信息生成交易树的hash，</span></span><br><span class="line">		b.transactions = <span class="built_in">make</span>(Transactions, <span class="built_in">len</span>(txs)) </span><br><span class="line">		<span class="built_in">copy</span>(b.transactions, txs)<span class="comment">//具体的交易信息保存在块中</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(receipts) == <span class="number">0</span> &#123;</span><br><span class="line">		b.header.ReceiptHash = EmptyRootHash <span class="comment">//收据树，空的hash,rlp空的时候生成的</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		b.header.ReceiptHash = DeriveSha(Receipts(receipts)) <span class="comment">//收据树列表hash</span></span><br><span class="line">		b.header.Bloom = CreateBloom(receipts) <span class="comment">//根据收据树生成一个布隆过滤器</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(uncles) == <span class="number">0</span> &#123;</span><br><span class="line">		b.header.UncleHash = EmptyUncleHash</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		b.header.UncleHash = CalcUncleHash(uncles) <span class="comment">//将所有叔块生成一个hash</span></span><br><span class="line">		b.uncles = <span class="built_in">make</span>([]*Header, <span class="built_in">len</span>(uncles))</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> uncles &#123;</span><br><span class="line">			b.uncles[i] = CopyHeader(uncles[i]) <span class="comment">//拷贝叔块</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二种生成块的方式">第二种生成块的方式</h3>
<p>这种方式只是传入了header信息，区别于第一种：第一种会传入txs,receipts，会随着这些信息的变化，header发生变换。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlockWithHeader</span><span class="params">(header *Header)</span></span> *Block &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Block&#123;header: CopyHeader(header)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="block的相关方法">block的相关方法</h3>
<p>列出目前还没被废弃的方法。</p>
<h4 id="序列化相关的两个方法：decoderlp和encoderlp">序列化相关的两个方法：DecodeRLP和EncodeRLP</h4>
<p>该方法将解码rlp字节流，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> DecodeRLP(s *rlp.Stream) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">//extblock结构体是用来存储解析结果的，其中包括header、uncles、transacitions</span></span><br><span class="line">	<span class="keyword">var</span> eb extblock </span><br><span class="line">	_, size, _ := s.Kind()</span><br><span class="line">	<span class="keyword">if</span> err := s.Decode(&amp;eb); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	b.header, b.uncles, b.transactions = eb.Header, eb.Uncles, eb.Txs</span><br><span class="line">	b.size.Store(common.StorageSize(rlp.ListSize(size)))</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法将一个block进行rlp序列化，不解释</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> EncodeRLP(w io.Writer) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> rlp.Encode(w, extblock&#123;</span><br><span class="line">		Header: b.header,</span><br><span class="line">		Txs:    b.transactions,</span><br><span class="line">		Uncles: b.uncles,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="其余方法">其余方法</h4>
<p>主要都是用来对外展示块信息，都是比较基础的方法，很好理解，先不要太过深的考虑每个方法什么地方使用，当梳理完这些内容后，心里自然会有底。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回叔块信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> Uncles() []*Header          &#123; <span class="keyword">return</span> b.uncles &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展示交易信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> Transactions() Transactions &#123; <span class="keyword">return</span> b.transactions &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据传入的hash返回其对应的交易信息，这个就是用来展示某交易是否在当前块中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> Transaction(hash common.Hash) *Transaction &#123;</span><br><span class="line">	<span class="keyword">for</span> _, transaction := <span class="keyword">range</span> b.transactions &#123;</span><br><span class="line">		<span class="keyword">if</span> transaction.Hash() == hash &#123;</span><br><span class="line">			<span class="keyword">return</span> transaction</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回当前块所在高度（*big.Int形式返回）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> Number() *big.Int     &#123; <span class="keyword">return</span> <span class="built_in">new</span>(big.Int).Set(b.header.Number) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回当前块所在高度（uint64形式返回）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> NumberU64() <span class="type">uint64</span>        &#123; <span class="keyword">return</span> b.header.Number.Uint64() &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前块的总gas上限</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> GasLimit() <span class="type">uint64</span>     &#123; <span class="keyword">return</span> b.header.GasLimit &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前实际使用了的gas</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> GasUsed() <span class="type">uint64</span>      &#123; <span class="keyword">return</span> b.header.GasUsed &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前块的难度值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> Difficulty() *big.Int &#123; <span class="keyword">return</span> <span class="built_in">new</span>(big.Int).Set(b.header.Difficulty) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前块的时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> Time() *big.Int       &#123; <span class="keyword">return</span> <span class="built_in">new</span>(big.Int).Set(b.header.Time) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用来计算难度值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> MixDigest() common.Hash   &#123; <span class="keyword">return</span> b.header.MixDigest &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用来计算难度值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> Nonce() <span class="type">uint64</span>            &#123; <span class="keyword">return</span> binary.BigEndian.Uint64(b.header.Nonce[:]) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//布隆过滤器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> Bloom() Bloom             &#123; <span class="keyword">return</span> b.header.Bloom &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//挖出当前块的账户地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> Coinbase() common.Address &#123; <span class="keyword">return</span> b.header.Coinbase &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//状态树的根hash</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> Root() common.Hash        &#123; <span class="keyword">return</span> b.header.Root &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父块的hash</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> ParentHash() common.Hash  &#123; <span class="keyword">return</span> b.header.ParentHash &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交易树的根hash</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> TxHash() common.Hash      &#123; <span class="keyword">return</span> b.header.TxHash &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//收据树的根hash</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> ReceiptHash() common.Hash &#123; <span class="keyword">return</span> b.header.ReceiptHash &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//叔块的hash，这是由两个叔块数据生成的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> UncleHash() common.Hash   &#123; <span class="keyword">return</span> b.header.UncleHash &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//额外的一些数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> Extra() []<span class="type">byte</span>            &#123; <span class="keyword">return</span> common.CopyBytes(b.header.Extra) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前块头部</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> Header() *Header &#123; <span class="keyword">return</span> CopyHeader(b.header) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回当前块的body，body主要就是交易和叔块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> Body() *Body &#123; <span class="keyword">return</span> &amp;Body&#123;b.transactions, b.uncles&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回当前块的大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> Size() common.StorageSize &#123;</span><br><span class="line">	<span class="keyword">if</span> size := b.size.Load(); size != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> size.(common.StorageSize)</span><br><span class="line">	&#125;</span><br><span class="line">	c := writeCounter(<span class="number">0</span>)</span><br><span class="line">	rlp.Encode(&amp;c, b)</span><br><span class="line">	b.size.Store(common.StorageSize(c))</span><br><span class="line">	<span class="keyword">return</span> common.StorageSize(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//共识算法校验一个块的时候会用到</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> WithSeal(header *Header) *Block &#123;</span><br><span class="line">	cpy := *header</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;Block&#123;</span><br><span class="line">		header:       &amp;cpy,</span><br><span class="line">		transactions: b.transactions,</span><br><span class="line">		uncles:       b.uncles,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回一个块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> WithBody(transactions []*Transaction, uncles []*Header) *Block &#123;</span><br><span class="line">	block := &amp;Block&#123;</span><br><span class="line">		header:       CopyHeader(b.header),</span><br><span class="line">		transactions: <span class="built_in">make</span>([]*Transaction, <span class="built_in">len</span>(transactions)),</span><br><span class="line">		uncles:       <span class="built_in">make</span>([]*Header, <span class="built_in">len</span>(uncles)),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">copy</span>(block.transactions, transactions)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> uncles &#123;</span><br><span class="line">		block.uncles[i] = CopyHeader(uncles[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> block</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个块的hash</span></span><br><span class="line"><span class="comment">//第一次调用时候计算，之后会被缓存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> Hash() common.Hash &#123;</span><br><span class="line">	<span class="keyword">if</span> hash := b.hash.Load(); hash != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> hash.(common.Hash)</span><br><span class="line">	&#125;</span><br><span class="line">	v := b.header.Hash()</span><br><span class="line">	b.hash.Store(v)</span><br><span class="line">	<span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="header">Header</h2>
<p>介绍完整个块的大体情况后，接着来详细看看块内部的内容，先来看header</p>
<h3 id="结构体">结构体</h3>
<p>来看看一个块的head中都有哪些：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 指向父区块(parentBlock)的指针。除了创世块(Genesis Block)外，每个区块有且只有一个父区块。</span></span><br><span class="line">	ParentHash  common.Hash    <span class="string">`json:&quot;parentHash&quot;       gencodec:&quot;required&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Block结构体的成员uncles的RLP哈希值。uncles是一个Header数组，它的存在，颇具匠心。</span></span><br><span class="line">	UncleHash   common.Hash    <span class="string">`json:&quot;sha3Uncles&quot;       gencodec:&quot;required&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 挖掘出这个区块的作者地址。在每次执行交易时系统会给与一定补偿的Ether，这笔金额就是发给这个地址的。</span></span><br><span class="line">	Coinbase    common.Address <span class="string">`json:&quot;miner&quot;            gencodec:&quot;required&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//StateDB中的“state Trie”的根节点的RLP哈希值。Block中，每个账户以stateObject对象表示，账户以Address为唯一标示，其信息在相关交易(Transaction)的执行中被修改。所有账户对象可以逐个插入一个Merkle-PatricaTrie(MPT)结构里，形成“state Trie”。</span></span><br><span class="line">	Root        common.Hash    <span class="string">`json:&quot;stateRoot&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Block中 交易树的根hash，由所有的交易生成的。“tx Trie”的根节点的RLP哈希值。Block的成员变量transactions中所有的tx对象，被逐个插入一个MPT结构，形成“tx Trie”。</span></span><br><span class="line">	TxHash      common.Hash    <span class="string">`json:&quot;transactionsRoot&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//收据树。可以用来确认一笔交易成功与否，Block中的 “Receipt Trie”的根节点的RLP哈希值。Block的所有Transaction执行完后会生成一个Receipt数组，这个数组中的所有Receipt被逐个插入一个MPT结构中，形成”Receipt Trie”。</span></span><br><span class="line">	ReceiptHash common.Hash    <span class="string">`json:&quot;receiptsRoot&quot;     gencodec:&quot;required&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//布隆过滤器，用来快速判断一个参数Log对象是否存在于一组已知的Log集合中。</span></span><br><span class="line">	Bloom       Bloom          <span class="string">`json:&quot;logsBloom&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//区块的难度。Block的Difficulty由共识算法基于parentBlock的Time和Difficulty计算得出，它会应用在区块的‘挖掘’阶段。</span></span><br><span class="line">	Difficulty  *big.Int       <span class="string">`json:&quot;difficulty&quot;       gencodec:&quot;required&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//块号 Block的Number等于其父区块Number +1。</span></span><br><span class="line">	Number      *big.Int       <span class="string">`json:&quot;number&quot;           gencodec:&quot;required&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//区块内所有Gas消耗的理论上限。该数值在区块创建时设置，与父区块有关。具体来说，根据父区块的GasUsed同GasLimit * 2/3的大小关系来计算得出。</span></span><br><span class="line">	GasLimit    <span class="type">uint64</span>         <span class="string">`json:&quot;gasLimit&quot;         gencodec:&quot;required&quot;`</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//区块内所有Transaction执行时所实际消耗的Gas总和。</span></span><br><span class="line">	GasUsed     <span class="type">uint64</span>         <span class="string">`json:&quot;gasUsed&quot;          gencodec:&quot;required&quot;`</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//区块“应该”被创建的时间。由共识算法确定，一般来说，要么等于parentBlock.Time + 15s，要么等于当前系统时间。</span></span><br><span class="line">	Time        *big.Int       <span class="string">`json:&quot;timestamp&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//区块相关的附加信息</span></span><br><span class="line">	Extra       []<span class="type">byte</span>         <span class="string">`json:&quot;extraData&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//该哈希值与Nonce值一起能够证明在该区块上已经进行了足够的计算（用于验证该区块挖矿成功与否的Hash值</span></span><br><span class="line">	MixDigest   common.Hash    <span class="string">`json:&quot;mixHash&quot;          gencodec:&quot;required&quot;`</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//一个64bit的哈希数，它被应用在区块的”挖掘”阶段，并且在使用中会被修改。</span></span><br><span class="line">	Nonce       BlockNonce     <span class="string">`json:&quot;nonce&quot;            gencodec:&quot;required&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的<code>gencodec</code>不是本文重点，有兴趣的可以单独去了解下这是什么，其实它主要就是扩展json的使用。</p>
<p><code>Root</code>，<code>TxHash</code>和<code>ReceiptHash</code>，分别取自三个MPT对象：<code>stateTrie</code>, <code>txTrie</code>, 和<code>receiptTrie</code>的根节点哈希值。 分别理解为是：<code>账户状态树</code>、<code>交易树</code>、<code>收据树</code><br>
receiptTrie 必须在Block的所有交易执行完成才能生成；txTrie 理论上只需tx数组transactions即可，不过依然被限制在所有交易执行完后才生成；最有趣的是stateTrie，由于它存储了所有账户的信息，比如余额，发起交易次数，虚拟机指令数组等等，所以随着每次交易的执行，stateTrie 其实一直在变化，这就使得Root值也在变化中</p>
<blockquote>
<p><a href="https://blog.csdn.net/niyuelin1990/article/details/80423823">以太坊系列—Block核心数据结构</a></p>
</blockquote>
<h3 id="header对应的方法">header对应的方法</h3>
<p>只有两个方法</p>
<h4 id="hash">Hash()</h4>
<p>该方法主要是将头部内容生成一个hash，过程是：先将头部rlp序列化，再用keccak256将其生成一个32位的hash值，这是该方法的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Header)</span></span> Hash() common.Hash &#123;</span><br><span class="line">	<span class="comment">//rlpHash方法就是为了实现：将头部rlp序列化，再用keccak256将其生成一个32位的hash值</span></span><br><span class="line">	<span class="keyword">return</span> rlpHash(h) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="size">Size()</h4>
<p>该方法用于近似的估算和限制各种缓存的消耗，主要是计算结构体中，指针类型数据的消耗<br>
func (h *Header) Size() common.StorageSize {<br>
return common.StorageSize(unsafe.Sizeof(*h)) + common.StorageSize(len(h.Extra)+(h.Difficulty.BitLen()+h.Number.BitLen()+h.Time.BitLen())/8)<br>
}</p>
<h2 id="body">Body</h2>
<p>body是一个简单的(可变的、不安全的)数据容器，用于存储和移动区块的数据内容(交易列表和叔块)在一起<br>
可以理解成是一个中间载体，通过前面的描述应该可以理解，这是一个块的核心部分。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Body <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">//交易记录</span></span><br><span class="line">	Transactions []*Transaction</span><br><span class="line">	<span class="comment">//叔块信息</span></span><br><span class="line">	Uncles       []*Header</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="块的排序">块的排序</h2>
<p>block.go中的最后一部分内容就是这个块排序了，代码写的有点绕，但细看以下还是很容易理解的，主要就是根据块号的大小进行排序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Blocks []*Block</span><br><span class="line"><span class="keyword">type</span> BlockBy <span class="function"><span class="keyword">func</span><span class="params">(b1, b2 *Block)</span></span> <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self BlockBy)</span></span> Sort(blocks Blocks) &#123;</span><br><span class="line">	bs := blockSorter&#123;</span><br><span class="line">		blocks: blocks,</span><br><span class="line">		by:     self,</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Sort(bs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> blockSorter <span class="keyword">struct</span> &#123;</span><br><span class="line">	blocks Blocks</span><br><span class="line">	by     <span class="function"><span class="keyword">func</span><span class="params">(b1, b2 *Block)</span></span> <span class="type">bool</span> <span class="comment">//使用哪种方式进行拍讯</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写了排序的接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self blockSorter)</span></span> Len() <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(self.blocks) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self blockSorter)</span></span> Swap(i, j <span class="type">int</span>) &#123;</span><br><span class="line">	self.blocks[i], self.blocks[j] = self.blocks[j], self.blocks[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self blockSorter)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> self.by(self.blocks[i], self.blocks[j]) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Number</span><span class="params">(b1, b2 *Block)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> b1.header.Number.Cmp(b2.header.Number) &lt; <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本章一个目的，了解一个块里到底有什么东西啊，这个块是怎么划分的，了解了这些，我们才能进一步往下走。<br>
最起码要知道，一个块里有三种类型的MPT，一个交易树、一个收据树、一个状态树（具体干嘛，前面都有解释）。</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊源码解读-第7讲-创世块</title>
    <url>/articles/85deafe/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>创世块是以太坊的第一个块，随着逐步对以太坊的了解，越来越发现应该关注一下这些地方细节上的实现了。</p>
<span id="more"></span>
<p>创世块的文件在这里：<code>core-&gt;genesis.go</code>，这里定义了整个创世块的规则，本文主要就是分析这个文件。</p>
<h2 id="配置文件的结构体">配置文件的结构体</h2>
<p>进去<code>core-&gt;genesis.go</code>这个文件，咋一看感觉有点乱，抽丝剥茧后，小编整理出下面的几个结构体，它们就是创世块的整个初始化原型。<br>
这些结构体中的字段，都是用来直接解析<code>*.json</code>配置文件的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Genesis <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//这个Config主要是配置chainID以及共识相关（pow和pos），还有一些硬分叉信息，在此就不列出来了</span></span><br><span class="line">    <span class="comment">//chainID是一个标示，1标示以太坊公网，测试时，建议设置别的</span></span><br><span class="line">    Config     *params.ChainConfig <span class="string">`json:&quot;config&quot;`</span></span><br><span class="line">    <span class="comment">//随机值</span></span><br><span class="line">	Nonce      <span class="type">uint64</span>              <span class="string">`json:&quot;nonce&quot;`</span></span><br><span class="line">	Timestamp  <span class="type">uint64</span>              <span class="string">`json:&quot;timestamp&quot;`</span></span><br><span class="line">	ExtraData  []<span class="type">byte</span>              <span class="string">`json:&quot;extraData&quot;`</span></span><br><span class="line">	GasLimit   <span class="type">uint64</span>              <span class="string">`json:&quot;gasLimit&quot;   gencodec:&quot;required&quot;`</span></span><br><span class="line">	Difficulty *big.Int            <span class="string">`json:&quot;difficulty&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line">	Mixhash    common.Hash         <span class="string">`json:&quot;mixHash&quot;`</span></span><br><span class="line">    Coinbase   common.Address      <span class="string">`json:&quot;coinbase&quot;`</span></span><br><span class="line">    <span class="comment">//加入一些账户，以太坊启动后就能直接用这几个账户</span></span><br><span class="line">	Alloc      GenesisAlloc        <span class="string">`json:&quot;alloc&quot;      gencodec:&quot;required&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//下面这三个是用来测试使用的</span></span><br><span class="line">	Number     <span class="type">uint64</span>      <span class="string">`json:&quot;number&quot;`</span></span><br><span class="line">	GasUsed    <span class="type">uint64</span>      <span class="string">`json:&quot;gasUsed&quot;`</span></span><br><span class="line">	ParentHash common.Hash <span class="string">`json:&quot;parentHash&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用于将账户追加到以太坊中，方便直接使用</span></span><br><span class="line"><span class="keyword">type</span> GenesisAlloc <span class="keyword">map</span>[common.Address]GenesisAccount</span><br><span class="line"><span class="keyword">type</span> GenesisAccount <span class="keyword">struct</span> &#123;</span><br><span class="line">	Code       []<span class="type">byte</span>                      <span class="string">`json:&quot;code,omitempty&quot;`</span></span><br><span class="line">	Storage    <span class="keyword">map</span>[common.Hash]common.Hash <span class="string">`json:&quot;storage,omitempty&quot;`</span></span><br><span class="line">	Balance    *big.Int                    <span class="string">`json:&quot;balance&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line">    Nonce      <span class="type">uint64</span>                      <span class="string">`json:&quot;nonce,omitempty&quot;`</span></span><br><span class="line">    <span class="comment">//用来测试</span></span><br><span class="line">	PrivateKey []<span class="type">byte</span>                      <span class="string">`json:&quot;secretKey,omitempty&quot;`</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了直观展示，我们看看操作部署以太坊时候，我们的配置文件，正好和上面一一对应：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;chainId&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;homesteadBlock&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;eip155Block&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;eip158Block&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;alloc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;0x81e71d34e8a9e4382c36fd90c3f234549106addd&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;balance&quot;</span><span class="punctuation">:</span> <span class="string">&quot;20000000000000000000&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;coinbase&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x0000000000000000000000000000000000000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;difficulty&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x20000&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;extraData&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;gasLimit&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x2fefd8&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;nonce&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x0000000000000042&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;mixhash&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;parentHash&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x00&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>为了方便测试，一般会在<code>alloc</code>中添加几个默认账户。</p>
<h2 id="上述配置结构体的说明">上述配置结构体的说明</h2>
<p>文件中，你会发现还有别的结构体，在此小编专门解释一下，因为上面提到的结构体是直接解析<code>*.json</code>的，会有很多限制，为此官方使用了<code>github.com/fjl/gencodec</code>包来扩充弥补其中的不足，可以在此处了解：<code>https://godoc.org/github.com/fjl/gencodec</code>。<br>
文件头部，会发现有这两行内容：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:generate gencodec -type Genesis -field-override genesisSpecMarshaling -out gen_genesis.go</span></span><br><span class="line"><span class="comment">//go:generate gencodec -type GenesisAccount -field-override genesisAccountMarshaling -out gen_genesis_account.go</span></span><br></pre></td></tr></table></figure>
<p>其中<code>go:generate</code>是golang1.4引入的机制，编译期间，会将后面的命令执行，生成对应文件。<br>
总结一下：</p>
<ol>
<li>需要了解<code>https://godoc.org/github.com/fjl/gencodec</code>这个</li>
<li>需要了解<code>go:generate</code>的作用</li>
</ol>
<h2 id="创世块的初始化设置">创世块的初始化设置</h2>
<p>前面提到的是用来初始化创世块的结构体，其具体的操作是使用如下这个方法来实现的：<br>
<code>时间有限，暂时先写到这里</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//若genesis为空，则进入主网</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetupGenesisBlock</span><span class="params">(db ethdb.Database, genesis *Genesis)</span></span> (*params.ChainConfig, common.Hash, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">//若自定义了创世块，却没有对Config进行配置，则返回错误</span></span><br><span class="line">	<span class="keyword">if</span> genesis != <span class="literal">nil</span> &amp;&amp; genesis.Config == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> params.AllEthashProtocolChanges, common.Hash&#123;&#125;, errGenesisNoConfig</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化新配置的以太坊节点会用到</span></span><br><span class="line">	stored := rawdb.ReadCanonicalHash(db, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> (stored == common.Hash&#123;&#125;) &#123; <span class="comment">//如果db中没有存储创世块</span></span><br><span class="line">		<span class="keyword">if</span> genesis == <span class="literal">nil</span> &#123; <span class="comment">//如果没有配置genesis，则使用主网的默认配置，这会连接到主网</span></span><br><span class="line">			log.Info(<span class="string">&quot;Writing default main-net genesis block&quot;</span>)</span><br><span class="line">			genesis = DefaultGenesisBlock()</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">//如果genesis不为空，则按照用户要求进行</span></span><br><span class="line">			log.Info(<span class="string">&quot;Writing custom genesis block&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		block, err := genesis.Commit(db) <span class="comment">//保存在db中</span></span><br><span class="line">		<span class="keyword">return</span> genesis.Config, block.Hash(), err <span class="comment">//返回结果，配置、创世块hash</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若是有自定义的genesis，则校验跟库中已有的是否一致 </span></span><br><span class="line">	<span class="keyword">if</span> genesis != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">//因为创世块的配置文件每次都可以随意改动，该步骤用来检查创世块是否有所变动</span></span><br><span class="line">		hash := genesis.ToBlock(<span class="literal">nil</span>).Hash() <span class="comment">//ToBlock传入nil会返回一个标准创世块的hash</span></span><br><span class="line">		<span class="keyword">if</span> hash != stored &#123;  <span class="comment">//检查从数据库中读取的创世块hash和启动时候配置的创世块hash是否一致</span></span><br><span class="line">			<span class="keyword">return</span> genesis.Config, hash, &amp;GenesisMismatchError&#123;stored, hash&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取链的配置，注意不是创世块的配置</span></span><br><span class="line">	<span class="comment">// 根据传入的stored检测要建立什么样的网络，主网、测试网等</span></span><br><span class="line">	newcfg := genesis.configOrDefault(stored)</span><br><span class="line">	storedcfg := rawdb.ReadChainConfig(db, stored)</span><br><span class="line">	<span class="comment">// 如果db中没有对链的配置，则将newcfg配置进去</span></span><br><span class="line">	<span class="keyword">if</span> storedcfg == <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Warn(<span class="string">&quot;Found genesis block without chain config&quot;</span>)</span><br><span class="line">		rawdb.WriteChainConfig(db, stored, newcfg)</span><br><span class="line">		<span class="keyword">return</span> newcfg, stored, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 再次做配置，若genesis为空，则创世块的hash值必须是主网的值</span></span><br><span class="line">	<span class="keyword">if</span> genesis == <span class="literal">nil</span> &amp;&amp; stored != params.MainnetGenesisHash &#123;</span><br><span class="line">		<span class="keyword">return</span> storedcfg, stored, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查兼容性</span></span><br><span class="line">	<span class="comment">// 只有当前是区块0的时候，才能进行下面的操作</span></span><br><span class="line">	height := rawdb.ReadHeaderNumber(db, rawdb.ReadHeadHeaderHash(db))</span><br><span class="line">	<span class="keyword">if</span> height == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> newcfg, stored, fmt.Errorf(<span class="string">&quot;missing block number for head header hash&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	compatErr := storedcfg.CheckCompatible(newcfg, *height)</span><br><span class="line">	<span class="comment">//若已经有区块在db，则不能更改配置</span></span><br><span class="line">	<span class="keyword">if</span> compatErr != <span class="literal">nil</span> &amp;&amp; *height != <span class="number">0</span> &amp;&amp; compatErr.RewindTo != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> newcfg, stored, compatErr</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//相当于在0块时更新链的配置</span></span><br><span class="line">	rawdb.WriteChainConfig(db, stored, newcfg)</span><br><span class="line">	<span class="keyword">return</span> newcfg, stored, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个创世块的配置，其目的就是为了保证网络启动后，自始至终只能配置一次。主要的说明都记录在注释中了。其中涉及到了几个比较重要的方法：<code>ToBlock()</code>、<code>Commit()</code>，之后我们一一来说明。</p>
<h2 id="toblock">ToBlock()</h2>
<p>这个方法的目的就是生成一个创世块，同时将相关信息写入到db中.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Genesis)</span></span> ToBlock(db ethdb.Database) *types.Block &#123;</span><br><span class="line">	<span class="keyword">if</span> db == <span class="literal">nil</span> &#123;</span><br><span class="line">		db = ethdb.NewMemDatabase() <span class="comment">//内存db</span></span><br><span class="line">	&#125;</span><br><span class="line">	statedb, _ := state.New(common.Hash&#123;&#125;, state.NewDatabase(db))</span><br><span class="line">	<span class="keyword">for</span> addr, account := <span class="keyword">range</span> g.Alloc &#123;</span><br><span class="line">		<span class="comment">//初始化时候设置的账户保存在db中</span></span><br><span class="line">		statedb.AddBalance(addr, account.Balance)</span><br><span class="line">		statedb.SetCode(addr, account.Code)</span><br><span class="line">		statedb.SetNonce(addr, account.Nonce)</span><br><span class="line">		<span class="comment">//将账户中的各种交易状态存入（注意此时并没有提交到真正数据库中，只是存入内存db）</span></span><br><span class="line">		<span class="keyword">for</span> key, value := <span class="keyword">range</span> account.Storage &#123;</span><br><span class="line">			statedb.SetState(addr, key, value)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取db根地址</span></span><br><span class="line">	root := statedb.IntermediateRoot(<span class="literal">false</span>)</span><br><span class="line">	<span class="comment">// 创世块的head</span></span><br><span class="line">	head := &amp;types.Header&#123;</span><br><span class="line">		<span class="comment">//块号</span></span><br><span class="line">		Number:     <span class="built_in">new</span>(big.Int).SetUint64(g.Number),</span><br><span class="line">		Nonce:      types.EncodeNonce(g.Nonce),</span><br><span class="line">		Time:       <span class="built_in">new</span>(big.Int).SetUint64(g.Timestamp),</span><br><span class="line">		<span class="comment">//父hash</span></span><br><span class="line">		ParentHash: g.ParentHash,</span><br><span class="line">		<span class="comment">//额外数据</span></span><br><span class="line">		Extra:      g.ExtraData,</span><br><span class="line">		<span class="comment">//gas限制</span></span><br><span class="line">		GasLimit:   g.GasLimit,</span><br><span class="line">		<span class="comment">//已使用的gas</span></span><br><span class="line">		GasUsed:    g.GasUsed,</span><br><span class="line">		<span class="comment">// 难度</span></span><br><span class="line">		Difficulty: g.Difficulty,</span><br><span class="line">		<span class="comment">//与nonce配合用于挖矿，由上一个区块的一部分生成的hash。</span></span><br><span class="line">		MixDigest:  g.Mixhash,</span><br><span class="line">		<span class="comment">//挖矿人</span></span><br><span class="line">		Coinbase:   g.Coinbase,</span><br><span class="line">		<span class="comment">//块hash</span></span><br><span class="line">		Root:       root,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创世块设置的默认gaslimit:4712388</span></span><br><span class="line">	<span class="keyword">if</span> g.GasLimit == <span class="number">0</span> &#123;</span><br><span class="line">		head.GasLimit = params.GenesisGasLimit</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//默认难度：131072</span></span><br><span class="line">	<span class="keyword">if</span> g.Difficulty == <span class="literal">nil</span> &#123;</span><br><span class="line">		head.Difficulty = params.GenesisDifficulty</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//真正将数据存入db</span></span><br><span class="line">	statedb.Commit(<span class="literal">false</span>)</span><br><span class="line">	statedb.Database().TrieDB().Commit(root, <span class="literal">true</span>)</span><br><span class="line">	<span class="comment">//返回创世块</span></span><br><span class="line">	<span class="keyword">return</span> types.NewBlock(head, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，整个过程都是为了组装创世块，里面并没有太复杂的逻辑，能够知道的就是，默认的难度为：<code>131072</code>，默认的gasLimit：<code>4712388</code>，返回的创世块中，只有head即可。</p>
<h2 id="commit">Commit()</h2>
<p>这个主要就是把创世块的配置相关记录到db中，<br>
对比上面的<code>ToBlock()</code>，会发现有rawdb和statedb两种不同的db操作，后者主要是存储块交易的各种信息，前者可以理解为是对后者的进一步封装，目前认为其主要是存储创世块相关配置信息，后续再把这个坑补上。。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Genesis)</span></span> Commit(db ethdb.Database) (*types.Block, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">//获取创世块</span></span><br><span class="line">	block := g.ToBlock(db)</span><br><span class="line">	<span class="comment">//只有创世块才可以操作</span></span><br><span class="line">	<span class="keyword">if</span> block.Number().Sign() != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;can&#x27;t commit genesis block with number &gt; 0&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将块的信息加入rawdb之中</span></span><br><span class="line">	rawdb.WriteTd(db, block.Hash(), block.NumberU64(), g.Difficulty)</span><br><span class="line">	rawdb.WriteBlock(db, block)</span><br><span class="line">	rawdb.WriteReceipts(db, block.Hash(), block.NumberU64(), <span class="literal">nil</span>)</span><br><span class="line">	rawdb.WriteCanonicalHash(db, block.Hash(), block.NumberU64())</span><br><span class="line">	rawdb.WriteHeadBlockHash(db, block.Hash())</span><br><span class="line">	rawdb.WriteHeadHeaderHash(db, block.Hash())</span><br><span class="line"></span><br><span class="line">	config := g.Config</span><br><span class="line">	<span class="keyword">if</span> config == <span class="literal">nil</span> &#123;</span><br><span class="line">		config = params.AllEthashProtocolChanges</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将创世块的配置写入</span></span><br><span class="line">	rawdb.WriteChainConfig(db, block.Hash(), config)</span><br><span class="line">	<span class="keyword">return</span> block, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="返回各种模式的genesis">返回各种模式的genesis</h2>
<p>这个是为了方便不同网络的测试和使用：<code>GenesisBlockForTesting</code>、<code>DefaultGenesisBlock</code>、<code>DefaultTestnetGenesisBlock</code>、<code>DefaultRinkebyGenesisBlock</code>、<code>DeveloperGenesisBlock</code>，可根据需要选择。<br>
这个就不详述了。</p>
<h2 id="总结">总结</h2>
<p>创世块这里，总的来说，没有太复杂的操作，主要就是配置文件的读取，校验，然后存储在db。注意区分rawdb和statedb。</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊各阶段说明</title>
    <url>/articles/ba73f461/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>以太坊正式发布后总共会分为4大阶段，加上最早的一个测试阶段，总共5各阶段，为了后面方便跟踪，在此做一些详细记录。</p>
<span id="more"></span>
<h2 id="olympic">Olympic</h2>
<p>这是以太坊正式发布前的最后一个测试网络。<br>
2015年5月发布</p>
<h2 id="第一阶段：frontier-前沿">第一阶段：Frontier（前沿）</h2>
<p>第一个正式版本<br>
2015年7月30日发布<br>
POW共识</p>
<h2 id="第二阶段：homestead-家园">第二阶段：Homestead（家园）</h2>
<p>2016年3月14日<br>
POW共识</p>
<h2 id="第三阶段：metropolis-大都会">第三阶段：Metropolis（大都会）</h2>
<p>该阶段划分的比较细</p>
<h3 id="vbyzantium-拜占庭阶段">vByzantium（拜占庭阶段）</h3>
<p>2017年12月16日发布<br>
POW共识</p>
<h3 id="vconstantinople-康斯坦丁堡阶段">vConstantinople（康斯坦丁堡阶段）</h3>
<p>当前这一阶段代码可以看到，<br>
共识算法将会采用：Casper（PoW+PoS混合共识），貌似正式发布被推迟了</p>
<h2 id="第四阶段：serenity-宁静">第四阶段：Serenity（宁静）</h2>
<p>等着吧，，，</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>综合</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊源码解读-第6.2讲-pow共识算法实现</title>
    <url>/articles/231042d1/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>这一部分，我们主要是来了解一下pow共识引擎的具体实现。<br>
本文主要是梳理引擎主要方法的流程。</p>
<span id="more"></span>
<p>在<code>consensus模块-&gt;ethash-&gt;ethash.go</code>文件中，列出了pow共识具体实现的结构体<code>Ethash</code>。本文将着重介绍该结构体以及其对应实现的方法。其余问题，我们放在后续文章中讲解。</p>
<h2 id="结构体ethash">结构体<code>Ethash</code></h2>
<p>先来看看这个结构体，它本身就是pow算法的具体描述：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下几种挖矿模式</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	ModeNormal Mode = <span class="literal">iota</span></span><br><span class="line">	ModeShared    <span class="comment">//分享模式，避免缓存干扰</span></span><br><span class="line">	ModeTest      <span class="comment">//测试模式</span></span><br><span class="line">	ModeFake      <span class="comment">//伪模式？</span></span><br><span class="line">	ModeFullFake  <span class="comment">//完全伪模式，完全不验证块，提高速度</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">	CacheDir       <span class="type">string</span></span><br><span class="line">	CachesInMem    <span class="type">int</span></span><br><span class="line">	CachesOnDisk   <span class="type">int</span></span><br><span class="line">	DatasetDir     <span class="type">string</span></span><br><span class="line">	DatasetsInMem  <span class="type">int</span></span><br><span class="line">	DatasetsOnDisk <span class="type">int</span></span><br><span class="line">	PowMode        Mode   <span class="comment">//从此处可以设置不同的挖矿模式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Ethash <span class="keyword">struct</span> &#123;</span><br><span class="line">	config Config <span class="comment">//pow的一些基本配置，比如缓存路径、数据库路径等</span></span><br><span class="line"></span><br><span class="line">	caches   *lru <span class="comment">// 在内存中存放的缓存信息</span></span><br><span class="line">    datasets *lru <span class="comment">// 在内存中存放的数据库信息</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 挖矿相关</span></span><br><span class="line">	rand     *rand.Rand    <span class="comment">// nonces的随机种子</span></span><br><span class="line">	threads  <span class="type">int</span>           <span class="comment">// 有多少条线程在挖矿</span></span><br><span class="line">	update   <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// 通知更新挖矿参数</span></span><br><span class="line">	hashrate metrics.Meter <span class="comment">// 跟踪hash相关的速率，应该是用来监控，保证难度恒定</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Remote sealer related fields，之后的翻译，等我具体了解了细节再来解释</span></span><br><span class="line">	workCh       <span class="keyword">chan</span> *sealTask   <span class="comment">// Notification channel to push new work and relative result channel to remote sealer</span></span><br><span class="line">	fetchWorkCh  <span class="keyword">chan</span> *sealWork   <span class="comment">// Channel used for remote sealer to fetch mining work</span></span><br><span class="line">	submitWorkCh <span class="keyword">chan</span> *mineResult <span class="comment">// Channel used for remote sealer to submit their mining result</span></span><br><span class="line">	fetchRateCh  <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="type">uint64</span> <span class="comment">// Channel used to gather submitted hash rate for local or remote sealer.</span></span><br><span class="line">	submitRateCh <span class="keyword">chan</span> *hashrate   <span class="comment">// Channel used for remote sealer to submit their mining hashrate</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 以下都是测试时候使用到的参数</span></span><br><span class="line">	shared    *Ethash       <span class="comment">// Shared PoW verifier to avoid cache regeneration</span></span><br><span class="line">	fakeFail  <span class="type">uint64</span>        <span class="comment">// Block number which fails PoW check even in fake mode</span></span><br><span class="line">	fakeDelay time.Duration <span class="comment">// Time delay to sleep for before returning from verify</span></span><br><span class="line"></span><br><span class="line">	lock      sync.Mutex      <span class="comment">// Ensures thread safety for the in-memory caches and mining fields</span></span><br><span class="line">	closeOnce sync.Once       <span class="comment">// Ensures exit channel will not be closed twice.</span></span><br><span class="line">	exitCh    <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="type">error</span> <span class="comment">// Notification channel to exiting backend threads</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于要使用到大量的数据集，所以有两个指向lru的指针，一个指向db，一个指向内存。并且通过threads控制挖矿线程数。并在测试模式或fake模式下，简单快速处理，使之快速得到结果。</p>
<h2 id="共识算法接口实现">共识算法接口实现</h2>
<p>上一篇文章<a href="/articles/3673b530">以太坊源码解读-第6.1讲-共识模块入口设计</a>我们得知，共识算法是实现<code>Engine接口</code>中的方法。也就是说结构体<code>Ethash</code>要实现其中的每一个接口，又因为它是POW的具体实现，还得实现pow中另一个接口<code>Hashrate()</code>。<br>
而具体的实现是在<code>consensus.go</code>文件中。<br>
下面我们一个个来解释。</p>
<h3 id="author">Author()</h3>
<p>获取挖出当前块的矿工地址</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> Author(header *types.Header) (common.Address, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> header.Coinbase, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="verifyheader">VerifyHeader()</h3>
<p>用于校验区块头部信息是否符合ethash共识引擎规则，</p>
<h4 id="先总结校验流程">先总结校验流程</h4>
<p>后续涉及到块批量校验，叔块的校验等，都是执行下面类似的步骤。<br>
该方法校验流程（具体细节看下面代码解析，该流程只用作梳理）：</p>
<ol>
<li>校验是否为<code>ModeFullFake</code>模式，是则返回成功，否则继续。</li>
<li>根据该块的块号和hash在链中判断，是否能找到该块，能则返回，否则继续</li>
<li>根据该块的父块的hash和块号，检测能否在链中找到该父块，不能则返回错误，否则继续。（此时说明该块是一个新块）</li>
<li>获取到父块后，进一步对该新块做更细的校验。
<ol>
<li>块头部额外数据(head.extra)的长度是否超过了最大限制长度（据了解extra表示可以让矿工加入有限字符，dao分叉后这个extra被占用了）</li>
<li>判断该块是否为叔块（true、false）。
<ol>
<li>该块若是叔块，则判断时间戳是否超过了256位长度，是则返回异常否则继续</li>
<li>该块若不是叔块，则判断该块时间戳是否超过当前时间（+15秒，可得知<code>每15秒左右出一个块</code>），若是则返回异常，否则继续</li>
</ol>
</li>
<li>判断该块的时间戳是否比父块的时间戳大，不是则返回异常，否则继续</li>
<li>根据该块和它父块难度计算预期的困难度，判断该预期困难度和该块中原先记录的困难度是否一致，不一致则返回异常，否则继续</li>
<li>判断<code>gaslimit</code>是否大于<code>2^63-1</code>，若大约则返回异常，否则继续（此处可得知gaslimit的上限是2^63-1，相当于9.2个左右的eth）</li>
<li>判断该块的<code>gasUsed</code>是否 &lt;= <code>gasLimit</code>，不是则返回异常，否则继续</li>
<li>确保当前块gaslimit相对于父块的是在一个范围内。若不是在该范围内，则返回异常否则继续。（此处可知，<code>gaslimit不得小于5000</code>）</li>
<li>子块number-父块number若不是1，则返回异常</li>
<li>校验密封？的块是否符合要求（这块暂时不太理解，再埋一个坑，回头填，只知道这块是很重要的，也是调用了共识引擎的一个接口实现）</li>
<li>如果所有检查通过，则验证硬分叉的特殊字段。</li>
</ol>
</li>
</ol>
<h4 id="具体代码分析">具体代码分析</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> VerifyHeader(chain consensus.ChainReader, header *types.Header, seal <span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// ModeFullFake模式，则不做任何验证</span></span><br><span class="line">	<span class="keyword">if</span> ethash.config.PowMode == ModeFullFake &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">    number := header.Number.Uint64()</span><br><span class="line">    <span class="comment">// 若根据块号和hash能在链中找到，则说明该块存在</span></span><br><span class="line">	<span class="keyword">if</span> chain.GetHeader(header.Hash(), number) != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时该块还没有被加入到链中，新生成的块，从其中尝试获取其父块</span></span><br><span class="line">	parent := chain.GetHeader(header.ParentHash, number<span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;  <span class="comment">//拿不到父块，则返回异常</span></span><br><span class="line">		<span class="keyword">return</span> consensus.ErrUnknownAncestor</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 拿到父块后，对该块做进一步到验证，用来确保该块的正确性</span></span><br><span class="line">    <span class="comment">// false表示不是叔块</span></span><br><span class="line">	<span class="keyword">return</span> ethash.verifyHeader(chain, header, parent, <span class="literal">false</span>, seal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码，小编注释写的很详细了，主要就是验证块头部的正确性（其实就是验证块），前面代码都还好理解，在最后一行代码<code>ethash.verifyHeader(...)</code>（注意verifyHeader是首字母是小写，并不是共识通用引擎中的接口），从逻辑上我们可以看出，它是用来详细校验一个新生成的块，具体来看看它的实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> verifyHeader(chain consensus.ChainReader, header, parent *types.Header, uncle <span class="type">bool</span>, seal <span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 头部额外的数据段长度合理，这个额外的数据段是什么，姑且放一放，最后再来补坑</span></span><br><span class="line">	<span class="keyword">if</span> <span class="type">uint64</span>(<span class="built_in">len</span>(header.Extra)) &gt; params.MaximumExtraDataSize &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;extra-data too long: %d &gt; %d&quot;</span>, <span class="built_in">len</span>(header.Extra), params.MaximumExtraDataSize)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 验证块头部的时间戳</span></span><br><span class="line">	<span class="keyword">if</span> uncle &#123; <span class="comment">//叔块</span></span><br><span class="line">		<span class="keyword">if</span> header.Time.Cmp(math.MaxBig256) &gt; <span class="number">0</span> &#123; <span class="comment">//以太坊可以被认为是256位机器，超过后，则异常</span></span><br><span class="line">			<span class="keyword">return</span> errLargeBlockTime</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> header.Time.Cmp(big.NewInt(time.Now().Add(allowedFutureBlockTime).Unix())) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">//该块的生产时间超过了当前时间（+15秒），说明该块异常</span></span><br><span class="line">            <span class="comment">//也说明出一个块15秒</span></span><br><span class="line">			<span class="keyword">return</span> consensus.ErrFutureBlock  </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> header.Time.Cmp(parent.Time) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errZeroBlockTime <span class="comment">//当前块时间戳比它上一个块的时间戳小，则说明块异常</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 根据该块的时间戳以及它父块的难度，获取当前块预期的难度值，CalcDifficulty是共识通用引擎的接口实现，我们稍后会专门分析</span></span><br><span class="line">	expected := ethash.CalcDifficulty(chain, header.Time.Uint64(), parent)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该块预期难度值和该块head中记录的难度值如果不一样，则返回错误</span></span><br><span class="line">	<span class="keyword">if</span> expected.Cmp(header.Difficulty) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid difficulty: have %v, want %v&quot;</span>, header.Difficulty, expected)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 判断该块的gaslimit上限是否超过2^63-1</span></span><br><span class="line">	<span class="built_in">cap</span> := <span class="type">uint64</span>(<span class="number">0x7fffffffffffffff</span>)</span><br><span class="line">	<span class="keyword">if</span> header.GasLimit &gt; <span class="built_in">cap</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid gasLimit: have %v, max %v&quot;</span>, header.GasLimit, <span class="built_in">cap</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 判断该块的gasUsed是否 &lt;= gasLimit</span></span><br><span class="line">	<span class="keyword">if</span> header.GasUsed &gt; header.GasLimit &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid gasUsed: have %d, gasLimit %d&quot;</span>, header.GasUsed, header.GasLimit)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 确保gas在允许范围内</span></span><br><span class="line">	diff := <span class="type">int64</span>(parent.GasLimit) - <span class="type">int64</span>(header.GasLimit)</span><br><span class="line">	<span class="keyword">if</span> diff &lt; <span class="number">0</span> &#123;   <span class="comment">//说明子块的gaslimit比父块的大，</span></span><br><span class="line">		diff *= <span class="number">-1</span>  <span class="comment">//保证差异值为正</span></span><br><span class="line">	&#125;</span><br><span class="line">	limit := parent.GasLimit / params.GasLimitBoundDivisor <span class="comment">//limit=父块gaslimit/1024</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//差异值过大，或者gaslimit比5000还要小，则返回</span></span><br><span class="line">	<span class="keyword">if</span> <span class="type">uint64</span>(diff) &gt;= limit || header.GasLimit &lt; params.MinGasLimit &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid gas limit: have %d, want %d += %d&quot;</span>, header.GasLimit, parent.GasLimit, limit)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 子块number-父块number若不是1，则返回异常</span></span><br><span class="line">	<span class="keyword">if</span> diff := <span class="built_in">new</span>(big.Int).Sub(header.Number, parent.Number); diff.Cmp(big.NewInt(<span class="number">1</span>)) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> consensus.ErrInvalidNumber</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 校验密封？的块是否符合要求</span></span><br><span class="line">	<span class="keyword">if</span> seal &#123;</span><br><span class="line">		<span class="keyword">if</span> err := ethash.VerifySeal(chain, header); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果所有检查通过，则验证硬分叉的特殊字段。</span></span><br><span class="line">    <span class="comment">// misc上一篇文章小编也提到过，硬分叉相关，暂时不考虑，后续文章再专门分析</span></span><br><span class="line">	<span class="keyword">if</span> err := misc.VerifyDAOHeaderExtraData(chain.Config(), header); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := misc.VerifyForkHashes(chain.Config(), header, uncle); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该头部校验的相关内容，到此就讲解完了，开头处也总结了一下整个校验流程，基本可以参考它实现整个校验过程。接着我们看下一个共识引擎接口。</p>
<h3 id="calcdifficulty">CalcDifficulty()</h3>
<p>用于计算<code>下一个块的难度</code>，以太坊分为不同的阶段（可参考：<a href="/articles/ba73f461">以太坊各阶段说明</a>），因此，这个难度计算针对不同的阶段会有不同的计算方式。<br>
这个方法用于计算下一个块的难度，同时，从上面校验方法我们可知，该方法也用来校验块中的难度值是否一致。<br>
可从以下代码看出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体的实现需要一层层的探索</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> CalcDifficulty(chain consensus.ChainReader, time <span class="type">uint64</span>, parent *types.Header) *big.Int &#123;</span><br><span class="line">	<span class="keyword">return</span> CalcDifficulty(chain.Config(), time, parent)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据不同阶段来计算下一个块的难度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CalcDifficulty</span><span class="params">(config *params.ChainConfig, time <span class="type">uint64</span>, parent *types.Header)</span></span> *big.Int &#123;</span><br><span class="line">    next := <span class="built_in">new</span>(big.Int).Add(parent.Number, big1)</span><br><span class="line">    <span class="comment">//可以看到下面是不同阶段的</span></span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> config.IsConstantinople(next): <span class="comment">//第三阶段的Metropolis（大都会）的vConstantinople（康斯坦丁堡阶段）</span></span><br><span class="line">		<span class="keyword">return</span> calcDifficultyConstantinople(time, parent)</span><br><span class="line">	<span class="keyword">case</span> config.IsByzantium(next): <span class="comment">//第三阶段的Metropolis（大都会）的vByzantium（拜占庭阶段）</span></span><br><span class="line">		<span class="keyword">return</span> calcDifficultyByzantium(time, parent)</span><br><span class="line">	<span class="keyword">case</span> config.IsHomestead(next): <span class="comment">//第二阶段Homestead（家园）</span></span><br><span class="line">		<span class="keyword">return</span> calcDifficultyHomestead(time, parent) </span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> calcDifficultyFrontier(time, parent) <span class="comment">//第一阶段Frontier（前沿）</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前稳定版是在第三阶段的Metropolis（大都会）的vByzantium（拜占庭阶段），使用的纯pow共识算法。因此我们来具体看看这一阶段的难度值是如何计算的。</p>
<h4 id="先总结计算流程">先总结计算流程</h4>
<ol>
<li>从第300万个块之后开始按照<code>拜占庭阶段</code>规则计算难度，</li>
<li>叔块难度介入，使用对应公式实计算，返回计算结果（公式下面给出）。</li>
<li>难度值始终不小于<code>131072</code>,创世块若不设置难度，默认也是这个大小。</li>
</ol>
<h4 id="具体代码分析">具体代码分析</h4>
<p>第三阶段的Metropolis（大都会）的vByzantium（拜占庭阶段）的每个块的下一个块难度计算，进一步是从以下入口开始的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个起源和规则可以参考：https://eips.ethereum.org/EIPS/eip-649</span></span><br><span class="line"><span class="comment">// 3000000表示从以太坊从第300万个块之后都使用这样一个难度计算方式</span></span><br><span class="line"><span class="comment">// 这个被称为难度炸弹。。。</span></span><br><span class="line">calcDifficultyByzantium = makeDifficultyCalculator(big.NewInt(<span class="number">3000000</span>))</span><br></pre></td></tr></table></figure>
<p>看看具体计算的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 看清楚代码，函数方法</span></span><br><span class="line"><span class="comment">// 这个过程叫做深水炸弹</span></span><br><span class="line"><span class="comment">// makeDifficultyCalculator返回的：是一个带有返回值的方法</span></span><br><span class="line"><span class="comment">// 方法参数bombDelay是块号，表示从哪个块开始</span></span><br><span class="line"><span class="comment">// 返回的方法中，第一个参数是块的时间戳，第二个是父块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeDifficultyCalculator</span><span class="params">(bombDelay *big.Int)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(time <span class="type">uint64</span>, parent *types.Header)</span></span> *big.Int &#123;</span><br><span class="line">	<span class="comment">// 要计算下一个块的难度，就需要先知道上一个块的编号</span></span><br><span class="line">	bombDelayFromParent := <span class="built_in">new</span>(big.Int).Sub(bombDelay, big1)</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(time <span class="type">uint64</span>, parent *types.Header)</span></span> *big.Int &#123;</span><br><span class="line">		<span class="comment">// 参考：https://github.com/ethereum/EIPs/issues/100.</span></span><br><span class="line">		...</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算的具体代码没有列出来，是按照这样一个计算公式实现该难度计算的：<br>
<code>diff = (parent_diff + (parent_diff / 2048 * max((2 if len(parent.uncles) else 1) - ((timestamp - parent.timestamp) / 9), -99)) ) + 2^(periodCount - 2)</code><br>
公式中可得知，难度的计算加入了叔块。<br>
为了更加清晰，公式整理如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">block_diff = parent_diff + [难度调整] + [难度炸弹]</span><br><span class="line">[难度调整] = parent_diff / <span class="number">2048</span> * max((<span class="number">2</span> <span class="keyword">if</span> <span class="built_in">len</span>(parent.uncles) <span class="keyword">else</span> <span class="number">1</span>) - (block_timestamp - parent_timestamp) / <span class="number">9</span>, <span class="number">-99</span>))</span><br><span class="line">[难度炸弹] = INT(<span class="number">2</span>^((periodCount / <span class="number">100000</span>) - <span class="number">2</span>))</span><br><span class="line">备注：在<span class="number">300</span>w~<span class="number">310</span>w块之间，[难度炸弹]=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="verifyheaders">VerifyHeaders()</h3>
<p>该方法和前面提到的<code>VerifyHeader</code>类似，只是这个是批量验证。<br>
中间用到了大量的goroutine，看着代码量挺大的，其实蛮好理解的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> VerifyHeaders(chain consensus.ChainReader, headers []*types.Header, seals []<span class="type">bool</span>) (<span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125;, &lt;-<span class="keyword">chan</span> <span class="type">error</span>) &#123;</span><br><span class="line">	... <span class="comment">// ModeFullFake，则什么也不处理，直接返回，此处代码略</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 确保每个核都参与工作</span></span><br><span class="line">	workers := runtime.GOMAXPROCS(<span class="number">0</span>)  <span class="comment">//0，表示使用最大cpu数</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(headers) &lt; workers &#123;</span><br><span class="line">		workers = <span class="built_in">len</span>(headers)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//定义一些必要的变量</span></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		inputs = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">		done   = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, workers)</span><br><span class="line">		errors = <span class="built_in">make</span>([]<span class="type">error</span>, <span class="built_in">len</span>(headers))</span><br><span class="line">		abort  = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;  <span class="comment">//所有worker全马力运转</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; </span><br><span class="line">			<span class="keyword">for</span> index := <span class="keyword">range</span> inputs &#123; <span class="comment">//接收到传来的数字（最下面代码注释），然后开始执行</span></span><br><span class="line">				errors[index] = ethash.verifyHeaderWorker(chain, headers, seals, index)</span><br><span class="line">				done &lt;- index</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	errorsOut := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>, <span class="built_in">len</span>(headers)) <span class="comment">//用于在select接收存储到的错误</span></span><br><span class="line">	...  <span class="comment">//此处是select，接收到chan信息后的处理逻辑，虽然代码有点长，但不复杂，在此就不列出了</span></span><br><span class="line">	     <span class="comment">//同时，此处也为input不停的传入数字1，2，3...，直到len(headers)</span></span><br><span class="line">	<span class="keyword">return</span> abort, errorsOut</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码有空的话，建议好好读读，写的蛮好的，通过goroutine和channel将整个过程做的清晰明了<br>
可以看出，真正验证头部，是在<code>ethash.verifyHeaderWorker()</code>这个方法中执行的，其中主要是调用共识引擎的<code>verifyHeader()接口</code>实现的，这个前面已经讲过，在此就不详述了。</p>
<h3 id="verifyuncles">VerifyUncles()</h3>
<p>什么是叔块，直接看图：</p>
<img src="/articles/231042d1/1.png" class="" title="叔块">
<p>用来校验当前块的叔块，和校验块头部其实很类似，直接看代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> VerifyUncles(chain consensus.ChainReader, block *types.Block) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// ModeFullFake，不执行</span></span><br><span class="line">	<span class="keyword">if</span> ethash.config.PowMode == ModeFullFake &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 目前一个块最多可以有两个叔块</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(block.Uncles()) &gt; maxUncles &#123;</span><br><span class="line">		<span class="keyword">return</span> errTooManyUncles</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 汇总叔块和祖先,祖先是指当前块的前8个块</span></span><br><span class="line">	<span class="comment">// ancestors 存放祖先块的hash</span></span><br><span class="line">	<span class="comment">// uncles 存放每个主块的uncles块的hash</span></span><br><span class="line">	uncles, ancestors := mapset.NewSet(), <span class="built_in">make</span>(<span class="keyword">map</span>[common.Hash]*types.Header)</span><br><span class="line"></span><br><span class="line">	number, parent := block.NumberU64()<span class="number">-1</span>, block.ParentHash() <span class="comment">//父块块号和hash</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">7</span>; i++ &#123;  <span class="comment">//这一坨，一目了然</span></span><br><span class="line">		ancestor := chain.GetBlock(parent, number)</span><br><span class="line">		<span class="keyword">if</span> ancestor == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		ancestors[ancestor.Hash()] = ancestor.Header()</span><br><span class="line">		<span class="keyword">for</span> _, uncle := <span class="keyword">range</span> ancestor.Uncles() &#123;</span><br><span class="line">			uncles.Add(uncle.Hash())</span><br><span class="line">		&#125;</span><br><span class="line">		parent, number = ancestor.ParentHash(), number<span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	ancestors[block.Hash()] = block.Header()  <span class="comment">//祖先中总共8个</span></span><br><span class="line">	uncles.Add(block.Hash())  <span class="comment">//这个貌似有点怪，但不影响，uncles主要就是用来保证hash不重复的</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 把当前块的叔块hash也加入到uncles中做重复过滤</span></span><br><span class="line">	<span class="comment">// 使用verifyHeader来进一步校验块</span></span><br><span class="line">	<span class="keyword">for</span> _, uncle := <span class="keyword">range</span> block.Uncles() &#123;</span><br><span class="line">		<span class="comment">//hash重复性检测</span></span><br><span class="line">		hash := uncle.Hash()</span><br><span class="line">		<span class="keyword">if</span> uncles.Contains(hash) &#123;</span><br><span class="line">			<span class="keyword">return</span> errDuplicateUncle</span><br><span class="line">		&#125;</span><br><span class="line">		uncles.Add(hash)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 检测有效性</span></span><br><span class="line">		<span class="keyword">if</span> ancestors[hash] != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errUncleIsAncestor</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//叔块应该指向当前块的父块的父块</span></span><br><span class="line">		<span class="keyword">if</span> ancestors[uncle.ParentHash] == <span class="literal">nil</span> || uncle.ParentHash == block.ParentHash() &#123;</span><br><span class="line">			<span class="keyword">return</span> errDanglingUncle</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 这个方法前面讲过，详细检测块</span></span><br><span class="line">		<span class="keyword">if</span> err := ethash.verifyHeader(chain, uncle, ancestors[uncle.ParentHash], <span class="literal">true</span>, <span class="literal">true</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重要总结">重要总结</h4>
<p>这块我们可以得知以下几个重要信息：</p>
<ol>
<li><code>当前块的父块的父块</code>是<code>当前块叔块的父块</code></li>
<li>一个块有两个叔块</li>
<li>将该块的前8个块及其叔块信息分别汇总，是为了更好的确保当前块叔块的正确性，防止有重复等问题，确保叔块和正常块不会交叉混淆，这也是避免有人恶意操作吧。</li>
</ol>
<h3 id="prepare">Prepare()</h3>
<p>在pow算法中，这个接口主要是用来填充块头部中的难度值的，目前并没有别的作用。<br>
难度的计算前面已经讲解过了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> Prepare(chain consensus.ChainReader, header *types.Header) <span class="type">error</span> &#123;</span><br><span class="line">	parent := chain.GetHeader(header.ParentHash, header.Number.Uint64()<span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> consensus.ErrUnknownAncestor</span><br><span class="line">	&#125;</span><br><span class="line">	header.Difficulty = ethash.CalcDifficulty(chain, header.Time.Uint64(), parent) <span class="comment">//计算并填充难度</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="finalize">Finalize()</h3>
<p>非常重要的一个方法，对确认的块进行奖励，通俗的讲，就是分配奖励给<code>区块账户</code>和<code>叔块账户</code>。<br>
需要注意的是，两个<code>叔块</code>是被一个<code>区块</code>引用的，也就是说，该方法最终会把这个区块记录在db中，从而生成一个新的区块。<br>
这里会涉及到很多经济哲理问题，需要自己来意会，来看代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> Finalize(chain consensus.ChainReader, header *types.Header, state *state.StateDB, txs []*types.Transaction, uncles []*types.Header, receipts []*types.Receipt) (*types.Block, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 区块账户和叔块账户的奖励规则</span></span><br><span class="line">	accumulateRewards(chain.Config(), state, header, uncles)</span><br><span class="line">	<span class="comment">// 根据保存的db state生成该块的root hash，然后记录在db中，这就是该区块的hash</span></span><br><span class="line">	<span class="comment">// EIP158硬分叉，参考：//https://github.com/ethereum/EIPs/issues/158</span></span><br><span class="line">	header.Root = state.IntermediateRoot(chain.Config().IsEIP158(header.Number))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回该新块</span></span><br><span class="line">	<span class="keyword">return</span> types.NewBlock(header, txs, uncles, receipts), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体的奖励实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">accumulateRewards</span><span class="params">(config *params.ChainConfig, state *state.StateDB, header *types.Header, uncles []*types.Header)</span></span> &#123;</span><br><span class="line">	blockReward := FrontierBlockReward  <span class="comment">// 基本奖励，5个eth奖励</span></span><br><span class="line">	<span class="keyword">if</span> config.IsByzantium(header.Number) &#123;  <span class="comment">//拜占庭阶段，3个eth奖励</span></span><br><span class="line">		blockReward = ByzantiumBlockReward</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> config.IsConstantinople(header.Number) &#123; <span class="comment">//康斯坦丁堡阶段，2个eth奖励</span></span><br><span class="line">		blockReward = ConstantinopleBlockReward</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 叔块的奖励逻辑</span></span><br><span class="line">	reward := <span class="built_in">new</span>(big.Int).Set(blockReward)</span><br><span class="line">	r := <span class="built_in">new</span>(big.Int)</span><br><span class="line">	<span class="keyword">for</span> _, uncle := <span class="keyword">range</span> uncles &#123;</span><br><span class="line">		<span class="comment">//公式：((uncle.Number+8)-heater.Number)*blockReward/8</span></span><br><span class="line">		<span class="comment">//可以看出，叔块块号越大，叔块的奖励越大</span></span><br><span class="line">		r.Add(uncle.Number, big8)</span><br><span class="line">		r.Sub(r, header.Number)</span><br><span class="line">		r.Mul(r, blockReward)</span><br><span class="line">		r.Div(r, big8)</span><br><span class="line">		state.AddBalance(uncle.Coinbase, r) <span class="comment">//叔块添加到db</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//从这里看出，每个区块中，每添加一个叔块，就会增加额外的1/32的奖励</span></span><br><span class="line">		r.Div(blockReward, big32)</span><br><span class="line">		reward.Add(reward, r)</span><br><span class="line">	&#125;</span><br><span class="line">	state.AddBalance(header.Coinbase, reward) <span class="comment">//区块账户，奖励加入db</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结一下">总结一下</h4>
<ol>
<li>当前<code>康斯坦丁堡阶段</code>，一个块默认会给3个eth的奖励，</li>
<li>该块每添加一个叔块，额外给予默认奖励1/32的奖励（一个块最多两个叔块）</li>
<li>奖励结束后，就会被永久记录在链中</li>
</ol>
<h3 id="sealhash">SealHash()</h3>
<p>该方法是返回被seal前的一个块头部的hash值，Seal到底是要干嘛，还不清楚，但不影响看这个方法细节，直接上代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> SealHash(header *types.Header) (hash common.Hash) &#123;</span><br><span class="line">	hasher := sha3.NewKeccak256()</span><br><span class="line"></span><br><span class="line">	rlp.Encode(hasher, []<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">		header.ParentHash,</span><br><span class="line">		header.UncleHash,</span><br><span class="line">		header.Coinbase,</span><br><span class="line">		header.Root,</span><br><span class="line">		header.TxHash,</span><br><span class="line">		header.ReceiptHash,</span><br><span class="line">		header.Bloom,</span><br><span class="line">		header.Difficulty,</span><br><span class="line">		header.Number,</span><br><span class="line">		header.GasLimit,</span><br><span class="line">		header.GasUsed,</span><br><span class="line">		header.Time,</span><br><span class="line">		header.Extra,</span><br><span class="line">	&#125;)</span><br><span class="line">	hasher.Sum(hash[:<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">return</span> hash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这明显是把一个块头部先rlp序列化，然后再生成一个hash，貌似目的是要生成一个块头部的hash,生成以后，这个块也就被确定了</p>
<h3 id="verifyseal">VerifySeal()</h3>
<p>VerifySeal()函数基于跟Seal()完全一样的算法原理，通过验证区块的某些属性(Header.Nonce，Header.MixDigest等)是否正确，来确定该区块是否已经经过Seal操作。<br>
会涉及到使用缓存来验证块的合法性或者使用dag来验证，使用dag是为了使得验证更快一些。<br>
看代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> VerifySeal(chain consensus.ChainReader, header *types.Header) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ethash.verifySeal(chain, header, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接返回的子方法<code>verifySeal</code>来处理，那就进去看看这个方法，看里面的注释：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关于fulldag，true表示使用DAG，false使用传统的缓存机制</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> verifySeal(chain consensus.ChainReader, header *types.Header, fulldag <span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// Fake模式，最简化处理，伪验证</span></span><br><span class="line">	<span class="keyword">if</span> ethash.config.PowMode == ModeFake || ethash.config.PowMode == ModeFullFake &#123;</span><br><span class="line">		time.Sleep(ethash.fakeDelay)</span><br><span class="line">		<span class="keyword">if</span> ethash.fakeFail == header.Number.Uint64() &#123;</span><br><span class="line">			<span class="keyword">return</span> errInvalidPoW</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// shanred模式的处理，这个暂时不考虑</span></span><br><span class="line">	<span class="keyword">if</span> ethash.shared != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ethash.shared.verifySeal(chain, header, fulldag)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 确保难度值大于0</span></span><br><span class="line">	<span class="keyword">if</span> header.Difficulty.Sign() &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errInvalidDifficulty</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 当前块号</span></span><br><span class="line">	number := header.Number.Uint64()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		digest []<span class="type">byte</span></span><br><span class="line">		result []<span class="type">byte</span></span><br><span class="line">	)</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="keyword">if</span> fulldag &#123; <span class="comment">//使用DAG,结合db,生成数据集</span></span><br><span class="line">		dataset := ethash.dataset(number, <span class="literal">true</span>)</span><br><span class="line">		<span class="keyword">if</span> dataset.generated() &#123;</span><br><span class="line">			digest, result = hashimotoFull(dataset.dataset, ethash.SealHash(header).Bytes(), header.Nonce.Uint64())</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 数据集finalizer中未映射。 确保数据集保持活动状态，直到调用hashimotoFull为止，因此在使用时不会取消映射。</span></span><br><span class="line">			runtime.KeepAlive(dataset)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">//使用缓存</span></span><br><span class="line">			fulldag = <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果使用普通验证或者是DAG还没准备好，则执行其中内容</span></span><br><span class="line">	<span class="keyword">if</span> !fulldag &#123;</span><br><span class="line">		cache := ethash.cache(number)</span><br><span class="line"></span><br><span class="line">		size := datasetSize(number)</span><br><span class="line">		<span class="keyword">if</span> ethash.config.PowMode == ModeTest &#123;</span><br><span class="line">			size = <span class="number">32</span> * <span class="number">1024</span> <span class="comment">//测试环境指定固定大小</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//调用hash计算算法，这就是hash碰撞的核心地方，参考：https://blog.csdn.net/ddffr/article/details/78773961</span></span><br><span class="line">		digest, result = hashimotoLight(size, cache.cache, ethash.SealHash(header).Bytes(), header.Nonce.Uint64())</span><br><span class="line"></span><br><span class="line">		<span class="comment">//缓存在finalizer中未映射。 确保缓存在调用hashimotoLight之前保持活动状态，因此在使用时不会取消映射。</span></span><br><span class="line">		runtime.KeepAlive(cache)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 验证计算结果是否满足</span></span><br><span class="line">	<span class="keyword">if</span> !bytes.Equal(header.MixDigest[:], digest) &#123;</span><br><span class="line">		<span class="keyword">return</span> errInvalidMixDigest</span><br><span class="line">	&#125;</span><br><span class="line">	target := <span class="built_in">new</span>(big.Int).Div(two256, header.Difficulty)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">new</span>(big.Int).SetBytes(result).Cmp(target) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errInvalidPoW</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面会涉及到很复杂的hash计算方式，本文只是大体梳理一下整体的运行情况，只是针对引擎接口的实现来描述，其中涉及到的其余ethash方法后续再描述。</p>
<h3 id="seal">Seal()</h3>
<p>它实现了工作量证明，Seal函数尝试找出一个满足区块难度的nonce值。<br>
人们常说的挖矿，其实就是调用的它，找到满足条件的块，它就是整个挖矿过程的核心。<br>
这个方法涉及的比较复杂，是另外在文件<code>sealer.go</code>中实现的。<br>
这个方法看似长，其实就是利用goroutine接受和传递，</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> Seal(chain consensus.ChainReader, block *types.Block, results <span class="keyword">chan</span>&lt;- *types.Block, stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">//fack模式则忽略挖矿</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// shared模式处理方式，暂时没研究这个模式是干嘛的，不影响</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 标准模式</span></span><br><span class="line">	abort := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	ethash.lock.Lock()</span><br><span class="line">	threads := ethash.threads  <span class="comment">//这就是有多少个矿工在挖矿</span></span><br><span class="line">	<span class="keyword">if</span> ethash.rand == <span class="literal">nil</span> &#123;</span><br><span class="line">		seed, err := crand.Int(crand.Reader, big.NewInt(math.MaxInt64))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			ethash.lock.Unlock()</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		ethash.rand = rand.New(rand.NewSource(seed.Int64())) <span class="comment">//得到一个随机数</span></span><br><span class="line">	&#125;</span><br><span class="line">	ethash.lock.Unlock()</span><br><span class="line">	<span class="keyword">if</span> threads == <span class="number">0</span> &#123;</span><br><span class="line">		threads = runtime.NumCPU() <span class="comment">//若没有设置矿工数，则使用cpu数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> threads &lt; <span class="number">0</span> &#123;</span><br><span class="line">		threads = <span class="number">0</span> <span class="comment">// 本地挖矿将被阻止</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将任务推向远程</span></span><br><span class="line">	<span class="keyword">if</span> ethash.workCh != <span class="literal">nil</span> &#123;</span><br><span class="line">		ethash.workCh &lt;- &amp;sealTask&#123;block: block, results: results&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		pend   sync.WaitGroup <span class="comment">//类似栅栏模式，线程等待</span></span><br><span class="line">		locals = <span class="built_in">make</span>(<span class="keyword">chan</span> *types.Block)</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; threads; i++ &#123;</span><br><span class="line">		pend.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">int</span>, nonce <span class="type">uint64</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> pend.Done()</span><br><span class="line">			ethash.mine(block, id, nonce, abort, locals) <span class="comment">//开始挖矿，进入hash碰撞模式</span></span><br><span class="line">		&#125;(i, <span class="type">uint64</span>(ethash.rand.Int63()))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取挖矿返回的结果，select接收，挖矿停止，或者找到合适的nonce</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> result *types.Block</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-stop:</span><br><span class="line">			<span class="built_in">close</span>(abort) <span class="comment">//关闭所有的channel</span></span><br><span class="line">		<span class="keyword">case</span> result = &lt;-locals:</span><br><span class="line">			<span class="comment">// 只要有一个矿工挖到合适的块，则停止其余所有。</span></span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> results &lt;- result:</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				log.Warn(<span class="string">&quot;Sealing result is not read by miner&quot;</span>, <span class="string">&quot;mode&quot;</span>, <span class="string">&quot;local&quot;</span>, <span class="string">&quot;sealhash&quot;</span>, ethash.SealHash(block.Header()))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">close</span>(abort)</span><br><span class="line">		<span class="keyword">case</span> &lt;-ethash.update:</span><br><span class="line">			<span class="comment">// 用户若更新了矿工数（新增或者减少），则停止所有矿工，然后重新挖</span></span><br><span class="line">			<span class="built_in">close</span>(abort)</span><br><span class="line">			<span class="keyword">if</span> err := ethash.Seal(chain, block, results, stop); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Error(<span class="string">&quot;Failed to restart sealing after update&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 等待所有矿工结束</span></span><br><span class="line">		pend.Wait()</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码解释了挖矿前的操作以及挖完矿后的接收方式，其中我们发现挖矿的细节是在<code>mine()</code>方法中，这个是ethash的方法之一，这个方法细节会在新的文章中讲解。在此只是了解整个流程。多个线程的开启就是多个groutine开启的过程。</p>
<h3 id="apis">Apis()</h3>
<p>这个就是对外提供RPC接口服务，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> APIs(chain consensus.ChainReader) []rpc.API &#123;</span><br><span class="line">	<span class="comment">//为了和旧版本的兼容，加入两个命名空间，都一样</span></span><br><span class="line">	<span class="keyword">return</span> []rpc.API&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			Namespace: <span class="string">&quot;eth&quot;</span>,</span><br><span class="line">			Version:   <span class="string">&quot;1.0&quot;</span>,</span><br><span class="line">			Service:   &amp;API&#123;ethash&#125;,</span><br><span class="line">			Public:    <span class="literal">true</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			Namespace: <span class="string">&quot;ethash&quot;</span>,</span><br><span class="line">			Version:   <span class="string">&quot;1.0&quot;</span>,</span><br><span class="line">			Service:   &amp;API&#123;ethash&#125;,</span><br><span class="line">			Public:    <span class="literal">true</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="hashrate">Hashrate()</h3>
<p>这个是pow算法专有的接口，并不是共识算法引擎的，用于获取当前节点的算力。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> Hashrate() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="comment">// fake模式使用</span></span><br><span class="line">	<span class="keyword">if</span> ethash.config.PowMode != ModeNormal &amp;&amp; ethash.config.PowMode != ModeTest &#123;</span><br><span class="line">		<span class="keyword">return</span> ethash.hashrate.Rate1()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> res = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">uint64</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="comment">// fetchRateCh本身是一个chan chan uint64类型</span></span><br><span class="line">	<span class="comment">//此处说明：本地或远程挖矿的算力会记录到ethash.fetchRateCh，然后它会将结果写入到res中，&lt;-res即可取出结果</span></span><br><span class="line">	<span class="keyword">case</span> ethash.fetchRateCh &lt;- res:  <span class="comment">//用来收集本地或者远程的算力</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-ethash.exitCh:</span><br><span class="line">		<span class="keyword">return</span> ethash.hashrate.Rate1()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//返回整个算力</span></span><br><span class="line">	<span class="keyword">return</span> ethash.hashrate.Rate1() + <span class="type">float64</span>(&lt;-res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体获取方式还是看上面注释吧，使用了select和channel，若不结合上下文，很难立马想通代码如何实现的。<br>
这个方法只是对蒜粒结果的展示处理，真正的处理过程大体是在<code>sealer.go</code>文件中的<code>mine()</code>方法中，每计算一次，算力+1，具体实现小编后续再专门解释。</p>
<h3 id="close">Close()</h3>
<p>这个相当于是关闭整个挖矿线程，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> Close() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	ethash.closeOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//只会触发执行一次</span></span><br><span class="line">		<span class="keyword">if</span> ethash.exitCh == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		errc := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>)</span><br><span class="line">		ethash.exitCh &lt;- errc</span><br><span class="line">		err = &lt;-errc</span><br><span class="line">		<span class="built_in">close</span>(ethash.exitCh)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>方法调用本身是代码逻辑，我们更多要考虑的是以太坊的设计逻辑，比如为什么要这样做，为什么不那样做，了解设计逻辑，才能真正了解以太坊的精华。<br>
代码中涉及到了大量的channel、goroutine、select的使用，它让我们体验了golang本身的魄力，也体会到了以太坊开发人员强大的实力。<br>
因为时间和精力，今天刚解析完以太坊pow实现共识引擎的整体逻辑，当然<code>Ethash</code>绝不仅仅只靠这几个接口方法就完成了整个共识过程，从上述代码解析中，也发现了<code>Ethash</code>新的一些方法，这些方法是<code>Ethash</code>本身独有的，而很多具体细节的实现也是在这些方法中，小编之后准备研究下<code>Ethash</code>剩余的方法。<br>
尽情期待。</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊源码解读-第6.1讲-共识模块入口设计</title>
    <url>/articles/3673b530/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>主要是先梳理一下<code>consensus</code>模块的入口文件<code>consensus.go</code>，这里体现了以太坊共识设计的整个设计思路。为后面进一步分析共识算法做好基础工作。</p>
<span id="more"></span>
<h2 id="模块文件结构">模块文件结构</h2>
<p>先来看下<code>consensus</code>模块的文件目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">|____misc                <span class="comment">## 貌似是硬分叉相关的处理，还没研究，先这么认为</span></span><br><span class="line">| |____forks.go    </span><br><span class="line">| |____dao.go</span><br><span class="line">|____consensus.go        <span class="comment">## 共识的通用规则设计，pow的入口设计就在这里</span></span><br><span class="line">|____ethash              <span class="comment">## pow共识算法的具体实现</span></span><br><span class="line">| |____sealer.go</span><br><span class="line">| |____algorithm.go</span><br><span class="line">| |____sealer_test.go</span><br><span class="line">| |____ethash_test.go</span><br><span class="line">| |____consensus.go</span><br><span class="line">| |____algorithm_test.go</span><br><span class="line">| |____api.go</span><br><span class="line">| |____ethash.go</span><br><span class="line">| |____consensus_test.go</span><br><span class="line">|____clique             <span class="comment">## poa共识算法的具体实现，这个主要是供私链使用。</span></span><br><span class="line">| |____clique.go</span><br><span class="line">| |____snapshot_test.go</span><br><span class="line">| |____api.go</span><br><span class="line">| |____snapshot.go</span><br><span class="line">|____errors.go</span><br></pre></td></tr></table></figure>
<p>从中可以大概看出，以太坊目前实现了pow和poa两种共识算法。<br>
其中poa是是一种POW与POS(proof of stake股权证明)混合的算法，主要是针对私有链使用的，以太坊测试网（Kovan）便是采用PoA算法，貌似将以太坊部署为联盟链也是用的这种共识，具体还没有研究。<br>
这里我们主要关注的是pow，poa等以后有空了再来考虑。</p>
<h2 id="consensus-go文件简介"><code>consensus.go</code>文件简介</h2>
<p>这个文件中，主要分为3部分：</p>
<ol>
<li>pow算法入口</li>
<li>共识通用引擎接口</li>
<li>读取链信息的部分接口</li>
</ol>
<h2 id="pow算法入口">Pow算法入口</h2>
<p>这是对pow的一个封装，<br>
先来看代码结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PoW <span class="keyword">interface</span> &#123;</span><br><span class="line">	Engine</span><br><span class="line">	Hashrate() <span class="type">float64</span> <span class="comment">//返回当前节点的算力</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从中可以看出，pow算法，只要满足<code>Engine接口</code>，就可以完成自己对整个共识过程。这也给了我们一个思路，如果我们要自己实现共识，同样需要继承了<code>Engine</code>。</p>
<h2 id="共识通用引擎接口engine">共识通用引擎接口Engine</h2>
<p>这也是整个共识的核心，一个通用的共识引擎接口，如果要在不改变以太坊整体运转的前提下，设计新的共识规则，那就必须要实现以下的接口，具体的内容都在注释中表明了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Engine <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// 获取当前挖矿矿工的以太坊地址</span></span><br><span class="line">    Author(header *types.Header) (common.Address, <span class="type">error</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 校验块头部信息是否符合共识规则，是否封印</span></span><br><span class="line">	VerifyHeader(chain ChainReader, header *types.Header, seal <span class="type">bool</span>) <span class="type">error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 批量校验块头部，这个方法返回一个退出信号用于终止操作，用于异步校验。</span></span><br><span class="line">    VerifyHeaders(chain ChainReader, headers []*types.Header, seals []<span class="type">bool</span>) (<span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125;, &lt;-<span class="keyword">chan</span> <span class="type">error</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 较验叔块是否满足规则</span></span><br><span class="line">	VerifyUncles(chain ChainReader, block *types.Block) <span class="type">error</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// VerifySeal()函数基于跟Seal()完全一样的算法原理，通过验证区块的某些属性(Header.Nonce，Header.MixDigest等)是否正确，来确定该区块是否已经经过Seal操作。</span></span><br><span class="line">	VerifySeal(chain ChainReader, header *types.Header) <span class="type">error</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于初始化区块头的共识字段根据共识引擎。这些改变都是内联执行的。</span></span><br><span class="line">	Prepare(chain ChainReader, header *types.Header) <span class="type">error</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 完成所有的状态修改，并最终组装成块。</span></span><br><span class="line">	<span class="comment">// 区块头和状态数据库在最终确认的时候可以被更新使之符合共识规则。</span></span><br><span class="line">	<span class="comment">// receipts表示返回显示交易结果</span></span><br><span class="line">	Finalize(chain ChainReader, header *types.Header, state *state.StateDB, txs []*types.Transaction,</span><br><span class="line">		uncles []*types.Header, receipts []*types.Receipt) (*types.Block, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Seal()函数可对一个调用过Finalize()的区块进行授权或封印，并将封印过程产生的一些值赋予区块中剩余尚未赋值的成员(Header.Nonce, Header.MixDigest)。Seal()成功时返回的区块全部成员齐整，可视为一个正常区块，可被广播到整个网络中，也可以被插入区块链等。</span></span><br><span class="line">	Seal(chain ChainReader, block *types.Block, results <span class="keyword">chan</span>&lt;- *types.Block, stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) <span class="type">error</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回前一个块的hash</span></span><br><span class="line">	SealHash(header *types.Header) common.Hash</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算下一个块的难度</span></span><br><span class="line">	CalcDifficulty(chain ChainReader, time <span class="type">uint64</span>, parent *types.Header) *big.Int</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回由共识引擎提供的RPC APIs </span></span><br><span class="line">	APIs(chain ChainReader) []rpc.API</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭共识，就是关闭挖矿的线程相关</span></span><br><span class="line">	Close() <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们大致了解了共识需要实现的规则，先不做详细探讨，心里先有个底，具体内容会在后续文章中进一步分析</p>
<h2 id="读取链信息的部分接口">读取链信息的部分接口</h2>
<p>共识毕竟是要涉及到链相关内容的操作的，在这个共识入口处，以太坊提供了一些访问本地链中<code>块</code>或者<code>块头部</code>的接口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ChainReader <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// 获取本地链的配置信息</span></span><br><span class="line">	Config() *params.ChainConfig</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回本地链当前块</span></span><br><span class="line">	CurrentHeader() *types.Header</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据输入内容（块hash和块号），从链中返回一个块的头部信息</span></span><br><span class="line">	GetHeader(hash common.Hash, number <span class="type">uint64</span>) *types.Header</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过块号从db中返回块</span></span><br><span class="line">	GetHeaderByNumber(number <span class="type">uint64</span>) *types.Header</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过块hash返回块</span></span><br><span class="line">	GetHeaderByHash(hash common.Hash) *types.Header</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据输入内容（块hash和块号），从db中返回一个块</span></span><br><span class="line">	GetBlock(hash common.Hash, number <span class="type">uint64</span>) *types.Block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p><code>consensus.go</code>这个文件告诉了我们，要实现一个公式算法需要实现特定引擎，为我们设计自己共识算法提供了一个比较好的思路。</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊源码解读-第5.5讲-rpc 订阅模块解读</title>
    <url>/articles/eafc7a8a/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>以太坊的rpc是拥有订阅功能的，这里大概介绍一下这个订阅功能</p>
<span id="more"></span>
<h2 id="订阅方法的规则">订阅方法的规则</h2>
<p>rpc注册service的时候，也可以注册订阅。<br>
这个过程请参考：<a href="/articles/6fa9e36">以太坊源码解读-第5.4讲-http rpc server相关源码详解</a><br>
其中主要就是判断一个结构体的某个方法是属于订阅方法还是普通方法。<br>
可在源码<code>rpc-&gt;utils.go-&gt;isPubSub(methodType reflect.Type)</code>这里找到。<br>
订阅方法的规则如下（必须满足以下<code>5</code>点要求）：</p>
<ol>
<li>方法参数个数必须<code>&gt;1</code>个</li>
<li>方法返回参数个数必须<code>=2</code>个</li>
<li>方法第一个参数必须是<code>context</code></li>
<li>方法第一个返回参数必须是<code>Subscription</code>类型的</li>
<li>方法第二个返回参数必须是<code>error</code>类型的</li>
</ol>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊源码解读-第5.4讲-http rpc server相关源码详解</title>
    <url>/articles/6fa9e36/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>在上一篇文章<a href="/articles/5e9143bf">以太坊源码解读-第5.3讲-http rpc的启动流程分析</a>的基础上，我们继续深入探索以太坊的rpc机制.<br>
在<a href="/articles/e10014d8">以太坊源码解读-第5.2讲-rpc源码解读</a>中，小编也介绍过rpc的实现，但涉及的有点广，可能并不太容易理解，为此，本文将结合http rpc的注册流程来讲解一下rpc的实现。</p>
<span id="more"></span>
<p>我们已经得知，http rpc的调用流程方式是：<br>
<code>创建server：rpc.NewServer()</code>-&gt;<code>注册service：handler.RegisterName(api.Namespace, api.Service)</code>-&gt;<code>启动监听：rpc.NewHTTPServer(cors, vhosts, handler).Serve(listener)</code>-&gt;<code>停止监听：n.httpListener.Close()</code>-&gt;<code>服务停止：n.httpHandler.Stop()</code><br>
下面我们一步步来了解每个过程是如何进行的。</p>
<p><code>ps</code>：先前我么已经得知，rpc总共有4类，这里小编由于时间和精力，只介绍<code>http rpc</code>的调用细节。<br>
<code>pps</code>：注意server和service的区别，下文中很多地方将会涉及到。</p>
<h2 id="第一步：创建server">第一步：创建server</h2>
<p>进入到这个<br>
先来看一下创建server（<code>rpc-&gt;server.go</code>）的代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">()</span></span> *Server &#123;</span><br><span class="line">  <span class="comment">//实例化一个server</span></span><br><span class="line">	server := &amp;Server&#123;</span><br><span class="line">		services: <span class="built_in">make</span>(serviceRegistry),</span><br><span class="line">		codecs:   set.New(),</span><br><span class="line">		run:      <span class="number">1</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//先注册一个RPC Service，该services是一个空的</span></span><br><span class="line">  <span class="comment">//将server加入到RPCService中</span></span><br><span class="line">  rpcService := &amp;RPCService&#123;server&#125;</span><br><span class="line">  <span class="comment">//此处MetadataApi=“rpc”</span></span><br><span class="line">	server.RegisterName(MetadataApi, rpcService)</span><br><span class="line">	<span class="keyword">return</span> server</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中，可以得知以下几个重要信息：</p>
<ol>
<li>创建的server是被加入到<code>RPCService</code>中的。这个<code>RPCService</code>结构体如下：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RPCService <span class="keyword">struct</span> &#123;</span><br><span class="line">	server *Server</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>返回的是一个server</li>
<li>可以大胆想象，之后所有的service注册后，都会被添加到第一个<code>RPCService</code>中的server，也就是说，<code>RPCService</code>管理着其余所有的<code>service</code></li>
</ol>
<h3 id="第一步：server相关结构体">第一步：Server相关结构体</h3>
<p>创建过程中，涉及到了Server相关结构，很重要，很有必要掌握。<br>
在<code>rpc-&gt;types.go</code>中，对<code>server</code>和<code>service</code>的定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//service使用传入的名称作为key来区分</span></span><br><span class="line"><span class="keyword">type</span> serviceRegistry <span class="keyword">map</span>[<span class="type">string</span>]*service </span><br><span class="line"></span><br><span class="line"><span class="comment">//用于标准化注册进来的服务</span></span><br><span class="line"><span class="comment">//这是以太坊每个功能模块提供的服务，都是在模块的api.service中</span></span><br><span class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123;</span><br><span class="line">	name          <span class="type">string</span>        <span class="comment">// service的名称</span></span><br><span class="line">	typ           reflect.Type  <span class="comment">// 类型，反射的</span></span><br><span class="line">	callbacks     callbacks     <span class="comment">// 回调方法的集合</span></span><br><span class="line">	subscriptions subscriptions <span class="comment">// 订阅/发布集合</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	services serviceRegistry  <span class="comment">//用来存储service</span></span><br><span class="line">	run      <span class="type">int32</span>  <span class="comment">//用来控制server是否可运行，1为运行，非1为不可运行</span></span><br><span class="line">	codecsMu sync.  <span class="comment">//用来保护多线程访问codecs的锁</span></span><br><span class="line">	codecs   *set.Set  <span class="comment">//用来存储所有的编码解码器，其实就是所有的连接。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，每一个<code>service</code>都会被装填到<code>server</code>中（也就是注册，具体注册细节后面会专门讲到），了解过geth启动流程后，会明白，这里的<code>service</code>表示的是每个以太坊功能模块api.service中的东西。这个<code>api</code>在rpc中是有定义的(同样是在types.go中)：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> API <span class="keyword">struct</span> &#123;</span><br><span class="line">	Namespace <span class="type">string</span>      <span class="comment">// 在该命名空间下，service的方法被公开</span></span><br><span class="line">	Version   <span class="type">string</span>      <span class="comment">// 给dapp展示的api版本号</span></span><br><span class="line">	Service   <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 这个就是要被注册到server中的service</span></span><br><span class="line">	Public    <span class="type">bool</span>        <span class="comment">// 在公共使用中，指示方法是否为安全的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>service</code>中的callbacks和subscriptions其实都是callbacks，这个是rpc回调用到的。结构如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> callbacks <span class="keyword">map</span>[<span class="type">string</span>]*callback      <span class="comment">// 回调方法的集合，可以看出是一个map</span></span><br><span class="line"><span class="keyword">type</span> subscriptions <span class="keyword">map</span>[<span class="type">string</span>]*callback  <span class="comment">// 订阅的集合，也可以看出是一个map</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> callback <span class="keyword">struct</span> &#123;</span><br><span class="line">	rcvr        reflect.Value  <span class="comment">// 反射出方法的值</span></span><br><span class="line">	method      reflect.Method <span class="comment">// 反射出方法本身</span></span><br><span class="line">	argTypes    []reflect.Type <span class="comment">// 输入的参数</span></span><br><span class="line">	hasCtx      <span class="type">bool</span>           <span class="comment">// 检测第一个参数是否为context，</span></span><br><span class="line">	errPos      <span class="type">int</span>            <span class="comment">// 返回错误的索引err，无法返回则为-1</span></span><br><span class="line">	isSubscribe <span class="type">bool</span>           <span class="comment">// 该callback是否为订阅</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第二步：注册service">第二步：注册service</h2>
<ol>
<li>前面创建<code>server</code>时候，我们已经发现其注册了一个<code>RPCService</code>，并且将<code>server</code>填充到了<code>RPCService</code>中。创建返回的结果是该<code>server</code>，之后的<code>service</code>都是在该<code>server</code>下注册的，也就是说，<code>RPCService</code>管理着之后的所有<code>service</code>。</li>
<li>前面我们也知道了，http rpc会调用<code>rpc-&gt;server.go</code>中的<code>RegisterName()</code>方法来进行注册。</li>
<li>接下来我们就进一步分析整个注册流程。</li>
</ol>
<h3 id="registername"><code>RegisterName()</code></h3>
<p>先来看一下<code>rpc-&gt;server.go</code>注册的源码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RegisterName 注册服务</span></span><br><span class="line"><span class="comment">//传入的rcvr可以是任意的，传入后都会被标准化处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> RegisterName(name <span class="type">string</span>, rcvr <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> s.services == <span class="literal">nil</span> &#123;</span><br><span class="line">		s.services = <span class="built_in">make</span>(serviceRegistry)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//注册进来的rcvr都被标准化为service</span></span><br><span class="line">	svc := <span class="built_in">new</span>(service)</span><br><span class="line">	svc.typ = reflect.TypeOf(rcvr)</span><br><span class="line">	rcvrVal := reflect.ValueOf(rcvr)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> name == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;no service name for type %s&quot;</span>, svc.typ.String())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断传进来的服务类型首字母是否为大写</span></span><br><span class="line">	<span class="keyword">if</span> !isExported(reflect.Indirect(rcvrVal).Type().Name()) &#123;</span><br><span class="line">		fmt.Println(reflect.Indirect(rcvrVal).Type().Name())</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%s is not exported&quot;</span>, reflect.Indirect(rcvrVal).Type().Name())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取到服务的回调方法和订阅</span></span><br><span class="line">	methods, subscriptions := suitableCallbacks(rcvrVal, svc.typ)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据name判断，若services中已经有了该service，则直接更新方法和订阅</span></span><br><span class="line">	<span class="keyword">if</span> regsvc, present := s.services[name]; present &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(methods) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(subscriptions) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;service %T doesn&#x27;t have any suitable methods/subscriptions to expose&quot;</span>, rcvr)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, m := <span class="keyword">range</span> methods &#123;</span><br><span class="line">			<span class="comment">//使用首字母小写的方法名作为key来保存该service的最新的方法</span></span><br><span class="line">			regsvc.callbacks[formatName(m.method.Name)] = m</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, s := <span class="keyword">range</span> subscriptions &#123;</span><br><span class="line">			<span class="comment">//使用首字母小写的订阅名作为key来保存该service的最新的订阅</span></span><br><span class="line">			regsvc.subscriptions[formatName(s.method.Name)] = s</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">//更新完后，则退出</span></span><br><span class="line">	&#125;</span><br><span class="line">	svc.name = name</span><br><span class="line">	svc.callbacks, svc.subscriptions = methods, subscriptions</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(svc.callbacks) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(svc.subscriptions) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;service %T doesn&#x27;t have any suitable methods/subscriptions to expose&quot;</span>, rcvr)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将service保存在server中</span></span><br><span class="line">	s.services[svc.name] = svc</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册阶段，会反射解析传入的service，有可能是普通的rpc，也有可能是订阅，根据各自的规则进行判断，比如订阅规则，可参考<a href="/articles/eafc7a8a">以太坊源码解读-第5.5讲-rpc 订阅模块解读</a>.<br>
从上面代码也可知道，真正解析service的是<code>suitableCallbacks()</code>方法，它会将rpc普通方法和订阅解析出来。</p>
<h2 id="第三步：启动http监听">第三步：启动http监听</h2>
<p>服务器注册完毕后，就该启动网络监听了。<br>
在<code>rpc-&gt;http.go</code>中，<code>NewHTTPServer()</code>方法启动监听。<br>
再来看看<code>http rpc</code>是怎样启动网络监听的：<code>go rpc.NewHTTPServer(cors, vhosts, handler).Serve(listener)</code><br>
异步，开了个goroutine。<br>
那就看看<code>NewHTTPServer()</code>的源码是什么：<br>
<code>ps</code>：大概看了下最新的代码<code>2018.11.09</code>的，结构稍微发生了点变化，但依旧用到了<code>NewHTTPServer()</code>，虽然该方法一直被标注为Deprecated，然并卵。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//小编看的代码是两个月前的，貌似和最新版的的有些差距</span></span><br><span class="line"><span class="comment">//最新版本的代码在现有基础上，又加入了延时等操作，但不影响整体阅读</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHTTPServer</span><span class="params">(cors []<span class="type">string</span>, vhosts []<span class="type">string</span>, srv *Server)</span></span> *http.Server &#123;</span><br><span class="line">	handler := newCorsHandler(srv, cors)  <span class="comment">//主要是浏览器读取时候的些问题设置</span></span><br><span class="line">	handler = newVHostHandler(vhosts, handler) <span class="comment">//host的设置</span></span><br><span class="line">	<span class="keyword">return</span> &amp;http.Server&#123;Handler: handler&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第四-五步：停止监听">第四、五步：停止监听</h2>
<p>这本身就是http内部的工作机制，<br>
net.Listener.Close()<br>
server.stop（）这个可以看源码去，不复杂，就不解释了。</p>
<h2 id="总结">总结</h2>
<p>至此，rpc server端的启动就结束了，应该还好理解吧</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊源码解读-第5.3讲-http rpc的启动流程分析</title>
    <url>/articles/5e9143bf/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>可先了解下这两节：<br>
<a href="/articles/25c7447">以太坊源码解读-第5.1讲-rpc官翻及个人理解</a><br>
<a href="/articles/e10014d8">以太坊源码解读-第5.2讲-rpc源码解读</a><br>
以太坊中，总共有四种rpc服务，分别是<code>InProc</code>、<code>IPC</code>、<code>Http</code>、<code>Ws(websockets)</code>，本文是通过介绍<code>Http rpc</code>的整个过程来了解以太坊rpc的情况。</p>
<span id="more"></span>
<h2 id="启动过程">启动过程</h2>
<h3 id="http的配置">http的配置</h3>
<ol>
<li>先按如下顺序来找到这么个入口：<br>
<code>cmd-&gt;geth-&gt;main.go-&gt;app.Run(os.Args)-&gt;geth-&gt;makeFullNode(ctx)-&gt;makeConfigNode(ctx)</code><br>
这个主要是完成以太坊的启动配置过程，这块的大意是，对<code>Eth模块</code>、<code>Shh模块</code>、<code>Node模块</code>、<code>Dashboard模块</code>进行配置，先给他们提供默认配置，然后检查是否有用户自定义的<code>toml</code>配置文件，若有，则覆盖默认配置，在此选择用默认配置。</li>
<li>先要说明一下，http相关配置是在<code>Node模块</code>中进行的，最后其余所有的模块都是注册到<code>Node模块中</code>，<code>Node</code>结构大体如下：</li>
</ol>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  config   *Config          <span class="comment">// http相关主要就是在该Config中配置的</span></span><br><span class="line">  services     <span class="keyword">map</span>[reflect.Type]Service <span class="comment">// 当前正在运行的服务（模块），以太坊把每个模块的功能都统一成service，然后注册到node.services中</span></span><br><span class="line">  rpcAPIs       []rpc.API   <span class="comment">// 所有模块的rpcAPIs都放在其中统一管理</span></span><br><span class="line">  <span class="comment">//http相关其余配置</span></span><br><span class="line">  httpEndpoint  <span class="type">string</span>       <span class="comment">// HTTP endpoint (interface + port) to listen at (empty = HTTP disabled)</span></span><br><span class="line">  httpWhitelist []<span class="type">string</span>     <span class="comment">// HTTP RPC modules to allow through this endpoint</span></span><br><span class="line">  httpListener  net.Listener <span class="comment">// HTTP RPC listener socket to server API requests</span></span><br><span class="line">  httpHandler   *rpc.Server  <span class="comment">// HTTP RPC request handler to process the API requests</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <img src="/articles/5e9143bf/1.png" class="" title="geth启动过程">
<ol start="3">
<li>这里我们主要关心http的配置，直接看对<code>Node模块</code>配置情况：<code>defaultNodeConfig</code>以及<code>defaultNodeConfig-&gt;node.DefaultConfig</code>，其中有对http的基本配置，具体解释看下面代码注释：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">defaultNodeConfig</span><span class="params">()</span></span> node.Config &#123;</span><br><span class="line">	cfg := node.DefaultConfig</span><br><span class="line">	cfg.Name = clientIdentifier</span><br><span class="line">	cfg.Version = params.VersionWithCommit(gitCommit)</span><br><span class="line">  cfg.HTTPModules = <span class="built_in">append</span>(cfg.HTTPModules, <span class="string">&quot;eth&quot;</span>, <span class="string">&quot;shh&quot;</span>)</span><br><span class="line">  <span class="comment">//在已有的modules基础上，再加上eth shh两个模块</span></span><br><span class="line">	cfg.WSModules = <span class="built_in">append</span>(cfg.WSModules, <span class="string">&quot;eth&quot;</span>, <span class="string">&quot;shh&quot;</span>)</span><br><span class="line">	cfg.IPCPath = <span class="string">&quot;geth.ipc&quot;</span></span><br><span class="line">	<span class="keyword">return</span> cfg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DefaultConfig = Config&#123;</span><br><span class="line">  <span class="comment">// 节点信息默认的存放位置，mac、windows、others三个平台</span></span><br><span class="line">  DataDir:          DefaultDataDir(),</span><br><span class="line">  <span class="comment">// HTTP RPC server的默认端口，8545</span></span><br><span class="line">  HTTPPort:         DefaultHTTPPort,</span><br><span class="line">  <span class="comment">// 默认rpcapi接口提供方式，标示，其实就是api.namespace</span></span><br><span class="line">  HTTPModules:      []<span class="type">string</span>&#123;<span class="string">&quot;net&quot;</span>, <span class="string">&quot;web3&quot;</span>&#125;,</span><br><span class="line">  <span class="comment">// 虚拟主机地址</span></span><br><span class="line">  HTTPVirtualHosts: []<span class="type">string</span>&#123;<span class="string">&quot;localhost&quot;</span>&#125;,</span><br><span class="line">  <span class="comment">// 下面websockets和p2p相关，暂不考虑</span></span><br><span class="line">	WSPort:           DefaultWSPort,</span><br><span class="line">	WSModules:        []<span class="type">string</span>&#123;<span class="string">&quot;net&quot;</span>, <span class="string">&quot;web3&quot;</span>&#125;,</span><br><span class="line">	P2P: p2p.Config&#123;</span><br><span class="line">		ListenAddr: <span class="string">&quot;:30303&quot;</span>,</span><br><span class="line">		MaxPeers:   <span class="number">25</span>,</span><br><span class="line">		NAT:        nat.Any(),</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此步我们可以看出，http modules默认总共有<code>net</code>、<code>web3</code>、<code>eth</code>、<code>shh</code>四类的rpcapi，标示我们有4种方式调用api接口</p>
<ol start="4">
<li>http的进一步配置<br>
<code>makeConfigNode(ctx)-&gt;utils.SetNodeConfig(ctx, &amp;cfg.Node)-&gt;setHTTP(ctx, cfg)</code>，在其中可以发现，其余默认的一些配置：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setHTTP</span><span class="params">(ctx *cli.Context, cfg *node.Config)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ctx.GlobalBool(RPCEnabledFlag.Name) &amp;&amp; cfg.HTTPHost == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		cfg.HTTPHost = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">		<span class="keyword">if</span> ctx.GlobalIsSet(RPCListenAddrFlag.Name) &#123;</span><br><span class="line">			cfg.HTTPHost = ctx.GlobalString(RPCListenAddrFlag.Name)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ctx.GlobalIsSet(RPCPortFlag.Name) &#123;</span><br><span class="line">		cfg.HTTPPort = ctx.GlobalInt(RPCPortFlag.Name)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ctx.GlobalIsSet(RPCCORSDomainFlag.Name) &#123;</span><br><span class="line">		cfg.HTTPCors = splitAndTrim(ctx.GlobalString(RPCCORSDomainFlag.Name))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ctx.GlobalIsSet(RPCApiFlag.Name) &#123;</span><br><span class="line">		cfg.HTTPModules = splitAndTrim(ctx.GlobalString(RPCApiFlag.Name))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ctx.GlobalIsSet(RPCVirtualHostsFlag.Name) &#123;</span><br><span class="line">		cfg.HTTPVirtualHosts = splitAndTrim(ctx.GlobalString(RPCVirtualHostsFlag.Name))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>注册<br>
返回到<code>cmd-&gt;geth-&gt;main.go-&gt;app.Run(os.Args)-&gt;geth-&gt;makeFullNode(ctx)</code>，其余配置好的模块（或者叫做服务）,都会被注册到<code>Node</code>中.<br>
前面提到过，会有四个功能模块：<code>Eth模块</code>、<code>Shh模块</code>、<code>Node模块</code>、<code>Dashboard模块</code><br>
这里提示一下，每个服务都会实现node中的下面这个接口：<br>
<code>node-&gt;service</code></li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Service <span class="keyword">interface</span> &#123;   </span><br><span class="line">    Protocols() []p2p.Protocol  </span><br><span class="line">    APIs() []rpc.API  </span><br><span class="line">    Start(server *p2p.Server) <span class="type">error</span>  </span><br><span class="line">    Stop() <span class="type">error</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>总结<br>
<code>cmd-&gt;geth-&gt;main.go-&gt;app.Run(os.Args)-&gt;geth-&gt;makeFullNode(ctx)</code>主要做了两件事：</li>
<li>配置模块</li>
<li>注册模块到node</li>
</ol>
<h3 id="启动http-rpc过程">启动http rpc过程</h3>
<ol>
<li>前往：<br>
<code>cmd-&gt;geth-&gt;main.go-&gt;app.Run(os.Args)-&gt;geth-&gt;makeFullNode(ctx)-&gt;startNode(ctx, node)-&gt;utils.StartNode(stack)-&gt;stack.Start()-&gt;n.startRPC(services)</code>中，找到：<br>
<code>n.startHTTP(n.httpEndpoint, apis, n.config.HTTPModules, n.config.HTTPCors, n.config.HTTPVirtualHosts);</code>，这一行就是用来启动http rpc的，看看它所需要的4个参数：</li>
<li>n.httpEndpoint，默认值为127.0.0.1</li>
<li>apis，默认值为所有的服务的api</li>
<li>n.config.HTTPModules，rpcapi的标示，前面提到过，默认给出：[“eth”,“shh”,“net”,“web3”]</li>
<li>n.config.HTTPCors 跨域资源共享，通过浏览器访问的化，需要设置它，</li>
<li>n.config.HTTPVirtualHosts 防攻击的设置，官方有解释，可以去看看，限制访问范围，默认：localhost</li>
<li>startHTTP还是很重要的，这里列出源码和注释：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化http以及启动http rpc服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span></span> startHTTP(endpoint <span class="type">string</span>, apis []rpc.API, modules []<span class="type">string</span>, cors []<span class="type">string</span>, vhosts []<span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// endpoint必须有</span></span><br><span class="line">	<span class="keyword">if</span> endpoint == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 白名单其实就是modules，默认给出：[&quot;eth&quot;,&quot;shh&quot;,&quot;net&quot;,&quot;web3&quot;]</span></span><br><span class="line">	whitelist := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">	<span class="keyword">for</span> _, module := <span class="keyword">range</span> modules &#123;</span><br><span class="line">		whitelist[module] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建一个rpc server，并且注册服务，要求满足白名单条件</span></span><br><span class="line">	handler := rpc.NewServer()</span><br><span class="line">	<span class="keyword">for</span> _, api := <span class="keyword">range</span> apis &#123;</span><br><span class="line">		<span class="keyword">if</span> whitelist[api.Namespace] || (<span class="built_in">len</span>(whitelist) == <span class="number">0</span> &amp;&amp; api.Public) &#123;</span><br><span class="line">			<span class="keyword">if</span> err := handler.RegisterName(api.Namespace, api.Service); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			n.log.Debug(<span class="string">&quot;HTTP registered&quot;</span>, <span class="string">&quot;service&quot;</span>, api.Service, <span class="string">&quot;namespace&quot;</span>, api.Namespace)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// All APIs registered, start the HTTP listener</span></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		listener net.Listener</span><br><span class="line">		err      <span class="type">error</span></span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> listener, err = net.Listen(<span class="string">&quot;tcp&quot;</span>, endpoint); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//启动 rpc</span></span><br><span class="line">	<span class="keyword">go</span> rpc.NewHTTPServer(cors, vhosts, handler).Serve(listener)</span><br><span class="line">	n.log.Info(<span class="string">&quot;HTTP endpoint opened&quot;</span>, <span class="string">&quot;url&quot;</span>, fmt.Sprintf(<span class="string">&quot;http://%s&quot;</span>, endpoint), <span class="string">&quot;cors&quot;</span>, strings.Join(cors, <span class="string">&quot;,&quot;</span>), <span class="string">&quot;vhosts&quot;</span>, strings.Join(vhosts, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">	<span class="comment">// All listeners booted successfully</span></span><br><span class="line">	n.httpEndpoint = endpoint</span><br><span class="line">	n.httpListener = listener</span><br><span class="line">	n.httpHandler = handler</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>总结<br>
这个rpc启动流程：<br>
<code>创建：rpc.NewServer()</code>-&gt;<code>注册：handler.RegisterName(api.Namespace, api.Service)</code>-&gt;<code>启动监听：rpc.NewHTTPServer(cors, vhosts, handler).Serve(listener)</code></li>
</ol>
<h3 id="http-rpc-stop">http rpc stop</h3>
<p>既然有启动，就有停止，这是停止的执行步骤：<br>
在<code>node-&gt;node.go</code>中，和上面的<code>startHTTP</code>在同一目录中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stopHTTP terminates the HTTP RPC endpoint.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span></span> stopHTTP() &#123;</span><br><span class="line">	<span class="keyword">if</span> n.httpListener != <span class="literal">nil</span> &#123;</span><br><span class="line">		n.httpListener.Close()</span><br><span class="line">		n.httpListener = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">		n.log.Info(<span class="string">&quot;HTTP endpoint closed&quot;</span>, <span class="string">&quot;url&quot;</span>, fmt.Sprintf(<span class="string">&quot;http://%s&quot;</span>, n.httpEndpoint))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n.httpHandler != <span class="literal">nil</span> &#123;</span><br><span class="line">		n.httpHandler.Stop()</span><br><span class="line">		n.httpHandler = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>再次来梳理一下http rpc注册流程：<br>
<code>创建：rpc.NewServer()</code>-&gt;<code>注册：handler.RegisterName(api.Namespace, api.Service)</code>-&gt;<code>启动监听：rpc.NewHTTPServer(cors, vhosts, handler).Serve(listener)</code>-&gt;<code>停止监听：n.httpListener.Close()</code>-&gt;<code>服务停止：n.httpHandler.Stop()</code><br>
原本打算把具体的rpc流程也顺带讲一下，但混在一起会乱，就先不提了。<br>
本文梳理后，可以很清晰的了解到，以太坊是如何启动一项rpc服务的，为我们后来进一步研究rpc做了一些充分的准备。</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊crypto模块的概览</title>
    <url>/articles/66d6f92e/</url>
    <content><![CDATA[<p>小编只敢说概览，密码学这片海洋，只是沾了沾脚。。。了解一下这个模块，对以太坊账户以及验证机制心里也就有个底了。了解后，有个好处就是，可以把它用在自己想用的地方。</p>
<span id="more"></span>
<h2 id="综述">综述</h2>
<p>以太坊中，对于数据的安全操作，都在以太坊官方的<code>crypto</code>代码中（要和golang官方提供的<code>crypto</code>区分），大致可以分为2部分：</p>
<ol>
<li>散列(sha3-Keccak算法)<br>
对块的验证、pow中的hash碰撞、签名等等，都是使用<code>Keccak算法</code>来生成hash的，严格意义上讲，Keccak算法和标准的sha3算法并不一样，因此，这个安全散列算法应该称为Keccak算法。</li>
<li>签名（secp256k1算法）<br>
该算法是一种椭圆曲线数字签名算法(ECDSA)，在比特币中已经得以应用，在以太坊中，是通过它来进行密钥生成、签名、验证、公钥账户地址转换）。在整个以太坊生态中，有举足轻重的作用。</li>
</ol>
<h2 id="keccak算法">Keccak算法</h2>
<ol>
<li>2015年以前,sha3的标准就是keccak，但后来，sha3标准修改了其中的“海绵算法”，导致之后两者没有太大关系。因此，为了更明确的区分，需要知道以太坊生成hash用的是<code>keccak安全散列算法</code>。</li>
<li>需要知道，该算法生成的散列长度是<code>32字节</code>，也就是<code>256位</code></li>
</ol>
<h3 id="算法原理">算法原理</h3>
<p>请参考这篇文章，原先转载的，里面很通俗的讲了keccak的原理：<a href="https://www.bitxx.top/articles/d7792efc">https://www.bitxx.top/articles/d7792efc</a></p>
<h3 id="以太坊中keccak的操作">以太坊中Keccak的操作</h3>
<p>下面是以太坊提供的一个单元测试用例：<br>
其中：<br>
<code>abc</code>为用来生成hash的原文<br>
<code>4e03657aea45a94fc7d47ba826c8d667c0d1e6e33a64a036ec44f58fa12d6c45</code>为<code>abc</code>生成的hash<br>
程序的大意就是，将<code>abc</code>生成hash，然后和预先设置的<code>abc</code>的hash做比较，看结果是否一致。<br>
真正调用到<code>Keccak</code>的地方，只有这么一处：<code>Keccak256Hash(in)</code>，传入原文，返回hash结果</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestKeccak256Hash</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="comment">//原文转为字节数组</span></span><br><span class="line">	msg := []<span class="type">byte</span>(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">	<span class="comment">//将16进制的hash结果，转为2进制。用于稍后和原文生成的hash做比较</span></span><br><span class="line">	exp, _ := hex.DecodeString(<span class="string">&quot;4e03657aea45a94fc7d47ba826c8d667c0d1e6e33a64a036ec44f58fa12d6c45&quot;</span>)</span><br><span class="line">	<span class="comment">//Keccak256Hash(in)，原文生成hash</span></span><br><span class="line">	checkhash(t, <span class="string">&quot;Sha3-256-array&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(in []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123; h := Keccak256Hash(in); <span class="keyword">return</span> h[:] &#125;, msg, exp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkhash</span><span class="params">(t *testing.T, name <span class="type">string</span>, f <span class="keyword">func</span>([]<span class="type">byte</span>)</span></span> []<span class="type">byte</span>, msg, exp []<span class="type">byte</span>) &#123;</span><br><span class="line">	sum := f(msg)</span><br><span class="line">	<span class="comment">//判断二者是否一致</span></span><br><span class="line">	<span class="keyword">if</span> !bytes.Equal(exp, sum) &#123;</span><br><span class="line">		t.Fatalf(<span class="string">&quot;hash %s mismatch: want: %x have: %x&quot;</span>, name, exp, sum)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="secp256k1签名">secp256k1签名</h2>
<ol>
<li>这个签名算法需要比较深的密码学背景才能吃透，我根据自己掌握的密码学基础讲一下为什么选择椭圆曲线的算法作为以太坊密钥生成算法，<br>
在密码学中，会有一个安全等级的划分。</li>
<li>通常，需要<code>2^n</code>次才能破解的算法，我们称为该算法拥有<code>n位安全等级</code>，通常分为四个等级：80位、128位、192位和256位四个等级，<br>
这个模块比较复杂,如果要细度源码,需要对密码学有比较深入的理解,但是使用起来其实比较简单.不同算法为了保证某安全等级，所要使用的密钥长度如下：</li>
</ol>
<table><tr><th>算法家族</th><th>密码体制</th><th colspan="4">安全级别（位）</th></tr><tr><td></td><td></td><td>80</td><td>128</td><td>192</td><td>256</td></tr><tr><td>离散分解<br>离散对数<br>椭圆曲线</td><td>RSA<br>DH、DSA、Elgamal<br>ECDH、ECDSA</td><td>1024位<br>1024位<br>160位</td><td>3072位<br>3072位<br>256位</td><td>7680位<br>7680位<br>384位</td><td>15360位<br>15360位<br>512位</td></tr><tr><td>对称密钥</td><td>AES、3DES</td><td>80位</td><td>128位</td><td>192位</td><td>256位</td></tr></table>
从对称与否、密钥长度和对应安全级别参考，综合考虑下来，椭圆曲线是不二之选。这是我个人的想法，不一定符合以太坊官方的考虑规则。
3. 该算法主要就是密钥生成、签名,验证,以及公钥与以太坊地址转换
4. 密钥长度是`256位`，需要切记。
5. `2018-11-13补充`：常见的非对称加密算法除了椭圆加密算法之外，还有著名的RSA。椭圆加密相比RSA的区别是：
	1. 椭圆加密的密钥更短
	2. 椭圆加密计算更快而安全性相当
	3. RSA的私钥和公钥是何以互换加解密的，但椭圆加密只能私钥加密公钥解密。
6. 公钥、私钥
	1. 私钥
		以太坊的私钥是一个32字节的数，取值范围从1~0xFFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFE BAAE DCE6 AF48 A03B BFD2 5E8C D036 4140。这个数可以由伪随机算法(PRNG)产生。其实0也是一个合法的私钥，只不过这是一个特殊私钥，以太坊的创世区块就是这个私钥生成的
	2. 公钥
		以太坊的非压缩公钥是一个65字节的数，这个是继承至比特币的。但以太坊只使用了其中64个字节，有一个字节这64个字节中，32字节表示椭圆曲线的X坐标，32字节表示椭圆曲线的Y坐标。这个XY坐标是私钥通过ECDSA-secp256k1推导出来的。所以说，椭圆曲线算法的公钥是通过私钥计算出来的。而反过来，用公钥推导私钥，以现有计算机的计算几乎是不可能的，这也是以太坊和比特币存在的基础。如果哪天计算机技术出现大飞跃，比如量子计算机普及，现有链上所有账户的私钥都会曝光。当然，区块链技术本身也会一定会持续演进的。
<h3 id="公钥-私钥生成">公钥、私钥生成</h3>
<p>crypto提供了随机生成私钥的方法，私钥是可以推导出公钥的：<br>
私钥随机生成的随机数，使用golang自己的 crypto/rand.reader生成的<br>
通过对以太坊中<code>cmd/geth/accountcmd.go</code>的源码分析（accountCreate方法中调用的keystore.StoreKey），发现就是通过下面这段代码来生成私钥地址的</p>
<p><code>备注：</code>私钥本质上就是一个 256 个二进制位的随机数字（2^256 ~ 10^77，目前可见宇宙中估计只含有 10^80 个原子）<br>
<em>这里遗留一个问题是，为什么这样生成不会出现重复的私钥？暂时还不明白。</em></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGenerateKey</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	privateKey, _ := GenerateKey()</span><br><span class="line">	publicKey := privateKey.Public()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;privateKey:%v,\npublicKey:%x\v&quot;</span>, privateKey, publicKey)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="签名-验证">签名、验证</h3>
<h4 id="1-签名">1. 签名</h4>
<p>secp256k1的私钥地址长度是<code>32字节256位</code>,公钥地址长度是65字节。<br>
其中，需要注意的是，被签名的必须是32字节的hash；二签名后的数据，长度和公钥一样长。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">//16进制，256位的私钥，这个可以理解为是secp256k1的私钥，为方便测试，预先生成</span></span><br><span class="line"><span class="keyword">var</span> testPrivHex = <span class="string">&quot;289c2857d4598e37fb9647507e47a309d6133539bf21a8b9cb6df88fd5232032&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSign</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="comment">//根据这个随机数来生成密钥</span></span><br><span class="line">	key, _ := HexToECDSA(testPrivHex)</span><br><span class="line">	<span class="comment">//使用keccak生成原文&quot;foo&quot;的hash</span></span><br><span class="line">	msg := Keccak256([]<span class="type">byte</span>(<span class="string">&quot;foo&quot;</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用密钥对原文对hash进行签名，该msg必须是32位的hash</span></span><br><span class="line">    <span class="comment">//生成的sign</span></span><br><span class="line">	sig, err := Sign(msg, key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Errorf(<span class="string">&quot;Sign error: %s&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-验证">2. 验证</h4>
<p>为了方便，将上一步骤的代码也加入了下方，形成签名-&gt;验证两个环节<br>
该过程主要就是从签名文件中拿到公钥，转换成以太坊地址，然后和测试提供的地址比较，是否一致。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个是测试用的账户地址，验证时候使用</span></span><br><span class="line"><span class="keyword">var</span> testAddrHex = <span class="string">&quot;970e8128ab834e8eac17ab8e3812f010678cf791&quot;</span></span><br><span class="line"><span class="comment">//一个256位的随机数，16进制，这个随机数是如何生成的，暂时还没研究，也是密码学里真随机和伪随机的概念</span></span><br><span class="line"><span class="comment">//根据这个随机数来生成密钥</span></span><br><span class="line"><span class="keyword">var</span> testPrivHex = <span class="string">&quot;289c2857d4598e37fb9647507e47a309d6133539bf21a8b9cb6df88fd5232032&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestVerify</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="comment">//根据这个随机数来生成密钥</span></span><br><span class="line">	key, _ := HexToECDSA(testPrivHex)</span><br><span class="line">	addr := common.HexToAddress(testAddrHex)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用keccak生成原文&quot;foo&quot;的hash</span></span><br><span class="line">	msg := Keccak256([]<span class="type">byte</span>(<span class="string">&quot;foo&quot;</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用密钥对原文对hash进行签名，该msg必须是32位的hash</span></span><br><span class="line">	sig, err := Sign(msg, key)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;签名结果：%v\n&quot;</span>, sig)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Errorf(<span class="string">&quot;Sign error: %s&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//根据签名和原文内容，提取出二进制公钥</span></span><br><span class="line">	recoveredPub, err := Ecrecover(msg, sig)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Errorf(<span class="string">&quot;ECRecover error: %s&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将2机制公钥转换成16进制（65字节）的公钥序列</span></span><br><span class="line">	pubKey := ToECDSAPub(recoveredPub)</span><br><span class="line">	<span class="comment">//将公钥序列转换成账户地址，其实就是取公钥hash处理后的后20位作为地址</span></span><br><span class="line">	recoveredAddr := PubkeyToAddress(*pubKey)</span><br><span class="line">	<span class="comment">//验证生成的公钥地址和测试提供的地址是否一致</span></span><br><span class="line">	<span class="keyword">if</span> addr != recoveredAddr &#123;</span><br><span class="line">		t.Errorf(<span class="string">&quot;Address mismatch: want: %x have: %x&quot;</span>, addr, recoveredAddr)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="公钥与地址的转换">公钥与地址的转换</h3>
<p>上一步骤中已经提到了，我们说的以太坊账户地址并不是公钥地址，而是取的<code>公钥地址hash运算</code>后的后20位作为账户。<br>
具体可以深入到代码中去理解。大概位置是：crypto.go中的PubkeyToAddress函数，调用的<code>common.BytesToAddress(Keccak256(pubBytes[1:])[12:])</code></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>ipfs集群客户端操作</title>
    <url>/articles/ccf3d056/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>本文主要讲的是ipfs集群客户端的操作，这种操作分为两类，一类是通过命令行来控制，另一类是通过restful api来操作，后者对于开发者来说，会有很大帮助。<br>
操作本文内容前，需要先完成前两篇文章中的内容：<br>
<a href="/articles/7987f3ac">ipfs私有环境搭建</a><br>
<a href="/articles/ba940e6d">ipfs集群搭建</a></p>
<span id="more"></span>
<h2 id="说明">说明</h2>
<ol>
<li><code>ipfs-cluster-ctl</code>的使用，请参考：<a href="https://cluster.ipfs.io/documentation/ipfs-cluster-ctl/">https://cluster.ipfs.io/documentation/ipfs-cluster-ctl/</a></li>
<li>默认情况下<code>ipfs-cluster-ctl</code>的使用，需要保证<code>service.json</code>中的设置为：<code>api.restapi.http_listen_multiaddress: /ip4/127.0.0.1/tcp/9094</code></li>
<li>可以选择其中一台安装有ipfs-cluster-server的机器来安装ipfs-cluster-cli</li>
</ol>
<h2 id="主要命令">主要命令</h2>
<ol>
<li>查看集群当前节点中的节点信息：</li>
</ol>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipfs-cluster-ctl peers <span class="built_in">ls</span> </span><br></pre></td></tr></table></figure>
  <img src="/articles/ccf3d056/1.png" class="" title="当前节点信息">
<ol start="2">
<li>查看集群节点关系图</li>
</ol>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipfs-cluster-ctl health graph</span><br></pre></td></tr></table></figure>
  <img src="/articles/ccf3d056/1.png" class="" title="集群拓扑信息">
<ol start="3">
<li>（补充）删除节点中的某个节点（集群节点）</li>
</ol>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipfs-cluster-ctl peers <span class="built_in">rm</span> 集群节点</span><br></pre></td></tr></table></figure>
<h2 id="ipfs集群数据同步">IPFS集群数据同步</h2>
<p>正常情况下，有被搜索过的数据才会被ipfs节点保存，要想让数据同步，需要集群的干预。<br>
以上传一个<code>test.txt</code>文件为例，里面内容为:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">HelloWorld!</span><br></pre></td></tr></table></figure>
<h3 id="1-ipfs节点node1上传文件test-txt">1. ipfs节点node1上传文件test.txt</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> ipfs ipfs add -r /export/test.txt</span><br></pre></td></tr></table></figure>
<p>获得该文件的hash：QmcxC7pxf96yiUyxzkUPoewMMtJst2cFAKQq8CMKXuCSdc</p>
<h3 id="2-根据文件hash将数据同步到集群">2. 根据文件hash将数据同步到集群</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全网的ipfs节点repo 都存在该hash.</span></span><br><span class="line">ipfs-cluster-ctl pin add QmcxC7pxf96yiUyxzkUPoewMMtJst2cFAKQq8CMKXuCSdc</span><br></pre></td></tr></table></figure>
<p>返回结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">QmcxC7pxf96yiUyxzkUPoewMMtJst2cFAKQq8CMKXuCSdc :</span><br><span class="line">    &gt; iZt4ne720rsobv353yq8kzZ : PINNED | 2018-10-25T16:24:04Z</span><br><span class="line">    &gt; iZt4ne720rsobv353yq8kyZ : PINNED | 2018-10-25T16:24:04Z</span><br></pre></td></tr></table></figure>
<h3 id="3-通过pin检测ipfs节点是否有某hash对应的文件">3. 通过pin检测ipfs节点是否有某hash对应的文件</h3>
<p>前面步骤中，得到了上传文件的hash。<br>
在另一个节点，使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> ipfs ipfs pin <span class="built_in">ls</span> QmcxC7pxf96yiUyxzkUPoewMMtJst2cFAKQq8CMKXuCSdc</span><br></pre></td></tr></table></figure>
<p>若返回：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">QmcxC7pxf96yiUyxzkUPoewMMtJst2cFAKQq8CMKXuCSdc recursive</span><br></pre></td></tr></table></figure>
<p>则说明，该数据在该节点上</p>
<h3 id="4-检测集群同步数据状态">4. 检测集群同步数据状态</h3>
<p>可查看集群中文件的同步状态，此命令在某一节点删除文件后有延迟，延迟时间尚不确定</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipfs-cluster-ctl status</span><br></pre></td></tr></table></figure>
<p>返回结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">QmcxC7pxf96yiUyxzkUPoewMMtJst2cFAKQq8CMKXuCSdc :</span><br><span class="line">    &gt; iZt4ne720rsobv353yq8kzZ : PINNED | 2018-10-25T16:24:04Z</span><br><span class="line">    &gt; iZt4ne720rsobv353yq8kyZ : PINNED | 2018-10-25T16:24:04Z</span><br></pre></td></tr></table></figure>
<h3 id="5-跟踪集群中文件的同步状态">5. 跟踪集群中文件的同步状态</h3>
<p>和上面的命令<code>ipfs-cluster-ctl status</code>稍微有所不同</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipfs-cluster-ctl <span class="built_in">sync</span></span><br></pre></td></tr></table></figure>
<h3 id="6-集群取消同步某个hash文件">6. 集群取消同步某个hash文件</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipfs-cluster-ctl pin <span class="built_in">rm</span> QmcxC7pxf96yiUyxzkUPoewMMtJst2cFAKQq8CMKXuCSdc</span><br></pre></td></tr></table></figure>
<h2 id="http-rest-api说明以及测试">http rest api说明以及测试</h2>
<h3 id="rest-api">rest api</h3>
<p>参考官方提供的说明：<a href="https://cluster.ipfs.io/developer/api/">https://cluster.ipfs.io/developer/api/</a><br>
通过它，可以很方便的使用开发操作</p>
<h3 id="测试">测试</h3>
<pre><code class="language-bash">http://192.168.3.100:9094/id
http://192.168.3.100:9094/version
```·
</code></pre>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ipfs</category>
        <category>ipfs应用</category>
      </categories>
      <tags>
        <tag>ipfs</tag>
        <tag>storate</tag>
      </tags>
  </entry>
  <entry>
    <title>ipfs集群搭建</title>
    <url>/articles/ba940e6d/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>本文主要是讲ipfs私有集群的搭建，本文是在上一篇文章<a href="/articles/7987f3ac">ipfs私有环境搭建</a>的基础上进一步搭建的。文中涉及到小编项目隐私的内容，已经做了脱敏处理。</p>
<span id="more"></span>
<h2 id="概述">概述</h2>
<p>ipfs集群同步，同时要对集群管理，在已有环境的基础上，还需要再加入如下项目:<br>
<code>https://github.com/ipfs/ipfs-cluster</code><br>
其中分为两个部分</p>
<ol>
<li><code>ipfs-cluster-service</code>：集群服务端<br>
下载地址：<code>https://dist.ipfs.io/ipfs-cluster-service/v0.6.0/ipfs-cluster-service_v0.6.0_linux-amd64.tar.gz</code></li>
<li><code>ipfs-cluster-ctl</code>：集群客户端<br>
下载地址：<code>https://dist.ipfs.io/ipfs-cluster-ctl/v0.6.0/ipfs-cluster-ctl_v0.6.0_linux-amd64.tar.gz</code></li>
</ol>
<h2 id="集群配置要求">集群配置要求</h2>
<ol>
<li>每个ipfs节点都要安装<code>ipfs-cluster-service</code></li>
<li>其中一个或者某几个节点安装<code>ipfs-cluster-ctl</code>来和前端交互</li>
<li>该安装过程略，都是可执行程序，加个环境变量就可以</li>
</ol>
<h2 id="配置">配置</h2>
<p>分别配置<code>ipfs-cluster-service</code>和<code>ipfs-cluster-ctl</code></p>
<h3 id="ipfs-cluster-service">ipfs-cluster-service</h3>
<ol>
<li>每个ipfs节点都要执行：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipfs-cluster-service init</span><br></pre></td></tr></table></figure>
<p>此时会在<code>/home/</code>中生成一个新目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── peerstore     #  存储当前连接集群节点地址</span><br><span class="line">├── raft          #  是ipfs的协议共识机制</span><br><span class="line">│   ├── raft.db</span><br><span class="line">│   └── snapshots</span><br><span class="line">└── service.json  #  集群service端配置文件</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>service.json</code>说明
<ol>
<li>该文件是集群server端核心配置文件</li>
<li>在该目录下生成的service.json中的<code>cluster.id</code>，表示集群当前节点的id，不是ipfs的节点id，注意区分。</li>
<li>在centos7中，是在此处生成：<code>/root/.ipfs-cluster/service.json</code></li>
</ol>
</li>
<li>选择一个管理节点<br>
管理节点的作用是，集群中，以该节点作为主节点<br>
还是上面的<code>service.json</code>，<br>
在此选择node1节点作为集群的管理节点：<code>cluster.id: QmXr7xVQmdVW45RPBnor2M3G600000PyktuZz5QLpN59QN</code><br>
<code>&quot;secret&quot;: &quot;2437f6e6a0b223e4ae0896efc68271939d000003151c5eeb1bad48d2a666584b&quot;</code></li>
<li>修改管理节点ip连接：<br>
<code>ps</code>:其余每个节点也要做类似操作，将ip改成自己所在节点的<code>地址</code>，不能是<code>域名</code><br>
有的文章中将<code>service.json</code>中，下面的地址改成127.0.0.1之外的ip，但是经过测试，后面集群同步会有问题，且效率低下，因此，如无必要或者对这些不熟悉，不建议修改，默认值即可。</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">## ip问题，以下为默认值，不建议修改</span></span><br><span class="line"><span class="comment"># 对外开放api，若有需要，可以修改此处ip</span></span><br><span class="line"><span class="attr">api.restapi.http_listen_multiaddress:</span> <span class="string">/ip4/127.0.0.1/tcp/9094</span></span><br><span class="line"><span class="comment"># 节点连接ipfs</span></span><br><span class="line"><span class="attr">ipfs_connector.ipfshttp.node_multiaddress:</span> <span class="string">/ip4/127.0.0.1/tcp/5001</span></span><br><span class="line"><span class="comment"># 节点监听</span></span><br><span class="line"><span class="attr">ipfs_connector.ipfshttp.proxy_listen_multiaddress:</span> <span class="string">/ip4/127.0.0.1/tcp/9095</span></span><br></pre></td></tr></table></figure>
<p><code>2018.10.26补充</code>：经过多次尝试，以上几个ip设置的都是默认的127.0.0.1,这样可以增加安全性，公网rest api无法直接访问其中的端口。若想要完全开放，只要将ip全改为<code>0.0.0.0</code>即可。<br>
<code>2018.10.27补充</code>：为了方便开发和测试，将node2节点此处的相关ip都设置成<code>0.0.0.0</code>。</p>
<h3 id="ipfs-cluster-ctl">ipfs-cluster-ctl</h3>
<p>安装好即可，不用额外处理，具体可看下一个笔记，客户端管理集群</p>
<h2 id="启动运行">启动运行</h2>
<h3 id="启动管理节点">启动管理节点</h3>
<p>启动管理节点的ipfs-cluster-serivce</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> ipfs-cluster-service daemon &amp;</span><br></pre></td></tr></table></figure>
<p>此时日志会有该管理节点地址，记录下，下一步用到：<br>
<code>/ip4/192.168.3.100/tcp/9096/ipfs/QmXr7xVQmdVW45RPBnor2M3G600000PyktuZz5QLpN59QN</code></p>
<h3 id="其余节点启动并加入管理节点之中">其余节点启动并加入管理节点之中</h3>
<p>其余每个节点都执行启动，都要和管理节点连通，注意，只能用ip地址，<code>不能用域名</code>，无法识别：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> ipfs-cluster-service daemon --bootstrap /ip4/192.168.3.100/tcp/9096/ipfs/QmXr7xVQmdVW45RPBnor2M3G600000PyktuZz5QLpN59QN &amp;</span><br></pre></td></tr></table></figure>
<h2 id="ipfs节点内容测试">ipfs节点内容测试</h2>
<p>其中<code>QmbvBDKPhdHMVDthaafapqsis9g4YorjRp3bTLc4v7ZMp2</code>，为原先上传的一张图片</p>
<pre><code>http://192.168.3.101:8080/ipfs/QmbvBDKPhdHMVDthaafapqsis9g4YorjRp3bTLc4v7ZMp2/

http://192.168.3.100:8080/ipfs/QmbvBDKPhdHMVDthaafapqsis9g4YorjRp3bTLc4v7ZMp2/
```·
</code></pre>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ipfs</category>
        <category>ipfs应用</category>
      </categories>
      <tags>
        <tag>ipfs</tag>
        <tag>storate</tag>
      </tags>
  </entry>
  <entry>
    <title>ipfs私有环境搭建</title>
    <url>/articles/7987f3ac/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>本文主要讲的是ipfs私有环境的配置，使用两个节点。</p>
<span id="more"></span>
<h2 id="ubuntu相关">ubuntu相关</h2>
<h3 id="服务器信息">服务器信息</h3>
<ol>
<li>服务器1（节点1）:root@192.168.3.100
<ol>
<li>ipfs第一节点</li>
<li>密码已修改******</li>
</ol>
</li>
<li>服务器2（节点2）:root@192.168.3.101
<ol>
<li>ipfs第二节点</li>
<li>密码已修改******</li>
</ol>
</li>
<li>hosts文件：<br>
虽然hosts中配置如下内容，但经测试发现，还是得用ip，用域名会产生异常</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.3.100 node1</span><br><span class="line">192.168.3.101 node2</span><br></pre></td></tr></table></figure>
<h3 id="目录结构说明">目录结构说明</h3>
<ol>
<li><code>~/app/</code> ：为方便管理，手动安装的软件统一放在此处
<ol>
<li><code>~/app/golang/go</code>：go安装目录</li>
<li><code>~/app/golang/gopath</code>：gopath位置</li>
</ol>
</li>
<li>docker镜像相关映射目录，均放在<code>~/docker</code>中
<ol>
<li><code>~/docker/ipfs</code>：ipfs相关</li>
</ol>
</li>
<li><code>/usr/local/bin</code>：部分执行文件直接放于此处
<ol>
<li><code>/usr/local/bindocker-compose</code>:不解释</li>
</ol>
</li>
</ol>
<h3 id="其余">其余</h3>
<p>其余基本配置和安装，此处略</p>
<h2 id="docker相关">docker相关</h2>
<p>其余基本的依赖安装、服务启动相关，此处不描述</p>
<h3 id="docker安装">docker安装</h3>
<ol>
<li>更新apt</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get  update</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>安装docker</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install  docker</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><a href="http://xn--docker-9f7km201a.io">安装docker.io</a></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install docker.io</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>安装docker-registry</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install  docker-registry</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>此时docker已经启动，若未启动，执行：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>
<h3 id="docker-compose安装">docker-compose安装</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo curl -L <span class="string">&quot;https://github.com/docker/compose/releases/download/1.22.0/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>
<h3 id="ipfs启动">ipfs启动</h3>
<p>此时会同时初始化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name ipfs -v ~/docker/ipfs/export:/export -v ~/docker/ipfs/data:/data/ipfs -p 4001:4001 -p 8080:8080 -p 5001:5001 ipfs/go-ipfs:latest</span><br></pre></td></tr></table></figure>
<h2 id="ipfs私有环境配置">ipfs私有环境配置</h2>
<h3 id="每个节点均执行以下步骤">每个节点均执行以下步骤</h3>
<h4 id="生成共享key">生成共享key</h4>
<p>私有网络，需要拥有相同key的节点在一起</p>
<ol>
<li>下载go相关依赖包：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u github.com/Kubuxu/go-ipfs-swarm-key-gen</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>生成key<br>
<code>ipfs/data</code>中</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/docker/ipfs/data/swarm.key</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>复制到另一个节点<br>
需要保证每个节点都有相同的swarm.key，类似于网络许可证</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp ~/docker/ipfs/data/swarm.key 192.168.3.101:~/docker/ipfs/data/</span><br></pre></td></tr></table></figure>
<h4 id="删掉默认的ipfs可以发现的网络">删掉默认的ipfs可以发现的网络</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> ipfs  ipfs bootstrap <span class="built_in">rm</span> --all</span><br></pre></td></tr></table></figure>
<h4 id="重新启动发现">重新启动发现</h4>
<p>docker镜像启动后，默认就会启动该服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> ipfs ipfs daemon</span><br></pre></td></tr></table></figure>
<h4 id="配置http-head">配置http head</h4>
<p>为了方便外部访问，比如5001的webui访问，需要修改配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /home/docker/ipfs/data/config</span><br><span class="line">补全如下内容：</span><br><span class="line">  <span class="string">&quot;API&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;HTTPHeaders&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;Server&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;go-ipfs/0.4.17&quot;</span></span><br><span class="line">      ]</span><br><span class="line">      <span class="string">&quot;Access-Control-Allow-Methods&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;GET&quot;</span>,<span class="string">&quot;POST&quot;</span>,<span class="string">&quot;PUT&quot;</span>,<span class="string">&quot;OPTIONS&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="string">&quot;Access-Control-Allow-Origin&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;*&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>重启：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker restart ipfs</span><br></pre></td></tr></table></figure>
<h4 id="总结">总结</h4>
<p>如此，就有一个节点生成了，此时已经是启动可发现状态</p>
<ol>
<li>node1节点id：<code>QmNdi6ExJ9Rcpggf41uB7TYuHhPUBExg2fbV8V7TCXFj8Z</code></li>
<li>node2节点id：<br>
<code>QmSBQvCgomiMCdGULVdehLZFKXLpNRNyo67ZRk43g8mQpC</code></li>
</ol>
<h3 id="将其中一个节点加入到另一个节点">将其中一个节点加入到另一个节点</h3>
<ol>
<li>若有多个节点，则选择其中一个节点做标准，然后加入到其它每个节点中，也就是说，若有A、B、C、D、E、F五个节点，选择节点A为标准，将节点A加入到B、C、D、E、F中。</li>
<li><code>ps</code>：因目前docker-compose还未使用，暂时直接添加ip，后面再用hosts文件来设置域名。</li>
<li>比如将节点2加入到节点1中</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> ipfs ipfs bootstrap add /ip4/192.168.3.100/tcp/4001/ipfs/QmNdi6ExJ9Rcpggf41uB7TYuHhPUBExg2fbV8V7TCXFj8Z</span><br></pre></td></tr></table></figure>
<p>检查是否加入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> ipfs ipfs swarm peers</span><br></pre></td></tr></table></figure>
<h3 id="测试">测试</h3>
<p>目的：将一张图片加入到ipfs节点</p>
<ol>
<li>因为使用的是docker，从外部映射的文件夹到ipfs中，也就是说，要将待上传图片test.jpg放在<code>/home/docker/ipfs/export</code></li>
<li>然后执行：</li>
</ol>
<pre><code class="language-bash">sudo docker exec ipfs ipfs add -r /export/test.jpg
```·
</code></pre>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ipfs</category>
        <category>ipfs应用</category>
      </categories>
      <tags>
        <tag>ipfs</tag>
      </tags>
  </entry>
  <entry>
    <title>evm架构梳理</title>
    <url>/articles/414c120c/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>这段时间在看evm，不是说evm偏底层就不该了解。它是支撑整个ethereum运行等基石，把握了它才能把握了以太坊的整个设计方向。</p>
<span id="more"></span>
<p>小编这段时间研究后，只能说，真的是长见识了。。<br>
小编把evm的代码抽离出来了，还没写完，等后面完的差不多了，就会提交到github<br>
目前源码还没看完，只知道一个新建合约在evm中的整个流程</p>
<h2 id="整体架构">整体架构</h2>
<p>先上图，精心绘制的</p>
<img src="/articles/414c120c/1.png" class="" title="evm整体架构">
<h2 id="evm文件结构图">evm文件结构图</h2>
<p>.<br>
|____memory.go                    //数据内存管理，指令涉及到内存操作的部分<br>
|____memory_table.go              //内存的读取等操作<br>
|____opcodes.go                   //指令符号定义等<br>
|____analysis.go<br>
|____gas_table_test.go            //gas价格测试<br>
|____gas_table.go                 //gas汇总<br>
|____evm.go                       //evm创建字节码合约，调用合约的入口<br>
|____gas.go                       //用于设定每个指令的gas费用<br>
|____logger.go                    //日志<br>
|____logger_test.go               //日志测试<br>
|____int_pool_verifier_empty.go   //注意文件里面，顶部的+build符号，这是用来验证整数池是否正常的（初始化）<br>
|____int_pool_verifier.go         //同上，这个过程是需要手动编译用的<br>
|____interface.go                 //数据物理存储，调用的外部接口，指令sstore执行后保存会用到<br>
|____analysis_test.go<br>
|____instructions.go              //每条指令具体执行的函数<br>
|____gen_structlog.go<br>
|____contracts.go                 //预编译合约<br>
|____contracts_test.go            //预编译合约测试<br>
|____noop.go<br>
|____instructions_test.go         //指令测试<br>
|____opt_test.go                  //指令执行测试<br>
|____doc.go<br>
|____stack.go                     //栈，指令操作<br>
|____stack_table.go               //栈验证的一些方法<br>
|____common.go                    //一些公用的工具<br>
|____interpreter.go               //解析指令，就是从合约字节编码中获取<br>
|____intpool.go                   //整数池<br>
|____jump_table.go                //指令执行方法的具体实现<br>
|____contract.go                  //字节码合约，外部传入的编码被映射到其中<br>
|____errors.go                    //错误管理</p>
<h2 id="具体说明">具体说明</h2>
<p>其实图中已经讲的很详细，<br>
看源码的话，建议从evm的create入手，看看创建一个字节码合约要经历哪些步骤。<br>
另外一定要知道intpool、stack、memory的作用，另外，指令的定义，执行等，也一定要了解。否则很难明白这个evm在做什么。</p>
<h2 id="一些有意义的内容">一些有意义的内容</h2>
<p>从源码中，小编了解到了一些内容：</p>
<ol>
<li>栈道深度是1024</li>
<li>一条指令不能超过8个字节，也就是64位</li>
<li>总共有7个硬分叉，在/go-ethereum/params/config.go中可以看出，难道是7次硬分叉？，其中<code>HomesteadBlock</code>、<code>ByzantiumBlock</code>、<code>ConstantinopleBlock</code>属于ethereum的3个里程碑，第4个还没出现，还在开发中 <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ChainConfig)</span></span> IsHomestead(num *big.Int) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> isForked(c.HomesteadBlock, num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// IsDAO returns whether num is either equal to the DAO fork block or greater.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ChainConfig)</span></span> IsDAOFork(num *big.Int) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> isForked(c.DAOForkBlock, num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ChainConfig)</span></span> IsEIP150(num *big.Int) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> isForked(c.EIP150Block, num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ChainConfig)</span></span> IsEIP155(num *big.Int) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> isForked(c.EIP155Block, num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ChainConfig)</span></span> IsEIP158(num *big.Int) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> isForked(c.EIP158Block, num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ChainConfig)</span></span> IsByzantium(num *big.Int) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> isForked(c.ByzantiumBlock, num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ChainConfig)</span></span> IsConstantinople(num *big.Int) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> isForked(c.ConstantinopleBlock, num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>忘了。。。。。。</li>
</ol>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>EVM</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊vm系列5- abi编码（暂不更新本文）</title>
    <url>/articles/6065d2dc/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>abi是什么？<br>
前面我们认识到的是智能合约直接在EVM上的表示方式，但是，比如我想用java端程序去访问智能合约的某个方法，难道让java开发人员琢磨透汇编和二进制的表示，再去对接？<br>
这明显是不可能的，为此abi产生了。这是一个通用可读的json格式的数据，任何别的客户端开发人员或者别的以太坊节点只要指定要调用的方法，通过abi将其解析为字节码并传递给evm，evm来计算处理该字节码并返回结果给前端。<br>
这个应该解释清楚了吧？</p>
<span id="more"></span>
<p>abi就起到这么一个作用，类似于传统的客户端和服务器端地址好交互规则，比如json格式的数据，然后进行交互。</p>
<p><code>忽略后面所写内容，暂不考虑</code></p>
<h2 id="先来看个案例">先来看个案例</h2>
<p>我们创建一个合约：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">  uint256 a;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">setA</span>(<span class="params">uint256 _a</span>) public &#123;</span><br><span class="line">    a = _a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getA</span>(<span class="params"></span>) public <span class="title function_">returns</span>(<span class="params">uint256</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行方法<code>setA(1)</code>，然后该方法会被解析成：<code>0xee919d500000000000000000000000000000000000000000000000000000000000000001</code>,总共36个字节，其中前4个字节取的是<code>setA(uint256)</code>经过keccak256运算生成的hash的前<code>4</code>个字节，剩下1为一个32字节的数据(uint256类型的数据，当然是32字节)<br>
<code>0xee919d500000000000000000000000000000000000000000000000000000000000000001</code>会被传到智能合约（比如solidity或别的可以接受的程序），它会将这些输入字节解释为方法调用，并为setA(1)执行适当的汇编代码。<br>
流程如下：</p>
<img src="/articles/6065d2dc/1.png" class="" title="方法执行的整个流程">
<h2 id="外部方法调用">外部方法调用</h2>
<p>编译好的合约是怎样处理输入源的？先来这么一个合约：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">  uint256 a;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">setA</span>(<span class="params">uint256 _a</span>) public payable &#123;</span><br><span class="line">    a = _a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>本文暂停更新，待进一步搞懂后再继续更新</code></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>EVM</tag>
      </tags>
  </entry>
  <entry>
    <title>快速实现以太坊免费空投token合约（揭开此类代币的假面）</title>
    <url>/articles/ebac0719/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>在imtoken或者metamask中，输入一个智能合约，立马就会发收到空投币。<br>
很激动是不是？不花手续费就能拿到币。然并卵，这只是套路，一切都是忽悠。。<br>
<code>小编的这句话是重点，一定要记住:</code>这种币是彻头彻尾的假币，在实际底层区块链地址上，根本没有这个币。<br>
我们从ethscanner或者imtoken上看到的以为到账的数字，只是程序的玩笑，亲眼见到的未必是真的。。</p>
<p>先来看看这个功能是怎么实现的？作为娱乐和恶搞，这个还是蛮有意思的。。。。</p>
<span id="more"></span>
<h2 id="主要开发环境搭建">主要开发环境搭建</h2>
<p>这不是本文的重点，就只大概解释一下</p>
<h3 id="开发工具：truffle">开发工具：truffle</h3>
<p>小编有专门的系列博客来讲如何使用该工具，大家可以搜搜。小编实在Intellij idea下部署的该开发工具。<br>
请自行初始化好该项目。</p>
<h3 id="钱包：metamask">钱包：Metamask</h3>
<p>这个是安装在google的插件，具体如何使用，请使用伟大的google。记得将Metamsk切换到Ropsten测试网络环境</p>
<h3 id="以太坊测试网：infura">以太坊测试网：infura</h3>
<p>以太坊公链测试项目，一点也不显示。好的一点是，有专门的机构提供测试网络，我们一般是使用infura进行以太坊相关测试的。<br>
具体怎么操作，还请google。<br>
生成自己的账户，并记住<code>助记词</code>,后面要用</p>
<h2 id="原理">原理</h2>
<p>imtoken和metamask在用户输入合约地址时候，会调用合约的<code>balanceof()</code>方法，然后我们在这里做文章就行。<br>
这就是原理。<br>
<code>还是记住，还是要记住，这个原理仅仅可以娱乐</code></p>
<h2 id="具体步骤">具体步骤</h2>
<p>这里会列出实现的每个流程，小编只会在重要的地方多讲下</p>
<h3 id="truffle项目中引入依赖包">truffle项目中引入依赖包</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install openzeppelin-solidity   <span class="comment">//里面有很多按照官方规范实现的比较权威的合约案例和标准</span></span><br><span class="line">npm install truffle-hdwallet-provider   <span class="comment">//可以用来提供私钥签名</span></span><br></pre></td></tr></table></figure>
<h3 id="编写智能合约">编写智能合约</h3>
<p>先上代码，后面来解释</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;openzeppelin-solidity/contracts/token/ERC20/PausableToken.sol&quot;</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="title class_">FreeAirToken</span> is <span class="title class_">PausableToken</span> &#123;</span><br><span class="line"></span><br><span class="line">    string public name;</span><br><span class="line">    string public symbol;</span><br><span class="line">    uint256 public airdropNum;</span><br><span class="line">    uint256 public constant decimals = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">    string public version = <span class="string">&quot;1.0&quot;</span>;</span><br><span class="line">    uint256 public currentSupply;</span><br><span class="line"></span><br><span class="line">    event <span class="title class_">Mint</span>(uint256 currentSupply, address to, uint256 amount);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">address _owner, string _name, string _symbol, uint256 _totalSupply, address _admin, uint256 _airdropNum</span>) public &#123;</span><br><span class="line">        owner = _owner;</span><br><span class="line">        name = _name;</span><br><span class="line">        symbol = _symbol;</span><br><span class="line">        totalSupply_ = _totalSupply * <span class="number">10</span> ** decimals;</span><br><span class="line">        currentSupply = <span class="number">0</span>;</span><br><span class="line">        airdropNum = _airdropNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">balanceOf</span>(<span class="params">address _owner</span>) public view returns (uint256) &#123;</span><br><span class="line">        balances[_owner] = airdropNum * <span class="number">10</span> ** decimals;   <span class="comment">//看着貌似是写入自己地址了，但别忘了这是view方法，数据是没有真正存在磁盘中！！</span></span><br><span class="line">        <span class="keyword">return</span> balances[_owner];  <span class="comment">//呵呵，返回的这个数据只是方法内存临时返回的结果，</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ok，整个ERC20合约token就是这么简单，上面合约的大意是：重写了erc20标准方法中的<code>balanceOf()</code>,这就是空投实现的秘密，因此,任何只要调用该方法的账户，都会显示你这个账户有真么多token，注意只是显示！！！。</p>
<h3 id="合约编译">合约编译</h3>
<p>根目录使用truffle编译</p>
<h3 id="合约发布">合约发布</h3>
<p>接着就要发布合约到测试网络了。</p>
<ol>
<li>在truffle项目根目录新建文件:<code>token_config.js</code>,输入如下内容：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">config</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;HelloToken&quot;</span>,</span><br><span class="line">        <span class="attr">symbol</span>: <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">        <span class="attr">totalSupply</span>: <span class="number">1e7</span>, <span class="comment">//总发行量</span></span><br><span class="line">        <span class="attr">owner</span>: <span class="string">&quot;0x7c54124fBd7e21C822A3827572FC31c5b1663711&quot;</span>,</span><br><span class="line">        <span class="attr">admin</span>: <span class="string">&quot;0xc99d160ad804Ee5B7ac9552bEF3B25f53E659d79&quot;</span>, </span><br><span class="line">        <span class="attr">airdropNum</span>: <span class="number">1000</span>  <span class="comment">//空投，每个账户能拿到的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = config;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>先在migrations/2_deploy_contracts.js文件中，做如下修改：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">FreeAirToken</span> = artifacts.<span class="built_in">require</span>(<span class="string">&quot;./FreeAirToken.sol&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> config = <span class="built_in">require</span>(<span class="string">&#x27;../token_config.js&#x27;</span>)();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">deployer</span>) &#123;</span><br><span class="line">    deployer.<span class="title function_">deploy</span>(<span class="title class_">FreeAirToken</span>, config.<span class="property">owner</span>,config.<span class="property">name</span>, config.<span class="property">symbol</span>, config.<span class="property">totalSupply</span>, config.<span class="property">admin</span>,config.<span class="property">airdropNum</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在根根目录的truffle.js中配置发布网络：<br>
因为我们是要发布在infura中，发布人是需要用私钥签名的，因此，这里需要提供Metamask的助记词。<br>
记者写上自己的gas，不要太少。目前市场gasLimit已经达到800w。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">HDWalletProvider</span> = <span class="built_in">require</span>(<span class="string">&quot;truffle-hdwallet-provider&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> mnemonic = <span class="string">&quot;unaware myth decade hour tragic hazard ship desert orchard will cream reform&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">networks</span>: &#123;</span><br><span class="line">        <span class="attr">ropsten</span>: &#123;</span><br><span class="line">            <span class="attr">provider</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span></span><br><span class="line">                <span class="title class_">HDWalletProvider</span>(mnemonic, <span class="string">&quot;https://ropsten.infura.io/xxxxxxxx&quot;</span>) <span class="comment">//这里输入自己申请的infura测试网地址，记得用ropsten</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">network_id</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">gas</span>: <span class="number">4712388</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>发布合约：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">truffle migrate</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>记着合约的地址：<br>
就是小编上面列出来的信息里的这一行，这就是这个token合约的地址：<br>
FreeAirToken: 0xd1cc0f89502c289b1d74c3d5d9ecf22d1b45d716</li>
</ol>
<p>接下来我们进入测试阶段</p>
<h2 id="测试">测试</h2>
<p>直接看测试结果:</p>
<img src="/articles/ebac0719/1.png" class="" title="空投领token">
<img src="/articles/ebac0719/2.png" class="" title="空投领token">
<p>ok，呵呵，账户多了token了，眼睛也是会欺骗人的。。。从底层来看，你账户依然一分没有，只是这些页面调用了小编说的那个方法而已，那个方法本身是不会真把token转给你的。</p>
<h2 id="为何说这个空投币是无效的？">为何说这个空投币是无效的？</h2>
<p>合约中，我们设置了每个调用balanceOf的人，都能拿到1000个币，但是，这个balanceOf方法是view级别的，按照规范，这里面是不能进行磁盘存储类操作的，<br>
因此，只是内存中返回了我们一个<code>假的1000</code>,真正地址上是没有这个1000的。<br>
这也是别的平台调用调用这个balanceof方法会显示你有1000个币的原因</p>
<h2 id="总结">总结</h2>
<p>记着天下没有免费的午餐，不要贪。。。空投币，没有靠谱项目方的，都是假的，不要轻易相信自己的眼睛。</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>综合</category>
      </categories>
      <tags>
        <tag>智能合约</tag>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊vm系列4-动态数据处理</title>
    <url>/articles/639ef287/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>本文主要是讲Solidity以及EVM对动态数据的复杂的数据类型的处理方式，了解了这些基本情况，对我们编写经济的合约或者设计新的vm，都有极大的帮助。<br>
动态数据分为这三大类：</p>
<ol>
<li>映射(Mappings)：mapping(bytes32 =&gt; uint256)， mapping(address =&gt; string)等等</li>
<li>数组(Arrays)：[]uint256，[]byte等等</li>
<li>字节数组(Byte arrays)：只有两种类型：string，bytes</li>
</ol>
<span id="more"></span>
<p>本文参考的是Howard是量子链的大神的文章，末尾处有文章出处，根据小编的理解，做了大量的调整和补充。<br>
指令集可参考：<a href="/articles/715e1612">以太坊vm系列1-指令集汇总</a>，里面有详细的汇总和解释<br>
讲之前，小编先要给大家脑补一点：<br>
把EVM理解为一个键-值(key-value)数据库，而每个key都限制为32字节。<br>
另外，本文所有合约都是在Remix上编译的</p>
<h2 id="映射">映射</h2>
<p>带有映射的一个简单合约：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">uint256</span> =&gt;</span> uint256) items;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) public &#123;</span><br><span class="line">      items[<span class="number">0xc0fefe</span>] = <span class="number">0x42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器开启<code>optimize</code>编译该合约。<br>
映射存储相关字节码：<code>62c0fefe600090815260205260427f79826054ee948a209ff4a6c9064d7398508d2c1909a392f899d301c6d232187c55</code><br>
对应的汇编指令：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">PUSH3</span> <span class="number">0xC0FEFE</span>       <span class="comment">//62 0xc0fefe，  将0xc0fefe压入栈，此时栈中数据stack[c0x0fefe]</span></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x0</span>            <span class="comment">//60 0x0，       将0x0压入栈，此时栈中数据stack[c0x0fefe，0x0]</span></span><br><span class="line"><span class="symbol">SWAP1</span>                <span class="comment">//90，           从栈顶起，将前两个数据交换。此时栈中数据stack[0x0 c0x0fefe]</span></span><br><span class="line"><span class="symbol">DUP2</span>                 <span class="comment">//81，           栈顶起，将栈中第2个元素复制并加入栈顶。此时栈中数据stack[0x0 c0x0fefe 0x0]</span></span><br><span class="line"><span class="symbol">MSTORE</span>               <span class="comment">//52，           先后pop出两个元素x,y，内存中将y存在x对应地址。此时栈中数据stack[0x0]，内存数据memory&#123;&#x27;0x0位置存储c0x0fefe&#x27;&#125;</span></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x20</span>           <span class="comment">//60 0x20，      将0x20压入栈，此时栈中数据stack[0x0 0x20]</span></span><br><span class="line"><span class="symbol">MSTORE</span>               <span class="comment">//52，           先后pop出两个元素x,y，内存中将y存在x对应地址。此时栈中数据stack[]，内存数据memory&#123;&#x27;0x0位置存储c0x0fefe&#x27;，&#x27;0x20位置存储0x0&#x27;&#125;</span></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x42</span>           <span class="comment">//60 0x42，      将0x20压入栈，此时栈中数据stack[0x42]，内存数据memory&#123;&#x27;0x0位置存储c0x0fefe&#x27;，&#x27;0x20位置存储0x0&#x27;&#125;</span></span><br><span class="line"><span class="symbol">PUSH32</span> <span class="number">0x7982</span>...     <span class="comment">//60 0x7982...， 将0x79826054EE948A209FF4A6C9064D7398508D2C1909A392F899D301C6D232187C压入栈，此时栈中数据stack[0x42 0x79826054EE948A209FF4A6C9064D7398508D2C1909A392F899D301C6D232187C]，内存数据memory&#123;&#x27;0x0位置存储c0x0fefe&#x27;，&#x27;0x20位置存储0x0&#x27;&#125;</span></span><br><span class="line"><span class="symbol">SSTORE</span>               <span class="comment">//55，           栈顶推出两位，将数值0x42存储在存储器的0x79826054EE948A209FF4A6C9064D7398508D2C1909A392F899D301C6D232187C的位置上。此时栈为空stack[]，内存数据memory&#123;&#x27;0x0位置存储c0x0fefe&#x27;，&#x27;0x20位置存储0x0&#x27;&#125;，此处发现这个内存貌似没什么用处。。。</span></span><br></pre></td></tr></table></figure>
<p>上面的指令是不是很诡异？还记得我们前面说的，evm看成是个k-v数据库，k有32字节。<br>
<code>0x7982...（32字节）</code>其实就是<code>0xc0fefe</code>使用<code>keccak256</code>哈希运算后的结果，用它来作为key。因为编译期间我们使用了<code>optimize</code>，Solidity会预先帮我们把<code>0xc0fefe</code>哈希生成<code>0x7982...（32字节）</code><br>
也就是说，上面的两条<code>MSTORE</code>指令貌似并没什么卵用，这块Solidity的优化器要是能进一步完善下，没准就又可以省下几个gas了。<br>
<code>MSTORE</code>指令是进行内存操作，很便宜，操作一次3gas。</p>
<p>其实，Solidity编译器之所以可以预先将<code>0xc0fefe</code>哈希生成<code>0x7982...（32字节）</code>，是因为直接数组中设置的的常量，但如果改成是变量，那又会变成什么样子？我们继续往下分析。<br>
也不是说上面的两个<code>MSTORE</code>没用，等看完小编后面写的内容，就知道若Solidity编译器的hash生成失效，汇编会用这两个内存值来进行汇编层次的hash运算。在上面的汇编代码中，只能说是Solidity优化不彻底。</p>
<p><code>ps:keccak256是一种hash计算标准，老权威了。。。</code></p>
<h2 id="汇编代码中的keccak256">汇编代码中的<code>keccak256</code></h2>
<p>改造一下上面的合约，将<code>0xc0fefe</code>提到外部变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">uint256</span> =&gt;</span> uint256) items;</span><br><span class="line">    uint256 i = <span class="number">0xC0FEFE</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) public &#123;</span><br><span class="line">      items[i] = <span class="number">0x42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器开启<code>optimize</code>编译该合约。<br>
映射存储相关字节码：<code>600154600090815260208190526040902060429055</code><br>
对应的汇编指令：<br>
<code>ps:0xc0fefe存储在存储器0x1地址的汇编过程，小编这里就不列出来了，以下都是该过程完成后的操作</code></p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x1</span>    <span class="comment">//60 0x1， 将0x0压入栈，此时栈中数据stack[0x1]</span></span><br><span class="line"><span class="symbol">SLOAD</span>        <span class="comment">//54，     取出栈顶元素，转为hash长度（表示在db中的地址），在db中是否存在对应值,并读取出,此处返回`0xc0fefe`，push到栈中。此时栈中数据stack[0xc0fefe]</span></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x0</span>    <span class="comment">//60 0x0， 将0x0压入栈，此时栈中数据stack[0xc0fefe 0x0]</span></span><br><span class="line"><span class="symbol">SWAP1</span>        <span class="comment">//90，     从栈顶起，将前两个数据交换。此时栈中数据stack[0x0 0xc0fefe]</span></span><br><span class="line"><span class="symbol">DUP2</span>         <span class="comment">//81，     从栈顶起，将栈中第2个元素复制并加入栈顶。此时栈中数据stack[0x0 0xc0fefe 0x0]</span></span><br><span class="line"><span class="symbol">MSTORE</span>       <span class="comment">//52，     先后pop出两个元素x,y，内存中将y存在x对应地址。此时栈中数据stack[0x0]，内存数据memory&#123;&#x27;0x0位置存储0xc0fefe&#x27;&#125;</span></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x20</span>   <span class="comment">//60 0x20，将0x20压入栈，此时栈中数据stack[0x0 0x20]</span></span><br><span class="line"><span class="symbol">DUP2</span>         <span class="comment">//81，     从栈顶起，将栈中第2个元素复制并加入栈顶。此时栈中数据stack[0x0 0x20 0x0]</span></span><br><span class="line"><span class="symbol">SWAP1</span>        <span class="comment">//90，     从栈顶起，将前两个数据交换。此时栈中数据stack[0x0 0x0 0x20]</span></span><br><span class="line"><span class="symbol">MSTORE</span>       <span class="comment">//52，     先后pop出两个元素x,y，内存中将y存在x对应地址。此时栈中数据stack[0x0]，内存数据memory&#123;&#x27;0x0位置存储0xc0fefe&#x27;,&#x27;0x0位置存储0x20&#x27;&#125;</span></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x40</span>   <span class="comment">//60 0x40，将0x20压入栈，此时栈中数据stack[0x0 0x40]</span></span><br><span class="line"><span class="symbol">SWAP1</span>        <span class="comment">//90，     从栈顶起，将前两个数据交换。此时栈中数据stack[0x40 0x0]</span></span><br><span class="line"><span class="symbol">KECCAK256</span>    <span class="comment">//20，     该过程在evm中是`SHA3操作`，pop出栈中两个元素偏离值m和大小n，结合内存中的两个数据x,y生成为32字节的hash，然后压入栈。此时栈中数据stack[0x79826054EE948A209FF4A6C9064D7398508D2C1909A392F899D301C6D232187C]，内存数据memory&#123;&#125;</span></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x42</span>   <span class="comment">//60 0x42，将0x20压入栈，此时栈中数据stack[0x79826054EE948A209FF4A6C9064D7398508D2C1909A392F899D301C6D232187C 0x42]</span></span><br><span class="line"><span class="symbol">SWAP1</span>        <span class="comment">//90，     从栈顶起，将前两个数据交换。此时栈中数据stack[0x42 0x79826054EE948A209FF4A6C9064D7398508D2C1909A392F899D301C6D232187C]</span></span><br><span class="line"><span class="symbol">SSTORE</span>       <span class="comment">//55，     栈顶推出两位，将数值0x42存储在存储器的0x79826054EE948A209FF4A6C9064D7398508D2C1909A392F899D301C6D232187C地址。此时栈中数据stack[]</span></span><br></pre></td></tr></table></figure>
<p>这下应该知道<code>MSTORE</code>两次操作的目的了吧？<br>
KECCAK256主要是操作栈和内存中的数据，成本大体为：</p>
<ol>
<li>操作一次KECCAK256需要支付30gas</li>
<li>每个32字节，需要支付6gas</li>
</ol>
<p>小编这么理解KECCAK256从栈中的两个数据，这个过程的费用已经包含在30gas中，而内存中两个32字节的数据操作是需要手续费，每个6gas，总共费用为：30+6x2=42gas。<br>
知道优化的重要性了吧？</p>
<p>are you ok？</p>
<h2 id="映射大数值和打包问题">映射大数值和打包问题</h2>
<p>只要记着，映射是按照32字节来处理，也就是说，当一个数据小于32字节的时候，按32字节处理，当大于32字节的时候，以32字节为单位递增。而且地址是连续的。<br>
对于打包问题，可以这么说，以映射的设计方式，是不存在打包问题的。原因同上。<br>
这个不复杂，请自行验证吧。</p>
<h2 id="动态数组">动态数组</h2>
<p>动态数组是什么东西？这里就不用问小编了吧？<br>
动态数组在Solidity中主要包含两大类：</p>
<ol>
<li>数组(Arrays)：[]uint256，[]byte等等</li>
<li>字节数组(Byte arrays)：只有两种类型：string，bytes</li>
</ol>
<p>需要知道的是，在Solidity中，数组是更加昂贵的映射。数组里面的元素会按照顺序排列在存储器中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x290d...e563</span><br><span class="line">0x290d...e564</span><br><span class="line">0x290d...e565</span><br><span class="line">0x290d...e566</span><br></pre></td></tr></table></figure>
<p>动态数组拥有这样一些信息：</p>
<ol>
<li>length表示一共有多少个元素</li>
<li>边界检查。当读取或写入时索引值大于length就会报错</li>
<li>比映射更加复杂的存储打包行为</li>
<li>当数组变小时，自动清除未使用的存储槽</li>
<li>字节数组bytes和string的特殊优化让短数组(小于32字节)存储更加高效</li>
</ol>
<h3 id="一个简单的动态数组">一个简单的动态数组</h3>
<p>合约代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    uint256[] chunks;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) public &#123;</span><br><span class="line">      chunks.<span class="title function_">push</span>(<span class="number">0xAA</span>);</span><br><span class="line">      chunks.<span class="title function_">push</span>(<span class="number">0xBB</span>);</span><br><span class="line">      chunks.<span class="title function_">push</span>(<span class="number">0xCC</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化器优化后的Solidity进行编译，汇编指令：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x0</span>       stack[<span class="number">0x0</span>]</span><br><span class="line"><span class="symbol">DUP1</span>            stack[<span class="number">0x0</span> <span class="number">0x0</span>]</span><br><span class="line"><span class="symbol">SLOAD</span>           stack[<span class="number">0x0</span> <span class="number">0x0</span>]</span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x1</span>       stack[<span class="number">0x0</span> <span class="number">0x0</span> <span class="number">0x1</span>]</span><br><span class="line"><span class="symbol">DUP2</span>            stack[<span class="number">0x0</span> <span class="number">0x0</span> <span class="number">0x1</span> <span class="number">0x0</span>]</span><br><span class="line"><span class="symbol">DUP2</span>            stack[<span class="number">0x0</span> <span class="number">0x0</span> <span class="number">0x1</span> <span class="number">0x0</span> <span class="number">0x1</span>]</span><br><span class="line"><span class="keyword">ADD</span>             stack[<span class="number">0x0</span> <span class="number">0x0</span> <span class="number">0x1</span> <span class="number">0x1</span>]</span><br><span class="line"><span class="symbol">DUP4</span>            stack[<span class="number">0x0</span> <span class="number">0x0</span> <span class="number">0x1</span> <span class="number">0x1</span> <span class="number">0x0</span>]</span><br><span class="line"><span class="symbol">SSTORE</span>          stack[<span class="number">0x0</span> <span class="number">0x0</span> <span class="number">0x1</span>] store&#123;<span class="number">0x0</span>地址存入<span class="number">0x1</span>&#125;</span><br><span class="line"><span class="symbol">DUP3</span>            stack[<span class="number">0x0</span> <span class="number">0x0</span> <span class="number">0x1</span> <span class="number">0x0</span>]</span><br><span class="line"><span class="symbol">DUP1</span>            stack[<span class="number">0x0</span> <span class="number">0x0</span> <span class="number">0x1</span> <span class="number">0x0</span> <span class="number">0x0</span>]</span><br><span class="line"><span class="symbol">MSTORE</span>          stack[<span class="number">0x0</span> <span class="number">0x0</span> <span class="number">0x1</span>] memory&#123;<span class="number">0x0</span>地址存入<span class="number">0x0</span>&#125;  此memory无效</span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0xAA</span>      stack[<span class="number">0x0</span> <span class="number">0x0</span> <span class="number">0x1</span> <span class="number">0xAA</span>]</span><br><span class="line"><span class="symbol">PUSH32</span> <span class="number">0x290</span>... stack[<span class="number">0x0</span> <span class="number">0x0</span> <span class="number">0x1</span> <span class="number">0xAA</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span>]</span><br><span class="line"><span class="symbol">SWAP3</span>           stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span> <span class="number">0xAA</span> <span class="number">0x0</span>]</span><br><span class="line"><span class="symbol">DUP4</span>            stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span> <span class="number">0xAA</span> <span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span>]</span><br><span class="line"><span class="keyword">ADD</span>             stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span> <span class="number">0xAA</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span>] </span><br><span class="line"><span class="symbol">SSTORE</span>          stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span>] store&#123;<span class="string">&#x27;0x0地址存入0x1&#x27;</span>,<span class="string">&#x27;0xAA地址存入0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="symbol">DUP3</span>            stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span> <span class="number">0x0</span>]</span><br><span class="line"><span class="symbol">SLOAD</span>           stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span> <span class="number">0x1</span>] store&#123;<span class="string">&#x27;0x0地址存入0x1&#x27;</span>,<span class="string">&#x27;0xAA地址存入0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="symbol">DUP1</span>            stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span> <span class="number">0x1</span> <span class="number">0x1</span>]</span><br><span class="line"><span class="symbol">DUP3</span>            stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span> <span class="number">0x1</span> <span class="number">0x1</span> <span class="number">0x1</span>]</span><br><span class="line"><span class="keyword">ADD</span>             stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span> <span class="number">0x1</span> <span class="number">0x2</span>]</span><br><span class="line"><span class="symbol">DUP5</span>            stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span> <span class="number">0x1</span> <span class="number">0x2</span> <span class="number">0x0</span>]</span><br><span class="line"><span class="symbol">SSTORE</span>          stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span> <span class="number">0x1</span>] store&#123;<span class="string">&#x27;0x0地址存入0x2&#x27;</span>,<span class="string">&#x27;0xAA地址存入0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563&#x27;</span>&#125;</span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0xBB</span>      stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span> <span class="number">0x1</span> <span class="number">0xBB</span>]</span><br><span class="line"><span class="symbol">SWAP1</span>           stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span> <span class="number">0xBB</span> <span class="number">0x1</span>]</span><br><span class="line"><span class="symbol">DUP4</span>            stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span> <span class="number">0xBB</span> <span class="number">0x1</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span>]</span><br><span class="line"><span class="keyword">ADD</span>             stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span> <span class="number">0xBB</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E564</span>]</span><br><span class="line"><span class="symbol">SSTORE</span>          stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span>] store&#123;<span class="string">&#x27;0x0地址存入0x2&#x27;</span>,<span class="string">&#x27;0xAA地址存入0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563&#x27;</span>,<span class="string">&#x27;0xBB地址存入0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E564&#x27;</span>&#125;</span><br><span class="line"><span class="symbol">DUP3</span>            stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span> <span class="number">0x0</span>]</span><br><span class="line"><span class="symbol">SLOAD</span>           stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span> <span class="number">0x2</span>]</span><br><span class="line"><span class="symbol">SWAP1</span>           stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x2</span> <span class="number">0x1</span>]</span><br><span class="line"><span class="symbol">DUP2</span>            stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x2</span> <span class="number">0x1</span> <span class="number">0x2</span>]</span><br><span class="line"><span class="keyword">ADD</span>             stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x2</span> <span class="number">0x3</span>]</span><br><span class="line"><span class="symbol">SWAP1</span>           stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x3</span> <span class="number">0x2</span>]</span><br><span class="line"><span class="symbol">SWAP3</span>           stack[<span class="number">0x2</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x3</span> <span class="number">0x0</span>]</span><br><span class="line"><span class="symbol">SSTORE</span>          stack[<span class="number">0x2</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span>]  store&#123;<span class="string">&#x27;0x0地址存入0x3&#x27;</span>,<span class="string">&#x27;0xAA地址存入0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563&#x27;</span>,<span class="string">&#x27;0xBB地址存入0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E564&#x27;</span>&#125;</span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0xCC</span>      stack[<span class="number">0x2</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0xCC</span>]  store&#123;<span class="string">&#x27;0x0地址存入0x3&#x27;</span>,<span class="string">&#x27;0xAA地址存入0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563&#x27;</span>,<span class="string">&#x27;0xBB地址存入0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E564&#x27;</span>&#125;</span><br><span class="line"><span class="symbol">SWAP2</span>           stack[<span class="number">0xCC</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x2</span>]</span><br><span class="line"><span class="keyword">ADD</span>             stack[<span class="number">0xCC</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E565</span>]</span><br><span class="line"><span class="symbol">SSTORE</span>          stack[]  store&#123;<span class="string">&#x27;0x0地址存入0x3&#x27;</span>,<span class="string">&#x27;0xAA地址存入0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563&#x27;</span>,<span class="string">&#x27;0xBB地址存入0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E564&#x27;</span>,<span class="string">&#x27;0xCC地址存入0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E565&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>哈哈，是不是crazy？小编把每步执行后，栈stack、内存memory、存储器storage中数据状态记录下了。<br>
不想看上面代码的，小编直接来解释吧：</p>
<ol>
<li>内存memory没毛用，只是浪费gas。</li>
<li>总共执行了6次<code>SSTORE</code>指令，总共执行了3次<code>SLOAD</code>指令。小编按先后顺序解释下这几个命令具体干啥了
<ol>
<li>第1次执行<code>SLOAD</code><br>
去地址0x0读取当前数组长度，返回0</li>
<li>第1次执行<code>SSTORE</code><br>
在地址0x0记录当前数组长度为1</li>
<li>第2次执行<code>SSTORE</code><br>
在一个hash地址记录数据0xAA</li>
<li>第2次执行<code>SLOAD</code><br>
去地址0x0读取当前数组长度，返回1</li>
<li>第3次执行<code>SSTORE</code><br>
在地址0x0记录当前数组长度为2</li>
<li>第4次执行<code>SSTORE</code><br>
在一个hash地址记录数据0xBB</li>
<li>第3次执行<code>SLOAD</code><br>
去地址0x0读取当前数组长度，返回2</li>
<li>第5次执行<code>SSTORE</code><br>
在地址0x0记录当前数组长度为3</li>
<li>第6次执行<code>SSTORE</code><br>
在一个hash地址记录数据0xCC</li>
</ol>
</li>
</ol>
<p>看出来了吧，数组长度，每加入一个数据，则更新一次。两种数据都需要<code>sstore</code><br>
所以说，相比较于动态数组，反而映射更加节省gas。</p>
<h2 id="动态数组打包">动态数组打包</h2>
<p>这个小编就不详细讲了，前面<a href="/articles/4b0172c1"><code>《以太坊vm系列2-基础篇》</code></a>介绍了一些打包情况，<br>
简单说就是，Solidity尽量优先填充满一个32字节的槽，尽量减少sstore的使用。<br>
但是需要知道的是，由于数组需要进行边界检查和一些别的因素，动态数组中，每对一个数据存储，都需要执行一次<code>sstore</code>。就是说如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint128[] s;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">        s.<span class="property">length</span> = <span class="number">4</span>;  <span class="comment">//执行1次sstore，第1个槽</span></span><br><span class="line">        s[<span class="number">0</span>] = <span class="number">0xAA</span>;   <span class="comment">//执行2次sstore，第2个槽</span></span><br><span class="line">        s[<span class="number">1</span>] = <span class="number">0xBB</span>;   <span class="comment">//执行3次sstore，第2个槽</span></span><br><span class="line">        s[<span class="number">2</span>] = <span class="number">0xCC</span>;   <span class="comment">//执行4次sstore，第3个槽</span></span><br><span class="line">        s[<span class="number">3</span>] = <span class="number">0xDD</span>;   <span class="comment">//执行5次sstore，第3个槽</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，用了3个槽，执行了5次<code>sstore</code>。占用的槽少了，但sstore次数一点不会少。</p>
<h2 id="字节数组和字符串">字节数组和字符串</h2>
<p><code>bytes</code>和<code>string</code>是为字节和字符进行优化的特殊数组类型。如果数组的长度不大于31字节，第32个字节存储有效编码的长度（看了下面的实例就懂了）。长一点的字节数组跟正常数组的表示方式差不多。<br>
<code>string</code>和<code>bytes</code>的情况都一样，这里就只演示<code>bytes</code>了。<br>
字节数组赋值短的数据和长的数据，会有什么情况？一个个来试试</p>
<h3 id="字节数组赋值短数据">字节数组赋值短数据</h3>
<p>先看合约代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    bytes s;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) public &#123;</span><br><span class="line">        s.<span class="title function_">push</span>(<span class="number">0xAA</span>);</span><br><span class="line">        s.<span class="title function_">push</span>(<span class="number">0xBB</span>);</span><br><span class="line">        s.<span class="title function_">push</span>(<span class="number">0xCC</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化器编译后，指令就不展示了，一大坨。直接看看在数据在存储器中的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key:   0x0000000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">value: 0xaabbcc0000000000000000000000000000000000000000000000000000000006</span><br></pre></td></tr></table></figure>
<p><code>value</code>最后面的06表示的是存储器此处的编码长度，而s的真实长度(长度问题在下面总结中描述原因)是：<code>编码长度/2=3</code>。<br>
另外，也看出value中，数据是从左往右存储的。</p>
<h3 id="字节数组赋值长数据">字节数组赋值长数据</h3>
<p>先看合约代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    bytes s;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) public &#123;</span><br><span class="line">       s.<span class="property">length</span> = <span class="number">32</span> * <span class="number">4</span>;</span><br><span class="line">        s[<span class="number">31</span>] = <span class="number">0x1</span>;</span><br><span class="line">        s[<span class="number">63</span>] = <span class="number">0x2</span>;</span><br><span class="line">        s[<span class="number">95</span>] = <span class="number">0x3</span>;</span><br><span class="line">        s[<span class="number">127</span>] = <span class="number">0x4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接来看在存储器中是如何存储的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key:   0x0000000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">value: 0x0000000000000000000000000000000000000000000000000000000000000101</span><br><span class="line"></span><br><span class="line">key:   0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563</span><br><span class="line">value: 0x0000000000000000000000000000000000000000000000000000000000000001</span><br><span class="line"></span><br><span class="line">key:   0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564</span><br><span class="line">value: 0x0000000000000000000000000000000000000000000000000000000000000002</span><br><span class="line"></span><br><span class="line">key:   0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e565</span><br><span class="line">value: 0x0000000000000000000000000000000000000000000000000000000000000003</span><br><span class="line"></span><br><span class="line">key:   0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e566</span><br><span class="line">value: 0x0000000000000000000000000000000000000000000000000000000000000004</span><br></pre></td></tr></table></figure>
<p>可以看出，总共5个地址，也就是在四个槽里存了数据（一个key表示一个地址）：</p>
<ol>
<li>第1个0x0地址存储的是数据编码长度。数据的实际长度(长度问题在下面总结中描述原因)：<code>长度=（编码长度-1）/2</code>,也就是0x101 - 1）/2=128</li>
<li>第2到第5的4个槽，分别存放了数组里的四个数据</li>
<li>看key的 最后一位，这几个地址都是连续的</li>
</ol>
<h3 id="长字节短字节的总结">长字节短字节的总结</h3>
<ol>
<li>字节数组的汇编代码相当多。除了正常的边界检查和数组恢复大小等，它还需要对长度进行编码/解码，以及注意长字节数组和短字节数组之间的转换。</li>
<li><code>为什么要编码长度？</code><br>
因为编码之后，可以很容易的测试出来字节数组是长还是短。注意对于长数组而言编码长度总是奇数，而短数组的编码长度总是偶数。汇编代码只需要查看一下最后一位是否为0，为0就是偶数（短数组），非0就是奇数（长数组）。</li>
</ol>
<h2 id="总结">总结</h2>
<ol>
<li>相比较于动态数组，反而映射更加节省gas。</li>
<li>使用数组的复杂度超过了想象，</li>
<li>这一节，小编感觉已经很吃力了。。。</li>
<li>其实，走到这里，反而问题越来越多，为什么选择256？为什么这么复杂？越来越底层，小编感觉有点吃不消了，毕竟后面跟cpu等硬件兼容性考虑，实在不是小编的长项。只能点到为止了。小编也看了下qtum对evm的见解，想要理解到那种程度，还有好几个境界要走。</li>
</ol>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>EVM</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊vm系列3-固定长度数据类型的处理</title>
    <url>/articles/8ddcbc00/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>本文主要是讲Solidity以及EVM对数组、结构体等复杂的数据类型的处理方式，了解了这些基本情况，对我们编写经济的合约或者设计新的vm，都有极大的帮助。</p>
<span id="more"></span>
<p>本文参考的是Howard，是量子链的大神的文章，末尾处有文章出处，根据小编的理解，做了大量的调整和补充。<br>
指令集可参考：<a href="/articles/715e1612">以太坊vm系列1-指令集汇总</a>，里面有详细的汇总和解释<br>
另外，本文所有合约都是在Remix上编译的</p>
<h2 id="sload和store指令的一些整理">SLOAD和STORE指令的一些整理</h2>
<p>通过前一篇文章<a href="/articles/4b0172c1"><code>《以太坊vm系列2-基础篇》</code></a>我们了解到：</p>
<ol>
<li>合约的数据，在EVM中，是使用一个个的32字节的槽器来存储的</li>
<li>SSTORE和SLOAD指令消耗的手续费是普通指令的很多倍，并且在合约整个过程中，基本都是这两条指令来主导。</li>
</ol>
<p>结合前面，再做一些新的补充：</p>
<ol>
<li>合约中，声明变量时候，并没有在存储器中开辟空间，只是依次给出对应在存储器上的位置，不收手续费。只有真正往对应地址赋值的时候，才会计算手续费。</li>
<li><code>SLOAD</code>指令读取某个地址上的数据，若该地址没有被初始化（也就是未赋值或使用），则返回0x0</li>
<li>Solidity并没有非常智能，即使某个地址没有赋值，它也会去<code>SLOAD</code>来获取0x0，花费了gas。汇编角度看，完全可以直接用0x0取代此时<code>SLOAD</code>所扮演的角色。</li>
<li><code>若数据类型为uint256，即使存入的只是个位数的值，编译器也会为每个数据存入各自一个槽。</code></li>
</ol>
<h2 id="结构体的存储">结构体的存储</h2>
<p>含有结构体的合约代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    struct <span class="title class_">Tuple</span> &#123;</span><br><span class="line">      uint256 a;</span><br><span class="line">      uint256 b;</span><br><span class="line">      uint256 c;</span><br><span class="line">      uint256 d;</span><br><span class="line">      uint256 e;</span><br><span class="line">      uint256 f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Tuple</span> t;</span><br><span class="line">    <span class="title function_">constructor</span> () public&#123;</span><br><span class="line">      t.<span class="property">f</span> = <span class="number">0xC0FEFE</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先说一下这些变量在存储器槽的存储方式：t.a存在0x0位置、t.b存在0x01位置、t.c存在0x2位置。。。<br>
编译，使用<code>optimize</code>设置</p>
<p>看看相应的字节码：<code>62c0fefe600555</code><br>
再看看汇编指令：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">PUSH3</span> <span class="number">0xC0FEFE</span>  <span class="comment">//62 c0fefe，将0xC0FEFE压入栈，此时栈中数据stack[c0x0fefe]</span></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x5</span>       <span class="comment">//60 0x5，   将0x5压入栈，此时栈中数据stack[0xc0fefe 0x5]</span></span><br><span class="line"><span class="symbol">SSTORE</span>          <span class="comment">//55，       两数出栈，将0xc0fefe存储0x5地址之中</span></span><br></pre></td></tr></table></figure>
<p>从中我们可以看出，合约结构体中其余声明的变量，并没有被写入到存储器中，也就是说，只有<code>t.f</code>才会收取手续费</p>
<h2 id="固定长度数组">固定长度数组</h2>
<p>含有固定长度数组的合约代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    uint256[<span class="number">6</span>] numbers;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) public&#123;</span><br><span class="line">      numbers[<span class="number">5</span>] = <span class="number">0xC0FEFE</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译，使用<code>optimize</code>设置。</p>
<p>看看相应的字节码：<code>62c0fefe600555</code><br>
再看看汇编指令：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">PUSH3</span> <span class="number">0xC0FEFE</span>  <span class="comment">//62 c0fefe，将0xC0FEFE压入栈，此时栈中数据stack[c0x0fefe]</span></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x5</span>       <span class="comment">//60 0x5，   将0x5压入栈，此时栈中数据stack[0xc0fefe 0x5]</span></span><br><span class="line"><span class="symbol">SSTORE</span>          <span class="comment">//55，       两数出栈，将0xc0fefe存储0x5地址之中</span></span><br></pre></td></tr></table></figure>
<p>哈哈，和上面结构体的汇编是一模一样。</p>
<h2 id="数组边界检查">数组边界检查</h2>
<p>上面我们看到结构体和数组存储布局以及指令都是一样的，但是如果我们编译时候去掉<code>optimize</code>配置，两者指令差距是蛮大的。<br>
在数组中，Solidity会进行数组边界检查<br>
先看看相应的字节码：<code>62c0fefe60006005600681101515602357fe5b0181905550</code><br>
再看看汇编指令：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">PUSH3</span> <span class="number">0xC0FEFE</span>  <span class="comment">//62 c0fefe，将0xC0FEFE压入栈，此时栈中数据stack[c0x0fefe]</span></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x0</span>       <span class="comment">//60 0x0， 将0x0压入栈，此时栈中数据stack[c0x0fefe 0x0]</span></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x5</span>       <span class="comment">//60 0x5， 将0x5压入栈，此时栈中数据stack[c0x0fefe 0x0 0x5]</span></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x6</span>       <span class="comment">//60 0x6， 将0x6压入栈，此时栈中数据stack[c0x0fefe 0x0 0x5 0x6]</span></span><br><span class="line"><span class="symbol">DUP2</span>            <span class="comment">//81，     从栈顶起，将栈中第2个元素复制并加入栈顶。此时栈中数据stack[c0x0fefe 0x0 0x5 0x6 0x5]</span></span><br><span class="line"><span class="symbol">LT</span>              <span class="comment">//10，     栈中pop出栈顶元素x，与栈中新的栈顶元素y比较，栈顶修改为新的运算结果（x&lt;y，则y=1否则y=0）。此时栈中数据stack[c0x0fefe 0x0 0x5 1]</span></span><br><span class="line"><span class="symbol">ISZERO</span>          <span class="comment">//15，     判断栈顶元素若大于0，则栈顶元素改为0，否则改为1。此时栈中数据stack[c0x0fefe 0x0 0x5 0]</span></span><br><span class="line"><span class="symbol">ISZERO</span>          <span class="comment">//15，     判断栈顶元素若大于0，则栈顶元素改为0，否则改为1。此时栈中数据stack[c0x0fefe 0x0 0x5 1]</span></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x23</span>      <span class="comment">//60 0x23，将0x23压入栈，此时栈中数据stack[c0x0fefe 0x0 0x5 1 23]</span></span><br><span class="line"><span class="symbol">JUMPI</span>           <span class="comment">//57，     栈中先后pop出两个值x,y，x表示跳转到第几个JUMPDEST，而y表示一个标记（若为0，则跳到下一个JUMPDEST）,若y不为0，则由x决定跳到第几个。此时栈中数据stack[c0x0fefe 0x0 0x5] </span></span><br><span class="line"><span class="symbol">INVALID</span>         <span class="comment">//无，      程序停止执行</span></span><br><span class="line"><span class="symbol">JUMPDEST</span>        <span class="comment">//5b，     JUMPI可跳到此处，继续执行后面的命令。此时栈中数据stack[c0x0fefe 0x0 0x5]</span></span><br><span class="line"><span class="keyword">ADD</span>             <span class="comment">//01，     stack[c0x0fefe 0x5]</span></span><br><span class="line"><span class="symbol">DUP2</span>            <span class="comment">//81，     stack[c0x0fefe 0x5 c0x0fefe]</span></span><br><span class="line"><span class="symbol">SWAP1</span>           <span class="comment">//90，     stack[c0x0fefe c0x0fefe 0x5]</span></span><br><span class="line"><span class="symbol">SSTORE</span>          <span class="comment">//55，     栈顶推出两位，将数值c0x0fefe存储在存储器的0x5的位置上。此时栈中数据stack[c0x0fefe],存储器数据store&#123;`c0x0fefe数值存在0x5地址`&#125;</span></span><br><span class="line"><span class="keyword">POP</span>             <span class="comment">//50，     丢弃栈顶数据。此时栈中数据stack[]，存储器数据store&#123;`c0x0fefe数值存在0x5地址`&#125;</span></span><br></pre></td></tr></table></figure>
<p>从中可以看出，汇编中做了很多的判断，确保数据没有越界，若越界，程序则会退出。<code>JUMPI</code>和<code>JUMPDEST</code>作用小编是大概猜的，问题应该不大，等后面看了源码再来修改。<br>
不过，明显感觉到编译器处理的优点啰嗦，也就是手Solidity还是有待提高的。</p>
<h2 id="打包行为">打包行为</h2>
<p>上一篇文章：<a href="/articles/4b0172c1"><code>《以太坊vm系列2-基础篇》</code></a>中，对这一部分已经做了很详细的解释，很多位操作的技巧，终归一句话，Solidity编译器使用优化器（<code>optimize</code>）尽可能的将两个小规模的数打包到一个32字节的槽中，以便减少燃料费的使用。</p>
<h2 id="干扰优化器-optimize">干扰优化器（<code>optimize</code>）</h2>
<p>这次干扰的做法是，我们将变量放在不同的方法下赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract <span class="title class_">Test</span> &#123;</span><br><span class="line">    uint64 a;</span><br><span class="line">    uint64 b;</span><br><span class="line">    uint64 c;</span><br><span class="line">    uint64 d;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) public &#123;</span><br><span class="line">      <span class="title function_">setAB</span>();</span><br><span class="line">      <span class="title function_">setCD</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">setAB</span>(<span class="params"></span>) internal &#123;</span><br><span class="line">      a = <span class="number">0xaaaa</span>;</span><br><span class="line">      b = <span class="number">0xbbbb</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">setCD</span>(<span class="params"></span>) internal &#123;</span><br><span class="line">      c = <span class="number">0xcccc</span>;</span><br><span class="line">      d = <span class="number">0xdddd</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>optimize</code>优化编译，生成的关键<code>armasm</code>汇编指令如下：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">tag1:</span>                                            <span class="comment">//结构体</span></span><br><span class="line">  JUMP [in]  setAB()                             <span class="comment">//跳转到tag5的setAB()方法</span></span><br><span class="line"><span class="symbol">tag4:</span></span><br><span class="line">  JUMP [in]  setCD()</span><br><span class="line"><span class="symbol">tag5:</span>                                            <span class="comment">//跳转到tag7的setAB()方法</span></span><br><span class="line">  JUMPDEST   <span class="meta">function</span> setAB() internal &#123;\n ...</span><br><span class="line">  ...                                            <span class="comment">//处理A，B</span></span><br><span class="line">  SSTORE                                         <span class="comment">//将A，B保存在本地</span></span><br><span class="line">  JUMP [out]                                     <span class="comment">//跳回到调用A，B的地方</span></span><br><span class="line"><span class="symbol">tag7:</span>                                            <span class="comment">//setCD()函数</span></span><br><span class="line">  JUMPDEST   <span class="meta">function</span> setCD() internal &#123;\n ...   </span><br><span class="line">  ...                                            <span class="comment">//保存C，D</span></span><br><span class="line">  SSTORE                                         <span class="comment">//将C，D保存在本地</span></span><br><span class="line">  JUMP [out]                                     <span class="comment">//跳回到调用C，D的地方</span></span><br></pre></td></tr></table></figure>
<p><code>ps：每个tag代表一个不同的模块</code><br>
指令非常的长，小编只列出一些。这里我们主要能看到里面有两个<code>sstore</code>就行。<br>
要知道，正常的优化中4个变量a、b、c、d加起来总共是32个字节，根据我们对<a href="/articles/4b0172c1"><code>《以太坊vm系列2-基础篇》</code></a>中<code>打包</code>的理解，应该是一次性写入存储器中的，也就是只调用一次<code>sstore</code>。<br>
但是，这里<code>sstroe</code>却调用了两次。也就是说说，Solidity目前并不能优化垮方法的变量。</p>
<p>也就是说，为了减少<code>sstore</code>方法的调用，降低成本，我们目前最合适的做法就是将变量的赋值都写在同一个方法中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = <span class="number">0xaaaa</span>;</span><br><span class="line">b = <span class="number">0xbbbb</span>;</span><br><span class="line">c = <span class="number">0xcccc</span>;</span><br><span class="line">d = <span class="number">0xdddd</span>;</span><br></pre></td></tr></table></figure>
<h2 id="再次干扰优化器-optimize">再次干扰优化器（<code>optimize</code>）</h2>
<p>这次的干扰我们的做法是，为定长数组中的每个变量赋值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint64[<span class="number">4</span>] numbers;</span><br><span class="line">    <span class="title function_">constructor</span> () public &#123;</span><br><span class="line">      numbers[<span class="number">0</span>] = <span class="number">0x0</span>;</span><br><span class="line">      numbers[<span class="number">1</span>] = <span class="number">0x1111</span>;</span><br><span class="line">      numbers[<span class="number">2</span>] = <span class="number">0x2222</span>;</span><br><span class="line">      numbers[<span class="number">3</span>] = <span class="number">0x3333</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>optimize</code>优化编译，生成的关键<code>armasm</code>汇编指令如下：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">...</span></span><br><span class="line"><span class="symbol">SSTORE</span>      <span class="comment">//保存数组到存储器</span></span><br><span class="line"><span class="symbol">...</span></span><br></pre></td></tr></table></figure>
<p>ok，这里出现意外了，只调用了一次<code>SSTORE</code>。小编是参考的<a href="https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7">Howard原文</a>，可能是Solidity的优化器升级的缘故，其中提到的调用4次<code>sstore</code>的情况并没有发生。<br>
这次干扰在此算是被优化器抵御了。<br>
好吧，这是一件好事，说明Solidity也在不断进步。也不影响我们继续探索，这里我们去掉<code>optimize</code>优化，重新编译下代码，再来看指令：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">SLOAD</span></span><br><span class="line"><span class="symbol">SSTORE</span>      <span class="comment">//保存numbers[0]到存储器</span></span><br><span class="line"><span class="symbol">SLOAD</span></span><br><span class="line"><span class="symbol">SSTORE</span>      <span class="comment">//保存numbers[1]到存储器</span></span><br><span class="line"><span class="symbol">SLOAD</span></span><br><span class="line"><span class="symbol">SSTORE</span>      <span class="comment">//保存numbers[2]到存储器</span></span><br><span class="line"><span class="symbol">SLOAD</span></span><br><span class="line"><span class="symbol">SSTORE</span>      <span class="comment">//保存numbers[3]到存储器</span></span><br></pre></td></tr></table></figure>
<p>呵呵，看出来了吧，优化和不优化，手续费差异蛮大的。</p>
<h2 id="总结">总结</h2>
<ol>
<li>Solidity会尽可能的打包将数据存在一个32字节的槽中</li>
<li>Solidity不能对跨方法对赋值进行优化。</li>
<li>相信Solidity会越走越好。</li>
</ol>
<blockquote>
<p>量子链-Howard英文原文：<a href="https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7">https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7</a><br>
xuli中文翻译：<a href="https://lilymoana.github.io/evm_part2.html">https://lilymoana.github.io/evm_part2.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>EVM</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊vm系列2-基础篇</title>
    <url>/articles/4b0172c1/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>vm这东西，要想自己搞任何链，这都是绕不开的一道坎。<br>
对于写智能合约也一样很重要，要知道自己写下的每一个字符都是真金白银，合理的规划，会让你极大的减少不必要的开支。</p>
<span id="more"></span>
<p>原本想根据黄皮书来逐步了解vm的理念，时间和精力有限，打算结合一些现有的网络资料，编辑整理出自己对vm的理解。Howard是量子链的大神，有幸在以太坊线下沙龙中听了他的演讲，一个字：非常强。回来翻了下他的相关文章，发现他有很完整的以太坊vm讲解的文章，都是英文^^。。。<br>
小编准备结合他的文章来以自己的方式了解到底vm是怎样运行的。</p>
<h2 id="概述">概述</h2>
<p>一个合约写出来，传到vm后是如何处理的？燃料手续费是怎么样一个逻辑？为什么任意别的语言也可以开发合约？想要开发自己的公链，别的模块怎么和vm对接？等等。。。<br>
带着种种问题，我们没有理由不去了解vm到底是怎么一回事。<br>
好，我们一步步的来揭开这层神秘的面纱</p>
<h2 id="解析只有一个变量的合约">解析只有一个变量的合约</h2>
<p>solidity编写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256 a;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) public &#123;</span><br><span class="line">      a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Remix编译（不要说不知道这是什么工具。。。）该合约，<br>
我们获取了EVM字节码：<br>
上面整个合约编辑后的字节码，16进制表示，evm中就是以这个来运行的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6080604052348015600f57600080fd5b50600160008190555060358060256000396000f3006080604052600080fd00a165627a7a72305820c2f00be46981ed7116a7d8162fd0cb5c04c4571aa49f5fccbea4b90a5fe8f9290029</span><br></pre></td></tr></table></figure>
<p>·······································<br>
<code>2019-01-17 ps:</code><br>
这部分内容可以不看，只是半年后的不同状况的补充，建议等了解本文全局后在看此处<br>
新版本solidity编译后的字节码结果不太一样，可能对细节做了优化，先记录下来<br>
6080604052348015600f57600080fd5b50600160005560358060226000396000f3006080604052600080fd00a165627a7a723058201504b6af3b58ab847e989f2345b4448a1d53d6107652ed711770c90cdb7d60890029<br>
此时的<code>a=1</code>的字节码为：<code>6001600055</code>，指令优化，比原先减少了一半，此时指令为：<br>
60 01<br>
60 00<br>
55<br>
简洁明了，出栈后，直接把01存储在00位置，比原先简单多了<br>
········································</p>
<p>上面的一坨信息，看的就头大，但不要急，我们先从合约中的简单的存储变量赋值来入手：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>这个过程的字节码是：<code>6001600081905550</code>（先不用考虑怎么得来的），我们通过查看<a href="/articles/715e1612">以太坊vm系列1-指令集汇总</a>，把它拆成一行一条指令</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="number">60</span> <span class="number">01</span> <span class="comment">//60是PUSH1指令，因此后面要跟另一个16进制数</span></span><br><span class="line"><span class="number">60</span> <span class="number">00</span> <span class="comment">//同理</span></span><br><span class="line"><span class="number">81</span></span><br><span class="line"><span class="number">90</span></span><br><span class="line"><span class="number">55</span></span><br><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure>
<p>为了更清晰的了解上面的内容，我们用<a href="/articles/715e1612">以太坊vm系列1-指令集汇总</a>中查出的结果重新描述一下汇编代码：<br>
<code>stack[]表示栈，store&#123;&#125;表示存储器</code>(后续均使用此表示)</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">PUSH1</span> <span class="number">01</span>  <span class="comment">//60 0x1，该过程可以用0x1表示,它是push(0x1)的速记。这条指令将数值1压入栈中。此时栈中数据stack[0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">00</span>  <span class="comment">//60 0x0，该过程可以用0x0表示,它是push(0x0)的速记。这条指令将数值0压入栈中。此时栈中数据stack[0x1 0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">DUP2</span>      <span class="comment">//81    ，从栈顶起，将栈中第2个元素复制并加入栈顶。此时栈中数据stack[0x1 0x0 0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">SWAP1</span>     <span class="comment">//90    ，从栈顶起，将前两个数据交换。此时栈中数据stack[0x1 0x1 0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">SSTORE</span>    <span class="comment">//55    ，栈顶推出两位，将数值0x01存储在存储器的0x0的位置上。此时栈中数据stack[0x1],存储器数据store&#123;`0x1数值存在0x0地址`&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">POP</span>       <span class="comment">//50    ，丢弃栈顶数据。此时栈中数据stack[],存储器数据store&#123;`0x1数值存在0x0地址`&#125;</span></span><br></pre></td></tr></table></figure>
<p>从上面分析中可知：Solidity是将<code>uint256 a</code>保存在<code>0x0</code>的位置上。</p>
<p>仔细观察，会发现<code>DUP2</code>、<code>SWAP1</code>	、<code>POP</code>命令都是多余的，去掉后，会更清晰，并且运行结果也一样：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">PUSH1</span> <span class="number">01</span>  <span class="comment">//60 0x1，该过程可以用0x1表示,它是push(0x1)的速记。这条指令将数值1压入栈中。此时栈中数据stack[0x1]</span></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">00</span>  <span class="comment">//60 0x0，该过程可以用0x0表示,它是push(0x0)的速记。这条指令将数值0压入栈中。此时栈中数据stack[0x1，0x0]</span></span><br><span class="line"><span class="symbol">SSTORE</span>    <span class="comment">//55    ，将数值0x01存储在存储器的0x0的位置上，此时会消耗掉栈顶的两项数据。此时栈中数据stack[0x1],存储器数据store&#123;`0x1数值存在0x0地址`&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="解析有两个变量的合约">解析有两个变量的合约</h2>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256 a;</span><br><span class="line">    uint256 b;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) public &#123;</span><br><span class="line">      a = <span class="number">1</span>;</span><br><span class="line">      b = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后，<code>b=2</code>的过程的EVM字节码（a=1前面已解析）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6002600181905550</span><br></pre></td></tr></table></figure>
<p>对应的汇编指令：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x2</span>  <span class="comment">//60 0x2，该过程可以用0x2表示,它是push(0x2)的速记。这条指令将数值2压入栈中。此时栈中数据stack[0x2]</span></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x1</span>  <span class="comment">//60 0x1，该过程可以用0x1表示,它是push(0x1)的速记。这条指令将数值2压入栈中。此时栈中数据stack[0x2 0x1]</span></span><br><span class="line"><span class="symbol">DUP2</span>       <span class="comment">//81，   从栈顶起，将栈中第2个元素复制并加入栈顶。此时栈中数据stack[0x2 0x1 0x2]</span></span><br><span class="line"><span class="symbol">SWAP1</span>      <span class="comment">//90，   从栈顶起，将前两个数据交换。此时栈中数据stack[0x2 0x2 0x1]</span></span><br><span class="line"><span class="symbol">SSTORE</span>     <span class="comment">//55，   将数值0x02存储在存储器的0x1的位置上，此时会消耗掉栈顶的两项数据。此时栈中数据stack[0x2],存储器数据store&#123;`0x02数值存在0x1地址`&#125;</span></span><br><span class="line"><span class="keyword">POP</span>        <span class="comment">//50，   丢弃栈顶数据。此时栈中数据stack[],存储器数据store&#123;`0x1数值存在0x0地址`,`0x2数值存在0x1地址`&#125;</span></span><br></pre></td></tr></table></figure>
<p>可知，最终：<br>
store{<code>0x1数值存在0x0地址</code>,<code>0x2数值存在0x1地址</code>}，也就是说a存在0x0地址，b存在0x1地址</p>
<h2 id="存储打包-合约初步优化">存储打包（合约初步优化）</h2>
<p>上面案例中，我们将每个数据都保存在了一个地址，其实每个地址可以看作是一个槽，一个槽可以放下32字节的。要是每个16字节的变量分别都放在32字节的不同槽中，会很浪费空间的，并且存储在不同的槽每次都需要很高的手续费，要知道手续费可不是闹着玩的。<br>
Solidity提供的优化方案：尽量将小一点的两个数据打包并存储在同一个槽中。<br>
把合约改为如下样子，a和b都使用uint128，也就是16个字节：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint128 a;</span><br><span class="line">    uint128 b;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) public &#123;</span><br><span class="line">      a = <span class="number">1</span>;</span><br><span class="line">      b = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后，<code>a=1;b=2;</code>对应EVM字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">60016000806101000a8154816fffffffffffffffffffffffffffffffff02191690836fffffffffffffffffffffffffffffffff1602179055506002600060106101000a8154816fffffffffffffffffffffffffffffffff02191690836fffffffffffffffffffffffffffffffff160217905550</span><br></pre></td></tr></table></figure>
<p>对应汇编指令：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">a<span class="number">=1</span>:</span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x1</span>                                 <span class="comment">//60 0x1，    该过程可以用0x1表示,它是push(0x1)的速记。这条指令将数值1压入栈中。此时栈中数据stack[0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x0</span>                                 <span class="comment">//60 0x0，    该过程可以用0x0表示,它是push(0x0)的速记。这条指令将数值0压入栈中。此时栈中数据stack[0x1 0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">DUP1</span>                                      <span class="comment">//80，        从栈顶起，将栈中第1个元素复制并加入栈顶。此时栈中数据stack[0x1 0x0 0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH2</span> <span class="number">0x100</span>                               <span class="comment">//61 0x100    占用2个字节，将值256压入栈。此时栈中数据stack[0x1 0x0 0x0 0x100]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">EXP</span>                                       <span class="comment">//0a          从栈顶起，依次取出2个元素，第一个元素为底数，第二个元素为指数，计算出结果为1，然后1字节存储到栈中。此时栈中数据stack[0x1 0x0 0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">DUP2</span>                                      <span class="comment">//81          从栈顶起，将栈中第2个元素复制并加入栈顶。此时栈中数据stack[0x1 0x0 0x1 0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">SLOAD</span>                                     <span class="comment">//54          取出栈顶元素，转为hash长度（表示在db中的地址），在db中是否存在对应值,并读取出,此处db中不存在对应数据，返回0x0，push到栈中。此时栈中数据stack[0x1 0x0 0x1 0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">DUP2</span>                                      <span class="comment">//81          从栈顶起，将栈中第2个元素复制并加入栈顶。此时栈中数据stack[0x1 0x0 0x1 0x0 0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH16</span> <span class="number">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span> <span class="comment">//6f 0xFF...  将16字节值0xFF...推入栈中。此时栈中数据stack[0x1 0x0 0x1 0x0 0x1 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MUL</span>                                       <span class="comment">//02          栈中两个元素相乘，结果存入栈中。此时栈中数据stack[0x1 0x0 0x1 0x0 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">NOT</span>                                       <span class="comment">//19          栈顶数据取反，但实际运算还需要转为补码。此时栈中数据stack[0x1 0x0 0x1 0x0 0XFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">AND</span>                                       <span class="comment">//16          栈中取出前两个数据进行与运算，结果推入栈。此时栈中数据stack[0x1 0x0 0x1 0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">SWAP1</span>                                     <span class="comment">//90          从栈顶起，将前两个数据交换。此时栈中数据stack[0x1 0x0 0x0 0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">DUP4</span>                                      <span class="comment">//83          从栈顶起，将栈中第4个元素复制并加入栈顶。此时栈中数据stack[0x1 0x0 0x0 0x1 0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH16</span> <span class="number">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span> <span class="comment">//6f 0xFF...  将16字节值0xFF...推入栈中。此时栈中数据stack[0x1 0x0 0x0 0x1 0x1 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">AND</span>                                       <span class="comment">//16          栈中取出前两个数据进行与运算，结果推入栈。此时栈中数据stack[0x1 0x0 0x0 0x1 0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MUL</span>                                       <span class="comment">//02          栈中两个元素相乘，结果存入栈中。此时栈中数据stack[0x1 0x0 0x0 0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">OR</span>                                        <span class="comment">//17          栈中pop出栈顶元素，与栈中新的栈顶元素或运算，栈顶修改为新的运算结果。此时栈中数据stack[0x1 0x0 0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">SWAP1</span>                                     <span class="comment">//90          从栈顶起，将前两个数据交换。此时栈中数据stack[0x1 0x1 0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">SSTORE</span>                                    <span class="comment">//55          栈顶开始，前两项。将数据0x1保存在0x0地址,此时store&#123;`0x1数值存在0x0地址`&#125;。此时栈中数据stack[0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">POP</span>                                       <span class="comment">//50          栈中数据推出。此时栈中数据stack[]。</span></span><br><span class="line"></span><br><span class="line">b<span class="number">=2</span>:</span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x2</span>                                 <span class="comment">//60 0x2，     该过程可以用0x2表示,它是push(0x2)的速记。这条指令将数值1压入栈中。此时栈中数据stack[0x2]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x0</span>                                 <span class="comment">//60 0x0，     该过程可以用0x0表示,它是push(0x0)的速记。这条指令将数值0压入栈中。此时栈中数据stack[0x2,0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x10</span>                                <span class="comment">//60 0x10，    将数值0x10压入栈中。此时栈中数据stack[0x2,0x0,0x10]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH2</span> <span class="number">0x100</span>                               <span class="comment">//60 0x100，   将数值0x100压入栈中。此时栈中数据stack[0x2,0x0,0x10,0x100]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">EXP</span>                                       <span class="comment">//0a           从栈顶起，依次取出2个元素，第一个元素为底数，第二个元素为指数，计算结果进栈。此时栈中数据stack[0x2,0x0,0x100000000000000000000000000000000]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">DUP2</span>                                      <span class="comment">//81           从栈顶起，将栈中第2个元素复制并加入栈顶。此时栈中数据stack[0x2,0x0,0x100000000000000000000000000000000,0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">SLOAD</span>                                     <span class="comment">//54           取出栈顶元素，转为hash长度（表示在db中的地址），在db中读取出对应值为1，将其压入栈中。此时栈中数据stack[0x2,0x0,0x100000000000000000000000000000000,0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">DUP2</span>                                      <span class="comment">//81           从栈顶起，将栈中第2个元素复制并加入栈顶。此时栈中数据stack[0x2,0x0,0x100000000000000000000000000000000,0x1,0x100000000000000000000000000000000]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH16</span> <span class="number">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span> <span class="comment">//6f 0xFF...   将16字节值0xFF...推入栈中。此时栈中数据stack[0x2,0x0,0x100000000000000000000000000000000,0x1,0x100000000000000000000000000000000,0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MUL</span>                                       <span class="comment">//02           栈中两个元素相乘，结果存入栈中。此时栈中数据stack[0x2,0x0,0x100000000000000000000000000000000,0x1,0XFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">NOT</span>                                       <span class="comment">//19           栈顶数据取反，但实际运算还需要转为补码。此时栈中数据stack[0x2,0x0,0x100000000000000000000000000000000,0x1,0XFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">AND</span>                                       <span class="comment">//16           栈中取出前两个数据进行与运算，结果推入栈。此时栈中数据stack[0x2,0x0,0x100000000000000000000000000000000,0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">SWAP1</span>                                     <span class="comment">//90           从栈顶起，将前两个数据交换。此时栈中数据stack[0x2,0x0,0x1,0x100000000000000000000000000000000]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">DUP4</span>                                      <span class="comment">//83           从栈顶起，将栈中第4个元素复制并加入栈顶。此时栈中数据stack[0x2,0x0,0x1,0x100000000000000000000000000000000,0x2]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH16</span> <span class="number">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span> <span class="comment">//6f 0xFF...   将16字节值0xFF...推入栈中。此时栈中数据stack[0x2,0x0,0x1,0x100000000000000000000000000000000,0x2,0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">AND</span>                                       <span class="comment">//16           栈中取出前两个数据进行与运算，结果推入栈。此时栈中数据stack[0x2,0x0,0x1,0x100000000000000000000000000000000,0x2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MUL</span>                                       <span class="comment">//02           栈中两个元素相乘，结果存入栈中。此时栈中数据stack[0x2,0x0,0x1,0x200000000000000000000000000000000]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">OR</span>                                        <span class="comment">//17           栈中pop出栈顶元素，与栈中新的栈顶元素或运算，栈顶修改为新的运算结果。此时栈中数据stack[0x2,0x0,0x200000000000000000000000000000000]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">SWAP1</span>                                     <span class="comment">//90           从栈顶起，将前两个数据交换。此时栈中数据stack[0x2,0x200000000000000000000000000000000,0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">SSTORE</span>                                    <span class="comment">//55           栈顶开始，前两项。将数据0x200000000000000000000000000000000保存在0x0地址,此时store&#123;`0x200000000000000000000000000000000数值存在0x0地址`,`0x1数值存在0x0地址`&#125;。此时栈中数据stack[0x2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">POP</span>                                       <span class="comment">//50           栈中数据推出。此时栈中数据stack[]。</span></span><br></pre></td></tr></table></figure>
<p>一路把这些蛋疼的指令整理后，会发现<code>a=1</code>和<code>b=2</code>都存在了同一个地址，完整的存储形式是这样子：<code>[0x0000000000000000000000000000000200000000000000000000000000000001]</code>,低16个字节存1，高16个字节存2，倒数第二行的<code>SSTORE</code>的指令应该是进行了或操作。<br>
指令分析完了，有什么用呢？先看看各指令手续费情况：</p>
<ol>
<li><code>sstore</code>指令第一次写入一个新位置需要花费20000 gas</li>
<li><code>sstore</code>指令后续写入一个已存在的位置需要花费5000 gas</li>
<li><code>sload</code>指令的成本是200 gas</li>
<li><code>其余</code>大多数的指令成本是3～10 gas</li>
</ol>
<p>知道手续费成本后，我们就明白，将两个变量写入同一个槽中，按照上面指令：<code>sstore</code>指令使用2次，费用25000gas；<code>sload</code>指令使用2次，费用1000gas；整体大概用了26000的gas。这比分别写在不同槽中，节省了将近15000gas。<br>
这里不知道大家是否发现，<code>SLOAD</code>命令，我们明明知道这个0x0地址没有值，结果肯定是值0x0，却还要用指令去读取，无辜花费了手续费,这是Solidity语言的不足之处。此处若直接用值0x0替代<code>SLOAD</code>，将会剩下不少手续费，期待后面Solidity语言的优化吧。</p>
<h2 id="合约进一步优化">合约进一步优化</h2>
<p>从上面的指令中进一步研究发现，如果能将<code>a=1</code>和<code>b=2</code>这两个128位的数只调用一次<code>sstroe</code>存储指令就将其存储，还可以再节省5000gas。<br>
Solidity中提供了这样一个方式来实现此目的，即在编译命令中加入<code>--optimize</code>，如：<code>solc --bin --asm --optimize test.sol</code>。<br>
小编使用的是<code>Remix</code>，如下图操作选中<code>optimize</code>即可:</p>
<img src="/articles/4b0172c1/1.png" class="" title="Remix启用optimize">
<p>（合约源码紧接上一部分的）编译后，<code>a=1;b=2;</code>对应EVM字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">600080547002000000000000000000000000000000006001608060020a03199091166001176001608060020a0316179055</span><br></pre></td></tr></table></figure>
<p>对应汇编指令：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x0</span>                                   <span class="comment">//60 0x0，      该过程可以用0x0表示,它是push(0x0)的速记。这条指令将数值0压入栈中。此时栈中数据stack[0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">DUP1</span>                                        <span class="comment">//80，          从栈顶起，将栈中第1个元素复制并加入栈顶。此时栈中数据stack[0x0 0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">SLOAD</span>                                       <span class="comment">//54，          取出栈顶元素，转为hash长度（表示在db中的地址），在db中是否存在对应值,并读取出,此处db中不存在对应数据，返回0x0，push到栈中。此时栈中数据stack[0x0 0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH17</span> <span class="number">0x200000000000000000000000000000000</span>  <span class="comment">//70 0x200...， 将17字节值0x200...推入栈中。此时栈中数据stack[0x0 0x0 0x200000000000000000000000000000000]        </span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x1</span>                                   <span class="comment">//60 0x1，      将值0x1压入栈。此时栈中数据stack[0x0 0x0 0x200000000000000000000000000000000 0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x80</span>                                  <span class="comment">//60 80，       将值0x80压入栈。此时栈中数据stack[0x0 0x0 0x200000000000000000000000000000000 0x1 0x80]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x2</span>                                   <span class="comment">//60 0x2，      将值0x2压入栈。此时栈中数据stack[0x0 0x0 0x200000000000000000000000000000000 0x1 0x80 0x2]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">EXP</span>                                         <span class="comment">//0a，          从栈顶起，依次取出2个元素，第一个元素为底数，第二个元素为指数，计算结果进栈。此时栈中数据stack[0x0 0x0 0x200000000000000000000000000000000 0x1 0x100000000000000000000000000000000]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SUB</span>                                         <span class="comment">//03，          栈中推出栈顶元素，减去新的栈顶元素，栈顶修改为新的运算结果。此时栈中数据stack[0x0 0x0 0x200000000000000000000000000000000 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">NOT</span>                                         <span class="comment">//19，          栈顶数据取反，但实际运算还需要转为补码。此时栈中数据stack[0x0 0x0  0x200000000000000000000000000000000 0XFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">SWAP1</span>                                       <span class="comment">//90，          从栈顶起，将前两个数据交换。此时栈中数据stack[0x0 0x0 0XFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000 0x200000000000000000000000000000000]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">SWAP2</span>                                       <span class="comment">//91，          栈顶元素和它下面的第2项进行交换，此时栈中数据stack[0x0 0x200000000000000000000000000000000 0XFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000 0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">AND</span>                                         <span class="comment">//16，          栈中取出前两个数据进行与运算，结果推入栈。此时栈中数据stack[0x0 0x200000000000000000000000000000000 0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x1</span>                                   <span class="comment">//60 0x1，      将值0x1压入栈。。此时栈中数据stack[0x0 0x200000000000000000000000000000000 0x0 0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">OR</span>                                          <span class="comment">//17，          栈中pop出栈顶元素，与栈中新的栈顶元素或运算，栈顶修改为新的运算结果。此时栈中数据stack[0x0 0x200000000000000000000000000000000 0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x1</span>                                   <span class="comment">//60 0x1，      将值0x1压入栈。此时栈中数据stack[0x0 0x200000000000000000000000000000000 0x1 0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x80</span>                                  <span class="comment">//60 80，       将值0x80压入栈。此时栈中数据stack[0x0 0x200000000000000000000000000000000 0x1 0x1 0x80]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x2</span>                                   <span class="comment">//60 0x2，      将值0x2压入栈。此时栈中数据stack[0x0 0x200000000000000000000000000000000 0x1 0x1 0x80 0x2]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">EXP</span>                                         <span class="comment">//0a，          从栈顶起，依次取出2个元素，第一个元素为底数，第二个元素为指数，计算结果进栈。此时栈中数据stack[0x0 0x200000000000000000000000000000000 0x1 0x1 0x100000000000000000000000000000000]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SUB</span>                                         <span class="comment">//03，          栈中推出栈顶元素，减去新的栈顶元素，栈顶修改为新的运算结果。此时栈中数据stack[0x0 0x200000000000000000000000000000000 0x1 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">AND</span>                                         <span class="comment">//16，          栈中取出前两个数据进行与运算，结果推入栈。此时栈中数据stack[0x0 0x200000000000000000000000000000000 0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">OR</span>                                          <span class="comment">//17，          栈中pop出栈顶元素，与栈中新的栈顶元素或运算，栈顶修改为新的运算结果。此时栈中数据stack[0x0 0x200000000000000000000000000000001]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">SWAP1</span>                                       <span class="comment">//90，          从栈顶起，将前两个数据交换。此时栈中数据stack[0x200000000000000000000000000000001 0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">SSTORE</span>                                      <span class="comment">//55，          栈顶开始，前两项。将数值0x200000000000000000000000000000001存储在存储器的0x0的位置上，此时会消耗掉栈顶的两项数据。此时栈中数据stack[],存储器数据store&#123;`0x200000000000000000000000000000001数值存在0x0地址`&#125;</span></span><br></pre></td></tr></table></figure>
<p>从上面指令中可以看出，Solidity使用了一系列的运算，生成<code>0x200000000000000000000000000000001</code>,然后一次性将其写入存储器中，正好32个字节。</p>
<h2 id="关于gas的考虑">关于Gas的考虑</h2>
<p>关于上面合约中<code>a=1;b=2</code>的字节码，仔细观察：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">600080547002000000000000000000000000000000006001608060020a03199091166001176001608060020a0316179055</span><br></pre></td></tr></table></figure>
<p>我们发现字节码中直接使用了<code>200000000000000000000000000000000</code>,而不是用指令<code>exp(0x2, 0x81)</code>来计算，原因很简单，因为前者便宜，我们来看看对于手续费的标准：</p>
<ol>
<li>一笔交易的每个零字节的数据或代码费用为<code>4 gas</code></li>
<li>一笔交易的每个非零字节的数据或代码的费用为<code>68 gas</code></li>
</ol>
<p>根据这个标准，我们来计算一下<code>200000000000000000000000000000000</code>的费用：</p>
<ol>
<li>一个非0数<code>2</code>，费用为<code>68gas</code></li>
<li>32个<code>0</code>，费用为<code>32*4=128gas</code></li>
<li>公共gas费用：<code>128+68=196gas</code></li>
</ol>
<p>再来计算一下使用<code>exp(0x2, 0x81)</code>费用：</p>
<ol>
<li><code>exp(0x2, 0x81)</code>的字节码为：<code>608160020a</code>,即指令：<code>PUSH 0x81 PUSH 0x02 EXP</code></li>
<li>其中代码：<code>60</code>、<code>60</code>、<code>0a</code>总共3个，费用为<code>3*68=204gas</code></li>
<li>非0数：81、02,费用为<code>2*68=136gas</code></li>
<li>总共gas费用<code>204+136=340gas</code></li>
</ol>
<p>看，虽然后者字节码短，但是费用却要高很多。因此Solidity的字节码会生成为前者。</p>
<h2 id="总结">总结</h2>
<p>EVM的编译器实际上不会为字节码的大小、速度或内存高效性进行优化。相反，它会为gas的使用进行优化，这间接鼓励了计算的排序，让以太坊区块链可以更高效一点。<br>
我们也看到了EVM一些奇特的地方：</p>
<ol>
<li>EVM是一个256位的机器。以32字节来处理数据是最自然的</li>
<li>持久存储是相当昂贵的</li>
<li>Solidity编译器会为了减少gas的使用而做出相应的优化选择</li>
<li>指令中涉及的位操作，小编也没有深究，也没有太多精力去深究，简单说一句是：位操作主要是用来优化汇编操作的，由Solidity的编译器来处理。</li>
</ol>
<p>Gas成本的设置有一点武断，也许未来会改变。当成本改变的时候，编译器也会做出不同的优化选择。</p>
<blockquote>
<p>量子链-Howard英文原文：<a href="https://blog.qtum.org/diving-into-the-ethereum-vm-6e8d5d2f3c30">https://blog.qtum.org/diving-into-the-ethereum-vm-6e8d5d2f3c30</a><br>
xuli中文翻译：<a href="https://lilymoana.github.io/evm_part1.html">https://lilymoana.github.io/evm_part1.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>EVM</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊vm系列1-指令集汇总</title>
    <url>/articles/715e1612/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>EVM的重要性不言而喻，为方便后面进一步研究和探索，小编在此先列出其中涉及到的汇编指令。</p>
<span id="more"></span>
<p>这些指令在以太坊的源码中的位置：<code>src/github.com/ethereum/go-ethereum/core/vm/opcodes.go</code>,不太直观</p>
<h2 id="指令级">指令级</h2>
<p><code>当前ethereum-go版本：1.8.4</code><br>
指令的功能以及每个指令的费用，小编后面会根据使用情况，逐步补充的，一下子去写，量太大了</p>
<table style="border-collapse:collapse;border-spacing:0;border:none;border-color:#aaa"><tr><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#f38630;text-align:center">16进制</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#f38630;text-align:center">指令</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#f38630;text-align:center">功能描述</th></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x00</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">STOP</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">停止</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x01</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">ADD</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">两数相加</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x02</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">MUL</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">两数相乘</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x03</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">SUB</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">栈中推出栈顶元素，减去新的栈顶元素，<br>栈顶修改为新的运算结果。</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x04</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">DIV</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">两个无符号数相除</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x05</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">SDIV</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x06</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">MOD</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x07</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">SMOD</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x08</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">ADDMOD</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x09</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">MULMOD</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x0a</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">EXP</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">从栈顶起，依次取出2个元素，第一个元素为底数，<br>第二个元素为指数，计算结果进栈。</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x0b</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">SIGNEXTEND</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x10</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">LT</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">栈中pop出栈顶元素x，<br>与栈中新的栈顶元素y比较，<br>栈顶修改为新的运算结果（x</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x11</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">GT</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x12</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">SLT</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x13</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">SGT</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x14</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">EQ</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x15</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">ISZERO</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">判断栈顶元素若大于0，则栈顶元素改为0，否则改为1。</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x16</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">AND</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">与运算</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x17</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">OR</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">栈中推出栈顶元素，与新的栈顶元素或运算，<br>栈顶修改为新的运算结果。</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x18</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">XOR</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x19</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">NOT</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">栈顶数据取反，但实际运算还需要转为补码</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x1a</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">BYTE</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x20</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">SHA3</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">该过程在evm中是`SHA3操作`，<br>pop出栈中两个元素偏离值m和大小n，<br>结合内存中的两个数据x,y生成为32字节的hash，<br>然后压入栈。</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x30</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">ADDRESS</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x31</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">BALANCE</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x32</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">ORIGIN</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x33</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">CALLER</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x34</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">CALLVALUE</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x35</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">CALLDATALOAD</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x36</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">CALLDATASIZE</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x37</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">CALLDATACOPY</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x38</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">CODESIZE</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x39</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">CODECOPY</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x3a</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">GASPRICE</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x3b</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">EXTCODESIZE</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x3c</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">EXTCODECOPY</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x40</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">BLOCKHASH</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x41</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">COINBASE</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x42</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">TIMESTAMP</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x43</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">NUMBER</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x44</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">DIFFICULTY</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x45</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">GASLIMIT</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x50</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">POP</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">丢弃栈顶元素</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x51</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">MLOAD</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x52</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">MSTORE</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">先后pop出两个元素x,y，内存中将y存在地址x</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x53</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">MSTORE8</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x54</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">SLOAD</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x55</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">SSTORE</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">将某数据存储到某个数据槽（地址），一个槽32字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x56</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">JUMP</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x57</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">JUMPI</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">栈中先后pop出两个值x,y，x表示跳转到第几个JUMPDEST，<br>而y表示一个标记（若为0，则跳到下一个JUMPDEST）,<br>若y不为0，则由x决定跳到第几个。</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x58</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PC</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x59</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">MSIZE</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x5a</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">GAS</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x5b</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">JUMPDEST</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">JUMPI可跳到此处，继续执行后面的命令。<br>该指令只起一个flag作用，帮助跳转</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x60</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PUSH1</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">二进制数据推送到栈顶，数据1个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x61</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH2</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">二进制数据推送到栈顶，数据2个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x62</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PUSH3</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">二进制数据推送到栈顶，数据3个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x63</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH4</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">二进制数据推送到栈顶，数据4个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x64</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PUSH5</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">二进制数据推送到栈顶，数据5个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x65</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH6</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">二进制数据推送到栈顶，数据6个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x66</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PUSH7</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">二进制数据推送到栈顶，数据7个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x67</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH8</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">二进制数据推送到栈顶，数据8个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x68</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PUSH9</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">二进制数据推送到栈顶，数据9个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x69</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH10</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">二进制数据推送到栈顶，数据10个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x6a</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PUSH11</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">二进制数据推送到栈顶，数据11个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x6b</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH12</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">二进制数据推送到栈顶，数据12个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x6c</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PUSH13</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">二进制数据推送到栈顶，数据13个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x6d</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH14</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">二进制数据推送到栈顶，数据14个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x6e</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PUSH15</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">二进制数据推送到栈顶，数据15个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x6f</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH16</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">二进制数据推送到栈顶，数据16个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x70</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PUSH17</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">二进制数据推送到栈顶，数据17个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x71</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH18</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">二进制数据推送到栈顶，数据18个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x72</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PUSH19</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">二进制数据推送到栈顶，数据19个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x73</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH20</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">二进制数据推送到栈顶，数据20个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x74</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PUSH21</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">二进制数据推送到栈顶，数据21个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x75</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH22</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">二进制数据推送到栈顶，数据22个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x76</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PUSH23</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">二进制数据推送到栈顶，数据23个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x77</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH24</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">二进制数据推送到栈顶，数据24个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x78</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PUSH25</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">二进制数据推送到栈顶，数据25个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x79</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH26</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">二进制数据推送到栈顶，数据26个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x7a</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PUSH27</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">二进制数据推送到栈顶，数据27个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x7b</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH28</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">二进制数据推送到栈顶，数据28个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x7c</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PUSH29</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">二进制数据推送到栈顶，数据29个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x7d</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH30</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">二进制数据推送到栈顶，数据30个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x7e</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PUSH31</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">二进制数据推送到栈顶，数据31个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x7f</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH32</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">二进制数据推送到栈顶，数据32个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x80</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">DUP1</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">从栈顶起，将栈中第1个元素复制并加入栈顶</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x81</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">DUP2</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">从栈顶起，将栈中第2个元素复制并加入栈顶</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x82</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">DUP3</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">从栈顶起，将栈中第3个元素复制并加入栈顶</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x83</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">DUP4</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">从栈顶起，将栈中第4个元素复制并加入栈顶</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x84</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">DUP5</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">从栈顶起，将栈中第5个元素复制并加入栈顶</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x85</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">DUP6</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">从栈顶起，将栈中第6个元素复制并加入栈顶</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x86</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">DUP7</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">从栈顶起，将栈中第7个元素复制并加入栈顶</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x87</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">DUP8</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">从栈顶起，将栈中第8个元素复制并加入栈顶</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x88</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">DUP9</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">从栈顶起，将栈中第9个元素复制并加入栈顶</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x89</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">DUP10</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">从栈顶起，将栈中第10个元素复制并加入栈顶</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x8a</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">DUP11</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">从栈顶起，将栈中第11个元素复制并加入栈顶</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x8b</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">DUP12</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">从栈顶起，将栈中第12个元素复制并加入栈顶</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x8c</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">DUP13</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">从栈顶起，将栈中第13个元素复制并加入栈顶</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x8d</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">DUP14</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">从栈顶起，将栈中第14个元素复制并加入栈顶</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x8e</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">DUP15</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">从栈顶起，将栈中第15个元素复制并加入栈顶</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x8f</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">DUP16</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">从栈顶起，将栈中第16个元素复制并加入栈顶</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x90</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">SWAP1</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">栈顶元素和它下面的第1项进行交换</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x91</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">SWAP2</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">栈顶元素和它下面的第2项进行交换</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x92</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">SWAP3</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">栈顶元素和它下面的第3项进行交换</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x93</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">SWAP4</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">栈顶元素和它下面的第4项进行交换</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x94</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">SWAP5</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">栈顶元素和它下面的第5项进行交换</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x95</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">SWAP6</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">栈顶元素和它下面的第6项进行交换</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x96</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">SWAP7</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">栈顶元素和它下面的第7项进行交换</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x97</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">SWAP8</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">栈顶元素和它下面的第8项进行交换</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x98</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">SWAP9</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">栈顶元素和它下面的第9项进行交换</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x99</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">SWAP10</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">栈顶元素和它下面的第10项进行交换</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x9a</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">SWAP11</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">栈顶元素和它下面的第11项进行交换</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x9b</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">SWAP12</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">栈顶元素和它下面的第12项进行交换</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x9c</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">SWAP13</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">栈顶元素和它下面的第13项进行交换</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x9d</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">SWAP14</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">栈顶元素和它下面的第14项进行交换</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x9e</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">SWAP15</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">栈顶元素和它下面的第15项进行交换</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x9f</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">SWAP16</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">栈顶元素和它下面的第16项进行交换</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0xa0</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">LOG0</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0xa1</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">LOG1</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0xa2</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">LOG1</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0xa3</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">LOG3</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0xa4</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">LOG4</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0xb0</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0xb1</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">DUP</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0xb2</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">SWAP</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0xf0</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">CREATE</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0xf1</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">CALL</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0xf2</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">CALLCODE</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0xf3</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">RETURN</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0xf4</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">DELEGATECALL</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0xfa</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">STATICCALL</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0xfd</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">REVERT</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center;vertical-align:top">0xfe</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center;vertical-align:top">INVALID</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center;vertical-align:top">退出运行，该程序异常</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0xff</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">SELFDESTRUCT</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr></table>
<blockquote>
<p>bytom：<a href="https://github.com/Bytom/bytom/blob/master/protocol/vm/ops.go">https://github.com/Bytom/bytom/blob/master/protocol/vm/ops.go</a><br>
hayeah：<a href="https://github.com/Bytom/bytom/blob/master/protocol/vm/ops.go">https://github.com/Bytom/bytom/blob/master/protocol/vm/ops.go</a></p>
</blockquote>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>EVM</tag>
      </tags>
  </entry>
  <entry>
    <title>POS权益证明解析</title>
    <url>/articles/fd535b82/</url>
    <content><![CDATA[<h2 id="pos-权益证明">POS-权益证明</h2>
<p>全称是<code>Proof of Stake</code>,可以这么理解：拥有币越多并且持有币时间越长的人，越容易获得记账权。</p>
<span id="more"></span>
<p>POS是预先生成块合法的块，然后判断生成这些块的账户，谁的token最多，那就认为谁的块会被记录在主链中。为了方便理解，小编大概画一张图：</p>
<img src="/articles/fd535b82/1.png" class="" title="每一次生产块的pos流程">
<p>上图很形象的解释了pos机制，具体如下描述</p>
<ol>
<li>持有币的人首先选择是否参与生产块</li>
<li>所有参与者生成合法块，并将各自的块加入<code>待提议队列S</code></li>
<li>队列S中的每个块，根据块生产者持有的token数，将生产者地址以对应次数加入到<code>待胜选队列Q</code>中，比如生产者C有3个Token，则在队列Q中加入3次生产者C的地址。</li>
<li>从队列Q中随机选一个地址作为最终胜利者，它对应的块会被追加到主链中（可以看出，队列Q中，拥有token越多的生产者，越容易被认为是最中块的生产者）<br>
<code>注意，这第3步开始可以设置一个固定间隔时间来操作，比如每隔3秒，这样一来，就可以每3秒钟生产一个块了</code></li>
</ol>
<p>大体上就是这样一个流程，应该算是讲清楚了吧。这里小编有一个关于实现POS机制的源码，有兴趣的同学可以参考一下：<br>
<a href="https://github.com/bitxx/blockchain-demo/tree/master/src/github.com/jason/blockchain-demo/pos">https://github.com/bitxx/blockchain-demo/tree/master/src/github.com/jason/blockchain-demo/pos</a></p>
<h2 id="优缺点">优缺点</h2>
<p>上面一长串的介绍，详细大家对pos已经有了很深的了解，当然，真实的公链实现要远比上面复杂，但核心基本都一样。<br>
POS的优点：节能：不需要挖矿，不会大量耗费电力和能源。其余优点暂不表态。<br>
从上面原理和实现机制中，我们会发现，持币越多的人，被选中的概率越大，这也会导致一个中心化的问题。有的公链会使用PoW+PoS的双重机制来解决这个问题，通过PoW挖矿发行加密货币，使用PoS维护网络稳定。但小编认为这并不是权宜之计。</p>
<blockquote>
<p>参考自：<a href="http://liyuechun.org/">http://liyuechun.org/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>综合</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>共识机制</tag>
      </tags>
  </entry>
  <entry>
    <title>POW共识机制解析</title>
    <url>/articles/131cedbf/</url>
    <content><![CDATA[<h2 id="pow-工作量证明机制">POW-工作量证明机制</h2>
<p>全称是<code>Proof of Work</code>,比特币的诞生，使得这个共识机制得到了更多人的认识，在小编跟很多道友的接触中，明显能感到，他们更加认可这个共识，它是一个真正公平公正的共识机制。</p>
<span id="more"></span>
<p>这个共识机制的原理，其实一句话就可以解释：<code>通过大量的计算，找到一个满意的结果</code>，而专业的说法是：<code>大量Hash碰撞，找到一个符合要求的hash值</code><br>
这个是pow算法的基本实现代码：<a href="https://github.com/bitxx/blockchain-demo/tree/master/src/github.com/jason/blockchain-demo/pow">https://github.com/bitxx/blockchain-demo/tree/master/src/github.com/jason/blockchain-demo/pow</a></p>
<h2 id="比特币的共识">比特币的共识</h2>
<p>小编认为，很有必要大致了解一下比特币的pow是如何实现的。<br>
里面主要是三个概念：<code>difficulty</code>、<code>Target</code>、<code>Nonce</code>。</p>
<h3 id="difficulty">difficulty</h3>
<p>也就是难度值，这个值保证了不管全网算力有多大，都能在10分钟左右生成一个块。这个值是在每个完整节点中独立自动发生的，每2016个区块，所有节点都会按统一的公式自动调整难度，这个公式是由最新2016个区块的花费时长与期望时长（期望时长为20160分钟即两周，是按每10分钟一个区块的产生速率计算出的总时长）比较得出的，根据实际时长与期望时长的比值，进行相应调整（或变难或变易）。<br>
公式如下：<code>新难度值 = 旧难度值 * ( 过去2016个区块花费时长 / 20160 分钟 )</code></p>
<h3 id="target">Target</h3>
<p>即目标值。大量的计算是要有目标的，这个公式比特币是这样给出的：<br>
<code>目标值 = 最大目标值 / difficulty 其中最大目标值为一个恒定值：0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</code><br>
目标值的大小与难度值成反比。比特币工作量证明的达成就是矿工计算出来的区块哈希值必须小于目标值。</p>
<h3 id="nonce">Nonce</h3>
<p>Nonce值是用来参与hash运算的，它存在于区块头中，通过不停的变换这个值，寻找一个满足条件的哈希值，也就是前导0个数在一定范围内的hash值，前导0越多，难度越大。</p>
<h3 id="总结">总结</h3>
<p>求出满足要求的hash值后，全网广播，其余节点验证该值是否符合要求，若符合，则成功加入主链。</p>
<h2 id="优点和不足">优点和不足</h2>
<p>这个通过上面分析已经很清楚了，优点：参与人可以公平竞争；不足：资源消耗巨大，效率低（比特币tps=6）。</p>
<blockquote>
<p>参考自：<a href="http://liyuechun.org/">http://liyuechun.org/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>综合</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>共识机制</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链术语汇总</title>
    <url>/articles/b35eb8c3/</url>
    <content><![CDATA[<h2 id="综述">综述</h2>
<p>区块链对于很多人来说，还是很陌生的，很多名词让人望而却步，小编整理汇总了一些目前常见的词汇，并将它们用尽量通俗的语言解释。若有新的词汇，也会不定期更新。</p>
<span id="more"></span>
<p>本文参考了<a href="http://liyuechun.org/2017/08/11/Blockchain-Glossary-From-A-Z/">区块链专业术语最全词汇表：从 A - Z</a>，但其中有些词汇的讲解还是过于专业，小编结合自身经历，重新描述了这些词汇，并结合当前区块链发展状况，新增了一些别的词汇</p>
<h2 id="词汇表">词汇表</h2>
<p><code>51%Attack 51%攻击</code><br>
可以这么理解，当某人掌控了超过一半的某区块链能力时，他就控制了整个区块链。也就是说，原本去中心化的区块链变成了一个中心化的区块链，这是很可怕的。</p>
<p><code>Address地址</code><br>
就是你用来接收数字资产的地址，可以理解成是你银行卡的账户</p>
<p><code>ASIC 专用集成电路</code><br>
这个是加速了比特币被挖完的罪魁祸首，看看下图，纵轴可以理解为算力，横轴为年份，自从ASIC出现后，全网算力明显上升。</p>
<img src="/articles/b35eb8c3/1.jpeg" class="" title="ASIC的出现带来的影响">
<p><code>Bitcoin 比特币</code><br>
第一个区块链应用，此公链就是为了发币而生。</p>
<p><code>Block 区块</code><br>
一个块中记录了一定容量的信息，信息永久记录并且不可被篡改</p>
<p><code>Blockchain 区块链</code><br>
区块串联后形成的一条链（一般是依据时间戳进行串联，当然这是个复杂的过程），也就是我们所说的主链，加入到主链中的块，将成为历史数据。</p>
<p><code>Block explorer 区块链浏览器</code><br>
可以通过它查看当前主链状态、信息、各区块的信息，公开透明，也就是完全可视化、透明化、人性化的将整个区块链展示在任何人面前。</p>
<p><code>Block Height 区块高度</code><br>
就是当前主链的块数，因为在某个时间段内，产生块的时间是固定的，比如每隔15秒，主链会新增一个块。因此，ICO年代，很多合约是通过块高度来控制发行Token的。</p>
<p><code>Block RewardToken奖励</code><br>
给矿工的奖励。块的产生就是共识达成的结晶，而这个块就是矿工来协助产生的，矿工为此付出了带宽、时间、设备等资源，因此需要得到这一奖励。而这个奖励就来自用户转账、交易等操作的手续费。<br>
当然，现实中，是远比这一讲解复杂的。</p>
<p><code>Consensus共识</code><br>
比如，某个块是否可以被加入到主链，这是需要某一比例的矿工认可，这个过程就是共识的过程。</p>
<p><code>Cryptocurrency 加密货币</code><br>
这个应该都熟悉，别称Token、通证、代币、数字货币。</p>
<p><code>Cryptographic Hash Function 加密哈希函数</code><br>
这个扩展讲起来会涉及到很多领域的底层技术。简单来说，就是不同的数据经过处理后，会产生一个唯一的固定长度的字符串，这个字符串就是一个哈希值，可以理解为关系型数据库中一张表的主键。</p>
<p><code>Dapp 去中心化应用</code><br>
全称：Decentralized Application，自主运行的应用，不需要某中心组织或机构干预。</p>
<p><code>DAO 去中心化自治组织</code><br>
公链，以及公链上的DAPP，在没有任何人的干预之下，依旧可以自行组织运营。</p>
<p><code>Difficulty 容易程度</code><br>
能够理解为，某个节点生成一个块的困难程度。</p>
<p><code>Digital Signature 数字签名</code><br>
这在密码学领域很常见，A用户使用公钥加密某信息，B用户在用私钥揭秘该信息，若能成功解开，则说明信息正确无误。</p>
<p><code>Double Spending 双重支付</code><br>
也就是区块链领域中经常涉及到的双花问题，简而言之，就是一笔钱花了两次。双花并不是产生新的币，只是通过某种方式把自己花出去的钱又重新拿回来了。<br>
双花攻击是一个让人头疼的问题，而要解决这个问题，主要是考虑一个健壮的共识算法。</p>
<p><code>Ethereum 以太坊</code><br>
被称为是第二代区块链技术</p>
<p><code>EVM 以太坊虚拟机</code><br>
以太坊的核心</p>
<p><code>Fork 分支</code><br>
一条链由于不同的原因，被分成了多个叉，每个叉是一条链</p>
<p><code>Genesis Block 创世区块</code><br>
第一个区块，期间会初始化整条链</p>
<p><code>Hard Fork 硬分叉</code><br>
区块链发生永久性分歧，在新共识规则发布后，部分没有升级的节点无法验证已经升级的节点生产的区块，通常硬分叉就会发生。</p>
<p><code>Hash collision 哈希碰撞</code><br>
这个其实就是挖矿的本质，哈希碰撞主要是在基于POW机制的区块链中才有。原理是：有可能两个不同的原始值在经过哈希运算后得到同样的结果，这样就是哈希碰撞。这个原理不需要去深究。只要知道，碰撞达到某一范围后，就能挖出一个块了。</p>
<p><code>keystore 钱包文件</code><br>
里面包含加密后的公钥私钥信息，需要使用自己设置的密码才能解开此文件中的信息，一般钱包导入，转账等操作时候的签名认证时候才需要。</p>
<p><code>Mining 挖矿</code><br>
挖矿的过程就是哈希碰撞的过程，也就是共识达成的过程。这块只需要知道，是为了挖出区块链的下一个块</p>
<p><code>Multi-Signature 多重签名</code><br>
这样来理解：为完成某一次交易，需要多个不同的用户认可才能成功，这类似于企业里，某份合同生效，需要多个负责任签字才能执行该合同。</p>
<p><code>Node 节点</code><br>
可以理解为对接到区块链网络中的用户，一般是指保存有区块链完整数据的用户，并实时对接网络。</p>
<p><code>Oracles 预言机</code><br>
通过它可以实现智能合约和外部世界的交流</p>
<p><code>Peer to Peer 点对点</code><br>
网络中，双方在没有第三方干预的情况下完成交流。</p>
<p><code>Public Address 公用地址</code><br>
这个就是前面提到的<code>Address地址</code>，要记住它不是公钥，而是在公钥的基础上hash处理后的结果。<br>
可把它理解为自己的银行卡账号</p>
<p><code>Private Key 私钥</code><br>
理解成是你的银行卡密码，不同的是，这个密码只有你自己拥有，而别的地方是无法获取到的，因此你必须牢牢记住自己的这个私钥</p>
<p><code>Proof of Work 工作证明</code><br>
一种用于挖矿的工作机制，也是维持区块链正常运转的共识机制。跟电脑性能有关。</p>
<p>Proof of Stake（股权证明）<br>
一种用于挖矿的工作机制，也是维持区块链正常运转的共识机制。跟电脑性能无关，此类机制的区块链，也没有挖矿的概念。</p>
<p><code>Scrypt 一种挖矿加密算法</code><br>
<code>哈希碰撞</code>(这个概念前面有描述)的一种函数，性能好，但是吃内存。这个主要</p>
<p><code>SHA-256 一种挖矿加密算法</code><br>
<code>哈希碰撞</code>(这个概念前面有描述)的一种函数，需要大量的硬件设备的投入。</p>
<p><code>Smart Contracts 智能合约</code><br>
可以理解为是合约发布者定制的一系列的法律法规，发布到链中，所有调用该合约的参与者都需要遵守其中的规则。可以说，代码即规则。发布后的规则，不可以再被修改。</p>
<p><code>Soft Fork 软分叉</code><br>
当新共识规则发布后，没有升级的节点会因为不知道新共识规则下，而生产不合法的区块，就会产生临时性分叉。</p>
<p><code>Solidity 开发语言</code><br>
用于开发智能合约的开发语言，目前，大多数公链的合约都兼容该语言。</p>
<p><code>Testnet 测试网</code><br>
这个就不用解释了吧。。</p>
<p><code>Transaction Free 手续费</code><br>
交易或者调用某些合约接口，都会涉及到手续费问题。手续费用来奖励给矿工的，毕竟矿工耗费了那么多精力来给用户生成块。</p>
<p><code>Wallet 钱包</code><br>
可以用来存放数字资产，转账交易等。</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>综合</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>委托股权证明原理(DPOS)--翻译及解读</title>
    <url>/articles/bbe43e3f/</url>
    <content><![CDATA[<h2 id="自述">自述</h2>
<p>关于这个共识算法，小编其实有很多想说的，码了一个多小时的见解，考虑良久后，还是不打算把这见解发出来了，一千个人一千个哈姆雷特，<br>
数十种共识算法中，它能被众人所知，那它必然是有它的优势。哲学上来说，存在即是合理。</p>
<span id="more"></span>
<p>DPOS最初是石墨烯提出来的，国内外也有几个基于石墨烯的区块链已经落地很久，运转也良好。<br>
这个算法小编再三考虑后，还是打算讲一下它的原理，当然，小编不会从头讲。eos白皮书里引用了一个讲解dpos原理的英文论坛地址，小编会将其翻译成中文，并加入自己的见解。<br>
虽然国内已经有人翻译过了，但为了自己能更好的走下去，小编还是打算自己再翻译一遍吧。</p>
<p>以下正文</p>
<h2 id="前言">前言</h2>
<p>英文原文地址：<a href="https://steemit.com/dpos/@dantheman/dpos-consensus-algorithm-this-missing-white-paper">https://steemit.com/dpos/@dantheman/dpos-consensus-algorithm-this-missing-white-paper</a><br>
这是EOS白皮书中缺失的关于讲解DPOS原理的部分内容。本文主要是讲DPOS怎样运行以及它的鲁棒性为什么很强。早期也写了<a href="https://bitshares.org/technology/delegated-proof-of-stake-consensus/">一篇关于描述DPOS机制的文章</a>;然而，那篇文章中还包含了许多不是关于共识机制的内容（<code>wj备注：那篇文章写的冗长，看的心累，然并卵，我只需要知道DPOS是什么就行</code>）<br>
所有的区块链本质上是由交易驱动的确定性状态机。共识的过程是用来确定被认可的交易顺序以及过滤无效的交易。目前已经有很多共识算法已经可以产生类似的有效交易排序，然而DPOS通过在不同的区块链项目中多年运转，已经证明了它拥有强鲁棒、高安全、高效率等特性。<br>
就像所有的其它共识算法一样，块生产者能够引起的最大的危害审查。所有的块在基于<code>确定性的开源状态机逻辑</code>中必须是有效的。</p>
<h2 id="dpos算法综述">DPOS算法综述</h2>
<p>DPOS算法被分为两部分：<code>选取一组块生产者</code>以及<code>生产调度</code>。选举过程要确保最终是由利益相关者来控制的（<code>小编的理解，也就是token持有者来控制选举过程</code>），因为网络不流畅时候，利益相关者的损失是最大的。人们是如何选举的，对于每时每刻的共识达成来说影响很小。因此，本文主要是聚焦在<code>当块生产者被选出来后共识是如何达成的</code>这一问题上。<br>
为了更好的解释这个算法，我想假设三个块生产者：<code>A</code>、<code>B</code>、<code>C</code>，因为共识的达成是需要2/3+1比例数量的生产者来解决期间遇到的所有情况。在这个简化的模型中会假设<code>C</code>是一个打破平衡的生产者。在真实的场景中，一般会有21个或者更多的生产者。就比如工作量证明(POW)，一般规定最长链为被认可的链（<code>小编理解就是，这个规则作为打破平衡的条件，就类似前面提到的生产者C，当A、B各作出一个不同选择而达到平衡时，C必须选择跟A或者跟B，无论结果怎样，都会打包当前的平衡</code>），任何时候，一个诚实的对等节点，看到一条有效的更长的链，自己都会从当前分支切换到最长链上。<br>
我将会在任何能够想象到的网络状态下，通过例子展示DPOS是如何运行的。这些例子将会帮助你更清楚的认识，为什么DPOS鲁棒性强并且难以破坏。<br>
（<code>注意：以下描述的案例，都是以3个节点为标准的</code>）</p>
<h3 id="一般操作">一般操作</h3>
<p>在一般情况下，块生产者轮流每3秒钟生产一个块（<code>小编补充一句，EOS将这一机制压缩到0.5秒了，公信宝还是3秒钟</code>）。假设每轮中，每个生产者都没有错过生产块的机会，那么就会产生一条最长链。在被正常调度轮次之外，块生产者生产的块是无效的。</p>
<img src="/articles/bbe43e3f/1.png" class="" title="每个生产者都是规规矩矩的">
<h3 id="少数分叉">少数分叉</h3>
<p>不超过1/3的节点是恶意的或者是故障的，并且它们有可能会制造少量的分叉。这种情况下（<code>小编备注：这里是假设1/3的节点制造了一条分叉，也就是案例中3个节点中的1个节点</code>），该分叉链每9秒钟产生一个块，而未分叉的2/3的节点所在链（<code>案例中的2个节点</code>），每9秒钟会产生2个块（<code>这块小编按自己的理解翻译的，原文直译过来很晦涩</code>）,如此，拥有2/3节点的链始终比1/3节点的链长（<code>也就是说，拥有2/3节点的链是被认可的诚实链</code>）。</p>
<img src="/articles/bbe43e3f/2.png" class="" title="前两轮中，恶意生产者B搞分叉">
<h3 id="少数离线节点进行多重生产">少数离线节点进行多重生产</h3>
<p>少数离线的节点试图产生无限多的分支，但是它们每个分支都会比拥有多数节点的主链短。因为，拥有少量节点的分支，出块的速度始终比拥有多数节点的分支产生块的速度慢。</p>
<img src="/articles/bbe43e3f/3.png" class="" title="离线的节点自己产生多个分叉">
<h3 id="网络碎片化">网络碎片化</h3>
<p>网络碎片化（<code>就是各种网络不稳定</code>）完全有可能导致没有一个分支拥有较多的块生产者（<code>就是每个分支都有相差不大的块生产者</code>）。这种情况下，生产者数量最多的那个分支将会被认为是主链。当网络状况恢复正常时，拥有较小数量生产者的分支将会倒向最大的那个分支，明确的共识也将会恢复。</p>
<img src="/articles/bbe43e3f/4.png" class="" title="每个分叉的生产者数都差不多">
<p>完全有可能会有这样一种情况：有3条分支，而其中最长的2条分支的长度是一样的。此时，较短分支中的块生产者切换回这两条较长分支中的任意一条，平衡都会被打破，就是说其中一条变成了最长链（<code>好吧，这块小编按自己的理解解释了，原文翻译过来看的会很心累的</code>）。随后我们将讨论块生产者的洗牌机制，如此将会使得生产块的顺序是随机化的，这样就能保证即使两个分支分别拥有相同数量的块生产者，生产块的步长也是不一样的，最终导致其中一条分支长度比另一条长。</p>
<h3 id="少数在线节点进行多重生产">少数在线节点进行多重生产</h3>
<p>在这种情况下，少数节点<code>B</code>同时生产了2个或者更多的块（<code>正常生产者是只能生产一个块的</code>），下一个正常生产者<code>C</code>生产出的一个块，要选择B生产的其中一个块作为父类块（<code>这块小编也是按中文理解重新组织了语义，原文直译不好理解</code>），一旦<code>C</code>选择了其中一个作为父类块，那逻辑上可判断出，<code>C</code>当前所在的链是最长链，<code>B</code>产生的其它块都是短链，如此一来，后面所有的节点都会以最长链为标准。主链上少数的不良生产者即使企图同时生产多个块也不会影响全局，每轮中，即使它们每个能生产的块再多，也最多只有一个能被认可。</p>
<img src="/articles/bbe43e3f/5.png" class="" title="个别节点B生成了多个分叉">
<h3 id="最终不可逆转块-后半部分不知道是什么意思-求教">最终不可逆转块（后半部分不知道是什么意思，求教）</h3>
<p>在网络碎片的情况下，很有可能多个分叉同时增长相当长的时间。长远来看，最终还是会有一条最长的链胜出的。但是观察者需要一种准确的手段来知道，一个块绝对是在增长最快的那条链中。这个可以通过<code>2/3+1</code>多数块生产者的确认来决定。<br>
在下面图中，块<code>B</code>已经被<code>C</code>和<code>A</code>确认，这代表了<code>2/3+1</code>数量的确认。从中也可以知道，若<code>2/3+1</code>的生产者是诚实的，就不会有其它分叉链会比这条链长。</p>
<img src="/articles/bbe43e3f/6.png" class="" title="2&#x2F;3+1确认机制">
<p>需要注意，这个<code>规则</code>类似于比特币中6个块的确认机制。一些聪明的人会设法促成一系列的事件，使得两个节点出现在不同的最后的不可逆块上，这种极端情况，需要攻击者能够完全的控制网络通信的延迟，同时在几分钟的时间内两次使用这个控制。但是，即便这种事发生，最长分支胜出的规则仍然是适用的。<br>
我们评估后认为，这种估计成功的概率几乎为0，经济后果也不足为虑，因此也没必要担心。（<code>然并卵，这一段话小编没看懂是在说什么，讲的太含糊了</code>）</p>
<h3 id="生产者的法定人数不足">生产者的法定人数不足</h3>
<p>在某些情况下，块生产者的法定人数有可能不足，这种情况下这些生产者也是可以继续出块的（<code>就是说生产者参与人数不是100%</code>）。在这些块中的利益相关者，是可以包括更改投票的交易（<code>小编理解：这句话的意思是，每一次投票也属于一个交易，这个交易信息被包含在这些块利益相关者之中了</code>），这些投票可以选出一组新的生产者，并将块生产者参与率恢复为100%。这样一来，不久之后，短链（<code>假设短链块生产者人数逐步由不足100变为了100%%</code>）终将会超过长的链（<code>假设长链块生产者人数不足100%</code>）。<br>
在这一个过程中所有的观察者都会明白，在一条链的块生产者参与率达到67%以前，整个网络状态是不稳定的。在这种状况下进行交易的风险（<code>就是生产者的法定人数不足</code>），类似于在比特币中块的确认不足6个。他们之所以愿意冒这个风险，是因为他们知道存在这样一种可能，最终会在不同的分叉中，各自建立共识。实践检验得知，dpos生产者的法定人数不足时候的问题，相比于比特币中少于3个块的确认问题安全很多。</p>
<h3 id="多数生产者腐败-就是作弊">多数生产者腐败（就是作弊）</h3>
<p>如果大多数生产者作弊，这样就会产生无限数量的分叉，每个分叉看着都像是2/3确认的机制进行的。这种情况下，最终的不可篡改块的算法变成了最长链算法。最长链就是大多数生产者所认可的那条链，而这条链也是诚实节点所认可的链。这种行为不会长时间存在，因为最终会被利益相关者投票替换生产者。</p>
<img src="/articles/bbe43e3f/7.png" class="" title="多数生产者不诚实">
<h2 id="基于交易的股权证明机制-tapos">基于交易的股权证明机制（TaPOS）</h2>
<p>当用户对交易进行签名时，他的这个行为是在一定条件下假设的区块链状态中执行的。这个假设是基于最近几个块来预测的。如果最长链的共识发生了改变，潜在的会使得签名者根据先前的假设所认可的交易失效（<code>小编觉得有点拗口，就是说，你先前根据当前链的状态判断自己的交易没问题，但是最终链的共识发生了变化，那你的交易就没能被记录进去，那就失效了</code>）。<br>
在TaPOS机制中，所有交易都包含最近一个块的hash，如果在链已有块中没有发现这个块，那这个块所包含的交易都会被认为是无效的（那这个块就被孤立了）。任何人在被孤立的块上进行交易都会发现交易是无效的，并且无法迁移到主链。<br>
这个过程的另一个作用是，可以抵御意图通过长期攻击来形成另外一条链的行为。每个利益相关者在每次交易时，都会直接对交易作出确认。随着时间的推移，所有的块都是由所有的利益相关者确认，这也是无法伪造链的原因。</p>
<h2 id="确定的对生产者洗牌-就是说公平的洗牌规则">确定的对生产者洗牌（<code>就是说公平的洗牌规则</code>）</h2>
<p>在前面讲的所有例子中，我们展示的都是按顺序调度块生产者。实际上，每N个块之后就会对所有块生产者进行一次洗牌（N表示块生产者的人数）。这种随机方式确保了每个生产者都能公平的参与到块生产中来，全员参与，一个也不会被忽略（<code>这句话小编换了一种说法</code>），并且当形成拥有相同数量的块生产者的多个分叉时，这种僵局总会被打破。</p>
<h2 id="总结">总结</h2>
<p>在我们能够想象到的自然网络异常或者大量生产者作弊的情况下，DPOS的鲁棒性都是很强的。不像别的共识算法，当大多数生产者不合格时，DPOS仍可以正常运转。这种时候，社区会通过选举来替换这些不合格的生产者，直到恢复为100%的参与度为止。我还没有发现别的还有哪个算法在高强度和多种异常变化的条件下依旧能够有如此好的鲁棒性(<code>怎么说吧，小编觉得，要满足市场所需，又要满足安全可靠，DPOS是个合适的选择，就看怎么具体设计了</code>)。<br>
总的来说，DPOS引人注目的安全性来自它的选择块生产者和验证高质量节点的算法，使用这样一个投票方式，确保了即使某个人拥有50%的投票权，也不能光靠自己就选出一个生产者。DPOS通过优化确保拥有健壮网络连接的诚实节点都能够100%的参与到投票中来，这使得DPOS能够在平均1.5秒内准确的确认99.9%的交易，同时也可以通过优雅和可检测的方式很容易的实现降级(<code>就是恢复</code>)。<br>
别的共识算法在网络条件差的不诚实节点的条件下进行设计，设计的结果结果导致网络性能低、高延迟、高开销，并且如果33%的节点失效，则整个网络将瘫痪。<br>
Bitshares三年的成功运行以及Steem的一年运行期间，我们经历了各种各样的网络问题以及软件bug。DPOS在期间成功运转，并且它能比别的区块链处理更多的交易。</p>
<h2 id="小编补充">小编补充</h2>
<h3 id="优缺点">优缺点</h3>
<h4 id="优点">优点</h4>
<ol>
<li>能耗更低。DPoS机制将节点数量进一步减少到101个，在保证网络安全的前提下，整个网络的能耗进一步降低，网络运行成本最低。</li>
<li>更加去中心化。目前，对于比特币而言，个人挖矿已经不现实了，比特币的算力都集中在几个大的矿池手里，每个矿池都是中心化的，就像DPoS的一个受托人，因此DPoS机制的加密货币更加去中心化。PoS机制的加密货币（比如未来币），要求用户开着客户端，事实上用户并不会天天开着电脑，因此真正的网络节点是由几个股东保持的，去中心化程度也不能与DPoS机制的加密货币相比。</li>
<li>更快的确认速度。每个块的时间为10秒，一笔交易（在得到6-10个确认后）大概1分钟，一个完整的101个块的周期大概仅仅需要16分钟。而比特币（PoW机制）产生一个区块需要10分钟，一笔交易完成（6个区块确认后）需要1个小时。点点币（PoS机制）确认一笔交易大概也需要1小时。</li>
</ol>
<h4 id="缺点">缺点</h4>
<ol>
<li>投票的积极性并不高。绝大多数持股人（90％+）从未参与投票。这是因为投票需要时间、精力以及技能，而这恰恰是大多数投资者所缺乏的。</li>
<li>对于坏节点的处理存在诸多困难。社区选举不能及时有效的阻止一些破坏节点的出现，给网络造成安全隐患。</li>
</ol>
<h3 id="伪代码实现">伪代码实现</h3>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> round i <span class="comment">//分成很多个round，round无限持续</span></span><br><span class="line">   dlist_i = get N delegates sort by votes <span class="comment">//根据投票结果选出得票率最高的N个受托人</span></span><br><span class="line">   dlist_i = shuffle(dlist_i) <span class="comment">//随机改变顺序</span></span><br><span class="line">   loop <span class="comment">//round完了，退出循环</span></span><br><span class="line">       slot = global_time_offset / block_interval</span><br><span class="line">       pos = slot % N</span><br><span class="line">       <span class="keyword">if</span> dlist_i[pos] exists in this node <span class="comment">//delegate在这个节点</span></span><br><span class="line">           generateBlock(keypair of dlist_i[pos]) <span class="comment">//产生block</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           skip</span><br></pre></td></tr></table></figure>
<h3 id="go代码实现">go代码实现</h3>
<p>请参考：<a href="https://github.com/bitxx/blockchain-demo/tree/master/src/github.com/jason/blockchain-demo/dpos">https://github.com/bitxx/blockchain-demo/tree/master/src/github.com/jason/blockchain-demo/dpos</a></p>
<blockquote>
<p>除翻译外，剩余内容参考自：<a href="http://liyuechun.org/">http://liyuechun.org/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>综合</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>共识算法</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊源码解读-第5.2讲-rpc源码解读</title>
    <url>/articles/e10014d8/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>本文我们将分析rpc模块的源码，如果对rpc概念还不是很清楚的同学，建议先看看这篇文章<a href="/articles/original/ethereum/src_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E7%AC%AC5.1%E8%AE%B2-rpc%E5%AE%98%E7%BF%BB%E5%8F%8A%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3.html"><code>以太坊源码解读-第5.1讲-rpc官翻及个人理解</code></a></p>
<span id="more"></span>
<p>本文后半部分解释有误，本文可对rpc了解大概，然后看之后的内容<br>
先来看看该模块下有哪些文件：<br>
.<br>
|____ipc_unix.go<br>
|____ipc_windows.go<br>
|____ipc.go<br>
|____http.go<br>
|____doc.go<br>
|____inproc.go<br>
|____utils.go<br>
|____websocket.go<br>
|____errors.go<br>
|____server.go<br>
|____server_test.go<br>
|____client.go<br>
|____client_example_test.go<br>
|____client_test.go<br>
|____subscription.go<br>
|____subscription_test.go<br>
|____utils_test.go<br>
|____http_test.go<br>
|____types.go<br>
|____types_test.go<br>
|____json.go<br>
|____json_test.go</p>
<p>文件很多，一眼看去真的很头大，小编借鉴<a href="https://github.com/ZtesoftCS/go-ethereum-code-analysis/blob/master/rpc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md">rpc源码分析-github</a>中提供的一张图片先全局的介绍一下rpc模块中整体的文件结构，这样方便后面的理解：</p>
<img src="/articles/e10014d8/1.png" class="" title="rpc模块文件结构">
<p>图中<code>网络协议channels</code>和<code>Json</code>两部分，其请求和回应的编码和解码都是同时与服务端和客户端打交道的类。<code>网络协议channels</code>主要提供连接和数据传输的功能。 <code>json</code>的编码和解码主要提供请求和回应的序列化和反序列化功能(Json -&gt; Go的对象)。<br>
另外需要知道，各种对外的服务都是被注册到server中的。<br>
<code>ps</code>：要区分server和service的区别，server表示服务实体，service表示被注册到server中的一项服务</p>
<h2 id="types-go源码">types.go源码</h2>
<p>要了解rpc，得先要了解rpc中对各大类的定义，因此我们很有必要先来看下这个文件。</p>
<h3 id="对外开放的api定义">对外开放的API定义</h3>
<p>外部访问rpc的server进行通信是通过调用这个API来实现。<br>
分析过geth启动rpc的过程后，就会发现，所有的模块，都会把自己的api放在其中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> API <span class="keyword">struct</span> &#123;</span><br><span class="line">	Namespace <span class="type">string</span>      <span class="comment">// 在该命名空间下，service的方法被公开</span></span><br><span class="line">	Version   <span class="type">string</span>      <span class="comment">// 给dapp展示的api版本号</span></span><br><span class="line">	Service   <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 带有方法的service实例</span></span><br><span class="line">	Public    <span class="type">bool</span>        <span class="comment">// 在公共使用中，指示方法是否为安全的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="service的定义">service的定义</h3>
<p>service定义了一个用来被注册到server中的服务，需要知道它内部结构是如何的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123;</span><br><span class="line">	name          <span class="type">string</span>        <span class="comment">// service的名称</span></span><br><span class="line">	typ           reflect.Type  <span class="comment">// 类型，反射的</span></span><br><span class="line">	callbacks     callbacks     <span class="comment">// 回调方法的集合</span></span><br><span class="line">	subscriptions subscriptions <span class="comment">// 订阅/发布集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现callbacks和subscriptions都是集合，它是如下定义的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> callbacks <span class="keyword">map</span>[<span class="type">string</span>]*callback      <span class="comment">// 回调方法的集合，可以看出是一个map</span></span><br><span class="line"><span class="keyword">type</span> subscriptions <span class="keyword">map</span>[<span class="type">string</span>]*callback  <span class="comment">// 订阅的集合，也可以看出是一个map</span></span><br></pre></td></tr></table></figure>
<p>这两个集合都是map类型的，而它们个体本身其实就是一个callback，它的结构如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> callback <span class="keyword">struct</span> &#123;</span><br><span class="line">	rcvr        reflect.Value  <span class="comment">// 反射出方法的值</span></span><br><span class="line">	method      reflect.Method <span class="comment">// 反射出方法本身</span></span><br><span class="line">	argTypes    []reflect.Type <span class="comment">// 输入的参数</span></span><br><span class="line">	hasCtx      <span class="type">bool</span>           <span class="comment">// 检测第一个参数是否为context，</span></span><br><span class="line">	errPos      <span class="type">int</span>            <span class="comment">// 返回错误的索引err，无法返回则为-1</span></span><br><span class="line">	isSubscribe <span class="type">bool</span>           <span class="comment">// 该callback是否为订阅</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，该callback主要就是使用反射来确定回调本身的。代码注释解释的可能不太好，大意上是那么一回事。。</p>
<h3 id="server的定义">server的定义</h3>
<p>上面说的service可以理解为一项服务，而server可以理解成是各种服务的容器，service最终是要被注册到server中的，而server的定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	services serviceRegistry  <span class="comment">//用来存储service</span></span><br><span class="line">	run      <span class="type">int32</span>  <span class="comment">//用来控制server是否可运行，1为运行，非1为不可运行</span></span><br><span class="line">	codecsMu sync.  <span class="comment">//用来保护多线程访问codecs的锁</span></span><br><span class="line">	codecs   *set.Set  <span class="comment">//用来存储所有的编码解码器，其实就是所有的连接。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的services就是用来存储service集合的，可以看出它是通过serviceRegistry来定义的，而serviceRegistry本身是如下定义的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> serviceRegistry <span class="keyword">map</span>[<span class="type">string</span>]*service </span><br></pre></td></tr></table></figure>
<p>呵呵，这下知道了，service在server中是存在map中的</p>
<h3 id="servercodec的定义">ServerCodec的定义</h3>
<p>server中的方法会用到这个东东，客户端发出的请求，对请求的处理，返回响应等过程，都是通过它来进行的。<br>
这个东西很重要，它贯穿了客户端和服务器端的交流，重要的不得了。<br>
先来看看它的定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ServerCodec <span class="keyword">interface</span> &#123;</span><br><span class="line">	ReadRequestHeaders() ([]rpcRequest, <span class="type">bool</span>, Error)    <span class="comment">//读取客户端发来的请求</span></span><br><span class="line">	<span class="comment">//根据给定的类型解析请求参数</span></span><br><span class="line">	ParseRequestArguments(argTypes []reflect.Type, params <span class="keyword">interface</span>&#123;&#125;) ([]reflect.Value, Error)</span><br><span class="line">	CreateResponse(id <span class="keyword">interface</span>&#123;&#125;, reply <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;  <span class="comment">//response返回成功</span></span><br><span class="line">	CreateErrorResponse(id <span class="keyword">interface</span>&#123;&#125;, err Error) <span class="keyword">interface</span>&#123;&#125;   <span class="comment">//response返回失败</span></span><br><span class="line">	<span class="comment">//response返回失败，包括一些别的信息</span></span><br><span class="line">	CreateErrorResponseWithInfo(id <span class="keyword">interface</span>&#123;&#125;, err Error, info <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	CreateNotification(id, namespace <span class="type">string</span>, event <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;  <span class="comment">// 创建发布响应</span></span><br><span class="line">	Write(msg <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span>  <span class="comment">// 写信息到客户端</span></span><br><span class="line">	Close()  <span class="comment">// 关闭底层的数据流</span></span><br><span class="line">	Closed() &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;  <span class="comment">// 当底层连接关闭后，则执行该接口方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>期间涉及到了两个比较重要的结构体：</p>
<ul>
<li>rpcRequest，它里面包含具体的请求信息：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> rpcRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">	service  <span class="type">string</span></span><br><span class="line">	method   <span class="type">string</span></span><br><span class="line">	id       <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	isPubSub <span class="type">bool</span></span><br><span class="line">	params   <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	err      Error <span class="comment">// invalid batch element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Error，错误信息结构：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Error <span class="keyword">interface</span> &#123;</span><br><span class="line">	Error() <span class="type">string</span>  <span class="comment">// 返回错误信息</span></span><br><span class="line">	ErrorCode() <span class="type">int</span> <span class="comment">// 返回错误代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="blocknumber的定义">BlockNumber的定义</h3>
<p>这个就是块号的解析，根据输入的byte[]来判断返回的BlockNumber是多少。这个后面大家可以了解下。</p>
<h2 id="json-go">json.go</h2>
<p>还记得我们前面提到的那个<code>ServerCodec</code>吗，它其实只是一个接口定义，真正其实是该文件中的<code>jsonCodec</code>生成的，<code>jsonCodec</code>实现了<code>ServerCodec</code>的所有接口</p>
<h3 id="jsoncodec结构">jsonCodec结构</h3>
<p>rpc消息的请求和响应，以及序列化和解析都是这个结构来实现的，这</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> jsonCodec <span class="keyword">struct</span> &#123;</span><br><span class="line">	closer sync.Once                 <span class="comment">// close closed channel once</span></span><br><span class="line">	closed <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;          <span class="comment">// closed on Close</span></span><br><span class="line">	decMu  sync.Mutex                <span class="comment">// guards the decoder</span></span><br><span class="line">	decode <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span> <span class="comment">// decoder to allow multiple transports</span></span><br><span class="line">	encMu  sync.Mutex                <span class="comment">// guards the encoder</span></span><br><span class="line">	encode <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span> <span class="comment">// encoder to allow multiple transports</span></span><br><span class="line">	rw     io.ReadWriteCloser        <span class="comment">// connection</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建jsoncodec的重要的两个方法">创建jsonCodec的重要的两个方法</h3>
<p>可以通过<code>NewCodec()</code>方法和<code>NewJSONCodec()</code>方法来创建jsonCodec，方法本身很简单，小编就不解释了，注意编码和解码就行。</p>
<h3 id="jsoncodec方法">jsonCodec方法</h3>
<p>这些方法都是具体实现了<code>ServerCodec</code>的接口，想了解具体是怎么实现的，可以看看代码去，小编在这就不详述了。</p>
<h2 id="server-go和server-test-go源码">server.go和server_test.go源码</h2>
<p>对上面的定义有了整体把握后，小编结合着server_test.go文件来讲解一下server.go源码。</p>
<h3 id="先来看看server-test-go">先来看看server_test.go</h3>
<p>为了方便测试，server_test.go中定义了一个<code>Service</code>，这个<code>Service</code>用来被注册到server中，关于这个Service很有必要知道是如何定义的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Service <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> &#123;</span><br><span class="line">	S <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">	String <span class="type">string</span></span><br><span class="line">	Int    <span class="type">int</span></span><br><span class="line">	Args   *Args</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span></span> NoArgsRets() &#123;&#125;  <span class="comment">//第1个有效的回调方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span></span> Echo(str <span class="type">string</span>, i <span class="type">int</span>, args *Args) Result &#123; <span class="comment">//第2个有效的回调方法</span></span><br><span class="line">	<span class="keyword">return</span> Result&#123;str, i, args&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span></span> EchoWithCtx(ctx context.Context, str <span class="type">string</span>, i <span class="type">int</span>, args *Args) Result &#123;  <span class="comment">//第3个有效的回调方法</span></span><br><span class="line">	<span class="keyword">return</span> Result&#123;str, i, args&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span></span> Sleep(ctx context.Context, duration time.Duration) &#123;  <span class="comment">//第4个有效的回调方法</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(duration):</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span></span> Rets() (<span class="type">string</span>, <span class="type">error</span>) &#123; <span class="comment">//第5个有效的回调方法</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span></span> InvalidRets1() (<span class="type">error</span>, <span class="type">string</span>) &#123; <span class="comment">//无效的回调方法</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span></span> InvalidRets2() (<span class="type">string</span>, <span class="type">string</span>) &#123; <span class="comment">//无效的回调方法</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span></span> InvalidRets3() (<span class="type">string</span>, <span class="type">string</span>, <span class="type">error</span>) &#123; <span class="comment">//无效的回调方法</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span></span> Subscription(ctx context.Context) (*Subscription, <span class="type">error</span>) &#123; <span class="comment">//一个有效的订阅</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据<a href="/articles/original/ethereum/src_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E7%AC%AC5.1%E8%AE%B2-rpc%E5%AE%98%E7%BF%BB%E5%8F%8A%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3.html"><code>以太坊源码解读-第5.1讲-rpc官翻及个人理解</code></a>中描述，我们知道上述代码中，<code>Service</code>对应的共有5个有效回调方法（也就是开放的方法），3个无效的回调方法，还有1个有效的订阅方法。在server.services中，是有两个服务的，是不是很好奇，其实在NewServer()时候，就会有一个rpc服务被添加进去的，具体可以看小编后面的介绍。<br>
需要知道，首字母为大写的方法名，被认为是对外开放的方法，不要问我为什么，后面代码里就是这么个逻辑。<br>
我们通过下面的测试用例来验证有效还是无效：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestServerRegisterName</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	server := NewServer()  <span class="comment">//server新实例</span></span><br><span class="line">	service := <span class="built_in">new</span>(Service)  <span class="comment">//具体某服务的实例</span></span><br><span class="line">	<span class="keyword">if</span> err := server.RegisterName(<span class="string">&quot;calc&quot;</span>, service); err != <span class="literal">nil</span> <span class="comment">//根据名称将某服务注册</span></span><br><span class="line">		t.Fatalf(<span class="string">&quot;%v&quot;</span>, err)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(server.services) != <span class="number">2</span>  <span class="comment">//是否有两个服务，其中一个是在NewServer)()时候添加的</span></span><br><span class="line">		t.Fatalf(<span class="string">&quot;Expected 2 service entries, got %d&quot;</span>, <span class="built_in">len</span>(server.services))</span><br><span class="line">	svc, ok := server.services[<span class="string">&quot;calc&quot;</span>]  <span class="comment">//获取某服务</span></span><br><span class="line">	<span class="keyword">if</span> !ok </span><br><span class="line">		t.Fatalf(<span class="string">&quot;Expected service calc to be registered&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(svc.callbacks) != <span class="number">5</span> <span class="comment">//是否有5个有效方法</span></span><br><span class="line">		t.Errorf(<span class="string">&quot;Expected 5 callbacks for service &#x27;calc&#x27;, got %d&quot;</span>, <span class="built_in">len</span>(svc.callbacks))</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(svc.subscriptions) != <span class="number">1</span>  <span class="comment">//是否有1个有效订阅方法</span></span><br><span class="line">		t.Errorf(<span class="string">&quot;Expected 1 subscription for service &#x27;calc&#x27;, got %d&quot;</span>, <span class="built_in">len</span>(svc.subscriptions))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后server_test.go中还有3个测试方法是用来测试<code>Service</code>中的每个方法是否正确，其中涉及到了rpc的方方面面。这几个测试方法小编就不列出来了，大家可以去看看，方法本身还是很容易理解的。</p>
<h3 id="server-go介绍">server.go介绍</h3>
<p>经过前面这么多的讲解，大家对rpc的server已经有了一些较为深刻的映像了吧？那我们就来看一下server.go中是如何实现server的。</p>
<h4 id="创建一个新server">创建一个新server</h4>
<p>需要先创建一个server，这样才能将service注册到该server中，具体是这样创建的，看代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">()</span></span> *Server &#123;</span><br><span class="line">	server := &amp;Server&#123; <span class="comment">//server先实例化</span></span><br><span class="line">		services: <span class="built_in">make</span>(serviceRegistry),  <span class="comment">//开辟存储service的空间</span></span><br><span class="line">		codecs:   set.New(),  <span class="comment">//不解释，看前面</span></span><br><span class="line">		run:      <span class="number">1</span>,  <span class="comment">//1,运行；非1不运行</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//注册一个默认的rpc服务，该服务可以提供server的一些基本信息，具体看前面小编描述的</span></span><br><span class="line">	rpcService := &amp;RPCService&#123;server&#125;  <span class="comment">//利用server生成一个rpcService，</span></span><br><span class="line">	server.RegisterName(MetadataApi, rpcService) <span class="comment">//MetadataApi=“rpc”</span></span><br><span class="line">	<span class="keyword">return</span> server</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码里，需要注意的是，初始化一个server，然后利用这个server生成一个rpcService，最后在用server把RPCService注册进去。<br>
RPCService的目的是给出server中的一些基本参数信息，目前来说，貌似只能给出拥有的service名称和对应的版本号，而且都是1.0。。。<br>
RPCService的定义以及它的方法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RPCService <span class="keyword">struct</span> &#123;   <span class="comment">//这个是RPCService的定义结构，很简单吧。。不解释</span></span><br><span class="line">	server *Server  <span class="comment">//可以看出，该server是指针引用进来的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *RPCService)</span></span> Modules() <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> &#123;</span><br><span class="line">	modules := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">	<span class="keyword">for</span> name := <span class="keyword">range</span> s.server.services &#123;</span><br><span class="line">		modules[name] = <span class="string">&quot;1.0&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> modules <span class="comment">//其实只是返回每个service的名称和其版本号。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>个人感觉，有点鸡肋额，，</p>
<h4 id="server所拥有的方法">server所拥有的方法</h4>
<p>server.go文件中，剩下的内容都是server结构体所对应的方法，都比较重要，我们一个个来介绍</p>
<h5 id="注册服务">注册服务</h5>
<p>前面我们一直在用server.RegisterName()来注册一个服务，但这个服务具体是怎么来执行呢？来，上一坨代码你就知道了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> RegisterName(name <span class="type">string</span>, rcvr <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> s.services == <span class="literal">nil</span> &#123;</span><br><span class="line">		s.services = <span class="built_in">make</span>(serviceRegistry)  <span class="comment">//开辟存储service的空间</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	svc := <span class="built_in">new</span>(service)</span><br><span class="line">	svc.typ = reflect.TypeOf(rcvr)</span><br><span class="line">	rcvrVal := reflect.ValueOf(rcvr)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> name == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;no service name for type %s&quot;</span>, svc.typ.String())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !isExported(reflect.Indirect(rcvrVal).Type().Name()) &#123; <span class="comment">//方法名中，首字母大写的被认为是对外开放的方法</span></span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%s is not exported&quot;</span>, reflect.Indirect(rcvrVal).Type().Name())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	methods, subscriptions := suitableCallbacks(rcvrVal, svc.typ)  <span class="comment">//将方法和订阅都反射解析出来</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若services中已经有了该service，则直接合并方法和订阅</span></span><br><span class="line">	<span class="keyword">if</span> regsvc, present := s.services[name]; present &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(methods) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(subscriptions) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;Service %T doesn&#x27;t have any suitable methods/subscriptions to expose&quot;</span>, rcvr)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, m := <span class="keyword">range</span> methods &#123;</span><br><span class="line">			regsvc.callbacks[formatName(m.method.Name)] = m</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, s := <span class="keyword">range</span> subscriptions &#123;</span><br><span class="line">			regsvc.subscriptions[formatName(s.method.Name)] = s</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	svc.name = name</span><br><span class="line">	svc.callbacks, svc.subscriptions = methods, subscriptions</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(svc.callbacks) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(svc.subscriptions) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;Service %T doesn&#x27;t have any suitable methods/subscriptions to expose&quot;</span>, rcvr)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s.services[svc.name] =   <span class="comment">//根据名称存入服务</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现：</p>
<ul>
<li>方法或订阅如果是对外开放的，首先要满足其名称的首字母是大写</li>
<li>调用utils.go中的suitableCallbacks()方法，使用service反射后的结果来判断是属于对外开放的方法还是订阅</li>
<li>如果server中先前已经注册过该服务，则将新传入的service和该服务合并。</li>
</ul>
<h5 id="servecodec-方法-异步处理请求">ServeCodec()方法，异步处理请求</h5>
<p>先来看代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> ServeCodec(codec ServerCodec, options CodecOption) &#123;</span><br><span class="line">	<span class="keyword">defer</span> codec.Close()</span><br><span class="line">	s.serveRequest(codec, <span class="literal">false</span>, options) <span class="comment">//具体实现后面再讲</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数codec中存储的是客户端发来的请求，经过处理后，会将响应结果写入codec中并返回给客户端。<br>
该方法处理完codec中的内容后，会调用codec.Close()接口方法，处理请求结束时候的一些操作。<br>
注意，看<code>s.serveRequest(codec, false, options)</code>，里面的<code>false</code>表示该方法是并发处理请求的</p>
<h5 id="servesinglerequest-方法-同步处理请求">ServeSingleRequest()方法，同步处理请求</h5>
<p>呵呵，这个方法和上面的那个方法刚好相反，是同步处理请求的，等处理结束后，整个过程才会结束。此结束不提供codec.Close()方法，不用想也该明白，同步结束了，后面该干嘛就干嘛。<br>
代码就不列出来了，自己YY。</p>
<h5 id="serverequest-方法-具体处理客户端发来的请求">serveRequest()方法，具体处理客户端发来的请求</h5>
<p>前面讲的两个方法，其实里面都是在调用这个方法的，这个也是我们服务器端的核心，下面小编就来好好探索一下。<br>
在讲之前，小编建议大家好好了解下go语言中并发与并行的一些机制，也是为了更好的读懂这一部分代码，小编整理了下面几篇文章，希望大家先好好读读：<br>
<a href="/articles/reprint/go/golang%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E2%80%94%E2%80%94goroutine%E5%92%8Cchannel%E7%9A%84%E8%AF%A6%E7%BB%86%E7%90%86%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89.html">golang语言并发与并行——goroutine和channel的详细理解（一）</a><br>
<a href="/articles/reprint/go/golang%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E2%80%94%E2%80%94goroutine%E5%92%8Cchannel%E7%9A%84%E8%AF%A6%E7%BB%86%E7%90%86%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89.html">golang语言并发与并行——goroutine和channel的详细理解（二）</a><br>
<a href="/articles/reprint/go/golang%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E2%80%94%E2%80%94goroutine%E5%92%8Cchannel%E7%9A%84%E8%AF%A6%E7%BB%86%E7%90%86%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89.html">golang语言并发与并行——goroutine和channel的详细理解（三）</a></p>
<p>这个方法，其实主要就执行了两个过程：解析读取发来的请求，执行处理请求。期间用到了很多锁和协程的概念，把该方法的主要代码列出来：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> serveRequest(codec ServerCodec, singleShot <span class="type">bool</span>, options CodecOption) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * golang中的同步是通过sync.WaitGroup来实现的．WaitGroup的功能：它实现了一个类似队列的结构，可以一直向队列中添加任务，当任务完成后便从队列中删除，如果队列中的任务没有完全完成，可以通过Wait()函数来出发阻塞，防止程序继续进行，直到所有的队列任务都完成为止．</span></span><br><span class="line"><span class="comment">	 * WaitGroup的特点是Wait()可以用来阻塞直到队列中的所有任务都完成时才解除阻塞，而不需要sleep一个固定的时间来等待．但是其缺点是无法指定固定的goroutine数目．可能通过使用channel解决此问题。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">var</span> pend  sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="comment">//结束时候的调用</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">const</span> size = <span class="number">64</span> &lt;&lt; <span class="number">10</span></span><br><span class="line">			buf := <span class="built_in">make</span>([]<span class="type">byte</span>, size)</span><br><span class="line">			buf = buf[:runtime.Stack(buf, <span class="literal">false</span>)]</span><br><span class="line">			log.Error(<span class="type">string</span>(buf))</span><br><span class="line">		&#125;</span><br><span class="line">		s.codecsMu.Lock()</span><br><span class="line">		s.codecs.Remove(codec)</span><br><span class="line">		s.codecsMu.Unlock()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//context.Background() 返回一个空的Context，这个空的Context一般用于整个Context树的根节点。</span></span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())  <span class="comment">//创建一个可取消的子Context</span></span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> options&amp;OptionSubscriptions == OptionSubscriptions &#123;</span><br><span class="line">		ctx = context.WithValue(ctx, notifierKey&#123;&#125;, newNotifier(codec))</span><br><span class="line">	&#125;</span><br><span class="line">	s.codecsMu.Lock()</span><br><span class="line">	<span class="comment">//接受一个*int32类型的指针值,并会返回该指针值指向的那个值</span></span><br><span class="line">	<span class="keyword">if</span> atomic.LoadInt32(&amp;s.run) != <span class="number">1</span> &#123; <span class="comment">// server stopped</span></span><br><span class="line">		s.codecsMu.Unlock()</span><br><span class="line">		<span class="keyword">return</span> &amp;shutdownError&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	s.codecs.Add(codec)  <span class="comment">//把请求加入集合</span></span><br><span class="line">	s.codecsMu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// test if the server is ordered to stop</span></span><br><span class="line">	<span class="keyword">for</span> atomic.LoadInt32(&amp;s.run) == <span class="number">1</span> &#123;  <span class="comment">//确保当前server没有停止</span></span><br><span class="line">		reqs, batch, err := s.readRequest(codec) <span class="comment">//从其中读到请求信息</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err.Error() != <span class="string">&quot;EOF&quot;</span> &#123;</span><br><span class="line">				log.Debug(fmt.Sprintf(<span class="string">&quot;read error %v\n&quot;</span>, err))</span><br><span class="line">				codec.Write(codec.CreateErrorResponse(<span class="literal">nil</span>, err))</span><br><span class="line">			&#125;</span><br><span class="line">			pend.Wait()</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//又是一堆验证</span></span><br><span class="line">		<span class="keyword">if</span> atomic.LoadInt32(&amp;s.run) != <span class="number">1</span> &#123; </span><br><span class="line">			err = &amp;shutdownError&#123;&#125;</span><br><span class="line">			<span class="keyword">if</span> batch &#123;</span><br><span class="line">				resps := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(reqs))</span><br><span class="line">				<span class="keyword">for</span> i, r := <span class="keyword">range</span> reqs &#123;</span><br><span class="line">					resps[i] = codec.CreateErrorResponse(&amp;r.id, err)</span><br><span class="line">				&#125;</span><br><span class="line">				codec.Write(resps)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				codec.Write(codec.CreateErrorResponse(&amp;reqs[<span class="number">0</span>].id, err))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> singleShot &#123;  <span class="comment">//非并发</span></span><br><span class="line">			<span class="keyword">if</span> batch &#123;</span><br><span class="line">				s.execBatch(ctx, codec, reqs)  <span class="comment">//批处理请求</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				s.exec(ctx, codec, reqs[<span class="number">0</span>])</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		pend.Add(<span class="number">1</span>) <span class="comment">//添加一个阻塞任务</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(reqs []*serverRequest, batch <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> pend.Done()  <span class="comment">//处理一个阻塞任务</span></span><br><span class="line">			<span class="keyword">if</span> batch &#123;</span><br><span class="line">				s.execBatch(ctx, codec, reqs) <span class="comment">//这个批处理请求</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				s.exec(ctx, codec, reqs[<span class="number">0</span>])  <span class="comment">//处理单个请求</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(reqs, batch)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从中我们得知，主要涉及到两个方法：</p>
<ul>
<li>readRequest(codec)<br>
该方法解析并读取有效的客户端请求，会区分哪些是方法，哪些是订阅，根据不同状况，将这些信息都组装到requests[]中；</li>
<li>execBatch()/exec()，用于处理requests[]请求。一个批量处理，一个是单一处理，然后回调。具体的解析，稍后专门来讲。</li>
</ul>
<h5 id="execbatch-exec">execBatch()/exec()</h5>
<p>这也是server的方法，前面也说了，这两个方法类似，都是处理请求的，一个批量处理，一个单个处理。<br>
小编就只列一下exec()的源码了：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> exec(ctx context.Context, codec ServerCodec, req *serverRequest) &#123;</span><br><span class="line">	<span class="keyword">var</span> response <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> callback <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">if</span> req.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		response = codec.CreateErrorResponse(&amp;req.id, req.err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		response, callback = s.handle(ctx, codec, req) <span class="comment">//处理请求</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := codec.Write(response); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Error(fmt.Sprintf(<span class="string">&quot;%v\n&quot;</span>, err))</span><br><span class="line">		codec.Close()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> callback != <span class="literal">nil</span> &#123;</span><br><span class="line">		callback()  <span class="comment">//执行回调</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法很简单，从头到尾，能入得了法眼的也只有里面涉及到的<code>handle()</code>方法了。这个<code>handle()</code>真正的处理了请求内容。<br>
接下来那就看一下这个handle()到底执行了哪些东西。</p>
<h5 id="handle-方法">handle()方法</h5>
<p>server中最长最重要的一个方法，用于真正的处理数据，代码如下：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> handle(ctx context.Context, codec ServerCodec, req *serverRequest) (<span class="keyword">interface</span>&#123;&#125;, <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> req.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> codec.CreateErrorResponse(&amp;req.id, req.err), <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> req.isUnsubscribe &#123; <span class="comment">// 取消订阅, 第一个参数必须是订阅id</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(req.args) &gt;= <span class="number">1</span> &amp;&amp; req.args[<span class="number">0</span>].Kind() == reflect.String &#123;</span><br><span class="line">			notifier, supported := NotifierFromContext(ctx)</span><br><span class="line">			<span class="keyword">if</span> !supported &#123; <span class="comment">// interface doesn&#x27;t support subscriptions (e.g. http)</span></span><br><span class="line">				<span class="keyword">return</span> codec.CreateErrorResponse(&amp;req.id, &amp;callbackError&#123;ErrNotificationsUnsupported.Error()&#125;), <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			subid := ID(req.args[<span class="number">0</span>].String())</span><br><span class="line">			<span class="keyword">if</span> err := notifier.unsubscribe(subid); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> codec.CreateErrorResponse(&amp;req.id, &amp;callbackError&#123;err.Error()&#125;), <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> codec.CreateResponse(req.id, <span class="literal">true</span>), <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> codec.CreateErrorResponse(&amp;req.id, &amp;invalidParamsError&#123;<span class="string">&quot;Expected subscription id as first argument&quot;</span>&#125;), <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果是订阅消息。 那么创建订阅。并激活订阅</span></span><br><span class="line">	<span class="keyword">if</span> req.callb.isSubscribe &#123;</span><br><span class="line">		subid, err := s.createSubscription(ctx, codec, req)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> codec.CreateErrorResponse(&amp;req.id, &amp;callbackError&#123;err.Error()&#125;), <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// active the subscription after the sub id was successfully sent to the client</span></span><br><span class="line">		activateSub := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			notifier, _ := NotifierFromContext(ctx)</span><br><span class="line">			notifier.activate(subid, req.svcname)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> codec.CreateResponse(req.id, subid), activateSub</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// regular RPC call, prepare arguments</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(req.args) != <span class="built_in">len</span>(req.callb.argTypes) &#123;</span><br><span class="line">		rpcErr := &amp;invalidParamsError&#123;fmt.Sprintf(<span class="string">&quot;%s%s%s expects %d parameters, got %d&quot;</span>,</span><br><span class="line">			req.svcname, serviceMethodSeparator, req.callb.method.Name,</span><br><span class="line">			<span class="built_in">len</span>(req.callb.argTypes), <span class="built_in">len</span>(req.args))&#125;</span><br><span class="line">		<span class="keyword">return</span> codec.CreateErrorResponse(&amp;req.id, rpcErr), <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	arguments := []reflect.Value&#123;req.callb.rcvr&#125;</span><br><span class="line">	<span class="keyword">if</span> req.callb.hasCtx &#123;</span><br><span class="line">		arguments = <span class="built_in">append</span>(arguments, reflect.ValueOf(ctx))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(req.args) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		arguments = <span class="built_in">append</span>(arguments, req.args...)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用提供的rpc方法，并获取reply</span></span><br><span class="line">	reply := req.callb.method.Func.Call(arguments)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(reply) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> codec.CreateResponse(req.id, <span class="literal">nil</span>), <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> req.callb.errPos &gt;= <span class="number">0</span> &#123; <span class="comment">// test if method returned an error</span></span><br><span class="line">		<span class="keyword">if</span> !reply[req.callb.errPos].IsNil() &#123;</span><br><span class="line">			e := reply[req.callb.errPos].Interface().(<span class="type">error</span>)</span><br><span class="line">			res := codec.CreateErrorResponse(&amp;req.id, &amp;callbackError&#123;e.Error()&#125;)</span><br><span class="line">			<span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> codec.CreateResponse(req.id, reply[<span class="number">0</span>].Interface()), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="stop-方法">Stop()方法</h5>
<p>好吧，server的最后一个方法，调用后，将停止接收请求，并且当阻塞队列中的消息处理结束后，则完整停止。代码就不列了。</p>
<p>至此，server.go内容到此结束。</p>
<h2 id="subscription-go">subscription.go</h2>
<p>发布/订阅相关，这里面封装了消息结构，是否订阅等操作，这块的代码其实很简单，有兴趣的再进一步研读吧，小编精力有限，这里就不细看了，待有机会需要了，再来好好读读。</p>
<h2 id="client-go-client-example-test-go-client-test-go源码">client.go/client_example_test.go/client_test.go源码</h2>
<p>大家有没有发现，前面一直在讲server相关，看得越多反而越迷茫，越往后，小编越迫切的想知道,client到底是怎样对接到server端的？<br>
这次，小编打算从client_example_test.go源码开始阅读代码了，这样子更容易理解<br>
打开<code>lient_example_test.go</code>你会发现，里面有一个客户端订阅消息的例子。来，还是先瞅一眼吧：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">	Number *big.Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleClientSubscription</span><span class="params">()</span></span> &#123;</span><br><span class="line">	client, _ := rpc.Dial(<span class="string">&quot;ws://127.0.0.1:8485&quot;</span>) <span class="comment">//客户端连接，</span></span><br><span class="line">	subch := <span class="built_in">make</span>(<span class="keyword">chan</span> Block)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">				time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">			&#125;</span><br><span class="line">			subscribeBlocks(client, subch)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">for</span> block := <span class="keyword">range</span> subch &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;latest block:&quot;</span>, block.Number)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subscribeBlocks</span><span class="params">(client *rpc.Client, subch <span class="keyword">chan</span> Block)</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), <span class="number">10</span>*time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	sub, err := client.EthSubscribe(ctx, subch, <span class="string">&quot;newBlocks&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;subscribe error:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> lastBlock Block</span><br><span class="line">	<span class="keyword">if</span> err := client.CallContext(ctx, &amp;lastBlock, <span class="string">&quot;eth_getBlockByNumber&quot;</span>, <span class="string">&quot;latest&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;can&#x27;t get latest block:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	subch &lt;- lastBlock</span><br><span class="line">	fmt.Println(<span class="string">&quot;connection lost: &quot;</span>, &lt;-sub.Err())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第1步-客户端连接">第1步–客户端连接</h3>
<p>首先映入眼帘的是<code>rpc.Dial(&quot;ws://127.0.0.1:8485&quot;)</code>，它是要连接到websocket服务器端，可以理解为<code>它就是为了建立起一个客户端</code>。我们跟着进入到<code>client.go</code>文件中，会发现它调用的是<code>DialContext()</code>方法，而该方法会根据传入的不同的url类型，选择具体的网络进行连接，可以看出它目前支持的是&quot;http&quot;, “https”, “ws” 以及 “wss”，若url没有头部，则认为是本地进行IPC连接。从上面例子我们可知传入的是<code>ws</code>协议的连接，因此，需要接入<code>DialWebsocket(ctx, rawurl, &quot;&quot;)</code>这个方法，具体来看一下该方法吧：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialWebsocket</span><span class="params">(ctx context.Context, endpoint, origin <span class="type">string</span>)</span></span> (*Client, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> origin == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">		<span class="keyword">if</span> origin, err = os.Hostname(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> strings.HasPrefix(endpoint, <span class="string">&quot;wss&quot;</span>) &#123; </span><br><span class="line">			origin = <span class="string">&quot;https://&quot;</span> + strings.ToLower(origin) <span class="comment">//origin为websocket客户端源</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			origin = <span class="string">&quot;http://&quot;</span> + strings.ToLower(origin)  <span class="comment">//</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	config, err := websocket.NewConfig(endpoint, origin)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> newClient(ctx, <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> (net.Conn, <span class="type">error</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> wsDialContext(ctx, config)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中可知，生成对应的origin，然后进一步配置websocket。origin官方的描述意思是<code>一个WebSocket客户端源</code>。<br>
一切准备就绪以后，就会执行newClient()方法来生成客户端，下面来讲一下该方法。</p>
<h3 id="第2步-客户端连接内部机制">第2步–客户端连接内部机制</h3>
<p>好吧，真正整合建立客户端连接的方法还是newClient()，该方法有两个参数，一个是上下文，一个是某协议生成并返回连接的方法（ws或者http）<br>
先来看代码：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newClient</span><span class="params">(initctx context.Context, connectFunc <span class="keyword">func</span>(context.Context)</span></span> (net.Conn, <span class="type">error</span>)) (*Client, <span class="type">error</span>) &#123;</span><br><span class="line">	conn, err := connectFunc(initctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	_, isHTTP := conn.(*httpConn)</span><br><span class="line"></span><br><span class="line">	c := &amp;Client&#123;</span><br><span class="line">		writeConn:   conn,</span><br><span class="line"></span><br><span class="line">		isHTTP:      isHTTP,</span><br><span class="line">		connectFunc: connectFunc,</span><br><span class="line">		<span class="built_in">close</span>:       <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		didQuit:     <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		reconnected: <span class="built_in">make</span>(<span class="keyword">chan</span> net.Conn),</span><br><span class="line">		readErr:     <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>),</span><br><span class="line">		readResp:    <span class="built_in">make</span>(<span class="keyword">chan</span> []*jsonrpcMessage),</span><br><span class="line">		requestOp:   <span class="built_in">make</span>(<span class="keyword">chan</span> *requestOp),</span><br><span class="line">		sendDone:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>, <span class="number">1</span>),</span><br><span class="line">		respWait:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*requestOp),</span><br><span class="line">		subs:        <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*ClientSubscription),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !isHTTP &#123;</span><br><span class="line">		<span class="keyword">go</span> c.dispatch(conn)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码主要就是两个意思，先判断某协议的连接是不是http形式的，如果不是，则会启动一个goroutine调用dispatch方法。 这个方法下一个步骤专门来讲。<br>
另外在此小编补充一句，HTTP协议和非HTTP协议有不同的处理流程， HTTP协议不支持长连接， 只支持一个请求对应一个回应的这种模式，同时也不支持发布/订阅模式。<br>
这里还涉及到了client的结构，为了更好的理解，小编还是把这个结构列出来吧：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">	idCounter   <span class="type">uint32</span></span><br><span class="line">	<span class="comment">//生成连接的函数，客户端会调用这个函数生成一个网络连接对象。</span></span><br><span class="line">	connectFunc <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> (net.Conn, <span class="type">error</span>)</span><br><span class="line">	<span class="comment">//HTTP协议和非HTTP协议有不同的处理流程， HTTP协议不支持长连接， 只支持一个请求对应一个回应的这种模式，同时也不支持发布/订阅模式。 </span></span><br><span class="line">	isHTTP      <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过这里的注释可以看到，writeConn是调用这用来写入请求的网络连接对象，</span></span><br><span class="line">	<span class="comment">//只有在dispatch方法外面调用才是安全的，而且需要通过给requestOp队列发送请求来获取锁，</span></span><br><span class="line">	<span class="comment">//获取锁之后就可以把请求写入网络，写入完成后发送请求给sendDone队列来释放锁，供其它的请求使用。</span></span><br><span class="line">	writeConn net.Conn</span><br><span class="line"></span><br><span class="line">	<span class="comment">// for dispatch</span></span><br><span class="line">	<span class="comment">//下面有很多的channel，channel一般来说是goroutine之间用来通信的通道，后续会随着代码介绍channel是如何使用的。</span></span><br><span class="line">	<span class="built_in">close</span>       <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	didQuit     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;                  <span class="comment">// closed when client quits</span></span><br><span class="line">	reconnected <span class="keyword">chan</span> net.Conn                  <span class="comment">// where write/reconnect sends the new connection</span></span><br><span class="line">	readErr     <span class="keyword">chan</span> <span class="type">error</span>                     <span class="comment">// errors from read</span></span><br><span class="line">	readResp    <span class="keyword">chan</span> []*jsonrpcMessage         <span class="comment">// valid messages from read</span></span><br><span class="line">	requestOp   <span class="keyword">chan</span> *requestOp                <span class="comment">// for registering response IDs</span></span><br><span class="line">	sendDone    <span class="keyword">chan</span> <span class="type">error</span>                     <span class="comment">// signals write completion, releases write lock</span></span><br><span class="line">	respWait    <span class="keyword">map</span>[<span class="type">string</span>]*requestOp          <span class="comment">// active requests</span></span><br><span class="line">	subs        <span class="keyword">map</span>[<span class="type">string</span>]*ClientSubscription <span class="comment">// active subscriptions</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第3步-非http协议的dispatch处理">第3步–非http协议的dispatch处理</h3>
<p>上一步中我们得知，因为我们的协议是<code>ws</code>因此会启动一个goroutine调用dispatch方法。dispatch方法是整个client的指挥中心，通过channel来和其他的goroutine来进行通信，获取信息，根据信息做出各种决策。<br>
这个方法是客户端的一个核心方法，先来看代码吧：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dispatch is the main loop of the client.</span></span><br><span class="line"><span class="comment">// It sends read messages to waiting calls to Call and BatchCall</span></span><br><span class="line"><span class="comment">// and subscription notifications to registered subscriptions.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> dispatch(conn net.Conn) &#123;</span><br><span class="line">	<span class="comment">// Spawn the initial read loop.</span></span><br><span class="line">	<span class="keyword">go</span> c.read(conn)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		lastOp        *requestOp    <span class="comment">// tracks last send operation</span></span><br><span class="line">		requestOpLock = c.requestOp <span class="comment">// nil while the send lock is held</span></span><br><span class="line">		reading       = <span class="literal">true</span>        <span class="comment">// if true, a read loop is running</span></span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(c.didQuit)</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		c.closeRequestOps(ErrClientQuit)</span><br><span class="line">		conn.Close()</span><br><span class="line">		<span class="keyword">if</span> reading &#123;</span><br><span class="line">			<span class="comment">// Empty read channels until read is dead.</span></span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;-c.readResp:</span><br><span class="line">				<span class="keyword">case</span> &lt;-c.readErr:</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-c.<span class="built_in">close</span>:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// Read path.</span></span><br><span class="line">		<span class="keyword">case</span> batch := &lt;-c.readResp:</span><br><span class="line">			<span class="comment">//读取到一个回应。调用相应的方法处理</span></span><br><span class="line">			<span class="keyword">for</span> _, msg := <span class="keyword">range</span> batch &#123;</span><br><span class="line">				<span class="keyword">switch</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> msg.isNotification():</span><br><span class="line">					log.Trace(<span class="string">&quot;&quot;</span>, <span class="string">&quot;msg&quot;</span>, log.Lazy&#123;Fn: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> fmt.Sprint(<span class="string">&quot;&lt;-readResp: notification &quot;</span>, msg)</span><br><span class="line">					&#125;&#125;)</span><br><span class="line">					c.handleNotification(msg)</span><br><span class="line">				<span class="keyword">case</span> msg.isResponse():</span><br><span class="line">					log.Trace(<span class="string">&quot;&quot;</span>, <span class="string">&quot;msg&quot;</span>, log.Lazy&#123;Fn: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> fmt.Sprint(<span class="string">&quot;&lt;-readResp: response &quot;</span>, msg)</span><br><span class="line">					&#125;&#125;)</span><br><span class="line">					c.handleResponse(msg)</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					log.Debug(<span class="string">&quot;&quot;</span>, <span class="string">&quot;msg&quot;</span>, log.Lazy&#123;Fn: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> fmt.Sprint(<span class="string">&quot;&lt;-readResp: dropping weird message&quot;</span>, msg)</span><br><span class="line">					&#125;&#125;)</span><br><span class="line">					<span class="comment">// <span class="doctag">TODO:</span> maybe close</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> err := &lt;-c.readErr:</span><br><span class="line">			<span class="comment">//接收到读取失败信息，这个是read线程传递过来的。</span></span><br><span class="line">			log.Debug(fmt.Sprintf(<span class="string">&quot;&lt;-readErr: %v&quot;</span>, err))</span><br><span class="line">			c.closeRequestOps(err)</span><br><span class="line">			conn.Close()</span><br><span class="line">			reading = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> newconn := &lt;-c.reconnected:</span><br><span class="line">			<span class="comment">//接收到一个重连接信息</span></span><br><span class="line">			log.Debug(fmt.Sprintf(<span class="string">&quot;&lt;-reconnected: (reading=%t) %v&quot;</span>, reading, conn.RemoteAddr()))</span><br><span class="line">			<span class="keyword">if</span> reading &#123;</span><br><span class="line">				<span class="comment">//等待之前的连接读取完成。</span></span><br><span class="line">				<span class="comment">// Wait for the previous read loop to exit. This is a rare case.</span></span><br><span class="line">				conn.Close()</span><br><span class="line">				&lt;-c.readErr</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//开启阅读的goroutine</span></span><br><span class="line">			<span class="keyword">go</span> c.read(newconn)</span><br><span class="line">			reading = <span class="literal">true</span></span><br><span class="line">			conn = newconn</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Send path.</span></span><br><span class="line">		<span class="keyword">case</span> op := &lt;-requestOpLock:</span><br><span class="line">			<span class="comment">// Stop listening for further send ops until the current one is done.</span></span><br><span class="line">			<span class="comment">//接收到一个requestOp消息，那么设置requestOpLock为空，</span></span><br><span class="line">			<span class="comment">//这个时候如果有其他人也希望发送op到requestOp，会因为没有人处理而阻塞。</span></span><br><span class="line">			requestOpLock = <span class="literal">nil</span></span><br><span class="line">			lastOp = op</span><br><span class="line">			<span class="comment">//把这个op加入等待队列。</span></span><br><span class="line">			<span class="keyword">for</span> _, id := <span class="keyword">range</span> op.ids &#123;</span><br><span class="line">				c.respWait[<span class="type">string</span>(id)] = op</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> err := &lt;-c.sendDone:</span><br><span class="line">			<span class="comment">//当op的请求信息已经发送到网络上。会发送信息到sendDone。如果发送过程出错，那么err !=nil。</span></span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="comment">// Remove response handlers for the last send. We remove those here</span></span><br><span class="line">				<span class="comment">// because the error is already handled in Call or BatchCall. When the</span></span><br><span class="line">				<span class="comment">// read loop goes down, it will signal all other current operations.</span></span><br><span class="line">				<span class="comment">//把所有的id从等待队列删除。</span></span><br><span class="line">				<span class="keyword">for</span> _, id := <span class="keyword">range</span> lastOp.ids &#123;</span><br><span class="line">					<span class="built_in">delete</span>(c.respWait, <span class="type">string</span>(id))</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Listen for send ops again.</span></span><br><span class="line">			<span class="comment">//重新开始处理requestOp的消息。</span></span><br><span class="line">			requestOpLock = c.requestOp</span><br><span class="line">			lastOp = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ps：由于工作上的一些意外，小编需要尽早结束本篇文章，后面剩余部分内容就全是[github-ZtesoftCS](https://github.com/ZtesoftCS/go-ethereum-code-analysis/blob/master/rpc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md)中的了，在此先感谢该作者了</code><br>
下面通过下面这种图来说明dispatch的主要流程。下面图片中圆形是线程。 蓝色矩形是channel。 箭头代表了channel的数据流动方向。</p>
<img src="/articles/e10014d8/1.png" class="" title="dispatch流程">
<ul>
<li>多线程串行发送请求到网络上的流程 首先发送requestOp请求到dispatch获取到锁， 然后把请求信息写入到网络，然后发送sendDone信息到dispatch解除锁。 通过requestOp和sendDone这两个channel以及dispatch代码的配合完成了串行的发送请求到网络上的功能。</li>
<li>读取返回信息然后返回给调用者的流程。 把请求信息发送到网络上之后， 内部的goroutine read会持续不断的从网络上读取信息。 read读取到返回信息之后，通过readResp队列发送给dispatch。 dispatch查找到对应的调用者，然后把返回信息写入调用者的resp队列中。完成返回信息的流程。</li>
<li>重连接流程。 重连接在外部调用者写入失败的情况下被外部调用者主动调用。 调用完成后发送新的连接给dispatch。 dispatch收到新的连接之后，会终止之前的连接，然后启动新的read goroutine来从新的连接上读取信息。</li>
<li>关闭流程。 调用者调用Close方法，Close方法会写入信息到close队列。 dispatch接收到close信息之后。 关闭didQuit队列，关闭连接，等待read goroutine停止。 所有等待在didQuit队列上面的客户端调用全部返回。</li>
</ul>
<p>订阅部分小编暂时就不讲了。</p>
<h2 id="全文总结">全文总结</h2>
<p>本篇写的有点仓促，小编也认为写的很不合格，由于一些意外，小编源码阅读暂时停止更新。<br>
后面若有机会，会修正本文内容的。</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊源码解读-第5.1讲-rpc官翻及个人理解</title>
    <url>/articles/25c7447/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>rpc在ethereum中是很重要的一个模块，官方在该模块的一个叫做<code>doc.go</code>的文件中专门介绍了RPC的机制。本文小编会带着自己的理解逐步翻译<code>doc.go</code>中对RPC机制的描述。</p>
<span id="more"></span>
<h2 id="什么是rpc">什么是RPC</h2>
<p>RPC全称是<code>Remote Procedure Call</code>，翻译过来就是远程程序调用，通俗的说就是远程服务器开放出某程序的方法(接口)，客户端通过网络或者其它的I/O通道调用这个方法，从而完成交互。又或者用另一种通俗的解释：调用远程计算机上的服务，就像调用本地服务一样。</p>
<p>当一个service创建后，将其注册到服务器上，这样该service就可以被外界的客户端访问了。<br>
符合以下标准的方法可用于远程访问：</p>
<ul>
<li>对象必须导出</li>
<li>方法必须导出</li>
<li>方法返回0，1（响应或错误）或2（响应和错误）值</li>
<li>方法参数必须导出或是内置类型</li>
<li>方法返回值必须导出或是内置类型</li>
</ul>
<p>RPC在此支持使用订阅来支持发布/订阅模式。要满足此类模式的方法必须满足如下条件：</p>
<ul>
<li>对象必须导出</li>
<li>方法必须导出</li>
<li>第一个方法参数类型必须是context.Context</li>
<li>方法参数必须导出或内置类型</li>
<li>方法必须返回<code>元组订阅</code>和<code>错误</code></li>
</ul>
<p>发生以下情况时，订阅将会被删除：</p>
<ul>
<li>用户发出取消订阅的请求</li>
<li>创建订阅的连接被关闭。这种情况可能由客户端或者服务器触发。 服务器在写入出错或者是通知队列长度太大的时候会选择关闭连接。</li>
</ul>
<p><code>ps</code>：被调用者认为是服务器，调用者认为是客户端</p>
<h2 id="案例">案例</h2>
<h3 id="示例1-基本操作">示例1-基本操作:</h3>
<p>如果返回的<code>error</code>不为空，则返回的<code>int</code>会被忽略，那<code>error</code>会被发送给客户端；反之若<code>error</code>为空，则发送<code>int</code>给客户端。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *CalcService)</span></span> Add(a, b <span class="type">int</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<h3 id="示例2-参数支持指针">示例2-参数支持指针</h3>
<p>关于这个示例官方写了很多解释，但越解释越乱，按小编的意思，知道可以接收指针就行。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *CalService)</span></span> Add(a, b <span class="type">int</span>, mod *<span class="type">int</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<h3 id="示例3-服务器端接收">示例3-服务器端接收</h3>
<p>服务器端提供一个ServeCodec方法，用来接收一个ServeCodec实例，其中的codec用来读取客户端发出的request。codec处理request后，会把response返回给客户端。<br>
服务器的这些请求或者响应，当然是并发的，不用解释了吧。<br>
下面来看一个json形式的codec例子：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> CalculatorService <span class="keyword">struct</span> &#123;&#125;  <span class="comment">//定义服务</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//CalculatorService对应的第一个方法 </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *CalculatorService)</span></span> Add(a, b <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//CalculatorService对应的第二个方法</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *CalculatorService Div(a, b <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> b == <span class="number">0</span> </span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;divide by zero&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> a/b, <span class="literal">nil</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> calculator := <span class="built_in">new</span>(CalculatorService)  <span class="comment">// 实例化</span></span><br><span class="line"> server := NewServer()  <span class="comment">//服务管理器</span></span><br><span class="line"> server.RegisterName(<span class="string">&quot;calculator&quot;</span>, calculator)  <span class="comment">//注册服务</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//监听获取回调</span></span><br><span class="line"> l, _ := net.ListenUnix(<span class="string">&quot;unix&quot;</span>, &amp;net.UnixAddr&#123;Net: <span class="string">&quot;unix&quot;</span>, Name: <span class="string">&quot;/tmp/calculator.sock&quot;</span>&#125;)</span><br><span class="line"> <span class="keyword">for</span> &#123;</span><br><span class="line">	c, _ := l.AcceptUnix()</span><br><span class="line">	codec := v2.NewJSONCodec(c)</span><br><span class="line">	<span class="keyword">go</span> server.ServeCodec(codec) <span class="comment">//</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例4-发布-订阅">示例4-发布/订阅</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *BlockChainService)</span></span> NewBlocks(ctx context.Context) (Subscription, <span class="type">error</span>) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="全文总结">全文总结</h2>
<p>整体来说，本文主要还是介绍了rpc的一些基本规范，真正的掌握这个内容，还需要我们再代码中来理解。小编下一部分来解析rpc模块的具体代码。</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊源码解读-第4讲-ethdb模块源码解读</title>
    <url>/articles/f54b1404/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>看了trie模块的源码，我们知道了其中的节点数据是通过ethdb来进行磁盘db的读写操作的。其实ethdb是依赖google的一个开源kv数据库levelDB实现的。最终所有的数据都是存储在levelDB中。<br>
我们会很好奇，什么是levelDB？在ethdb中是如何处理levelDB的？下面小编一步步来揭开它的面纱。</p>
<span id="more"></span>
<h2 id="什么是leveldb">什么是levelDB</h2>
<h3 id="特点：">特点：</h3>
<ul>
<li>效率高，支持billion级别的数据量</li>
<li>key和value都是任意长度的字节数组；</li>
<li>entry（即一条K-V记录）默认是按照key的字典顺序存储的，当然开发者也可以重载这个排序函数；</li>
<li>提供的基本操作接口：Put()、Delete()、Get()、Batch()；</li>
<li>支持批量操作以原子操作进行；</li>
<li>可以创建数据全景的snapshot(快照)，并允许在快照中查找数据；</li>
<li>可以通过前向（或后向）迭代器遍历数据（迭代器会隐含的创建一个snapshot）；</li>
<li>自动使用Snappy压缩数据；</li>
<li>可移植性；</li>
</ul>
<h3 id="限制：">限制：</h3>
<ul>
<li>非关系型数据模型（NoSQL），不支持sql语句，也不支持索引；</li>
<li>一次只允许一个进程访问一个特定的数据库；</li>
<li>没有内置的C/S架构，就是说不包含网络服务架构，但开发者可以使用LevelDB库自己封装一个server；</li>
</ul>
<h2 id="ethdb模块概述">ethdb模块概述</h2>
<p>这个模块不复杂，直接看里面的文件结构：<br>
.<br>
|____interface.go  数据库接口定义<br>
|____database.go  对levelDB进行封装<br>
|____database_test.go  测试案例，本文不讲这个，模块不复杂，不需要专门去探讨案例<br>
|____memory_database.go  用于db测试，生产中不可使用。在trie模块中的测试案例应该见过很多次这个东西了<br>
一目了然，只有四个文件。下面我们一个个来讲</p>
<h2 id="interface-go源码解读">interface.go源码解读</h2>
<p>这个是需要第一个掌握的源码内容，因为它为在以太坊中操作db定义了一套规则，因此，要想了解ethdb模块就得先了解这个文件。<br>
接口规范，代码不多，老规矩，先贴代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> IdealBatchSize = <span class="number">100</span> * <span class="number">1024</span> <span class="comment">//批处理数据的时候用的值，这个值是根据实际调试经验确定的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于普通操作和批量操作写入数据</span></span><br><span class="line"><span class="keyword">type</span> Putter <span class="keyword">interface</span> &#123;</span><br><span class="line">	Put(key []<span class="type">byte</span>, value []<span class="type">byte</span>) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义了所有的数据库操作， 所有的方法都是多线程安全的。</span></span><br><span class="line"><span class="keyword">type</span> Database <span class="keyword">interface</span> &#123;</span><br><span class="line">	Putter</span><br><span class="line">	Get(key []<span class="type">byte</span>) ([]<span class="type">byte</span>, <span class="type">error</span>) <span class="comment">//获取</span></span><br><span class="line">	Has(key []<span class="type">byte</span>) (<span class="type">bool</span>, <span class="type">error</span>)  <span class="comment">//判断</span></span><br><span class="line">	Delete(key []<span class="type">byte</span>) <span class="type">error</span>  <span class="comment">//删除</span></span><br><span class="line">	Close()  <span class="comment">//关闭</span></span><br><span class="line">	NewBatch() Batch  <span class="comment">//实例化新的批处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//批量操作接口，不能多线程同时使用，当Write方法被调用的时候，数据库会提交写入的更改。</span></span><br><span class="line"><span class="keyword">type</span> Batch <span class="keyword">interface</span> &#123;</span><br><span class="line">	Putter</span><br><span class="line">	ValueSize() <span class="type">int</span>   <span class="comment">//批处理中的数据量</span></span><br><span class="line">	Write() <span class="type">error</span></span><br><span class="line">	Reset()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到了吧，<code>全都是字节形式的数据。</code><br>
主要就是两大类，批处理操作和普通操作，两种方式的数据库操作。<br>
没什么可以解释的</p>
<h2 id="memory-database-go-源码解读">memory_database.go 源码解读</h2>
<p>看过trie模块代码的同学，应该很熟悉这个文件，官方解释说该文件仅供测试使用，可以说，这个文件只是模拟的一个数据库，并没有真正对接到levelDB，只是为了方便数据库的测试操作而使用。先来看代码，然后再解释，先上一坨代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个模拟存储数据的&lt;k,v&gt;数据库，可以看到，数据是存在了内存map中</span></span><br><span class="line"><span class="keyword">type</span> MemDatabase <span class="keyword">struct</span> &#123;</span><br><span class="line">	db   <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">byte</span></span><br><span class="line">	lock sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于实例化数据库，此处是为map开辟空间，没有指定具体大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMemDatabase</span><span class="params">()</span></span> (*MemDatabase, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;MemDatabase&#123;</span><br><span class="line">		db: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">byte</span>),</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于实例化数据库，此处是为map开辟空间，指定了具体大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMemDatabaseWithCap</span><span class="params">(size <span class="type">int</span>)</span></span> (*MemDatabase, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;MemDatabase&#123;</span><br><span class="line">		db: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">byte</span>, size),</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数据存放到模拟的数据库里，也就是那个map里</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *MemDatabase)</span></span> Put(key []<span class="type">byte</span>, value []<span class="type">byte</span>) <span class="type">error</span> &#123;</span><br><span class="line">	db.lock.Lock() <span class="comment">//注意读写锁额</span></span><br><span class="line">	<span class="keyword">defer</span> db.lock.Unlock() <span class="comment">//defer是干嘛的，小编在别的文章里解释好多遍了。。</span></span><br><span class="line"></span><br><span class="line">	db.db[<span class="type">string</span>(key)] = common.CopyBytes(value) <span class="comment">//　好，插进去了</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据key检测某个数据是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *MemDatabase)</span></span> Has(key []<span class="type">byte</span>) (<span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	db.lock.RLock()  <span class="comment">//只读锁</span></span><br><span class="line">	<span class="keyword">defer</span> db.lock.RUnlock()</span><br><span class="line"></span><br><span class="line">	_, ok := db.db[<span class="type">string</span>(key)]</span><br><span class="line">	<span class="keyword">return</span> ok, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据key获取某value</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *MemDatabase)</span></span> Get(key []<span class="type">byte</span>) ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	db.lock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> db.lock.RUnlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> entry, ok := db.db[<span class="type">string</span>(key)]; ok &#123;</span><br><span class="line">		<span class="keyword">return</span> common.CopyBytes(entry), <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;not found&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取db中所有的key，这样就可以在内存中验证某数据是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *MemDatabase)</span></span> Keys() [][]<span class="type">byte</span> &#123;</span><br><span class="line">	db.lock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> db.lock.RUnlock()</span><br><span class="line"></span><br><span class="line">	keys := [][]<span class="type">byte</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> key := <span class="keyword">range</span> db.db &#123;</span><br><span class="line">		keys = <span class="built_in">append</span>(keys, []<span class="type">byte</span>(key))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> keys</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除数据，没啥解释的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *MemDatabase)</span></span> Delete(key []<span class="type">byte</span>) <span class="type">error</span> &#123;</span><br><span class="line">	db.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> db.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">delete</span>(db.db, <span class="type">string</span>(key))</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭，但是这是模拟数据库，因此也没什么可以关闭的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *MemDatabase)</span></span> Close() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化批量操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *MemDatabase)</span></span> NewBatch() Batch &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;memBatch&#123;db: db&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//db长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *MemDatabase)</span></span> Len() <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(db.db) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给批量操作定义一个要写入的数据的结构体</span></span><br><span class="line"><span class="keyword">type</span> kv <span class="keyword">struct</span>&#123; k, v []<span class="type">byte</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内存中模拟的批量数据的格式</span></span><br><span class="line"><span class="keyword">type</span> memBatch <span class="keyword">struct</span> &#123;</span><br><span class="line">	db     *MemDatabase <span class="comment">//数据库</span></span><br><span class="line">	writes []kv  <span class="comment">//写入的数据长度</span></span><br><span class="line">	size   <span class="type">int</span>   <span class="comment">//写入的数据长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入数据前的预处理，把外部批量导入的数据，进行批处理结构体格式的组合，</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *memBatch)</span></span> Put(key, value []<span class="type">byte</span>) <span class="type">error</span> &#123;</span><br><span class="line">	b.writes = <span class="built_in">append</span>(b.writes, kv&#123;common.CopyBytes(key), common.CopyBytes(value)&#125;)</span><br><span class="line">	b.size += <span class="built_in">len</span>(value)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把预处理好的数据插入到模拟数据库中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *memBatch)</span></span> Write() <span class="type">error</span> &#123;</span><br><span class="line">	b.db.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> b.db.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, kv := <span class="keyword">range</span> b.writes &#123;</span><br><span class="line">		b.db.db[<span class="type">string</span>(kv.k)] = kv.v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//批处理数据的长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *memBatch)</span></span> ValueSize() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> b.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复原批处理，毕竟这只是数据库中间的操作过程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *memBatch)</span></span> Reset() &#123;</span><br><span class="line">	b.writes = b.writes[:<span class="number">0</span>]</span><br><span class="line">	b.size = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个文件只是一个模拟的数据库，其实都是在内存中操作的。两部分，一个是数据库的操作，一个是批处理的操作。<br>
上面小编基本都注释好了，应该很好理解吧？那小编就开始下一部分的讲解啦</p>
<h2 id="database-go源码解读">database.go源码解读</h2>
<p>本来小编是想通过database_test.go中的测试用例来解读database.go源码的，但综合前面已经介绍的数据库相关内容，直接解释database.go源码应该更好一些。<br>
这个文件真正的封装了google的levelDB，让我们来揭开一下这个神秘的面纱。</p>
<h3 id="所引用的包">所引用的包</h3>
<p>先来看看它引用了哪些包：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/ethereum/go-ethereum/log&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/ethereum/go-ethereum/metrics&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/syndtr/goleveldb/leveldb&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/syndtr/goleveldb/leveldb/errors&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/syndtr/goleveldb/leveldb/filter&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/syndtr/goleveldb/leveldb/iterator&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/syndtr/goleveldb/leveldb/opt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/syndtr/goleveldb/leveldb/util&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>可以看出，除了引用了go本身的包的，还引用了<code>github.com/syndtr/goleveldb/leveldb</code>中的东西，这个是使用go封装过的leveldb，在github中可以找到该源码。</p>
<h3 id="db数据结构">db数据结构</h3>
<p>接着来看一下以太坊对levelDB的结构的封装</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> OpenFileLimit = <span class="number">64</span>  <span class="comment">//限制同时最多只能打开64个文件？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义了一套用于记录操作db的结构</span></span><br><span class="line"><span class="keyword">type</span> LDBDatabase <span class="keyword">struct</span> &#123;</span><br><span class="line">	fn <span class="type">string</span>      <span class="comment">// 用于存放报告的文件</span></span><br><span class="line">	db *leveldb.DB <span class="comment">// google的levelDB实例</span></span><br><span class="line"></span><br><span class="line">	compTimeMeter  metrics.Meter <span class="comment">// 计算压缩数据所要花费的时间</span></span><br><span class="line">	compReadMeter  metrics.Meter <span class="comment">// 压缩期间读取的数据</span></span><br><span class="line">	compWriteMeter metrics.Meter <span class="comment">// 压缩期间写入的数据</span></span><br><span class="line">	diskReadMeter  metrics.Meter <span class="comment">// 计算读取数据影响到的条数</span></span><br><span class="line">	diskWriteMeter metrics.Meter <span class="comment">// 计算写入数据影响到的条数</span></span><br><span class="line"></span><br><span class="line">	quitLock sync.Mutex      <span class="comment">// 停止时候的访问保护</span></span><br><span class="line">	quitChan <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="type">error</span> <span class="comment">// 退出db前的处理</span></span><br><span class="line"></span><br><span class="line">	log log.Logger <span class="comment">// 日志 db路径跟踪</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先看到的是一堆的<code>metrics</code>，这是以太坊自己用于统计数据，评估性能的模块，姑且不去考虑。<br>
从结构中我们也大致了解到，这它主要就是用来记录数据库的使用情况，加上退出db时候的处理。</p>
<h3 id="ldbdatabase用于实例化的方法">LDBDatabase用于实例化的方法</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLDBDatabase</span><span class="params">(file <span class="type">string</span>, cache <span class="type">int</span>, handles <span class="type">int</span>)</span></span> (*LDBDatabase, <span class="type">error</span>) &#123;</span><br><span class="line">	logger := log.New(<span class="string">&quot;database&quot;</span>, file)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 确保有一些缓存和文件</span></span><br><span class="line">	<span class="keyword">if</span> cache &lt; <span class="number">16</span> </span><br><span class="line">		cache = <span class="number">16</span></span><br><span class="line">	<span class="keyword">if</span> handles &lt; <span class="number">16</span> </span><br><span class="line">		handles = <span class="number">16</span></span><br><span class="line">	logger.Info(<span class="string">&quot;Allocated cache and file handles&quot;</span>, <span class="string">&quot;cache&quot;</span>, cache, <span class="string">&quot;handles&quot;</span>, handles)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化，性能调优相关 leveldb</span></span><br><span class="line">	db, err := leveldb.OpenFile(file, &amp;opt.Options&#123;</span><br><span class="line">		OpenFilesCacheCapacity: handles,</span><br><span class="line">		BlockCacheCapacity:     cache / <span class="number">2</span> * opt.MiB,</span><br><span class="line">		WriteBuffer:            cache / <span class="number">4</span> * opt.MiB, </span><br><span class="line">		Filter:                 filter.NewBloomFilter(<span class="number">10</span>),</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> _, corrupted := err.(*errors.ErrCorrupted); corrupted </span><br><span class="line">		db, err = leveldb.RecoverFile(file, <span class="literal">nil</span>)</span><br><span class="line">	<span class="comment">// (Re)check for errors and abort if opening of the db failed</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	<span class="keyword">return</span> &amp;LDBDatabase&#123;</span><br><span class="line">		fn:  file,</span><br><span class="line">		db:  db,</span><br><span class="line">		log: logger,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个大体上就是levelDB的初始化操作，被外面的LDBDatabase封装了</p>
<h3 id="ldbdatabase的方法">LDBDatabase的方法</h3>
<p>LDBDatabase的方法还是需要关注的。<br>
封装之后的代码是支持多线程同时访问的，LDBDatabase中的方法是不需要进行安全处理的，可直接调用。</p>
<h4 id="先来看一些简单的方法">先来看一些简单的方法</h4>
<p>都是一些比较基础的方法操作，有一个需要注意：插入数据时候，其实是插入到了内存队列中，并未写入db磁盘。而删除时候会把队列和磁盘的都删除了。<br>
剩下的小编就不解释了，都在代码里标注了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取db的路径</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *LDBDatabase)</span></span> Path() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> db.fn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到leveldb的缓存队列中了，此时并没有写入磁盘</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *LDBDatabase)</span></span> Put(key []<span class="type">byte</span>, value []<span class="type">byte</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> db.db.Put(key, value, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//某key对应的数据是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *LDBDatabase)</span></span> Has(key []<span class="type">byte</span>) (<span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> db.db.Has(key, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 某key对应的数据若存在，则返回数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *LDBDatabase)</span></span> Get(key []<span class="type">byte</span>) ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	dat, err := db.db.Get(key, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	<span class="keyword">return</span> dat, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据key删除缓存队列和磁盘中的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *LDBDatabase)</span></span> Delete(key []<span class="type">byte</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> db.db.Delete(key, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历的迭代器初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *LDBDatabase)</span></span> NewIterator() iterator.Iterator &#123;</span><br><span class="line">	<span class="keyword">return</span> db.db.NewIterator(<span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据提供的前缀，返回一个合适的迭代器，方便你查找该前缀子集的内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *LDBDatabase)</span></span> NewIteratorWithPrefix(prefix []<span class="type">byte</span>) iterator.Iterator &#123;</span><br><span class="line">	<span class="keyword">return</span> db.db.NewIterator(util.BytesPrefix(prefix), <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//某次数据库操作结束后关闭该实例，停止metrics统计信息，防止多个因为启动的数据库实例过多造成内部资源竞争</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *LDBDatabase)</span></span> Close() &#123;</span><br><span class="line">	db.quitLock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> db.quitLock.Unlock()</span><br><span class="line">	<span class="keyword">if</span> db.quitChan != <span class="literal">nil</span> &#123;</span><br><span class="line">		errc := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>)</span><br><span class="line">		db.quitChan &lt;- errc</span><br><span class="line">		<span class="keyword">if</span> err := &lt;-errc; err != <span class="literal">nil</span> </span><br><span class="line">			db.log.Error(<span class="string">&quot;Metrics collection failed&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	err := db.db.Close()</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> </span><br><span class="line">		db.log.Info(<span class="string">&quot;Database closed&quot;</span>)</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		db.log.Error(<span class="string">&quot;Failed to close database&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回当前db实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *LDBDatabase)</span></span> LDB() *leveldb.DB &#123;</span><br><span class="line">	<span class="keyword">return</span> db.db</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *LDBDatabase)</span></span> NewBatch() Batch &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;ldbBatch&#123;db: db.db, b: <span class="built_in">new</span>(leveldb.Batch)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="再来看个比较复杂的方法">再来看个比较复杂的方法</h4>
<p>这个方法主要是配置db性能检测的属性，也就是记录leveldb中的一些计数器，如果没有收到<code>quitChan()</code>,则会一直运行监测，另外要记住是每3秒钟获取一次leveldb中的计数器信息，具体看代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *LDBDatabase)</span></span> Meter(prefix <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> !metrics.Enabled  <span class="comment">//不检测，检测会消耗不少性能（个人感觉）</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="comment">//根据传入的前缀，增加一些信息</span></span><br><span class="line">	db.compTimeMeter = metrics.NewRegisteredMeter(prefix+<span class="string">&quot;compact/time&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	db.compReadMeter = metrics.NewRegisteredMeter(prefix+<span class="string">&quot;compact/input&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	db.compWriteMeter = metrics.NewRegisteredMeter(prefix+<span class="string">&quot;compact/output&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	db.diskReadMeter = metrics.NewRegisteredMeter(prefix+<span class="string">&quot;disk/read&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	db.diskWriteMeter = metrics.NewRegisteredMeter(prefix+<span class="string">&quot;disk/write&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 退出处理</span></span><br><span class="line">	db.quitLock.Lock()</span><br><span class="line">	db.quitChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> <span class="type">error</span>)</span><br><span class="line">	db.quitLock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> db.meter(<span class="number">3</span> * time.Second) <span class="comment">//启动线程，调用监控，这貌似是每3秒监控一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最后来看个最复杂的方法">最后来看个最复杂的方法</h4>
<p>周期性监测leveldb内部的计数器，然后把信息报告给检测器，来看代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是当前版本报告的图表样式:</span></span><br><span class="line"><span class="comment">//   Compactions</span></span><br><span class="line"><span class="comment">//    Level |   Tables   |    Size(MB)   |    Time(sec)  |    Read(MB)   |   Write(MB)</span></span><br><span class="line"><span class="comment">//   -------+------------+---------------+---------------+---------------+---------------</span></span><br><span class="line"><span class="comment">//      0   |          0 |       0.00000 |       1.27969 |       0.00000 |      12.31098</span></span><br><span class="line"><span class="comment">//      1   |         85 |     109.27913 |      28.09293 |     213.92493 |     214.26294</span></span><br><span class="line"><span class="comment">//      2   |        523 |    1000.37159 |       7.26059 |      66.86342 |      66.77884</span></span><br><span class="line"><span class="comment">//      3   |        570 |    1113.18458 |       0.00000 |       0.00000 |       0.00000</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 这是当前版本读写监控的文本样式:</span></span><br><span class="line"><span class="comment">// Read(MB):3895.04860 Write(MB):3654.64712</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *LDBDatabase)</span></span> meter(refresh time.Duration) &#123;</span><br><span class="line">	<span class="comment">// 创建一个计数器集合用于保存当前和先前的压缩值</span></span><br><span class="line">	compactions := <span class="built_in">make</span>([][]<span class="type">float64</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++</span><br><span class="line">		compactions[i] = <span class="built_in">make</span>([]<span class="type">float64</span>, <span class="number">3</span>)</span><br><span class="line">	<span class="comment">// 用于保存读写的数据信息</span></span><br><span class="line">	<span class="keyword">var</span> iostats [<span class="number">2</span>]<span class="type">float64</span></span><br><span class="line">	<span class="comment">// 一直循环来记录</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; ; i++ &#123;</span><br><span class="line">		<span class="comment">// 恢复数据状态</span></span><br><span class="line">		stats, err := db.db.GetProperty(<span class="string">&quot;leveldb.stats&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> </span><br><span class="line">			db.log.Error(<span class="string">&quot;Failed to read database stats&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="comment">//找用于记录压缩table</span></span><br><span class="line">		lines := strings.Split(stats, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">		<span class="keyword">for</span> <span class="built_in">len</span>(lines) &gt; <span class="number">0</span> &amp;&amp; strings.TrimSpace(lines[<span class="number">0</span>]) != <span class="string">&quot;Compactions&quot;</span> </span><br><span class="line">			lines = lines[<span class="number">1</span>:]</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(lines) &lt;= <span class="number">3</span> &#123;</span><br><span class="line">			db.log.Error(<span class="string">&quot;Compaction table not found&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		lines = lines[<span class="number">3</span>:]</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 检索所有table</span></span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(compactions[i%<span class="number">2</span>]); j++ </span><br><span class="line">			compactions[i%<span class="number">2</span>][j] = <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> _, line := <span class="keyword">range</span> lines &#123;</span><br><span class="line">			parts := strings.Split(line, <span class="string">&quot;|&quot;</span>)</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(parts) != <span class="number">6</span> </span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			<span class="keyword">for</span> idx, counter := <span class="keyword">range</span> parts[<span class="number">3</span>:] &#123;</span><br><span class="line">				value, err := strconv.ParseFloat(strings.TrimSpace(counter), <span class="number">64</span>)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					db.log.Error(<span class="string">&quot;Compaction entry parsing failed&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">				compactions[i%<span class="number">2</span>][idx] += value</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 更新所有需要的meter</span></span><br><span class="line">		<span class="keyword">if</span> db.compTimeMeter != <span class="literal">nil</span> </span><br><span class="line">			db.compTimeMeter.Mark(<span class="type">int64</span>((compactions[i%<span class="number">2</span>][<span class="number">0</span>] - compactions[(i<span class="number">-1</span>)%<span class="number">2</span>][<span class="number">0</span>]) * <span class="number">1000</span> * <span class="number">1000</span> * <span class="number">1000</span>))</span><br><span class="line">		<span class="keyword">if</span> db.compReadMeter != <span class="literal">nil</span> </span><br><span class="line">			db.compReadMeter.Mark(<span class="type">int64</span>((compactions[i%<span class="number">2</span>][<span class="number">1</span>] - compactions[(i<span class="number">-1</span>)%<span class="number">2</span>][<span class="number">1</span>]) * <span class="number">1024</span> * <span class="number">1024</span>))</span><br><span class="line">		<span class="keyword">if</span> db.compWriteMeter != <span class="literal">nil</span> </span><br><span class="line">			db.compWriteMeter.Mark(<span class="type">int64</span>((compactions[i%<span class="number">2</span>][<span class="number">2</span>] - compactions[(i<span class="number">-1</span>)%<span class="number">2</span>][<span class="number">2</span>]) * <span class="number">1024</span> * <span class="number">1024</span>))</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 初始化io操作的记录</span></span><br><span class="line">		ioStats, err := db.db.GetProperty(<span class="string">&quot;leveldb.iostats&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			db.log.Error(<span class="string">&quot;Failed to read database iostats&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		parts := strings.Split(ioStats, <span class="string">&quot; &quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(parts) &lt; <span class="number">2</span> &#123;</span><br><span class="line">			db.log.Error(<span class="string">&quot;Bad syntax of ioStats&quot;</span>, <span class="string">&quot;ioStats&quot;</span>, ioStats)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		r := strings.Split(parts[<span class="number">0</span>], <span class="string">&quot;:&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(r) &lt; <span class="number">2</span> &#123;</span><br><span class="line">			db.log.Error(<span class="string">&quot;Bad syntax of read entry&quot;</span>, <span class="string">&quot;entry&quot;</span>, parts[<span class="number">0</span>])</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		read, err := strconv.ParseFloat(r[<span class="number">1</span>], <span class="number">64</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			db.log.Error(<span class="string">&quot;Read entry parsing failed&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		w := strings.Split(parts[<span class="number">1</span>], <span class="string">&quot;:&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(w) &lt; <span class="number">2</span> &#123;</span><br><span class="line">			db.log.Error(<span class="string">&quot;Bad syntax of write entry&quot;</span>, <span class="string">&quot;entry&quot;</span>, parts[<span class="number">1</span>])</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		write, err := strconv.ParseFloat(w[<span class="number">1</span>], <span class="number">64</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			db.log.Error(<span class="string">&quot;Write entry parsing failed&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> db.diskReadMeter != <span class="literal">nil</span> &#123;</span><br><span class="line">			db.diskReadMeter.Mark(<span class="type">int64</span>((read - iostats[<span class="number">0</span>]) * <span class="number">1024</span> * <span class="number">1024</span>))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> db.diskWriteMeter != <span class="literal">nil</span> &#123;</span><br><span class="line">			db.diskWriteMeter.Mark(<span class="type">int64</span>((write - iostats[<span class="number">1</span>]) * <span class="number">1024</span> * <span class="number">1024</span>))</span><br><span class="line">		&#125;</span><br><span class="line">		iostats[<span class="number">0</span>] = read</span><br><span class="line">		iostats[<span class="number">1</span>] = write</span><br><span class="line"></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> errc := &lt;-db.quitChan:</span><br><span class="line">			errc &lt;- <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(refresh):</span><br><span class="line">			<span class="comment">// 超时</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="批处理相关">批处理相关</h3>
<p>从前面我们也了解到了，有时候我们需要批量处理数据，具体在database.go中是如下定义和实现的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ldbBatch <span class="keyword">struct</span> &#123;</span><br><span class="line">	db   *leveldb.DB</span><br><span class="line">	b    *leveldb.Batch</span><br><span class="line">	size <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意这里只是写入内存队列，并没有插入db</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ldbBatch)</span></span> Put(key, value []<span class="type">byte</span>) <span class="type">error</span> &#123;</span><br><span class="line">	b.b.Put(key, value)</span><br><span class="line">	b.size += <span class="built_in">len</span>(value)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里才真正写入db</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ldbBatch)</span></span> Write() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> b.db.Write(b.b, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ldbBatch)</span></span> ValueSize() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> b.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ldbBatch)</span></span> Reset() &#123;</span><br><span class="line">	b.b.Reset()</span><br><span class="line">	b.size = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和<code>memory_database.go</code>中的定义一样，一目了然，不用小编解释了吧？</p>
<h3 id="通用的db操作封装">通用的db操作封装</h3>
<p>剩下的代码，定义了<code>table</code>和<code>tableBatch</code>的规则，这进一步对数据库做了通用的处理，通过这一套规则，底层可以使用别的各种数据库，不一定要选择levelDB。本不打算再列这块的代码的，算了，这模块的内容不多，就把这代码也都贴出来吧：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> table <span class="keyword">struct</span> &#123;</span><br><span class="line">	db     Database</span><br><span class="line">	prefix <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只要传入一个满足Database接口的db，均可正常操作本数据库，通用性更强</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTable</span><span class="params">(db Database, prefix <span class="type">string</span>)</span></span> Database &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;table&#123;</span><br><span class="line">		db:     db,</span><br><span class="line">		prefix: prefix,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dt *table)</span></span> Put(key []<span class="type">byte</span>, value []<span class="type">byte</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> dt.db.Put(<span class="built_in">append</span>([]<span class="type">byte</span>(dt.prefix), key...), value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dt *table)</span></span> Has(key []<span class="type">byte</span>) (<span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> dt.db.Has(<span class="built_in">append</span>([]<span class="type">byte</span>(dt.prefix), key...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dt *table)</span></span> Get(key []<span class="type">byte</span>) ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> dt.db.Get(<span class="built_in">append</span>([]<span class="type">byte</span>(dt.prefix), key...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dt *table)</span></span> Delete(key []<span class="type">byte</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> dt.db.Delete(<span class="built_in">append</span>([]<span class="type">byte</span>(dt.prefix), key...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dt *table)</span></span> Close() &#123;</span><br><span class="line">	<span class="comment">// Do nothing; don&#x27;t close the underlying DB.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> tableBatch <span class="keyword">struct</span> &#123;</span><br><span class="line">	batch  Batch</span><br><span class="line">	prefix <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewTableBatch returns a Batch object which prefixes all keys with a given string.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTableBatch</span><span class="params">(db Database, prefix <span class="type">string</span>)</span></span> Batch &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;tableBatch&#123;db.NewBatch(), prefix&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dt *table)</span></span> NewBatch() Batch &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;tableBatch&#123;dt.db.NewBatch(), dt.prefix&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tb *tableBatch)</span></span> Put(key, value []<span class="type">byte</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> tb.batch.Put(<span class="built_in">append</span>([]<span class="type">byte</span>(tb.prefix), key...), value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tb *tableBatch)</span></span> Write() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> tb.batch.Write()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tb *tableBatch)</span></span> ValueSize() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> tb.batch.ValueSize()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tb *tableBatch)</span></span> Reset() &#123;</span><br><span class="line">	tb.batch.Reset()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体代码就不讲了，自己领悟吧。</p>
<h2 id="全文总结">全文总结</h2>
<p>本文主要介绍了以太坊对db接口的定义，对levelDB的封装，另外也给出一套通用的规范，来让人们可以更自由的选择使用别的数据库。<br>
其中db中均涉及到了普通操作和批处理操作。另外对于levelDB,还加入了性能检测（计数）相关内容。</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊源码解读-第3.2讲-trie模块源码解读</title>
    <url>/articles/dcade07d/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>这一部分，我们主要是讲trie源码的实现，要理解代码的实现过程，是需要先了解一下理论内容的，建议大家先看看我的上一篇文章：<a href="/articles/original/ethereum/src_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E7%AC%AC3.1%E8%AE%B2-trie%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D.html">以太坊源码解读-第3.1讲-trie原理介绍</a></p>
<span id="more"></span>
<h2 id="概述">概述</h2>
<p>小编根据对已有代码的了解，画了这么个trie相关一览图：</p>
<img src="/articles/dcade07d/1.png" class="" title="空树中添加到一个节点">
<h2 id="encoding-go源码解读">encoding.go源码解读</h2>
<p>trie模块中，这个文件是我们首先要掌握的，这个主要是讲三种编码（<code>KEYBYTES encoding</code>、<code>HEX encoding</code>、<code>COMPACT encoding</code>）的实现与转换，trie中全程都需要用到这些，该文件中主要实现了如下功能：</p>
<ol>
<li>hex编码转换为Compact编码：<code>hexToCompact()</code></li>
<li>Compact编码转换为hex编码：<code>compactToHex()</code></li>
<li>keybytes编码转换为Hex编码：<code>keybytesToHex()</code></li>
<li>hex编码转换为keybytes编码：<code>hexToKeybytes()</code></li>
<li>获取两个字节数组的公共前缀的长度：<code>prefixLen()</code></li>
</ol>
<p>但是，小编不会去讲这块的源码内容了，因为<a href="/articles/original/ethereum/src_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E7%AC%AC3.1%E8%AE%B2-trie%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D.html">以太坊源码解读-第3.1讲-trie原理介绍</a>这篇文章里已经穿插了很多相关的源码，重点都已经在其中解释的很详细了。<br>
如果还有哪些地方不了解，大家可以留言或者微信与小编联系。</p>
<h2 id="node-go源码解读">node.go源码解读</h2>
<p>大家得先看懂<a href="/articles/original/ethereum/src_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E7%AC%AC3.1%E8%AE%B2-trie%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D.html">以太坊源码解读-第3.1讲-trie原理介绍</a>关于节点方面的内容，否则很难理解小编下面要讲的源码。</p>
<h3 id="node的结构与定义">node的结构与定义</h3>
<p>以太坊为MPT中的node定义了一套基本接口规则：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">interface</span> &#123;</span><br><span class="line">	fstring(<span class="type">string</span>) <span class="type">string</span> <span class="comment">//用来打印节点信息，没别的作用</span></span><br><span class="line">	cache() (hashNode, <span class="type">bool</span>)  <span class="comment">//保存缓存</span></span><br><span class="line">	canUnload(cachegen, cachelimit <span class="type">uint16</span>) <span class="type">bool</span>  <span class="comment">//除去缓存，cache次数的计数器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以太坊依据上面的规则为MTP定义了四种类型的节点，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	fullNode <span class="keyword">struct</span> &#123;</span><br><span class="line">		Children [<span class="number">17</span>]node  <span class="comment">//对应了黄皮书里面的分支节点</span></span><br><span class="line">		flags    nodeFlag</span><br><span class="line">	&#125;</span><br><span class="line">	shortNode <span class="keyword">struct</span> &#123;  <span class="comment">//对应了黄皮书里面的扩展节点</span></span><br><span class="line">		Key   []<span class="type">byte</span></span><br><span class="line">		Val   node  <span class="comment">//可能指向叶子节点，也可能指向分支节点。</span></span><br><span class="line">		flags nodeFlag</span><br><span class="line">	&#125;</span><br><span class="line">	hashNode  []<span class="type">byte</span></span><br><span class="line">	valueNode []<span class="type">byte</span>  <span class="comment">//叶子节点值，但是该叶子节点最终还是会包装在shortNode中</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>分为这四种节点：</p>
<ul>
<li>fullNode<br>
这就是传说中的分支节点，会发现它里面定义了17个node，其中16个对应的16进制的0~9a~f，第17个还没搞清楚，后面清楚了再来讲。nodeFlag稍后再说。</li>
<li>shortNode<br>
它本身若是扩展节点，则它的属性Val可能指向分支节点或者叶子节点，但要知道，叶子节点本身同样是用shortNode表示的；<br>
它本身若是叶子节点，则Val的值为rlp编码的数据，而key则是该数据的完整hash(经过hex编码的)</li>
<li>valueNode：这是给叶子节点用的，但是要知道它不能单独使用，而是要放在shortNode中使用的，用于存放rlp编码的原始数据</li>
<li>hashNode：这个同样不能单独使用，我们在上面节点定义中发现了，会涉及到<code>nodeFlag</code>，先来看看定义：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> nodeFlag <span class="keyword">struct</span> &#123;</span><br><span class="line">	hash  hashNode <span class="comment">// cached hash of the node (may be nil)</span></span><br><span class="line">	gen   <span class="type">uint16</span>   <span class="comment">// cache generation counter</span></span><br><span class="line">	dirty <span class="type">bool</span>     <span class="comment">// whether the node has changes that must be written to the database</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在其中发现了hashNode，这个属性是用来标记nodeFlag所属的node对象本身经过rlp编码后的hash值（该hash在hashNode中同样是经过hex编码的），若node有任何变化，则该hash就会发生变化。<br>
nodeFlag中的gen，只要对应的node发生一次变化，计数就加一<br>
nodeFlage中的bool，只要对应的node发生变化，它就变成true，表示要把数据重新刷新到DB中(以太坊用levelDB存储MTP信息)<br>
小编认为，对node理解到此处就可以了，对node的具体操作，要结合MPT的具体操作来掌握，这就引出了我们的下一部分需要掌握的文件：trie.go</p>
<h2 id="trie-go源码解读">trie.go源码解读</h2>
<p>我们先来了解下以太坊给trie定义的结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Trie <span class="keyword">struct</span> &#123;</span><br><span class="line">	db           *Database  <span class="comment">//trei在levelDB中</span></span><br><span class="line">	root         node  <span class="comment">//根结点</span></span><br><span class="line">	originalRoot common.Hash  <span class="comment">//32位byte[],从db中恢复出完整的trie</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//cachegen表示当前trie树的版本，trie每次commit，则增加1</span></span><br><span class="line">	<span class="comment">//cachelimit如果当前的cache时代 - cachelimit参数 大于node的cache时代，那么node会从cache里面卸载，以便节约内存。</span></span><br><span class="line">	cachegen, cachelimit <span class="type">uint16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体我们来解读一下其中的每部分：</p>
<ul>
<li>db</li>
<li>root 可以理解为当前root指向哪个节点，初始时候，没有内容，则root=nil，表示指向nil</li>
<li>originalRoot</li>
<li>cachegen</li>
<li>cachelimit</li>
</ul>
<p>按小编的理解，trie中存入db本身的是各种类型的node，也就是从root指向的那个node开始存储，root本身并不存储。</p>
<p>想要真正掌握以太坊中的trie，小编建议还是从它的测试文件node_test.go作为入口来读取源码，这里面涉及到内容如果都看懂，那相信你对MPT了解已经非常深刻了。好，那咱们一个个来看：</p>
<h3 id="一颗空树">一颗空树</h3>
<p>当为一颗空树时候，也就是trie只有一个节点，且trie.root=nil。<br>
此时使用trie.Hash()可以返回当前整个trie树的hash值。而emptyRoot是trie预先定义的一个空节点时候的hash常量，将当前trie的hash和它比较，可以校验当前trie是否为空树。具体代码如下：<br>
注意，这些hash是真实值，从进一步的代码中，我们是可以得知，这些hash是使用hex转换回来的hash。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestEmptyTrie</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> trie Trie</span><br><span class="line">	res := trie.Hash() <span class="comment">//获取当前trie的hash</span></span><br><span class="line">	exp := emptyRoot</span><br><span class="line">	<span class="keyword">if</span> res != common.Hash(exp) &#123;</span><br><span class="line">		t.Errorf(<span class="string">&quot;expected %x got %x&quot;</span>, exp, res)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从空树中添加一个节点">从空树中添加一个节点</h3>
<p>添加一个节点，也就是添加叶子结点，先来看代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNull</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> trie Trie</span><br><span class="line">	value := []<span class="type">byte</span>(<span class="string">&quot;test&quot;</span>)  <span class="comment">//value为字节数组</span></span><br><span class="line">	key := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">32</span>) <span class="comment">//一个32位的hash，但是其中每一位都是0</span></span><br><span class="line">	trie.Update(key, value)</span><br><span class="line">	<span class="keyword">if</span> !bytes.Equal(trie.Get(key), value) &#123;</span><br><span class="line">		t.Fatal(<span class="string">&quot;wrong value&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始时，tril.root指向的是nil。<br>
value：要把一个字符串内容为&quot;test&quot;的数据存入trie中<br>
key：应该是value对应的rlp编码后的hash值<br>
从trie.Update()进入到trie.go的insert方法中：会发现，key和value被组成一个shortNode，表示一个叶子节点，插入到trie空树中。<br>
然后trie.root指向这个叶子节点。<br>
可以这么理解，此时这棵树有一个根结点和一个叶子结点。<br>
为更好说明，上个图，大体如下：</p>
<img src="/articles/dcade07d/1.png" class="" title="空树中添加到一个节点">
<h3 id="数据库中检测一个不存在的trie根节点">数据库中检测一个不存在的trie根节点</h3>
<p>小编曾说个，以太坊的MPT中，是有google的levelDB参与的，而从trie定义的结构中，我们可知通过trie中的originalRoot可以恢复出一棵levelDB中存在的MPT树。<br>
这个案例中，我们尝试使用一个不存在的hash来判断level中的确不存在该对应的MTP树。代码如下：<br>
<code>ps：小编需要说明，其中涉及的levelDB以及代码中的db操作相关，属于以太坊的ethdb模块中的内容，这个将在后续的文章中讲解，本文只一笔概述不会深入去讲db内容。</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMissingRoot</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	diskdb, _ := ethdb.NewMemDatabase()</span><br><span class="line">	<span class="comment">//New()中，第一个参数是将hex编码转为原始的hash 32位byte[]</span></span><br><span class="line">	trie, err := New(common.HexToHash(<span class="string">&quot;0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33&quot;</span>), NewDatabase(diskdb))</span><br><span class="line">	<span class="keyword">if</span> trie != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Error(<span class="string">&quot;New returned non-nil trie for invalid root&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _, ok := err.(*MissingNodeError); !ok &#123;</span><br><span class="line">		t.Errorf(<span class="string">&quot;New returned wrong error: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中我们可知，我们是要从一个新建的db中去找某hash对应的trie树。呵呵，当然会找不到。但程序具体是怎么执行查找的？需要我们进入New()方法去进一步了解过程：<br>
传入的root是一个hash，根据该hash最后是在db中查找对应的trie根的。<br>
其中<code>originalRoot: root, </code>，若最终查找出了该trie，则该root就是整个trie的hash。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(root common.Hash, db *Database)</span></span> (*Trie, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> db == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;trie.New called without a database&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	trie := &amp;Trie&#123;</span><br><span class="line">		db:           db,</span><br><span class="line">		originalRoot: root,  <span class="comment">//把传入的hash保存在此处，只要能恢复了整个trie</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (root != common.Hash&#123;&#125;) &amp;&amp; root != emptyRoot &#123;</span><br><span class="line">		rootnode, err := trie.resolveHash(root[:], <span class="literal">nil</span>) <span class="comment">//检查是否有对应的trie</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		trie.root = rootnode  <span class="comment">//返回了找到的trie，按小编理解，这个rootnode应该是分支节点或叶子节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> trie, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，真正进行node查找的方法是resolveHash()该方法也需要大家了解一下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> resolveHash(n hashNode, prefix []<span class="type">byte</span>) (node, <span class="type">error</span>) &#123;</span><br><span class="line">	cacheMissCounter.Inc(<span class="number">1</span>)  <span class="comment">//每执行一次resolveHash()方法，计数器+1</span></span><br><span class="line"></span><br><span class="line">	hash := common.BytesToHash(n)</span><br><span class="line">	enc, err := t.db.Node(hash)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> || enc == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, &amp;MissingNodeError&#123;NodeHash: hash, Path: prefix&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> mustDecodeNode(n, enc, t.cachegen), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要的是那个计数器，<code>cacheMissCounter.Inc(1)</code>，不论从db中还原trie成功还是失败，计数器都会累加1</p>
<h3 id="操作存储在内存或磁盘的trie">操作存储在内存或磁盘的trie</h3>
<p>db中只会存放最终真正确认有效的数据块，因此trie会被分为存在db磁盘中的以及留在内存中的两大类，具体可以看测试代码，（期间会涉及到部分非重点代码，小编就不列出了）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testMissingNode</span><span class="params">(t *testing.T, memonly <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">	diskdb, _ := ethdb.NewMemDatabase()  <span class="comment">//磁盘空间</span></span><br><span class="line">	triedb := NewDatabase(diskdb)  <span class="comment">//生成db</span></span><br><span class="line"></span><br><span class="line">	trie, _ := New(common.Hash&#123;&#125;, triedb) <span class="comment">//空节点创建</span></span><br><span class="line">	<span class="comment">//实际使用时，Update中的 value是需要先经过rlp编码</span></span><br><span class="line">	trie.Update([]<span class="type">byte</span>(<span class="string">&quot;120000&quot;</span>), []<span class="type">byte</span>(<span class="string">&quot;qwerqwerqwerqwerqwerqwerqwerqwer&quot;</span>))</span><br><span class="line">	trie.Update([]<span class="type">byte</span>(<span class="string">&quot;123456&quot;</span>), []<span class="type">byte</span>(<span class="string">&quot;asdfasdfasdfasdfasdfasdfasdfasdf&quot;</span>))</span><br><span class="line">	root, _ := trie.Commit(<span class="literal">nil</span>)  <span class="comment">//trie.Commit需要了解</span></span><br><span class="line">	<span class="keyword">if</span> !memonly &#123;  <span class="comment">//根据此处来判断是否提交到db</span></span><br><span class="line">		triedb.Commit(root, <span class="literal">true</span>)  <span class="comment">//这个就是将trie提交到db了</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据key查找某个trie是否存在</span></span><br><span class="line">	<span class="keyword">var</span> bts []<span class="type">byte</span></span><br><span class="line">	trie, _ = New(root, triedb)</span><br><span class="line">	bts, err := trie.TryGet([]<span class="type">byte</span>(<span class="string">&quot;120000&quot;</span>))</span><br><span class="line">	fmt.Println(bts)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//添加一个node</span></span><br><span class="line">	trie, _ = New(root, triedb)</span><br><span class="line">	<span class="comment">//本质上也是调用trie.Update()方法</span></span><br><span class="line">	err = trie.TryUpdate([]<span class="type">byte</span>(<span class="string">&quot;120099&quot;</span>), []<span class="type">byte</span>(<span class="string">&quot;zxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcv&quot;</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除一个node</span></span><br><span class="line">	trie, _ = New(root, triedb)</span><br><span class="line">	err = trie.TryDelete([]<span class="type">byte</span>(<span class="string">&quot;123456&quot;</span>))</span><br><span class="line">	</span><br><span class="line">	hash := common.HexToHash(<span class="string">&quot;0xe1d943cc8f061a0c0b98162830b970395ac9315654824bf21b73b891365262f9&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> memonly &#123; <span class="comment">//为true，则在内存中删除该trie</span></span><br><span class="line">		<span class="built_in">delete</span>(triedb.nodes, hash)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;  <span class="comment">//为false，则在磁盘中删除该trie</span></span><br><span class="line">		diskdb.Delete(hash[:])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会发现，trie中存这样的几对方法：Update()和TryUpdate()、Get()和TryGet()、Delete()和TryDelete()；其实是没有加<code>Try</code>关键字的方法进一步封装了带有<code>Try</code>的方法，做了异常处理。另外：</p>
<ul>
<li>TryUpdate()方法：当传入的value长度大于0，则调用trie.insert()把把key和value组成节点插入trie（插入逻辑后续再说）；否则若value长度为0，则调用trie.delete()方法删除trie中key对应的节点。</li>
<li>TryGet()方法：就是从trie中调用tryGet()方法获取key对应的那一部分数据</li>
<li>TryDelete()方法：就是调用trie中delete()方法删除trie中key对应的节点。</li>
<li>triedb.Commit()方法：将数据提交给db，这个涉及到trie模块下的database.go，后面章节中单独讲</li>
<li>diskdb.Delete()方法：磁盘中删除某节点，这个属于<code>diskdb模块</code>内容，本文不讲解。</li>
</ul>
<p>节点的操作本身很重要，我们知道了，真正处理数据的是trie中的insert()、delete()、tryGet()这三个方法。接下来详细介绍一下它们。<br>
先要知道，这些操作的数据目前都是在内存中保存的。<br>
下面操作中，除了明确标明是在操作db，其余情况都是在内存中操作，这点一定要清楚，很容易搞混。</p>
<p><code>注意！小编多个新号让大家注意：****</code><br>
<em>只要trie树上的某条路径上有节点新增或者删除，那这条路径的节点都会被重新实例化并负值，如此一来，节点的nodeFlag中的dirty也被改为true，这样就表示这条路径的所有节点都需要重新插入到db。</em></p>
<h4 id="新增数据到trie">新增数据到trie</h4>
<p>其实就是新增一个叶子节点到trie<br>
前面提到过的一些文章中只是理论上讲了讲新增原理，真实情况要复杂很多。<br>
<span id="insert">先来上一坨代码，看看以太坊是怎么处理新增的：</span></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该方法会被递归调用</span></span><br><span class="line"><span class="comment">//n表示从trie当前节点n开始插入</span></span><br><span class="line"><span class="comment">//prefix表示当前匹配到的key的公共前缀</span></span><br><span class="line"><span class="comment">//key 表示待插入数据当前key中剩余未匹配的部分</span></span><br><span class="line"><span class="comment">//value 待插入数据本身</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> insert(n node, prefix, key []<span class="type">byte</span>, value node) (<span class="type">bool</span>, node, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(key) == <span class="number">0</span> &#123; </span><br><span class="line">		<span class="keyword">if</span> v, ok := n.(valueNode); ok &#123;</span><br><span class="line">			<span class="keyword">return</span> !bytes.Equal(v, value.(valueNode)), value, <span class="literal">nil</span></span><br><span class="line">		&#125; <span class="comment">//要在节点A中新增节点B，若A和B本身数据一致，则认为已经新增，则直接返回true</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, value, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> n := n.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> *shortNode:</span><br><span class="line">		matchlen := prefixLen(key, n.Key) <span class="comment">//n.Key是扩展节点的公共key，这是公共结点匹配</span></span><br><span class="line">		<span class="keyword">if</span> matchlen == <span class="built_in">len</span>(n.Key) &#123; </span><br><span class="line">			dirty, nn, err := t.insert(n.Val, <span class="built_in">append</span>(prefix, key[:matchlen]...), key[matchlen:], value)</span><br><span class="line">			<span class="keyword">if</span> !dirty || err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>, n, err</span><br><span class="line">			&#125;<span class="comment">//新增返回的必是叶子结点</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>, &amp;shortNode&#123;n.Key, nn, t.newFlag()&#125;, <span class="literal">nil</span> <span class="comment">//从这里可以看出，从根路径到插入数据的位置，整条路径的节点都会被重新实例化，node的dirty也被改为true，表示要重新更新</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//该case中，剩余部分代码，是为了将一个扩展节点拆分为两部分</span></span><br><span class="line">		branch := &amp;fullNode&#123;flags: t.newFlag()&#125; <span class="comment">//新建一个分支节点</span></span><br><span class="line">		<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">		<span class="comment">//插入分支节点第一个数据</span></span><br><span class="line">		_, branch.Children[n.Key[matchlen]], err = t.insert(<span class="literal">nil</span>, <span class="built_in">append</span>(prefix, n.Key[:matchlen+<span class="number">1</span>]...), n.Key[matchlen+<span class="number">1</span>:], n.Val)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//插入分支节点第二个数据</span></span><br><span class="line">		_, branch.Children[key[matchlen]], err = t.insert(<span class="literal">nil</span>, <span class="built_in">append</span>(prefix, key[:matchlen+<span class="number">1</span>]...), key[matchlen+<span class="number">1</span>:], value)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//若待插入数据和trie中当前节点的前缀key一个也没匹配，则返回分支节点</span></span><br><span class="line">		<span class="keyword">if</span> matchlen == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>, branch, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 否则返回扩展节点</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, &amp;shortNode&#123;key[:matchlen], branch, t.newFlag()&#125;, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> *fullNode: <span class="comment">//分支节点插入数据</span></span><br><span class="line">		dirty, nn, err := t.insert(n.Children[key[<span class="number">0</span>]], <span class="built_in">append</span>(prefix, key[<span class="number">0</span>]), key[<span class="number">1</span>:], value)</span><br><span class="line">		<span class="keyword">if</span> !dirty || err != <span class="literal">nil</span> </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, n, err</span><br><span class="line">		n = n.<span class="built_in">copy</span>()</span><br><span class="line">		n.flags = t.newFlag()</span><br><span class="line">		n.Children[key[<span class="number">0</span>]] = nn</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, n, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="literal">nil</span>: <span class="comment">//也就是说，在空trie中添加一个节点，就是叶子节点，返回shortNode。</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, &amp;shortNode&#123;key, value, t.newFlag()&#125;, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> hashNode: <span class="comment">//恢复一个存储在db中的node</span></span><br><span class="line">		rn, err := t.resolveHash(n, prefix)  <span class="comment">//检查该node是否存在，若存在，加载在node中</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, err</span><br><span class="line">		dirty, nn, err := t.insert(rn, prefix, key, value)</span><br><span class="line">		<span class="keyword">if</span> !dirty || err != <span class="literal">nil</span> </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, rn, err</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, nn, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;%T: invalid node: %v&quot;</span>, n, n))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中我们可以看出：</p>
<ul>
<li>此时，只有key被编码为hex编码，而value是经过rlp编码的字节数组。</li>
<li>insert()最终返回的node其实就是trie.root所指向的node。</li>
<li>若trie中本身是存在key所对应的数据的，则不可被修改。也就是会说，trie本身只可增加节点，不可修改节点</li>
<li>若节点<code>n</code>指向的是<code>nil</code>，则当前是空trie，直接在其后加一个shortNode(叶子节点)即可。</li>
<li>若节点<code>n</code>指向的是<code>shortNode</code>，则该<code>shortNode</code>可能是扩展节点，也可能是叶子节点。
<ul>
<li>若待插入的key剩余未匹配的部分能匹配到当前<code>shortNode</code>中key的全部长度，则在该<code>shortNode</code>之后新增分支节点，或者在<code>shortNode</code>之后的分支节点上新增待插入节点。</li>
<li>若待插入的key剩余未匹配的部分不能匹配到当前<code>shortNode</code>中key的全部长度，则该<code>shortNode</code>会新增一个分支节点，将shortNode分裂成两部分。这块建议大家画图理解。</li>
</ul>
</li>
<li>若节点<code>n</code>指向的是分支节点<code>fullNode</code>，理解了上面指向<code>shortNode</code>的过程，那这里就容易理解了，从分支节点下进一步查找要匹配的位置</li>
<li>若节点<code>n</code>指向的是<code>hashNode</code>，说明此时该节点属于轻节点，真实的节点数据被释放了。因此，通过hashNode去db中恢复该节点，然后进一步去插入。</li>
</ul>
<h4 id="从trie中获取数据">从trie中获取数据</h4>
<p>其实就是根据输入到hash，在找到对应的叶子节点的数据，一言不合，先来代码，一坨。。。：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//origNode：当前查找的起始node位置</span></span><br><span class="line"><span class="comment">//key：输入要查找的数据的hash</span></span><br><span class="line"><span class="comment">//pos：当前hash匹配到第几位</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> tryGet(origNode node, key []<span class="type">byte</span>, pos <span class="type">int</span>) (value []<span class="type">byte</span>, newnode node, didResolve <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">switch</span> n := (origNode).(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="literal">nil</span>: <span class="comment">//这表示当前trie是空树</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> valueNode: <span class="comment">//这就是我们要查找的叶子节点对应的数据</span></span><br><span class="line">		<span class="keyword">return</span> n, n, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> *shortNode: <span class="comment">//在叶子节点或者扩展节点匹配</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(key)-pos &lt; <span class="built_in">len</span>(n.Key) || !bytes.Equal(n.Key, key[pos:pos+<span class="built_in">len</span>(n.Key)]) </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, n, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">		value, newnode, didResolve, err = t.tryGet(n.Val, key, pos+<span class="built_in">len</span>(n.Key))</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; didResolve &#123;</span><br><span class="line">			n = n.<span class="built_in">copy</span>()</span><br><span class="line">			n.Val = newnode</span><br><span class="line">			n.flags.gen = t.cachegen</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> value, n, didResolve, err</span><br><span class="line">	<span class="keyword">case</span> *fullNode:  <span class="comment">//在分支节点匹配</span></span><br><span class="line">		value, newnode, didResolve, err = t.tryGet(n.Children[key[pos]], key, pos+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; didResolve &#123;</span><br><span class="line">			n = n.<span class="built_in">copy</span>()</span><br><span class="line">			n.flags.gen = t.cachegen</span><br><span class="line">			n.Children[key[pos]] = newnode</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> value, n, didResolve, err</span><br><span class="line">	<span class="keyword">case</span> hashNode: <span class="comment">//说明当前节点是轻节点，需要从db中获取</span></span><br><span class="line">		child, err := t.resolveHash(n, key[:pos])</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, n, <span class="literal">true</span>, err  <span class="comment">//trie重组，因此需要返回true</span></span><br><span class="line">		value, newnode, _, err := t.tryGet(child, key, pos)</span><br><span class="line">		<span class="keyword">return</span> value, newnode, <span class="literal">true</span>, err</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;%T: invalid node: %v&quot;</span>, origNode, origNode))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不说别的，先说<code>didResolve</code>这个东西，用于判断trie树是否会发生变化，按理tryGet()只是用来获取数据的，哪里会影响trie发生变化，但是因为有可能我们会根据hashNode去db中获取该node值，获取到后，需要更新现有的trie，<code>didResolve</code>就会发生变化。<br>
其实这段查询代码里，也就只有<code>didResolve</code>会让人郁闷一下，其它的就只是基本的递归查找树了。小编就不详解了，代码里注释大概写了点，够用了。<br>
补充一下，当涉及到hashNode时，我们要知道，这是通过外部输入hashNode，进磁盘DB中查找对应节点。</p>
<h4 id="从trie中删除数据">从trie中删除数据</h4>
<p>也就是说删除trie中的一个叶子节点。这个过程和插入过程很相似，小编就不讲了，再讲就累死了。</p>
<h3 id="节点缓存设置">节点缓存设置</h3>
<p>当一个节点被提交次数达到指定上线时候，该节点将会被重新加载。<br>
这个功能还是蛮有用的，提高效率。这个代码没细看，有兴趣的可以看看。<br>
在<code>test_trie.go</code>中看<code>TestCacheUnload()</code>测试方法，在<code>trie.go</code>中看trie.SetCacheLimit()方法<br>
话说这个缓存机制小编一直没看懂。。。</p>
<h2 id="trie树的序列化-缓存-轻节点">Trie树的序列化、缓存(轻节点)</h2>
<p>小编相信，看懂<a href="/articles/original/ethereum/src_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E7%AC%AC2%E8%AE%B2-rlp%E6%A8%A1%E5%9D%97%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.html">以太坊源码解读-第2讲-rlp模块源码解读</a>的同学，会很容易理解trie树的序列化的 。<br>
序列化和反序列化，本就是内存和磁盘存储时候的两种转化，具体概念小编就不讲了。<br>
当trie.Commit(nil)的时候，会执行序列化、缓存等操作，因此小编就将这两者合在一起讲了<br>
需要注意的是，trie树序列化后，真正保存在磁盘上，是使用的<code>Compact Encoding</code>编码，这样会节省空间。<br>
还有一点需要分清：<code>node本身节点的hash和shortNode中的key要区分，从根结点到叶子节点的key衔接起来，表示的是叶子节点value数据的hash值</code><br>
关于trie的缓存机制，其实就是轻节点机制的设计理念，后面小编在代码中深入介绍吧。</p>
<h3 id="trie-commit-nil-入口解析">trie.Commit(nil)入口解析</h3>
<p>Commit()的目的，是将trie树中的key转为Compact编码，为每个节点生成一个hash。<br>
可以这么说，它就是为了确保后续能正常将变动的数据提交到db.<br>
来看代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> Commit(onleaf LeafCallback) (root common.Hash, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> t.db == <span class="literal">nil</span> </span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;commit called on trie with nil database&quot;</span>)</span><br><span class="line">	hash, cached, err := t.hashRoot(t.db, onleaf)  </span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> </span><br><span class="line">		<span class="keyword">return</span> common.Hash&#123;&#125;, err</span><br><span class="line">	t.root = cached</span><br><span class="line">	t.cachegen++</span><br><span class="line">	<span class="keyword">return</span> common.BytesToHash(hash.(hashNode)), <span class="literal">nil</span>  <span class="comment">//返回trie.root所指向的节点的hash，注意该hash是原始的32位hash，并未编码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为每个node生成一个hash</span></span><br><span class="line"><span class="comment">//返回的结果中，有两个node，后面文中详细解释</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> hashRoot(db *Database, onleaf LeafCallback) (node, node, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> t.root == <span class="literal">nil</span> </span><br><span class="line">		<span class="keyword">return</span> hashNode(emptyRoot.Bytes()), <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	h := newHasher(t.cachegen, t.cachelimit, onleaf) <span class="comment">//涉及到haser.go，后面解释</span></span><br><span class="line">	<span class="keyword">defer</span> returnHasherToPool(h)</span><br><span class="line">	<span class="keyword">return</span> h.hash(t.root, db, <span class="literal">true</span>)  <span class="comment">//为每个节点生成一个未编码的hash，该方法后面具体会详解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码我们了解到：</p>
<ul>
<li>每Commit()一次，该trie的cachegen就会加1</li>
<li>最终Commit()方法返回的是trie.root所指向的node的hash（未编码）。</li>
<li>其中的hashRoot()方法目的是<code>返回trie.root所指向的node的hash</code>以及<code>每个节点都带有各自hash的trie树的root</code>。</li>
<li>期间会涉及到hasher.go中的操作，它维护着一个操作trie中hash相关的对象池，我们也发现，在hashRoot()中最重要的就是它的hash()方法，接下来我们就好好探索一下它的具体实现。</li>
</ul>
<h3 id="haser-go的hash-方法">haser.go的hash()方法</h3>
<p>这个方法主要就是为每个节点都生成一个hash，<br>
<span id="hash">来一坨代码：</span></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hasher)</span></span> hash(n node, db *Database, force <span class="type">bool</span>) (node, node, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> hash, dirty := n.cache(); hash != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> db == <span class="literal">nil</span> </span><br><span class="line">			<span class="keyword">return</span> hash, n, <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> n.canUnload(h.cachegen, h.cachelimit) &#123;</span><br><span class="line">			cacheUnloadCounter.Inc(<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> hash, hash, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !dirty </span><br><span class="line">			<span class="keyword">return</span> hash, n, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	collapsed, cached, err := h.hashChildren(n, db) <span class="comment">//处理每个节点</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> </span><br><span class="line">		<span class="keyword">return</span> hashNode&#123;&#125;, n, err</span><br><span class="line">	hashed, err := h.store(collapsed, db, force) <span class="comment">//将当前节点生成hash，这方法很重要，下一节讲</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> </span><br><span class="line">		<span class="keyword">return</span> hashNode&#123;&#125;, n, err</span><br><span class="line"></span><br><span class="line">	cachedHash, _ := hashed.(hashNode)</span><br><span class="line">	<span class="keyword">switch</span> cn := cached.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> *shortNode:</span><br><span class="line">		cn.flags.hash = cachedHash <span class="comment">//将当前节点的hasn保存在flags中</span></span><br><span class="line">		<span class="keyword">if</span> db != <span class="literal">nil</span> </span><br><span class="line">			cn.flags.dirty = <span class="literal">false</span></span><br><span class="line">	<span class="keyword">case</span> *fullNode:  <span class="comment">//和上面一样操作</span></span><br><span class="line">		cn.flags.hash = cachedHash</span><br><span class="line">		<span class="keyword">if</span> db != <span class="literal">nil</span> </span><br><span class="line">			cn.flags.dirty = <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> hashed, cached, <span class="literal">nil</span>  <span class="comment">//返回当前节点的hash以及当前节点本身</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//依次处理trie中的每个节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hasher)</span></span> hashChildren(original node, db *Database) (node, node, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	<span class="keyword">switch</span> n := original.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> *shortNode:</span><br><span class="line">		collapsed, cached := n.<span class="built_in">copy</span>(), n.<span class="built_in">copy</span>()  <span class="comment">//递归算下来，相当于复制了两个新的trie</span></span><br><span class="line">		collapsed.Key = hexToCompact(n.Key) <span class="comment">//将前缀hex转为compact，方便磁盘存储</span></span><br><span class="line">		cached.Key = common.CopyBytes(n.Key) <span class="comment">//将key字节数组复制给cached</span></span><br><span class="line">		<span class="keyword">if</span> _, ok := n.Val.(valueNode); !ok &#123;</span><br><span class="line">			collapsed.Val, cached.Val, err = h.hash(n.Val, db, <span class="literal">false</span>)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> </span><br><span class="line">				<span class="keyword">return</span> original, original, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> collapsed.Val == <span class="literal">nil</span> </span><br><span class="line">			collapsed.Val = valueNode(<span class="literal">nil</span>) <span class="comment">//确保不为nil</span></span><br><span class="line">		<span class="keyword">return</span> collapsed, cached, <span class="literal">nil</span>  <span class="comment">//前者是用于磁盘存储的节点，后者是hash化的节点，可以称为轻节点</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> *fullNode:</span><br><span class="line">		collapsed, cached := n.<span class="built_in">copy</span>(), n.<span class="built_in">copy</span>()</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> n.Children[i] != <span class="literal">nil</span> &#123; <span class="comment">//类似，处理每个节点</span></span><br><span class="line">				collapsed.Children[i], cached.Children[i], err = h.hash(n.Children[i], db, <span class="literal">false</span>)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> </span><br><span class="line">					<span class="keyword">return</span> original, original, err</span><br><span class="line">			&#125; <span class="keyword">else</span> </span><br><span class="line">				collapsed.Children[i] = valueNode(<span class="literal">nil</span>) <span class="comment">//确保不会出现nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		cached.Children[<span class="number">16</span>] = n.Children[<span class="number">16</span>]</span><br><span class="line">		<span class="keyword">if</span> collapsed.Children[<span class="number">16</span>] == <span class="literal">nil</span> </span><br><span class="line">			collapsed.Children[<span class="number">16</span>] = valueNode(<span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">return</span> collapsed, cached, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> n, original, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>纠结了半天，小编觉得也没什么注释可以写的。具体的这里来解释吧：</p>
<ul>
<li>hash()方法很重要，最终它返回了头节点的hash以及每个子节点都带有hash的头节点。（头节点就是为了让trie.root最终指向它）<br>
它主要完成了3个任务：
<ul>
<li>缓存管理，检测是否要释放某节点</li>
<li>递归调用hashChildren()处理每个节点，它返回的是两个node，具体看下面的解释。</li>
<li>调用store()方法生成每个节点的hash，并保存在当前节点中，store()方法很重要，我们下一节单独讲</li>
</ul>
</li>
<li>hashChildren()方法主要就是为了处理树中的每个节点，比如：将shortNode的前缀key转为Compact编码，将nil数据处理一下。小编认为这个方法真正最主要的目的就是将当前所在节点复制了两份（分别叫做<code>collapsed</code>, <code>cached</code>），这样此时加上原先传入的总共就有3份当前节点数据了。复制的两份，其中一份<code>collapsed</code>是为了将来db磁盘存储；而另一份<code>cached</code>会保留在内存中，回调结束后trie.root会指向这个cached，这样，原先的那一份就会被gc了（trie.root原先是指向这一份），</li>
</ul>
<h3 id="haser-go的store-方法-涉及缓存">haser.go的store()方法（涉及缓存）</h3>
<p>我们上面提到了hashChildren()返回的是两个node，其中一个叫做<code>collapsed</code>的当前node被传入了store()方法中，而它只返回了一个当前node的hash。<br>
前面我们已经知道<code>collapsed</code>节点做了部分处理，它最终目的是保存在db磁盘的。当它的节点本身被rlp序列化，就可以直接传入db保存了。<br>
store()方法就是用来rlp序列化<code>collapsed</code>节点并将其插入db磁盘中，当前节点的hash也是由它来生成的。<br>
具体我们来看这样一坨代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hasher)</span></span> store(n node, db *Database, force <span class="type">bool</span>) (node, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> _, isHash := n.(hashNode); n == <span class="literal">nil</span> || isHash <span class="comment">//空数据或者hashNode，则不处理</span></span><br><span class="line">		<span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">	h.tmp.Reset() <span class="comment">//缓存初始化</span></span><br><span class="line">	<span class="keyword">if</span> err := rlp.Encode(h.tmp, n); err != <span class="literal">nil</span> <span class="comment">//将当前node序列化</span></span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;encode error: &quot;</span> + err.Error())</span><br><span class="line">	<span class="keyword">if</span> h.tmp.Len() &lt; <span class="number">32</span> &amp;&amp; !force </span><br><span class="line">		<span class="keyword">return</span> n, <span class="literal">nil</span> <span class="comment">//编码后的node长度小于32，若force为true，则可确保所有节点都被编码</span></span><br><span class="line">	<span class="comment">// 长度过大的，则都将被新计算出来的hash取代</span></span><br><span class="line">	hash, _ := n.cache()  <span class="comment">//取出当前节点的hash</span></span><br><span class="line">	<span class="keyword">if</span> hash == <span class="literal">nil</span> &#123;  <span class="comment">//如果hash</span></span><br><span class="line">		h.sha.Reset()</span><br><span class="line">		h.sha.Write(h.tmp.Bytes())  <span class="comment">//将rlp编码的节点数据传入hash工具</span></span><br><span class="line">		hash = hashNode(h.sha.Sum(<span class="literal">nil</span>))  <span class="comment">//根据传入的节点信息，生成hash</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> db != <span class="literal">nil</span> &#123;</span><br><span class="line">		db.lock.Lock()</span><br><span class="line"></span><br><span class="line">		hash := common.BytesToHash(hash)</span><br><span class="line">		db.insert(hash, h.tmp.Bytes()) <span class="comment">//将其插入db</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> n := n.(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> *shortNode:</span><br><span class="line">			<span class="keyword">if</span> child, ok := n.Val.(hashNode); ok <span class="comment">//指向的是分支节点</span></span><br><span class="line">				db.reference(common.BytesToHash(child), hash) <span class="comment">//用于统计当前节点的信息，比如当前节点有几个子节点，当前有效的节点数</span></span><br><span class="line">		<span class="keyword">case</span> *fullNode:</span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">				<span class="keyword">if</span> child, ok := n.Children[i].(hashNode); ok </span><br><span class="line">					db.reference(common.BytesToHash(child), hash)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		db.lock.Unlock()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> h.onleaf != <span class="literal">nil</span> &#123; <span class="comment">//onleaf是回调时候使用的，记得trie.Commit(x)里的那个参数吧，就是它</span></span><br><span class="line">			<span class="keyword">switch</span> n := n.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> *shortNode:</span><br><span class="line">				<span class="keyword">if</span> child, ok := n.Val.(valueNode); ok </span><br><span class="line">					h.onleaf(child, hash)</span><br><span class="line">			<span class="keyword">case</span> *fullNode:</span><br><span class="line">				<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ </span><br><span class="line">					<span class="keyword">if</span> child, ok := n.Children[i].(valueNode); ok &#123;</span><br><span class="line">						h.onleaf(child, hash)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> hash, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中重要的一点就是hash的生成，它是根据序列化后的节点生成的。<br>
注意看db的插入，根据hash来插入rlp序列化的节点，到时候我们就能根据这个hash来还愿整个节点了。而要注意的一点是<code>该hash是32位的原始hash，并未经过任何编码，最终该方法返回的hash也没有经过任何处理</code><br>
另外stroe()方法传入的有个参数叫force，通过代码我们得知，如果设置为true，则即使长度再小的节点，也要进行rlp编码<br>
剩下的代码，小编发现没什么要讲的。。。代码不复杂，写的都很清楚，能注释的也都注释了，</p>
<h3 id="缓存机制-轻节点">缓存机制（轻节点）</h3>
<p>讲了半天，就剩缓存没讲了，再次回到haser.go的hash()方法，这时候再来看这个缓存机制就很容易理解了。<br>
<a href="#hash">代码看这里</a><br>
还记得Trie树的结构里面有两个参数， 一个是cachegen,一个是cachelimit。这两个参数就是cache控制的参数。 Trie树每一次调用Commit方法，会导致当前的cachegen增加1。<br>
数据节点插入时候（<a href="#insert">代码看这里</a>），会把当前trie的cachegen存放到该节点中。<br>
要知道，只要trie路径上新增或者删除一个节点，整个路径的节点都需要重新实例化，也就是节点中的nodeFlag被初始化了。都需要重新更新到db磁盘。<br>
node.go源码中有针对每种node实现的<code>canUnload()</code>方法，大体上是当<code>trie.cachegen - node.cachegen &gt; cachelimit</code>和<code>dirty=false（表示当前节点未发生变化）</code>条件满足时就会返回true（说明该节点数据始终没有发生变化，自己好好悟悟这句话吧，最好拿数据实际操作一下）,此时hash()方法中，就不会返回节点数据，而是返回节点的一个hash值。</p>
<h4 id="轻节点">轻节点</h4>
<p>小编在<a href="/articles/original/ethereum/src_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E7%AC%AC3.1%E8%AE%B2-trie%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D.html">以太坊源码解读-第3.1讲-trie原理介绍</a>中已经初步介绍了轻节点的概念，根据上述缓存机制，我们返回的只有hash节点本身。这其实就是我们所说的轻节点。。。貌似小编没有什么需要继续往下说的了。。。一路看下来这篇文章的同学，应该会很容易理解这个吧。</p>
<h2 id="proof-go-源码">proof.go 源码</h2>
<p>看了下，总共有三个方法：</p>
<ul>
<li>Prove()：根据给定的key，在trie中，将满足key中最大长度前缀的路径上的节点都加入到proofDb（队列中每个元素满足：未编码的hash以及对应rlp编码后的节点）</li>
<li>VerifyProof()：验证proffDb中是否存在满足输入的hash，和对应key的节点，如果满足，则返回rlp解码后的该节点。</li>
</ul>
<p>具体代码小编就不列了，也不复杂，有兴趣的可以看看</p>
<h2 id="database-go源码">database.go源码</h2>
<p>它对ethdb做了进一步封装，方便trie中节点的插入删除操作，具体代码小编等下一次讲ethdb.go的时候再来解释。现在就不说了。</p>
<h2 id="iterator-go源码">iterator.go源码</h2>
<p>以太坊提供的对trie树的遍历工具，有兴趣的看看，这里也不解释了，小编也懒得看了。</p>
<h2 id="security-trie-go源码">security_trie.go源码</h2>
<p>这个可以理解为加密了的trie的实现，ecurity_trie包装了一下trie树， 所有的key都转换成keccak256算法计算的hash值。同时在数据库里面存储hash值对应的原始的key。<br>
但是官方在代码里也注释了，这个代码不稳定，除了测试用例，别的地方并没有使用该代码。</p>
<h2 id="总结">总结</h2>
<p>还有几个trie模块下的代码文件，小逼没有提到，不是说不重要，只是小编的精力主要集中在trie的整体逻辑。关于trie，写了两篇文章，写了将近半个月，涉及的比较多，有些地方写的不一定合理，大家可以留言指出。</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊源码解读-第3.1讲-trie原理介绍</title>
    <url>/articles/636a5647/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>了解以太坊的同学都知道，以太坊中有三大重要的状态：<code>账户状态</code>、<code>交易状态</code>、<code>收据状态</code>（不要问小编它们有什么用-_-）。这三大状态怎么保存，怎样保证这些信息的安全？这就离不开我们这次要讲的以太坊<code>trie</code>模块了。</p>
<span id="more"></span>
<p>它提供了一种强大的数据结构<code>Merkle Patricia Tries</code>，我们亲切的称它为<code>MPT</code>。正是它维护着我们的这三种状态，让整个以太坊平稳有序的进行着。<br>
看到这么强大的东西，是不是经不起诱惑了？那我们就快来解刨吧。</p>
<p>这篇文章主要是讲阅读trie模块源码前要掌握<code>编码</code>以及<code>节点原理</code>，具体源码的解析请看小编的另一篇文章：<a href="/articles/dcade07d">以太坊源码解读-第3.2讲-trie模块源码解读</a></p>
<h2 id="mpt的前世今生">MPT的前世今生</h2>
<ul>
<li>MPT是这三种结构的组合：Trie，Patricia Trie，Merkle tree。每一种都非常经典，为了更好的了解以太坊，小编专门整理了三篇文章，值得一读（依次从上往下读）：<br>
<a href="/articles/5f802b92"><code>浅谈标准Trie树（字典树）</code></a><br>
<a href="/articles/12370dbd"><code>Patricia树介绍</code></a><br>
<a href="/articles/b3334ff6"><code>Merkle Tree（默克尔树）算法解析</code></a><br>
正是这三种树的进一步柔和，才有了今天以太坊上大名鼎鼎的MPT。</li>
<li>MPT是什么，它相比上面有什么优势？建议大家看看小编整理的这篇文章：<br>
<a href="/articles/f54d9616"><code>Merkle Patricia Tree (MPT) 以太坊merkle技术分析</code></a></li>
</ul>
<p>注意，上面这篇文章只是宏观上的介绍，MPT也只是大概讲讲是什么样的逻辑，能有个大概映像。具体细节，小编后面再详细介绍。</p>
<h2 id="mpt中的编码概念">MPT中的编码概念</h2>
<p>MPT中会涉及到三种编码：<code>KEYBYTES encoding</code>、<code>HEX encoding</code>、<code>COMPACT encoding</code>，每种编码在特定场合都有其重要的作用，小编曾尝试通过网络中的相关文章来了解这些编码是怎么生成的，但无奈啊，这些文章一个比一个写的复杂，一堆数学公式和专业术语，越看越看不懂。。。<br>
终于，小编还是看完源码后，弯回来，自己来解释下这三种编码具体是怎么实现的。毕竟，了解了这些基础后，再看源码就会容易很多。吸取以前看的文章的不足之处，这次小编一定讲的通俗易懂：</p>
<h3 id="keybytes-encoding">KEYBYTES encoding</h3>
<p>这就是原生的字节，没有添加任何防腐剂：go语言中的<code>byte</code>,长度为8，范围是0～255。二进制表示的话，就是<code>00000000~11111111</code>。<br>
也就是说，一串普通数据通过<code>KEYBYTES encoding</code>编码后，就是由<code>很多byte</code>组成的一个<code>byte[]</code>数组，也就是我么说的字节数组。<br>
这个编码搞开发的应该都懂，不难理解。</p>
<h3 id="hex-encoding">HEX encoding</h3>
<p>我想，把它称为半字节编码(<code>nibble</code>)更好一些，具体细节一会儿讲。<br>
在内存中，这种编码访问会更容易，不要问为什么，小编也不知道。。。涉及到硬件效率相关，貌似是因为16进制更容易计算。<br>
具体这种编码是怎么实现的？这块小编重点讲讲。<br>
用<code>KEYBYTES encoding</code>编码（上面有讲，就是go中普通的byte）转为<code>hex</code>编码的过程来演示，大家可能会更容易理解，先看代码演示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//申明一个byte数据t，值为249，这个t可以理解为就是`KEYBYTES encoding`编码数据</span></span><br><span class="line"><span class="comment">//它将会被转为`hex`编码</span></span><br><span class="line"><span class="keyword">var</span> t <span class="type">byte</span> = <span class="number">249</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为了方便演示这里加一个l变量，表示t的长度为1，也就是总共一个字节</span></span><br><span class="line"><span class="keyword">var</span> l = <span class="number">1</span>  </span><br><span class="line"><span class="comment">//hex编码t总共会用到的空间大小</span></span><br><span class="line">l := <span class="number">2</span>*l + <span class="number">1</span>  </span><br><span class="line"><span class="comment">//开辟l大小的空间，传说中的nibbles</span></span><br><span class="line"><span class="keyword">var</span> nibbles = <span class="built_in">make</span>([]<span class="type">byte</span>, l)  </span><br><span class="line"><span class="comment">//将s的高4位存入nibbles的第一个字节</span></span><br><span class="line">nibbles[<span class="number">0</span>] = s / <span class="number">16</span></span><br><span class="line"><span class="comment">//将s的低4位存入nibbles的第二个字节</span></span><br><span class="line">nibbles[<span class="number">1</span>] = s % <span class="number">16</span></span><br><span class="line"><span class="comment">//nibbles的最后一位存入标示符，代表这个是hex编码</span></span><br><span class="line">nibbles[l<span class="number">-1</span>] = <span class="number">16</span></span><br><span class="line">fmt.Println(nibbles)</span><br></pre></td></tr></table></figure>
<p>最后输出编码为hex的结果nibbles：<br>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[<span class="number">15</span> <span class="number">9</span> <span class="number">16</span>]  <span class="comment">//原先数据的高4位保存位15，低4位保存位9，16表示该hex编码是通过KEYBYTES编码转换的</span></span><br></pre></td></tr></table></figure></p>
<p>代码里有些地方是不是还很懵逼？小编来解释一下：</p>
<ul>
<li>
<p>hex编码的目的是：<br>
要将一个原始字节数组byte[]，其中的每个byte都拆分位高4位和低4位，分别放在同为字节数组的nibbles[]中（<code>bibbles的数组长度为原始字节数组的2倍再加1</code>）。其中依次高4位放在nibbles[]的偶数位，低4位放在nibbles[]的奇数位，最后一位设置为16（二进制表示<code>00010000</code>），表示这个hex编码是通过<code>KEYBYTES</code>编码转换的。</p>
</li>
<li>
<p>还不懂？小编继续换种方式解释：</p>
<ul>
<li>先记住：<code>一个byte的长度为8，范围是0～255。二进制表示的话，就是：00000000~11111111</code>。</li>
<li>要将byte值为<code>249</code>的数据转为hex编码，首先将<code>249</code>转为二进制表示：<code>11111001</code>，看清楚，高4位是1111，低4位是1001</li>
<li>249除以16得到的值为15，15的二进制表示是：1111，看清楚了吗？这就是249的高4位，</li>
<li>249除以16得到的余数为9，9的二进制表示是：1001，看清楚了吗？这就是249的低4位，</li>
<li><code>249</code>的长度为l=1，因此nibbles[]字节数组的长度为2*l+1=3，就是说，hex编码需要用3个byte才能表示了原来的<code>249</code>，nibbles的偶数位nibbles[0]存入<code>249</code>的高4位<code>00001111</code>，nibbles的奇数位nibbles[1]的低4位存入<code>249</code>的低4位<code>00001001</code>,最后一位nibbles[2]存入16（也就是二进制<code>00010000</code>）,发现了吗？hex中的每一个byte都表示一个16进制数。</li>
<li>因此<code>249</code>最终hex编码结果为：[<code>00001111</code>,<code>00001001</code>,<code>00010000</code>]，也就是[15 9 16]</li>
<li>这下该懂了吧，再不懂就只能弯回去再读几遍了。。小编自认为对这个hex编码的解释算是很仔细啦。。</li>
</ul>
</li>
<li>
<p>小编还要补充的重要内容是，很重要，否则很难理解<code>COMPACT encoding</code>编码：</p>
<ul>
<li><code>KEYBYTES encoding</code>编码的数据转成<code>HEX encoding</code>的编码的数据后，该byte[]最后一个是一定有后缀的，值为<code>16</code>，并且除去后缀后，剩余的编码长度为偶数。具体看上面的解释。</li>
<li>hex中两个连续byte表示原始数据的一个byte。</li>
<li>但是小编从以太坊源码中了解到，hex字节数组如果不是经过<code>KEYBYTES encoding</code>编码得到的，可能会有<code>前缀</code>(姑且这么称呼)这么一个东西，具体生成的hex结果会分为如下几种情况：
<ol>
<li>hex字节数组长度为奇数，最后一个是后缀，标记为16，此时无前缀这。种就是前面所讲的经过<code>KEYBYTES encoding</code>编码得到的。</li>
<li>hex字节数组长度为奇数，最后一个不是后缀，此时会认为hex字节数组的第一个是其的前缀。</li>
<li>hex字节数组长度为偶数，最后一个是后缀，此时hex字节数组的第一个一定是其前缀。</li>
<li>hex字节数组长度为偶数，最后一个不是后缀，并且无前缀</li>
</ol>
</li>
</ul>
<p><code>ps:</code>截止目前为止，小编依旧不知道hex的这个前缀是怎么生成的，为什么要有。。。如果有哪个小伙伴了解，可以留言分享一下。</p>
</li>
</ul>
<h3 id="compact-encoding">COMPACT encoding</h3>
<p>这种编码也就是黄皮书里讲的<code>Hex-Prefix Encoding</code>编码，可以看作是<code>HEX encoding</code>编码的另一种形式，在磁盘存储数据的时候，会节省磁盘空间。<br>
既然都说了它是<code>HEX encoding</code>编码的另一种形式，也就是说，<code>COMPACT encoding</code>是通过<code>HEX encoding</code>转换实现的，转换后，会节省将近一半的磁盘空间。<br>
思前想后，换了N种方式，最终小编认为，还是得先通过数学公式来理解什么是<code>COMPACT encoding</code>编码。</p>
<h4 id="数学公式定义">数学公式定义</h4>
<p>这是黄皮书中给出的公式，耐心看，不复杂。</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: No such environment: split at position 7: \begin{̲s̲p̲l̲i̲t̲}̲
HP(x,t):x \in …'>\begin{split}
HP(x,t):x \in \mathbb{Y} &amp;\equiv 
\begin{cases}
&amp;(16f(t),16x[0]+x[1],16x[2]+x[3],...)\ \ \ \ if\ ||x||\ is\ even \\\
&amp;(16(f(t)+1)+x[0],16x[1]+x[2],16x[3]+x[4],...)\ \ \ \ otherwise
\end{cases}
\\\
f(t) &amp;\equiv 
\begin{cases}
&amp;2\ \ \ \ if\ \ t = 1 \\\
&amp;0\ \ \ \ if\ \ t = 0
\end{cases}
\end{split}
</p>
<p>解释一下公式的意思：</p>
<ol>
<li>||x||表示求x的长度，在源码中，x表示一个字节数组byte[]，也就是hex编码。</li>
<li>HP(x,t)代表的就是最终<code>COMPACT encoding</code>编码后的结果，其中的<code>t</code>，黄皮书中原本定义的是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>0</mn><mtext>和</mtext><mi>t</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">t=0和t \neq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord cjk_fallback">和</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>两种情况，但是结合源码，小编将其改为t=0和t=1这两种情况，这样更容易理解。<br>
因为，源码中是这样实现的：<code>当hex有后缀的时候，则t=1，否则t=0</code>。</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Y</mi></mrow><annotation encoding="application/x-tex">\mathbb{Y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Y</span></span></span></span></span>根据hex的长度是<code>偶数(even)</code>还是<code>奇数(odd)</code>，划分为两种集合。每种集合中的第一个数据，代表的是<code>COMPACT encoding</code>编码的前缀，它包含了转换回hex编码所需要的信息。</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Y</mi></mrow><annotation encoding="application/x-tex">\mathbb{Y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Y</span></span></span></span></span>每种集合中的第二个数据开始，你会发现全是<code>16x[i]+x[i+1]</code>这种样式，这在二进制中，其实就是高4位和低4位组成一个byte 8位的过程1。如下图（为了画个像样的图，小编专门学axure。。。）：</li>
</ol>
<img src="/articles/636a5647/1.png" class="" title="16x[i]+x[i+1]过程">
<p><code>COMPACT encoding</code>大体就是这样子，理解了吗？不理解的继续看看后面的代码实现。</p>
<h4 id="代码实现">代码实现</h4>
<p>来看一下hex编码是怎样转换为COMPACT编码的（<code>先知道，hex是有前缀的，前面提到过</code>）,要对着上面公式看：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试案例，将hex编码&#123;1,2,3,4,5&#125;转换成Compact编码，并输出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHexToCompact</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	testBytes := []<span class="type">byte</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	fmt.Print(hexToCompact(testBytes))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于hex编码是转换为COMPACT编码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hexToCompact</span><span class="params">(hex []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	terminator := <span class="type">byte</span>(<span class="number">0</span>) <span class="comment">//初始化一个值为0的byte，它就是我们上面公式中提到的t</span></span><br><span class="line">	<span class="keyword">if</span> hasTerm(hex) &#123; <span class="comment">//验证hex有后缀编码，</span></span><br><span class="line">		terminator = <span class="number">1</span>  <span class="comment">//hex编码有后缀，则t=1</span></span><br><span class="line">		hex = hex[:<span class="built_in">len</span>(hex)<span class="number">-1</span>]  <span class="comment">//此处只是去掉后缀部分的hex编码</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//Compact开辟的空间长度为hex编码的一半再加1，这个1对应的空间是Compact的前缀</span></span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(hex)/<span class="number">2</span>+<span class="number">1</span>) </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//这一阶段的buf[0]可以理解为公式中的16*f(t)</span></span><br><span class="line">	buf[<span class="number">0</span>] = terminator &lt;&lt; <span class="number">5</span> </span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(hex)&amp;<span class="number">1</span> == <span class="number">1</span> &#123; <span class="comment">//hex 长度为奇数，则逻辑上说明hex有前缀</span></span><br><span class="line">		<span class="comment">//这一阶段的buf[0]可以理解为公式中的16*（f(t)+1）</span></span><br><span class="line">		buf[<span class="number">0</span>] |= <span class="number">1</span> &lt;&lt; <span class="number">4</span> </span><br><span class="line">		<span class="comment">//这一阶段的buf[0]可以理解为公式中的16*（f(t)+1）+ x[0]</span></span><br><span class="line">		buf[<span class="number">0</span>] |= hex[<span class="number">0</span>]  </span><br><span class="line">		hex = hex[<span class="number">1</span>:] <span class="comment">//此时获取的hex编码无前缀无后缀</span></span><br><span class="line">	&#125;</span><br><span class="line">	decodeNibbles(hex, buf[<span class="number">1</span>:]) <span class="comment">//将hex编码映射到compact编码中</span></span><br><span class="line">	<span class="keyword">return</span> buf  <span class="comment">//返回compact编码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeNibbles</span><span class="params">(nibbles []<span class="type">byte</span>, bytes []<span class="type">byte</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> bi, ni := <span class="number">0</span>, <span class="number">0</span>; ni &lt; <span class="built_in">len</span>(nibbles); bi, ni = bi+<span class="number">1</span>, ni+<span class="number">2</span> &#123;</span><br><span class="line">		bytes[bi] = nibbles[ni]&lt;&lt;<span class="number">4</span> | nibbles[ni+<span class="number">1</span>] <span class="comment">//这个过程就是16x[i]+x[i+1]的过程</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后输出的Compact编码结果为：<br>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//17为compact前缀</span></span><br><span class="line">[<span class="number">17</span> <span class="number">35</span> <span class="number">69</span>]  </span><br></pre></td></tr></table></figure><br>
大伙这下该理解Compact编码是怎么实现的了吧？要还有什么疑问，就请大家留言吧。。</p>
<h3 id="总结一下">总结一下</h3>
<p>在以太坊中，<code>KEYBYTES encoding</code>不会直接转位<code>COMPACT encoding</code>，需要先经过<code>HEX encoding</code>。<br>
三种编码中，目前以太坊只支持如下转换：</p>
<ul>
<li><code>KEYBYTES encoding</code>转<code>HEX encoding</code></li>
<li><code>HEX encoding</code>转<code>KEYBYTES encoding</code></li>
<li><code>HEX encoding</code>转<code>COMPACT encoding</code></li>
<li><code>COMPACT encoding</code>转<code>HEX encoding</code></li>
</ul>
<h2 id="mpt树的形成原理">MPT树的形成原理</h2>
<p>MPT的节点的形成等细节，网上很多文章讲的都很模糊，对于初学者很难理解，小编当初也是半天没看懂，最终还是看了源码后才真正了解是怎么一回事。也因此打算以自己的方式举个例子来好好解释下这些细节。<br>
我们假设要将4个交易信息：<code>A</code>、<code>B</code>、<code>C</code>、<code>D</code>存储在MPT中，需要经过以下一系列操作。这四个交易信息，假设分别如下：<br>
<code>A</code>的交易信息内容：i am a<br>
<code>B</code>的交易信息内容：i am b<br>
<code>C</code>的交易信息内容：i am c,i am not d<br>
<code>D</code>的交易信息内容：i am d,i am not c</p>
<h3 id="1-将源数据序列化">1. 将源数据序列化</h3>
<p>为了便于传输，<code>A</code>、<code>B</code>、<code>C</code>、<code>D</code>这四个交易信息的数据是需要先使用<a href="articles/reprint/blockchain/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E7%AC%AC2%E8%AE%B2-rlp%E6%A8%A1%E5%9D%97%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.html">rlp</a>进行序列化的，它们经过序列化后分别为如下结果：<br>
<code>A_Serialize</code>：[134 105 32 97 109 32 <strong>97</strong>]<br>
<code>B_Serialize</code>：[134 105 32 97 109 32 <strong>98</strong>]<br>
<code>C_Serialize</code>：[145 105 32 97 109 32 <strong>99</strong> 44 105 32 97 109 32 110 111 116 32 <strong>100</strong>]<br>
<code>D_Serialize</code>：[145 105 32 97 109 32 <strong>100</strong> 44 105 32 97 109 32 110 111 116 32 <strong>99</strong>]</p>
<h3 id="2-为序列化后的数据源生成hash并将其转为hex编码">2. 为序列化后的数据源生成hash并将其转为hex编码</h3>
<p>在MPT中，其实是在操作经过hex编码的hash(32位)。因此上面序列化后的数据，需要做如下两部分操作：</p>
<ul>
<li>生成hash（均为32位长度）：<br>
<code>A_Hash</code>：[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 134 105 32 97 109 32 <strong>97</strong>]<br>
<code>B_Hash</code>：[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 134 105 32 97 109 32 <strong>98</strong>]<br>
<code>C_Hash</code>：[0 0 0 0 0 0 0 0 0 0 0 0 0 0 145 105 32 97 109 32 <strong>99</strong> 44 105 32 97 109 32 110 111 116 32 <strong>100</strong>]<br>
<code>D_Hash</code>：[0 0 0 0 0 0 0 0 0 0 0 0 0 0 145 105 32 97 109 32 <strong>100</strong> 44 105 32 97 109 32 110 111 116 32 <strong>99</strong>]</li>
<li>对上面这些hash进行hex编码（内存运算效率高），依据hex编码原理，最终结果每个都是65位长度：<br>
<code>A_Hex</code>：[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 6 6 9 2 0 6 1 6 13 2 0 6 <strong>1</strong> 16]<br>
<code>B_Hex</code>：[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 6 6 9 2 0 6 1 6 13 2 0 6 <strong>2</strong> 16]<br>
<code>C_Hex</code>：[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9 1 6 9 2 0 6 1 6 13 2 0 6 <strong>3</strong> 2 12 6 9 2 0 6 1 6 13 2 0 6 14 6 15 7 4 2 0 6 <strong>4</strong> 16]<br>
<code>D_Hex</code>：[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9 1 6 9 2 0 6 1 6 13 2 0 6 <strong>4</strong> 2 12 6 9 2 0 6 1 6 13 2 0 6 14 6 15 7 4 2 0 6 <strong>3</strong> 16]</li>
</ul>
<h3 id="3-生成mpt树">3. 生成MPT树</h3>
<p>前两步准备ok，接下来我们就要生成这颗MPT树了。讲多少遍也不如画一张图，我们先把这颗MPT树画出来，然后再来解释</p>
<img src="/articles/636a5647/2.png" class="" title="MPT树基本结构">
<p>从图中我们可以看出MPT的节点分为四种：<code>根节点</code>、<code>分支节点</code>、<code>扩展节点</code>、<code>叶子节点</code>，下面我们来详细解释一下这些节点的作用：</p>
<ul>
<li>根节点<br>
根节点不存有任何信息，是一颗空节点</li>
<li>扩展节点<br>
是&lt;K,V&gt;类型的节点，这节点中，K是hash的公共部分，就比如上面的<code>A_Hex</code>、<code>B_Hex</code>、<code>C_Hex</code>和<code>D_Hex</code>它们每个hash值从开始处，<code>0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 </code>共28个0是公共一致的，因此图中最上面的分支节点key就是这个公共部分;而V则是一个指针，会指向分支节点或者叶子节点。</li>
<li>分支节点<br>
这个节点中有17个字段，其中前16个中，分别存有16进制从0～f中的一个字符，而这每一个字符所处区域，又指向hash非公共区域的起始位置，这块靠文字解释很难解释清楚，建议大家直接看图吧。<br>
而第17个字段则存储在此处截止的节点信息，比如有三个key,分别是 (abc ,abd, ab) 第17个字段储存了ab节点的值。这块还有一些细节小编也还没搞懂，等后期了解后，再调整。</li>
<li>叶子节点<br>
存储的是rlp编码后的原始数据，这个同样看图，文字很难说明，小编最初也是看各种文章文字解释，越解释越乱。</li>
</ul>
<p>小编想补充说明的是，在MPT中，除了叶子部分存有真实的数据，其余部分存储了完整的数据校验信息，只要获取到非叶子部分的MPT树，就可以进行如下几个操作：</p>
<ul>
<li>下载某个hash对应的数据块</li>
<li>校验下载的数据块是不是真实的</li>
</ul>
<p>看图，因为从根节点到叶子节点前，可以获取到一个完整的hash。</p>
<p>另外，只要节点中某条路径下新增或者删除节点，整条路径的节点都会被重新实例化，然后重新插入db。</p>
<h3 id="本节总结">本节总结</h3>
<p>本节使用一个案例，介绍了生成一棵MPT树的基本流程，这为我们后续在代码中理解整个过程打下了非常好的基础。</p>
<h2 id="mpt轻节点">MPT轻节点</h2>
<h3 id="引出">引出</h3>
<p>上面的MPT树，有两个问题：</p>
<ul>
<li>每个节点都包含有大量信息，并且叶子节点中还包含有完整的数据信息。如果该MPT树并没有发生任何变化，并且没有被使用，则会白白占用一大片空间，想象一个以太坊，有多少个MPT树，都在内存中，那还了得。</li>
<li>并不是任何的客户端都对所有的MPT树都感兴趣，若每次都把完整的节点信息都下载下，下载时间长不说，并且会占用大量的磁盘空间。</li>
</ul>
<h3 id="解决方式">解决方式</h3>
<p>为了解决上述问题，以太坊使用了一种缓存机制，可以称为是轻节点机制（名词是小编瞎编的），大体如下：</p>
<ul>
<li>若某节点数据一直没有发生变化，则仅仅保留该节点的32位hash值，剩下的内容全部释放</li>
<li>若需要插入或者删除某节点，先通过该hash值db中查找对应的节点，并加载到内存，之后再进行删除插入操作</li>
</ul>
<h3 id="图示轻节点">图示轻节点</h3>
<p>根据上述，一棵长时间没有发生变化的MPT树，它内存应该是一棵轻节点树，如下图所示：</p>
<img src="/articles/636a5647/3.png" class="" title="内存中的轻节点">
<p>是不是很惊讶，root节点指向一个只有hash值的节点，该hash表示的是完整节点中MPT中root指向的那个节点本身的hash。</p>
<h4 id="轻节点中添加数据">轻节点中添加数据</h4>
<p>内存中只有这么一个轻节点，但是我要添加一个数据，也就是要给完整的MPT树中添加一个叶子节点，怎么添加？大体如下图所示：</p>
<img src="/articles/636a5647/4.png" class="" title="轻节点添加数据">
<h3 id="删除和获取">删除和获取</h3>
<p>delete、get操作与上面的添加数据过程类似，小编就不讲了</p>
<h2 id="全文总结">全文总结</h2>
<p>本文需要了解中的三种编码，以及MPT树的形成原理、MPT轻节点的原理。<br>
小编的初衷是为了更通俗的解释一些比较理论的概念，若有不合适的地方，大家可以留言，小编会及时改进的。</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>Patricia树介绍</title>
    <url>/articles/12370dbd/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>小编本想在网上找一篇合适的文章来介绍这个Patricia树的，但找了半天，没发现一个合适的。尤其很多地方直接把标准的trie当成了Patricia树，这样很容易受到勿扰。<br>
思来想去，小编打算自己大概介绍下这个树了。</p>
<span id="more"></span>
<p>看该文前，Patricia树是标准trie的改进，因此，建议大家先看看另一篇文章：<a href="/articles/5f802b92">浅谈标准Trie树（字典树）</a></p>
<h2 id="什么是patricia树">什么是Patricia树</h2>
<p>对标准Trie树有过了解后，聪明的你会发现标准Trie树有如下缺点：</p>
<ol>
<li>标准Trie树给每个字符分配一个结点，如果某个字符串没有公共结点，那就变成，一个字符串每个字符占用一个空间，长此下去，资源量费</li>
<li>容易遭到黑客拒绝服务攻击。</li>
</ol>
<p>为了解决这些问题，Patricia树悄然而生，它和标准Trie树最大的区别就是，<code>对于其中的结点，如果该节点是唯一的儿子的话，就和父节点合并。</code><br>
标准trie树再讲一遍也没意思，下面这张图是小编在网上找到的一张很能标明Patricia树结构的图，应该是一目了然吧？</p>
<img src="/articles/12370dbd/1.png" class="" title="patricia树示例">
<p>公共结点与<code>标准Trie树一样</code>，叶子结点处，都是兄弟。也就是说，除了叶子结点，每个结点都有左孩子和右孩子。</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>综合</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊源码解读-第2讲-rlp模块源码解读</title>
    <url>/articles/c2a19e0e/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>在正式解读源码前，小编想先解释下为什么使用选择这一模块作为以太坊源码解读的开端：</p>
<ol>
<li>该模块可以独立于其余模块，且内容少，便于理解整体编码风格，找找感觉。</li>
<li>不懂go语言的，读完这么模块，基本就没什么语言障碍了，话说，go语言是有点怪。。</li>
</ol>
<span id="more"></span>
<h2 id="什么是rlp">什么是rlp</h2>
<ul>
<li>rlp(递归长度前缀，Recursive Length Prefix)，是不是看的一脸懵逼？</li>
<li>序列化听说过不？java开发的同学们应该更了解吧？<code>rlp</code>就是以太坊中的序列化工具，它可以将其中涉及到的任何类型的数据都转化为字节序列，方便网络传输。</li>
<li>待序列化的数据需要<code>大端</code>化处理</li>
<li>以太坊的rlp主要分为：<code>对树形结构的数据序列化</code>以及<code>字节数组的序列化</code>。</li>
<li>rlp适用于任意二进制数据数组的编码。</li>
</ul>
<h2 id="以太坊中rlp规则">以太坊中rlp规则</h2>
<p>黄皮书中，介绍到了以太坊的rlp规则，公式比较多，小编一个个来解释一下。<br>
公式是从整体到细节的，希望大家能按顺序看，这样看更容易理解</p>
<h3 id="公式中可能涉及到的符号解释">公式中可能涉及到的符号解释</h3>
<ul>
<li>||x||表示公式的长度</li>
<li><code>这个点号符号</code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋅</mo></mrow><annotation encoding="application/x-tex">\cdot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord">⋅</span></span></span></span><code>表示的是字符串衔接，不是相乘</code></li>
<li>BE(x)表示x的<code>大端模式</code>,啥是大端模式小编不解释，基础概念，上百度谷歌一下～</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≡</mo></mrow><annotation encoding="application/x-tex">\equiv</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mrel">≡</span></span></span></span>，恒等于，理解成等于姑且也可以。。。</li>
<li>剩下的符号，小编看了看，都是初中高中的，不要说不知道。。。</li>
</ul>
<h3 id="公式1：待序列化数据定义">公式1：待序列化数据定义</h3>
<p>要被序列化的数据类型，用数学定义如下：</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: No such environment: split at position 7: \begin{̲s̲p̲l̲i̲t̲}̲
&amp;\mathbb{T} \e…'>\begin{split}
&amp;\mathbb{T} \equiv \mathbb{L} \cup \mathbb{B} \\\
&amp;\mathbb{L} \equiv \\{t: t = (t[0], t[1], ...) \cap \forall_{n&lt;||t||}\ t[n] \in \mathbb{T} \\} \\\
&amp;\mathbb{B} \equiv \\{b: b = (b[0], b[1], ...) \cap \forall_{n&lt;||b||}\ b[n] \in \mathbb{O} \\}
\end{split}
</p>
<p>解释的不一定合理，但大体是这么个意思:</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">T</mi></mrow><annotation encoding="application/x-tex">\mathbb{T}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">T</span></span></span></span></span>表示：待序列化数据中，<em>字节数组</em>以及*树形结构（树、结构体）*的数据。</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">L</mi></mrow><annotation encoding="application/x-tex">\mathbb{L}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">L</span></span></span></span></span>表示：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">T</mi></mrow><annotation encoding="application/x-tex">\mathbb{T}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">T</span></span></span></span></span>之一的，不止一个节点的树形结构。</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">B</mi></mrow><annotation encoding="application/x-tex">\mathbb{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">B</span></span></span></span></span>表示：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">T</mi></mrow><annotation encoding="application/x-tex">\mathbb{T}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">T</span></span></span></span></span>之一的，字节数组。</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">O</mi></mrow><annotation encoding="application/x-tex">\mathbb{O}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85556em;vertical-align:-0.16667em;"></span><span class="mord"><span class="mord mathbb">O</span></span></span></span></span>表示：小编的理解是，包括待序列化数据以外的，任何字节数组。要知道最终序列化时，待序列化的数据是需要大端处理的。</li>
</ul>
<h3 id="公式2：序列化过程">公式2：序列化过程</h3>
<p>以太坊序列化是如何执行的：</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \
 at position 65: …n \mathbb{B} \\\̲
̲R_l(x), &amp;\ othe…'>RLP(x) \equiv
\begin{cases}
R_b(x), &amp;\ if\ \ x \in \mathbb{B} \\\
R_l(x), &amp;\ otherwise \\\
\end{cases}
</p>
<p>这个公式就好理解了吧，对于这两大类数据，执行不同的函数来处理序列化</p>
<h3 id="公式3：r-b-x-字节数组的序列化规则">公式3：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>b</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R_b(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>字节数组的序列化规则</h3>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \
 at position 63: …cap x[0]&lt;128 \\\̲
̲(128+||x||) \cd…'>R_b(x) \equiv
\begin{cases}
x, &amp;if\ \ ||x||=1 \cap x[0]&lt;128 \\\
(128+||x||) \cdot x, &amp;else\ if\ \ ||x||&lt;56 \\\
(183+||BE(||x||)||) \cdot BE(||x||)\cdot x, &amp;otherwise
\end{cases}
</p>
<p>这公式的意思如下：</p>
<ul>
<li>如果字节数组长度为1，且这个字节的值小于128，则不处理</li>
<li>如果不满足上一条要求，但是满足字节数组的长度小于56，那么就在原始数据前面加上<code>128与该字节数组长度之和</code>，该过程类似字符串衔接。</li>
<li>如果不满足以上两种条件，那么就先在原始数据前面加上<code>原始数据长度的大端表示的数据</code>，再在其前面加上<code>183与原始数据大端表示的长度之和</code></li>
</ul>
<h3 id="公式4-r-l-x-树型结构数据的序列化规则">公式4: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>l</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R_l(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>树型结构数据的序列化规则</h3>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: No such environment: split at position 7: \begin{̲s̲p̲l̲i̲t̲}̲
s(x) &amp;\equiv R…'>\begin{split}
s(x) &amp;\equiv RLP(x_0) \cdot RLP(x_1)...\\\
R_l(x) &amp;\equiv
\begin{cases}
(192+||s(x)||) \cdot s(x), &amp;if\ \ ||s(x)||&lt;56 \\\
(247+||BE(||s(x)||)||) \cdot BE(||s(x)||) \cdot s(x), &amp;otherwise \\\
\end{cases}
\end{split}
</p>
<p>第1个公式的意思如下：</p>
<ul>
<li>将树形结构中的每个元素分别使用RLP进行处理，然后将处理结果依次连接起来（字符串连接），生成新的字节，表示为<code>s</code>。</li>
</ul>
<p>第2个公式的意思如下：</p>
<ul>
<li>如果公式1连接后的<code>s</code>字节长度小于56，那结果就是在<code>s</code>前面连接上<code>192与 *s的长度* 之和</code></li>
<li>如果不满足上面的要求，也就是<code>s</code>字节长度大于等于56，则在s的前面连接上<code>s长度的大端表示</code>，再在其前面加上<code>247与*连接后长度的大端模式的长度*</code></li>
</ul>
<p>看懂上面的两个公式了不？看懂的话，你就会明白，这公式会是一个<code>递归过程</code>，因为结构体里还有结构体，一层又一层。。。</p>
<h3 id="公式5-标量数据处理-特殊数据">公式5: 标量数据处理(特殊数据)</h3>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>L</mi><mi>P</mi><mo stretchy="false">(</mo><mi>i</mi><mo>:</mo><mi>i</mi><mo>∈</mo><mi mathvariant="double-struck">P</mi><mo stretchy="false">)</mo><mo>≡</mo><mi>R</mi><mi>L</mi><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mi>E</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">RLP(i:i \in \mathbb{P} ) \equiv RLP(BE(i))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbb">P</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p>
<p>标量数据，可以理解为我们通常所说的基本的数据。<br>
此时RLP只能用来处理正整数。这块理解貌似有点费劲，后面可以看看源码来进一步了解。这些数据需要先大端处理。</p>
<h3 id="总结：">总结：</h3>
<p>抛离公式，小编在此总结一下，RLP是如下处理数据的：</p>
<ol>
<li>如果是一个单字节(长度为1)并且其值在<code>[0x00,0x7f]</code>范围内（即0～127），RLP编码就是自身。</li>
<li>如果一个数据串的字节长度是0-55字节，那么它的RLP编码是在数据串开头增加一个字节，这个字节的值是0x80加上数据串的字节长度。因此增加的该字节的取值范围为[0x80, 0xb7]。</li>
<li>如果一个数据串的字节长度大于55，那么它的RLP编码是在开头增加一个字节，这个字节的值等于0xb7加上数据串字节长度的二进制编码的字节长度，然后依次跟着数据串字节长度部分和内容部分。比如：一个长度为1024字节的数据串，其字节长度用16进制表示为0x0400，长度为2个字节，因此RLP编码头字节的值为0xb9（0xb7 + 0x02），然后跟着两字节为0x0400，后面再加上数据串的具体内容。因此增加的首字节的取值范围为[0xb8, 0xbf]，因此其能编码的最大数据长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>5</mn></msup><mn>6</mn></mrow><annotation encoding="application/x-tex">2^56</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mord">6</span></span></span></span></li>
<li>如果是一个嵌套的列表数据，则需要先将列表中的数据按照单元素的编码规则进行RLP编码后串联得到列表数据的s。如果一个列表数据的s的字节长度为0-55，那么列表的RLP编码在其s前加上一个字节，这个字节的值是0xc0加上s的字节长度。因此首字节的取值范围为[0xc0, 0xf7]。</li>
<li>如果一个列表数据的s的长度大于55，那么它的RLP编码是在开头增加一个字节，这个字节的值等于0xf7加上列表s字节长度的二进制编码的字节长度，然后依次跟着s字节长度部分和s部分。因此首字节的取值范围为[0xf8, 0xff]，因此一个列表中存储的所有元素的字节长度不能超过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>5</mn></msup><mn>6</mn></mrow><annotation encoding="application/x-tex">2^56</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mord">6</span></span></span></span>。</li>
</ol>
<h2 id="rlp源码解析">RLP源码解析</h2>
<p>讲了一堆天书，终于到了关键地方了。<br>
rlp分为<code>编码</code>和<code>解码</code>两个部分，当然，小编只会讲<code>编码</code>过程。<br>
<code>解码</code>过程的实现和<code>编码</code>过程都差不多。<br>
另外一个原因是小编没那么多精力去那么细看啦，知道有那么一回事就行。</p>
<h3 id="rlp编码后数据格式：">rlp编码后数据格式：</h3>
<p>为了便于更好的理解后面的代码，小编现画出如下结构图：</p>
<img src="/articles/c2a19e0e/1.png" class="" title="序列化后的数据结构">
<p>除了最后一个编码数据，其余编码后的每个原始数据之后，都对应的标有该数据的起始和截止位置信息。</p>
<h3 id="rlp模块源文件结构">rlp模块源文件结构</h3>
<p>项目根目录下，找到<code>rlp</code>目录，里面如下结构：<br>
.<br>
|____raw.go                  //用于处理编码后的rlp数据，比如计算长度、分离等<br>
|____raw_test.go             //rlp数据测试用例<br>
|____encode.go               //编码器，用于将给定的数据编码为rlp<br>
|____encode_test.go          //编码测试，各种测试用例验证编码器的稳定性<br>
|____encoder_example_test.go //用案例体验测试编码<br>
|____decode.go               //解码器，用于将rlp数据解码为原始数据<br>
|____decode_test.go          //用于测试解码，各种测试用例测试解码器的稳定性<br>
|____decode_tail_test.go     //用案例体验测试解码<br>
|____typecache.go            //类型缓存，用于记录哪些类型数据应该如何处理（如何编码和解码）<br>
|____doc.go                  //没什么，rlp的相关描述</p>
<h3 id="rlp编码过程解析：第1部分">rlp编码过程解析：第1部分</h3>
<p>经过小编分析，从<code>encoder_example_test.go</code>这个文件作为入口来分析是最合适不过的。<br>
该example的目的是编码一个结构体。根据前面的描述可知，编码一个结构体，基本就会牵涉到rlp的所有编码逻辑了。<br>
具体来看看该文件的内容，先是定义了一个要进行编码的结构体，名为<code>MyCoolType</code>,而紧随其后，定义了属于该结构体的一个函数<code>EncodeRLP()</code>。<br>
此处<code>EncodeRLP()</code>其实是一个<code>被实现了的接口函数</code>，等后面分析了<code>encode.go</code>的代码就会明白（具体go语法的接口实现，小编不想解释。。小编突然觉得，<code>该写个go语言教程了</code>)。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyCoolType <span class="keyword">struct</span> &#123;  <span class="comment">//要编码的的结构体</span></span><br><span class="line">	Name <span class="type">string</span>  <span class="comment">//字符串，名称</span></span><br><span class="line">	a, b <span class="type">uint</span>    <span class="comment">//两个整型数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 呵呵，(x *MyCoolType)表示，该方法是属于结构体的MyCoolType</span></span><br><span class="line"><span class="comment">// 呵呵，(err error)表示这个方法的返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *MyCoolType)</span></span> EncodeRLP(w io.Writer) (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> x == <span class="literal">nil</span> &#123;  <span class="comment">//若结构体指针本身是空的，则编码&#123;0,0&#125;</span></span><br><span class="line">		err = Encode(w, []<span class="type">uint</span>&#123;<span class="number">0</span>, <span class="number">0</span>&#125;) <span class="comment">//此处可以发现，真正参与编码的只有结构体中的a,b两个</span></span><br><span class="line">	&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;  <span class="comment">//否则编码指定结果</span></span><br><span class="line">		err = Encode(w, []<span class="type">uint</span>&#123;x.a, x.b&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着来看看具体该结构体编码的过程</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例，测试为空和不为空的结构体的编码方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleEncoder</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> t *MyCoolType <span class="comment">// t 是空指针</span></span><br><span class="line">	bytes, _ := EncodeToBytes(t) <span class="comment">//编码成字节数组</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v → %X\n&quot;</span>, t, bytes)  <span class="comment">//输出编码结果</span></span><br><span class="line"></span><br><span class="line">	t = &amp;MyCoolType&#123;Name: <span class="string">&quot;foobar&quot;</span>, a: <span class="number">5</span>, b: <span class="number">6</span>&#125; <span class="comment">//t有数据</span></span><br><span class="line">	bytes, _ = EncodeToBytes(t)  </span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v → %X\n&quot;</span>, t, bytes)  <span class="comment">//输出编码结果</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Output:         //标准测试，必须如此输出，用于校验输出结果        </span></span><br><span class="line">	<span class="comment">// &lt;nil&gt; → C28080</span></span><br><span class="line">	<span class="comment">// &amp;&#123;foobar 5 6&#125; → C20506</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体怎么运转这个测试，不要问小编，小编是个大忙人。。。</p>
<h3 id="rlp编码过程解析：第2部分">rlp编码过程解析：第2部分</h3>
<p>从上一部分example中发现，编码的入口函数是：<code>EncodeToBytes()</code>，随即我们跟踪到<code>encode.go</code>这个文件中，重头戏来了.</p>
<ol>
<li>
<p>先来看看该文件中定义的两个全局内容：</p>
<ul>
<li>该文件定义了，<code>空数据（理解成字符串吧）</code>和<code>空集合（树形结构）</code>对应编码后的结果  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">EmptyString = []<span class="type">byte</span>&#123;<span class="number">0x80</span>&#125;  <span class="comment">//128，定义了序列化时候的空字符串，空的时候对应的是编码128。</span></span><br><span class="line">EmptyList   = []<span class="type">byte</span>&#123;<span class="number">0xC0</span>&#125;  <span class="comment">//192，定义了序列化时候的空集合，空的时候对应的编码192</span></span><br></pre></td></tr></table></figure>
</li>
<li>其次，定义了一个接口，用于自定义编码数据（<code>看到了不，第1部分那个结构体里实现的方法，就是这个接口</code>）：  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以理解为，任何拥有下面接口中函数的`结构体`，都表示继承并实现了该接口</span></span><br><span class="line"><span class="keyword">type</span> Encoder <span class="keyword">interface</span> &#123;</span><br><span class="line">	EncodeRLP(io.Writer) <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>第1部分的一个待编码的结构体中，有两个uint数据，编码后，两个uint的序列是会衔接在一起的，因此为了便于区分我是需要知道每个uint在编码序列中的哪个位置，因此，有这么一个结构体：  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> encbuf <span class="keyword">struct</span> &#123;</span><br><span class="line">	str     []<span class="type">byte</span>      <span class="comment">// 被编码后的数据全部在此处，比如第1部分结构体中的两个uint，编码后的结果都紧挨着存在该str中</span></span><br><span class="line">	lheads  []*listhead <span class="comment">// 每个数据在编码序列中存储的位置。比如，还是上面那两个uint，编码后，第一个uint在str中的起始位置是多少，截止位置是多少，都在listhead[0]中记录的</span></span><br><span class="line">	lhsize  <span class="type">int</span>         <span class="comment">// lheads的长度，也就是说，被编码的数据有几个。比如，两个uint参与编码，那lhsize=2</span></span><br><span class="line">	sizebuf []<span class="type">byte</span>      <span class="comment">// 9个字节大小的辅助buffer，专门用来处理uint的编码的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>呵呵，<code>listhead</code>这个结构体是如下定义的，用来确定被编码的数据，在序列中的哪一部分：  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> listhead <span class="keyword">struct</span> &#123;</span><br><span class="line">	offset <span class="type">int</span> <span class="comment">// 被编码的某个数据在序列中的起始位置</span></span><br><span class="line">	size   <span class="type">int</span> <span class="comment">// 包含头部在内的所有编码了的数据的总长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>另外，encbuf结构体有如下这些函数（函数比较多，小编在此概述一下这些函数的功能）：
<ol>
<li><code>reset()</code>：用于将encbuf中的数据初始化，后面对象池中调取时候，会用到。</li>
<li><code>Write()</code>：实现了<code>io.Writer的接口</code>，用于连接byte[]编码，可以理解为字符串连接，在结构体若实现了<code>EncodeRLP</code>自定义编码，用<code>Write()</code>函数会很方便</li>
<li><code>encode()</code>：用于编码数据，同时将先后编码的数据依次衔接起来（<code>后面详细介绍</code>）。</li>
<li><code>encodeStringHeader()</code>：将encbuf中的头部是需要序列化，该函数是将头部结构体中的一个<code>新的编码后的元素</code>和<code>先前已编码的所有数据</code>衔接起来</li>
<li><code>encodeString()</code>：该函数是将当前编码后的一个原始数据衔接到已编码的所有数据之后</li>
<li><code>list()</code>：用于保存每个元素编码后的头部信息，</li>
<li><code>listEnd()</code>：编码衔接结束后的长度统计处理</li>
<li><code>size()</code>：计算编码后的数据和其头部的总长度</li>
<li><code>toBytes()</code>：将每个头部编码，并衔接到对应的编码后的数据之后</li>
<li><code>toWriter</code>：该方法是io流方式，将编码后的头部写在编码数据之后</li>
<li>看不懂这些方法的同学，最好先好好看看上面画的那个<code>序列化后的数据结构</code>图</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>ok，接着来看看我们的<code>EncodeToBytes()</code>函数，它就是用来将数据序列化为byte数组的元凶。<br>
该函数中，可以发现，为了减少资源浪费，提高连续编码的效率，以太坊使用了对象池来保存一个<code>encbuf</code>实例<br>
<code>ps</code>:下面代码有个关键词叫<code>defer</code>，表示，这行代码要等return完之后才会执行。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncodeToBytes</span><span class="params">(val <span class="keyword">interface</span>&#123;&#125;)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	eb := encbufPool.Get().(*encbuf)  <span class="comment">//从对象池中获取一个用于存储完整编码数据的空间</span></span><br><span class="line">	<span class="keyword">defer</span> encbufPool.Put(eb)          <span class="comment">//return 结束之后才会执行，将实例化的encbuf放入对象池，方便下次使用。</span></span><br><span class="line">	eb.reset()  <span class="comment">//encbuf结构体的函数，初始化该结构体对应实例中的元素</span></span><br><span class="line">	<span class="keyword">if</span> err := eb.encode(val); err != <span class="literal">nil</span> &#123; <span class="comment">//原始数据进行编码，刚编码好的数据是放在字符串中的</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> eb.toBytes(), <span class="literal">nil</span> <span class="comment">//将编码后的数据本身和头部衔接起来并放在byte[]中，并返回最终结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里真正重要的一段代码就是：<code>eb.encode(val)</code>，不要闷逼，再次强调<code>eb</code>是<code>encbuf结构体的实例</code>，<code>encode</code>是其最重要的函数，看看它的实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *encbuf)</span></span> encode(val <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">	rval := reflect.ValueOf(val)  <span class="comment">//获取该数据具体的值（包括结构体）</span></span><br><span class="line">	ti, err := cachedTypeInfo(rval.Type(), tags&#123;&#125;) <span class="comment">//根据数据类型来编码数据</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ti.writer(rval, w)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先注意一下其中的最后一行代码涉及到的<code>writer()</code>，这个在下一节中会具体去讲，简单说就是，writer被定义为了一种数据类型，<code>只要满足它函数格式的，都属于writer类型</code><br>
好的，这块代码，其中的<code>cachedTypeInfo()</code>，把我们的节奏引入了高潮，具体如何，且听下一部分分析</p>
<h3 id="rlp编码过程解析：第3部分">rlp编码过程解析：第3部分</h3>
<p>继续上回讲解，<code>cachedTypeInfo()</code>函数是在<code>typecache.go</code>中实现的，这个文件里，对编码和解码做了详细的规划，让我们更加清晰的了解到了rlp的全局结构。</p>
<ol>
<li><code>cachedTypeInfo()</code>函数具体怎么回事我们先不说，按惯例，先来看看<code>typecache.go</code>该文件中主要定义了哪些全局属性：
<ul>
<li>该文件定义了一个读写锁，多线程、并发读取数据时候的保护措施；还定义了一个映射，不同的数据类型，对应不同的编码或者解码器。  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	typeCacheMutex sync.RWMutex    <span class="comment">//读写锁，用来在多线程的时候保护typeCache这个Map</span></span><br><span class="line">	<span class="comment">//核心数据结构，保存了类型-&gt;编解码器函数，*typeinfo指针类型，根据不同的数据类型（reflect.Type），保存不同的解码方式</span></span><br><span class="line">	typeCache      = <span class="built_in">make</span>(<span class="keyword">map</span>[typekey]*typeinfo)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
其中发现有两个重要的结构体：
<ul>
<li>首先是<code>typekey</code>，定义了数据所属类型，以及该数据的特点（是否是集合，是否为空等）  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> typekey <span class="keyword">struct</span> &#123;</span><br><span class="line">	reflect.Type   <span class="comment">//数据类型不同，则编码解码的数据类型也不同</span></span><br><span class="line">	tags <span class="comment">//某种数据类型中，是否为空，是否为集合，不同情况处理不同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在该结构体其中其中，又有一个<code>tags</code>结构体，主要是用来标注数据的特点，如下：  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> tags <span class="keyword">struct</span> &#123;</span><br><span class="line">	nilOK <span class="type">bool</span>  <span class="comment">//是否为空</span></span><br><span class="line">	tail <span class="type">bool</span>  <span class="comment">//是否为集合（切片）</span></span><br><span class="line">	ignored <span class="type">bool</span>  <span class="comment">//该参数留着，备用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>其次定义了一个编码器和解码器的结构体<code>typeinfo</code>，注意他们对应的函数  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> typeinfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	decoder  <span class="comment">//解码，</span></span><br><span class="line">	writer   <span class="comment">//编码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> decoder <span class="function"><span class="keyword">func</span><span class="params">(*Stream, reflect.Value)</span></span> <span class="type">error</span> <span class="comment">//把满足该结构的函数，定义为数据类型decoder</span></span><br><span class="line"><span class="keyword">type</span> writer <span class="function"><span class="keyword">func</span><span class="params">(reflect.Value, *encbuf)</span></span> <span class="type">error</span>  <span class="comment">//把满足该结构的函数，定义为数据类型writer</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>接着我们来讲讲期待已久的<code>cachedTypeInfo()</code>函数，怎么说吧，它的作用是，根据数据属性的不同，返回一个合适的<code>编码\解码器</code>来处理该数据，为了保证读写安全，使用了读写锁；为了提高效率，缓存了<code>数据类型</code>和<code>编码\解码器</code>的映射（就是说，比如字符串类型的数据，要用到专门处理字符串的编码\解码器）。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cachedTypeInfo</span><span class="params">(typ reflect.Type, tags tags)</span></span> (*typeinfo, <span class="type">error</span>) &#123;</span><br><span class="line">	typeCacheMutex.RLock()  <span class="comment">//加读锁来保护</span></span><br><span class="line">	info := typeCache[typekey&#123;typ, tags&#125;]  <span class="comment">//在缓存中查是找是否有typ类型的数据对应的 编码\解码器</span></span><br><span class="line">	typeCacheMutex.RUnlock()</span><br><span class="line">	<span class="keyword">if</span> info != <span class="literal">nil</span> &#123;   </span><br><span class="line">		<span class="keyword">return</span> info, <span class="literal">nil</span>  <span class="comment">//若找到了，则返回结果</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// not in the cache, need to generate info for this type.</span></span><br><span class="line">	<span class="comment">//加写锁 调用cachedTypeInfo1函数创建并返回，</span></span><br><span class="line">	<span class="comment">//这里需要注意的是在多线程环境下有可能多个线程同时调用到这个地方，</span></span><br><span class="line">	<span class="comment">//所以当你进入cachedTypeInfo1方法的时候需要判断一下是否已经被别的线程先创建成功了。</span></span><br><span class="line">	typeCacheMutex.Lock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> typeCacheMutex.Unlock()  <span class="comment">//等return执行完毕后，才会调用该行defer。再次吐槽go..</span></span><br><span class="line">	<span class="keyword">return</span> cachedTypeInfo1(typ, tags) <span class="comment">//缓存中不存在，则创建对应类型的编码\解码器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>上面代码，真正该注意的是<code>cachedTypeInfo1(typ,tags)</code>，它的目的就是根据数据类型去创建并缓存对应的编码\解码器。代码实现如下：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cachedTypeInfo1</span><span class="params">(typ reflect.Type, tags tags)</span></span> (*typeinfo, <span class="type">error</span>) &#123;</span><br><span class="line">	key := typekey&#123;typ, tags&#125;</span><br><span class="line">	info := typeCache[key]</span><br><span class="line">	<span class="keyword">if</span> info != <span class="literal">nil</span> &#123;  <span class="comment">//此处再次验证是为了避免并发请求造成影响</span></span><br><span class="line">		<span class="keyword">return</span> info, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	typeCache[key] = <span class="built_in">new</span>(typeinfo)  <span class="comment">//根据数据类型，新建一个它的编码\解码器的缓存空间（此时并不知道具体是哪个编码\解码器）</span></span><br><span class="line">	info, err := genTypeInfo(typ, tags) <span class="comment">//根据数据类型，找到它对应的编码\解码器</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">delete</span>(typeCache, key)  <span class="comment">//创建失败则清除此空间</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err  <span class="comment">//返回空</span></span><br><span class="line">	&#125;</span><br><span class="line">	*typeCache[key] = *info <span class="comment">//创建成功保存该编码器</span></span><br><span class="line">	<span class="keyword">return</span> typeCache[key], err <span class="comment">//返回当前数据类型的编码/解码器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>* 上面代码，又有一个重要的函数：`genTypeInfo(typ, tags)`，它用来根据数据类型，找到对应的编码\解码器，具体实现如下：
	<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genTypeInfo</span><span class="params">(typ reflect.Type, tags tags)</span></span> (info *typeinfo, err <span class="type">error</span>) &#123;</span><br><span class="line">	info = <span class="built_in">new</span>(typeinfo)  <span class="comment">//新建一个保存编码\解码的空间</span></span><br><span class="line">	<span class="keyword">if</span> info.decoder, err = makeDecoder(typ, tags); err != <span class="literal">nil</span> &#123; <span class="comment">//解码获取失败，则返回空</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> info.writer, err = makeWriter(typ, tags); err != <span class="literal">nil</span> &#123;  <span class="comment">//编码获取失败，则返回空</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//只有成功找到了编码器和解码器，才会返回它们的映射信息。别忘了info的结构体类型</span></span><br><span class="line">	<span class="keyword">return</span> info, <span class="literal">nil</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<p>清楚了吧，整个编码器和解码器的框架结构其实并不复杂，其中用到的线程安全机制和缓存机制是蛮有意思的。对于上面代码提到的<code>makeDecoder()</code>和<code>makeWriter()</code>,也就是具体获取编码\解码器是怎样实现的，小编在下一部分来解释，莫心急，心急吃不了豆腐～～～</p>
<h3 id="rlp编码过程解析：第4部分">rlp编码过程解析：第4部分</h3>
<ol>
<li>紧接上一部分，<code>makeDecoder()</code>和<code>makeWriter()</code>具体是用来实现获取对应编码\解码器的，这下又跳转回<code>encode.go</code>文件中，小编这里只讲编码器<code>makeWriter()</code>的获取了，解码器类似，只是相反而已。具体如下： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeWriter</span><span class="params">(typ reflect.Type, ts tags)</span></span> (writer, <span class="type">error</span>) &#123;</span><br><span class="line">	kind := typ.Kind()  <span class="comment">//先获取数据类型</span></span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> typ == rawValueType:</span><br><span class="line">			<span class="keyword">return</span> writeRawValue, <span class="literal">nil</span> </span><br><span class="line">		<span class="keyword">case</span> typ.Implements(encoderInterface):</span><br><span class="line">			<span class="keyword">return</span> writeEncoder, <span class="literal">nil</span> </span><br><span class="line">		<span class="keyword">case</span> kind != reflect.Ptr &amp;&amp; reflect.PtrTo(typ).Implements(encoderInterface):</span><br><span class="line">			<span class="keyword">return</span> writeEncoderNoPtr, <span class="literal">nil</span> </span><br><span class="line">		<span class="keyword">case</span> kind == reflect.Interface:</span><br><span class="line">			<span class="keyword">return</span> writeInterface, <span class="literal">nil</span>    </span><br><span class="line">		<span class="keyword">case</span> typ.AssignableTo(reflect.PtrTo(bigInt)):</span><br><span class="line">			<span class="keyword">return</span> writeBigIntPtr, <span class="literal">nil</span>  </span><br><span class="line">		<span class="keyword">case</span> typ.AssignableTo(bigInt):</span><br><span class="line">			<span class="keyword">return</span> writeBigIntNoPtr, <span class="literal">nil</span> </span><br><span class="line">		<span class="keyword">case</span> isUint(kind):</span><br><span class="line">			<span class="keyword">return</span> writeUint, <span class="literal">nil</span>  </span><br><span class="line">		<span class="keyword">case</span> kind == reflect.Bool:</span><br><span class="line">			<span class="keyword">return</span> writeBool, <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> kind == reflect.String:</span><br><span class="line">			<span class="keyword">return</span> writeString, <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> kind == reflect.Slice &amp;&amp; isByte(typ.Elem()):</span><br><span class="line">			<span class="keyword">return</span> writeBytes, <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> kind == reflect.Array &amp;&amp; isByte(typ.Elem()):</span><br><span class="line">			<span class="keyword">return</span> writeByteArray, <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> kind == reflect.Slice || kind == reflect.Array:</span><br><span class="line">			<span class="keyword">return</span> makeSliceWriter(typ, ts)</span><br><span class="line">		<span class="keyword">case</span> kind == reflect.Struct:</span><br><span class="line">			<span class="keyword">return</span> makeStructWriter(typ)</span><br><span class="line">		<span class="keyword">case</span> kind == reflect.Ptr:</span><br><span class="line">			<span class="keyword">return</span> makePtrWriter(typ)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;rlp: type %v is not RLP-serializable&quot;</span>, typ)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这个代码应该很好懂吧，根据不同的数据类型，返回对应的具体的编码函数，注意看<code>makeWriter()</code>的数据返回类型，返回的是一个编码函数，这就是对应数据类型的编码器。每种数据类型都有各自的编码器被返回。建议大家根据需要去仔细读读每种编码器的具体实现方式，也挺有意思的。<br>
另外需要知道，对于长度为1的数据，是没有必要做head记录的。因此，关于对head操作，大伙看看不同的编码器中的处理就明白了。</li>
<li>小编根据第1部分提供的待编码数据类型可知，该数据类型是指针，且实现了<code>EncodeRLP()</code>接口，它对应的类型是上述代码中的第2个<code>case</code>,即<code>typ.Implements(encoderInterface)</code>，因此小编详细介绍下<code>writeEncoder()</code>，先看它的代码：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeEncoder</span><span class="params">(val reflect.Value, w *encbuf)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> val.Interface().(Encoder).EncodeRLP(w)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>就两行代码，指向了我们在第1部分的定义的待编码的结构体数据中的`EncodeRLP()`函数，为了方便演示，小编这里再列出来看看：
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyCoolType <span class="keyword">struct</span> &#123;  </span><br><span class="line">	Name <span class="type">string</span>  </span><br><span class="line">	a, b <span class="type">uint</span>   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *MyCoolType)</span></span> EncodeRLP(w io.Writer) (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> x == <span class="literal">nil</span> </span><br><span class="line">		err = Encode(w, []<span class="type">uint</span>&#123;<span class="number">0</span>, <span class="number">0</span>&#125;) </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		err = Encode(w, []<span class="type">uint</span>&#123;x.a, x.b&#125;)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
呵呵，发现了吧，该接口实现中，调用了`Encode()`函数，其中的参数`w`指的是它是`encbuf`，该函数是在`encode.go`文件中。那就看看它的具体实现吧：
该函数其实也很有特点：因为有的时候，以太坊中的数据并不是直接通过`EncodeToBytes()`传入具体的数据来编码，很多时候它是通过io流传入待编码数据的，因此，其实这个`Encode()`函数也很重要。
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Encode</span><span class="params">(w io.Writer, val <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">//语法说明，断言w.(*encbuf)的具体类型是否为*encbuf，是，则返回给outer=*encbuf,并且ok为true；否，则返回outer=nil，并且ok为false</span></span><br><span class="line">	<span class="keyword">if</span> outer, ok := w.(*encbuf); ok &#123; <span class="comment">//EncodeRLP接口提供的参数是`io.Writer`类型，但是，从前面分析我们得知，我们传入的是实现了`io.Writer`的`encbuf`。因此需要判断。</span></span><br><span class="line">		<span class="keyword">return</span> outer.encode(val) </span><br><span class="line">	&#125;</span><br><span class="line">	eb := encbufPool.Get().(*encbuf) <span class="comment">//若是直接输入的`io.Writer`流来编码，则通过该处对象池将其转为`encbuf`</span></span><br><span class="line">	<span class="keyword">defer</span> encbufPool.Put(eb) <span class="comment">//当return后才会执行</span></span><br><span class="line">	eb.reset()</span><br><span class="line">	<span class="keyword">if</span> err := eb.encode(val); err != <span class="literal">nil</span> &#123; </span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> eb.toWriter(w)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
若传入的是标准`io.Writer`,则该代码最终返回的是`eb.toWriter(w)`流结果，它和`EncodeToBytes()`函数中返回的byte[]结果还是有区别的。
此处编码结束，看看下1部分吧，在坚持一下就可以结束了～～
</code></pre>
<h3 id="rlp编码过程解析：第5部分">rlp编码过程解析：第5部分</h3>
<p>拿到编码器就可以回到第2部分的<code>encode()</code>函数了。返回编码结果，进一步返回到<code>EncodeToBytes()</code>函数，最终返回到第1部分的编码结果。</p>
<h2 id="解码相关概述">解码相关概述</h2>
<p>本来小编是不想讲的，想了想，还是大概说两句吧。<br>
解码和编码的方向相反，方式一样。解码时候，先计算好开辟好的结构体、数据类型等的大小和空间，然后就可以在被序列化的编码中，读取到指定位置的值，从而读取到具体数据。<br>
还不懂吗？看代码吧。。。</p>
<h2 id="总结">总结</h2>
<p>整个编码过程，其实可以这么说明：<br>
待编码数据，先根据数据类型去对象池中找相应的解码器，若没有该解码器则新建一个并将其加入缓存。编码结束后，会返回一个结构体信息，其中包含所有编码后的序列以及其中每个被编码的数据的头部信息（它们在整个编码序列中的位置）。最后，拼装编码序列以及头部信息（此时头部信息会进行编码），生成最终的编码序列。图示如下：</p>
<img src="/articles/c2a19e0e/2.png" class="" title="编码整体流程">
<p>吐出一口老血，终于完成这个浩大的工程了。。。<br>
解码过程就不写了，根据编码过程反推就行。</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>(以太坊源码解读)第1讲-看前必读</title>
    <url>/articles/ff874140/</url>
    <content><![CDATA[<span id="more"></span>
<ul>
<li>本项目是在IntelliJ idea 2017.3.1版中部署的，部署时候，需要注意项目结构，具体部署不是小编的重点，此处就不详细解释了，有需要的可以别的网站查阅，资料很多</li>
<li>可以在此处参考小编从IntelliJ idea发布的以太坊项目来部署：<a href="https://github.com/bitxx/blockchain-analysis">https://github.com/bitxx/blockchain-analysis</a></li>
<li>小编是基于ethereum 1.8.3阅读的（原先看的是1.8.1，看改动不大，这次编辑文章，就直接用1.8.3啦）</li>
<li>源码解读最初参考自：<a href="https://github.com/ZtesoftCS/go-ethereum-code-analysis">https://github.com/ZtesoftCS/go-ethereum-code-analysis</a> ，小编根据自己个人学习方式和理解能力做了大量修改，个人认为，更容易让初学者理解。</li>
</ul>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>使用web3.js与智能合约交互</title>
    <url>/articles/7a486277/</url>
    <content><![CDATA[<p>使用truffle编译并发布智能合约到以太坊私有网络后，接下来，就该开放接口给前端使用了。这时会面临个问题，怎样和以太坊的智能合约进行交互？<br>
大体两种方式：</p>
<ol>
<li>直接使用原生的web3.js与智能合约操作，小编尝试了以下，操作起来很麻烦，总之很别扭。</li>
<li>使用<code>truffle-contract</code>模块来操作智能合约，它将原生的web3.js进行了一些必要的封装，简化了操作方式，用着很顺手，基本类似于写truffle测试用例时候的语法格式。但是<a href="https://github.com/trufflesuite/truffle-contract">官方</a>有些地方的使用方法讲的很模糊，小编在此进一步翻译一下。</li>
</ol>
<span id="more"></span>
<h2 id="truffle-contract的使用-需要有nodejs基础">truffle-contract的使用 (<code>需要有nodejs基础</code>)</h2>
<ol>
<li>truffle编译智能合约，发布到以太坊私有网络。生成的json文件放在接口项目的某文件夹下：<br>
<code>备注：</code>编译发布智能合约可以参考此处：<a href="https://www.bitxx.top/categories/%E5%8E%9F%E5%88%9B/%E4%BB%A5%E5%A4%AA%E5%9D%8A/truffle/%E5%AE%98%E7%BF%BB/">https://www.bitxx.top/categories/原创/以太坊/truffle/官翻/</a></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">小编在此处放的：</span><br><span class="line">testProject/assert/contract/token/CrowdsaleFCToken</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>项目根目录安装web3.js以及truffle-contract:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install web3.js</span><br><span class="line">npm install truffle-contract</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>核心代码，头部声明：<br>
小编用的nodejs的express框架，主要看方法内部就可以，别的地方不用深究</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Web3</span> = <span class="built_in">require</span>(<span class="string">&#x27;web3&#x27;</span>);  <span class="comment">//导入web3模块</span></span><br><span class="line"><span class="keyword">var</span> contract = <span class="built_in">require</span>(<span class="string">&#x27;truffle-contract&#x27;</span>);  <span class="comment">//导入truffle-contract模块</span></span><br><span class="line"><span class="keyword">var</span> crowdsaleToken = <span class="built_in">require</span>(<span class="string">&#x27;../assert/contract/token/CrowdsaleFCToken&#x27;</span>) <span class="comment">//导入（json文件）指定的已经发布到以太坊私有网络中的合约，该合约应该位于第1步提到的地方。</span></span><br><span class="line"><span class="keyword">var</span> web3 = <span class="keyword">new</span> <span class="title class_">Web3</span>();  <span class="comment">//实例化web3</span></span><br><span class="line"><span class="keyword">var</span> token = <span class="title function_">contract</span>(crowdsaleToken);  <span class="comment">//实例化合约，contract方法可以将json解析，并将最终合约文件信息返回</span></span><br><span class="line">web3.<span class="title function_">setProvider</span>(<span class="keyword">new</span> web3.<span class="property">providers</span>.<span class="title class_">HttpProvider</span>());  <span class="comment">//设置网络</span></span><br><span class="line">token.<span class="title function_">setProvider</span>(web3.<span class="property">currentProvider</span>);</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>核心代码，具体合约中的方法以及变量的调用(要注意合约中的方法和变量是不是<code>public</code>的)：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/send&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        token.<span class="title function_">deployed</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">instance</span>) &#123;</span><br><span class="line">            <span class="comment">//调用智能合约方法</span></span><br><span class="line">            instance.<span class="title function_">getTokenExchangeAmount</span>(<span class="number">6000000000000000</span>,<span class="number">100</span>,<span class="number">18</span>,<span class="number">8</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">                res.<span class="title function_">send</span>(result);</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//调用智能合约方法</span></span><br><span class="line">            instance.<span class="title function_">balanceOf</span>(web3.<span class="property">eth</span>.<span class="property">coinbase</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">                res.<span class="title function_">send</span>(result);</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//调用合约中的全局变量或常量</span></span><br><span class="line">            instance.<span class="property">saleAmount</span>.<span class="title function_">call</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">               res.<span class="title function_">send</span>(result);</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//发送以太币，换取token</span></span><br><span class="line">            instance.<span class="title function_">buyTokens</span>(web3.<span class="property">eth</span>.<span class="property">accounts</span>[<span class="number">1</span>],&#123;<span class="attr">from</span>:web3.<span class="property">eth</span>.<span class="property">accounts</span>[<span class="number">1</span>],<span class="attr">value</span>:web3.<span class="title function_">toWei</span>(<span class="number">1000</span>,<span class="string">&quot;ether&quot;</span>)&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">                res.<span class="title function_">send</span>(result);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<pre><code>代码中，`deployed()`标示使用以太坊默认账户操作，也就是`coinbase`账户，也可以使用`at(账户地址)`来指定别的账户。
</code></pre>
<ol start="5">
<li>整体的使用方式就是上面提到的那些了，这么一展示，之后看<a href="https://github.com/trufflesuite/truffle-contract">官方</a>的文档就很容易了</li>
</ol>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>truffle</category>
      </categories>
      <tags>
        <tag>truffle</tag>
        <tag>contracts</tag>
      </tags>
  </entry>
  <entry>
    <title>(truffle官翻)第16讲 将应用和truffle集成编译</title>
    <url>/articles/2937276b/</url>
    <content><![CDATA[<span id="more"></span>
<p>如果你的应用要和Truffle集成在一起（反正小编还没见过有集成在一起的），则需要参考该文档：<a href="http://truffleframework.com/docs/advanced/build_processes">http://truffleframework.com/docs/advanced/build_processes</a><br>
（这个小编就不翻译了，暂时没卵用）</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>truffle</category>
        <category>官翻</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>truffle</tag>
      </tags>
  </entry>
  <entry>
    <title>(truffle官翻)第15讲 网络和app发布</title>
    <url>/articles/cf19e958/</url>
    <content><![CDATA[<span id="more"></span>
<p>暂未翻译</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>truffle</category>
        <category>官翻</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>truffle</tag>
      </tags>
  </entry>
  <entry>
    <title>(truffle官翻)第14讲 各种配置文件（truffle.js、MochaJS、Solidity）</title>
    <url>/articles/c382f486/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="truffle-js配置">truffle.js配置</h2>
<h3 id="概述">概述</h3>
<p>当使用Windows的命令行时，默认的配置文件名与truffle冲突。这种情况下，我们推荐使用Windows的power Shell或Git BASH。你也可以将配置文件重命名为truffle-config.js来避免冲突。<br>
这也是为什么<code>truffle init</code>时候，项目里会生成一个<code>truffle.js</code>和<code>truffle_config.js</code>。</p>
<ol>
<li>配置文件位置：<br>
它在项目根目录中，称为<em>truffle.js</em></li>
<li>必须要配置这个文件，格式如下，默认是8545端口： <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">networks</span>: &#123;</span><br><span class="line">    <span class="attr">development</span>: &#123;</span><br><span class="line">      <span class="attr">host</span>: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">      <span class="attr">port</span>: <span class="number">8545</span>,</span><br><span class="line">      <span class="attr">network_id</span>: <span class="string">&quot;*&quot;</span> <span class="comment">// Match any network id</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="常规配置">常规配置</h3>
<ol>
<li>
<p>build设置<br>
就是说，将你的应用和Truffle结合在一起当应用（一般很少见），可参考：<br>
<a href="/doc/truffle/doc/%E7%AC%AC16%E8%AE%B2_%E5%B0%86%E5%BA%94%E7%94%A8%E5%92%8Ctruffle%E9%9B%86%E6%88%90%E7%BC%96%E8%AF%91.md">第16讲_将应用和truffle集成编译</a></p>
</li>
<li>
<p>合约发布时，可以指定使用哪个网络：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//使用哪种网络，需要在truffle.js中配置</span><br><span class="line">migrate —network live  </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>具体配置文件如下：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">networks</span>: &#123;</span><br><span class="line">      <span class="attr">development</span>: &#123;</span><br><span class="line">        <span class="attr">host</span>: <span class="string">&quot;127.0.0.1&quot;</span>,  <span class="comment">// 默认为localhost</span></span><br><span class="line">        <span class="attr">port</span>: <span class="number">8545</span>,         <span class="comment">// 默认为8545</span></span><br><span class="line">        <span class="attr">network_id</span>: <span class="string">&quot;*&quot;</span> <span class="comment">// match any network</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">live</span>: &#123;</span><br><span class="line">        <span class="attr">host</span>: <span class="string">&quot;178.25.19.88&quot;</span>, <span class="comment">// Random IP for example purposes (do not use)</span></span><br><span class="line">        <span class="attr">port</span>: <span class="number">80</span>,</span><br><span class="line">        <span class="attr">network_id</span>: <span class="number">1</span>,        <span class="comment">// Ethereum public network</span></span><br><span class="line">        <span class="comment">// optional config values:</span></span><br><span class="line">        <span class="comment">// gas  - 默认为4712388  </span></span><br><span class="line">        <span class="comment">// gasPrice  - 默认为100000000000（100Gwei）</span></span><br><span class="line">        <span class="comment">// from - default address to use for any transaction Truffle makes during migrations</span></span><br><span class="line">        <span class="comment">// provider - web3 provider instance Truffle should use to talk to the Ethereum network.</span></span><br><span class="line">        <span class="comment">//          - function that returns a web3 provider instance (see below.)</span></span><br><span class="line">        <span class="comment">//          - if specified, host and port are ignored.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>说明：</p>
<ol>
<li><strong>注意，networks中，每一个代表一个provider</strong></li>
<li>设置网络参数，设置gas和地址等信息，</li>
<li>truffle.js中的networks配置是必要的，默认给出的网络是可以连接在任意的network_id中的，在测试时候，这是有用的，但是在生产环境下，不建议。可通过network _id来指定多个网络。</li>
<li>gas：gas最大值设置，默认为4712388（这个设置的大点，默认就好，）</li>
<li>gasPrice：gas 价格，默认为100000000000wei(众筹一般：100Gwei就够了)</li>
<li>from：移植期间，默认的第一个有效提供者（当前指定以太坊网络中）</li>
<li>provider：默认是web3使用host和port提供：<br>
注意，在任意网络中，或者是设置host/port或者设置provider，不可以同时设置。 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">new</span> <span class="title class_">Web3</span>.<span class="property">providers</span>.<span class="title class_">HttpProvider</span>(<span class="string">&quot;http://&lt;host&gt;:&lt;port&gt;&quot;</span>);</span><br><span class="line">    <span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string">8. 管理多个providers，  </span></span><br><span class="line"><span class="string">一个网络还不够用啊，非要搞一堆，具体自己看文档吧（http://truffleframework.com/docs/advanced/configuration），这里小编偷懒不翻译了，感觉没啥用。</span></span><br><span class="line"><span class="string">9. 设置.sol合约编译输出的默认路径（contracts_build_directory）  </span></span><br><span class="line"><span class="string">默认就是输出来./build/contracts  </span></span><br><span class="line"><span class="string">    `</span><span class="string">``</span>js</span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">      <span class="attr">contracts_build_directory</span>: <span class="string">&quot;./output&quot;</span>,</span><br><span class="line">      <span class="attr">networks</span>: &#123;</span><br><span class="line">        <span class="attr">development</span>: &#123;</span><br><span class="line">          <span class="attr">host</span>: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">          <span class="attr">port</span>: <span class="number">8545</span>,</span><br><span class="line">          <span class="attr">network_id</span>: <span class="string">&quot;*&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<p>Mocha配置</p>
<ol>
<li>可参考：<a href="http://mochajs.org/">http://mochajs.org/</a></li>
<li>例子： <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">mocha</span>: &#123;</span><br><span class="line">  <span class="attr">useColors</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<p>Solidity编译器配置<br>
可以设置solc:</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">solc</span>: &#123;</span><br><span class="line">  <span class="attr">optimizer</span>: &#123;</span><br><span class="line">    <span class="attr">enabled</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">runs</span>: <span class="number">200</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>truffle</category>
        <category>官翻</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>truffle</tag>
      </tags>
  </entry>
  <entry>
    <title>(truffle官翻)第13讲 编写外部脚本</title>
    <url>/articles/712f35b3/</url>
    <content><![CDATA[<span id="more"></span>
<ol>
<li>
<p>有时候想写个外部脚本来和合约交互，Truffle已经替你想好了，你只要这么做就行</p>
</li>
<li>
<p>truffle develop环境中运行：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exec &lt;path/to/file.js&gt;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>文件结构<br>
为了使得脚本能正常运行，需要它们能通过js模块导出一个函数，并且有一个回调函数：</p>
<pre><code class="language-js">module.exports = function(callback)&#123;
   //perform actions
&#125;
</code></pre>
<p>在脚本里，随便写，只要能运行就好。上面那个回调，当脚本结束后，会被执行</p>
</li>
</ol>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>truffle</category>
        <category>官翻</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>truffle</tag>
      </tags>
  </entry>
  <entry>
    <title>(truffle官翻)第12讲 Truffle的develop环境和console环境</title>
    <url>/articles/70e2cc7d/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="概述">概述</h2>
<ol>
<li>总之是很叼的东西，有时候方便测试</li>
<li>提供了两种方式
<ol>
<li>Truffle console :一个基本的交互控制台，用于连接一个已有以太坊网络或者是已有的Truffle Develop环境</li>
<li>Truffle Develop：一个基本的控制台，就是创建独立的一个测试环境（模拟以太坊）</li>
</ol>
</li>
<li>为什么会有这两种方式
<ol>
<li>使用Truffle console
<ol>
<li>有一个真实的区块链网络</li>
<li>想要发布到以太坊公共测网络</li>
<li>想用别的账户名称</li>
</ol>
</li>
<li>使用Truffle Develop
<ol>
<li>用于测试项目，并不急于发布</li>
<li>不需要特殊的账户操作</li>
<li>不想安装或者管理区块链客户端</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="命令">命令</h2>
<ol>
<li>退出环境使用：control+c</li>
<li>所有的命令都需要在你项目的根目录下运行
<ol>
<li>
<p>Truffle console环境，命令：</p>
<pre><code>truffle console
</code></pre>
<p>他将会在配置文件truffle.js中查找命名为development的网络，并且连接。你也可以使用  —netwokr <name>，这样就会去truffle.js对应的networks的 name</p>
</li>
<li>
<p>Truffle Develop环境</p>
<ol>
<li>登陆环境:</li>
</ol>
<pre><code class="language-bash">truffle develop
</code></pre>
</li>
<li>
<p>连接localhost:9545，这种方式不会去考虑truffle.js中配置的环境怎样</p>
</li>
<li>
<p>Truffle console和Truffle Develop的环境的命令基本都一致</p>
</li>
</ol>
</li>
</ol>
<h2 id="主要命令">主要命令</h2>
<p>如果命令不可用，说明该命令对该阶段的项目并不起作用</p>
<ol>
<li>build</li>
<li>compile</li>
<li>create</li>
<li>debug</li>
<li>exec</li>
<li>install</li>
<li>migrate</li>
<li>networks</li>
<li>opcode</li>
<li>publish</li>
<li>test</li>
<li>version</li>
</ol>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>truffle</category>
        <category>官翻</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>truffle</tag>
      </tags>
  </entry>
  <entry>
    <title>(truffle官翻)第7.2讲 编写一个JavaScript测试文件</title>
    <url>/articles/d2be0737/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="概述">概述</h2>
<ul>
<li>Truffle使用了Mocha（<a href="https://mochajs.org/%EF%BC%89%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E5%92%8CChai%E6%96%AD%E8%A8%80%E6%9D%A5%E5%86%99js%E6%B5%8B%E8%AF%95%EF%BC%8C%E8%AE%A9%E6%88%91%E4%BB%AC%E6%9D%A5%E7%9E%85%E7%9E%85%E6%9C%89%E5%A4%9A%E5%90%8A%E3%80%82">https://mochajs.org/）测试框架和Chai断言来写js测试，让我们来瞅瞅有多吊。</a><br>
如果你不熟悉使用Mocha写测试用例，需要先看https://mochajs.org/<br>
小编肯定没用它写过。。。也懒得去专研它了，有需要的还是看原文吧。。</li>
</ul>
<h2 id="呵呵">呵呵</h2>
<p>量真大，翻译不动了。。。。。。。。。。。。。。。</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>truffle</category>
        <category>官翻</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>truffle</tag>
      </tags>
  </entry>
  <entry>
    <title>(truffle官翻)第7.1讲 合约测试</title>
    <url>/articles/d97bcb06/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="框架">框架</h2>
<ol>
<li>可以用两种不同的方式编写简单且容易管理的测试：
<ol>
<li>在JavaScript中，执行合约就像运行一个应用一样简单</li>
<li>在Solidity 中，总之也是很方便</li>
</ol>
</li>
<li>test文件是从根目录中可以找打到，Truffle只会运行.js, .es, .es6, and .jsx, and .sol这几个文件，其他会被忽略</li>
</ol>
<h2 id="命令">命令</h2>
<ol>
<li>运行 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">truffle develop  //进入环境（若已经在项目根目录下进入该环境，则不需要执行该命令）</span><br><span class="line">test  //该环境中测试</span><br></pre></td></tr></table></figure>
</li>
<li>也可指定路径<pre><code>test ./path/to/test/file.js
</code></pre>
</li>
</ol>
<h2 id="独立的运行环境">独立的运行环境</h2>
<p>运行测试文件时，Truffle提供了一个独立的环境，确保每个测试不会被干扰</p>
<h2 id="快速和可靠性">快速和可靠性</h2>
<p>一句话翻译：测试速度老快了，而且老安全了。</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>truffle</category>
        <category>官翻</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>truffle</tag>
      </tags>
  </entry>
  <entry>
    <title>(truffle官翻)第6讲 发布合约</title>
    <url>/articles/615df6fa/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="概述">概述</h2>
<ol>
<li>migrations说白了就是将编译好的智能合约移到网上</li>
<li>truffle项目的根目录中，会找到一个名叫migrations目录：</li>
<li>该目录中都是javascript文件，用于将智能合约发布到以太坊网上</li>
<li>中文翻译migrate，叫做移植，或者是发布，后面就都这么称呼了</li>
<li>就是说，需要再该目录下，编辑一些发布文件，这样才能将合约部署到以太坊上</li>
</ol>
<h2 id="命令">命令</h2>
<p>为了运行migrations目录，同样是在项目根目录下，输入如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">truffle develop  //进入环境（若已经在项目根目录下进入该环境，则不需要执行该命令）</span><br><span class="line">migrate  //该环境中发布，migrate可以指定发布网络，网络在truffle.js中：migrate —live</span><br></pre></td></tr></table></figure>
<p>运行后，在migrations中的所有文件都会被执行。<br>
如果你之前已经运行过，则将从上次运行的位置开始执行。<br>
若其中的文件没有改变，则该命令不生效。<br>
可以加入—reset配置，则可覆盖重新运行该命令。</p>
<h2 id="初始化发布">初始化发布</h2>
<ol>
<li>综述：<br>
我先大概解释下，要不然后面看的一脸懵逼，按我的理解，就是初始化truffle项目的时候，contracts目录中会自动生成一个叫做<em>Migrations.sol</em>的智能合约文件，然后你需要按照“迁移文件（下面介绍）”的规则实现具体的迁移，其中需要引用到该Migrations.sol中的合约，否则移植功能无法实现。<br>
下面的内容都是官方的翻译，基本就是我这句话的意思。</li>
<li>Truffle需要你有一个发布合约以便可以使用提供的移植功能。这个合约必须包含一个特殊的接口，但是你按照你的想法任意修改合约。对于大多数项目，这个合约将会作为第一次迁移进行部署，并且不会再被更新。<br>
另外，这个发布合约在你使用truffle init命令时候，就会被创建出。然后你就可以按着你的想法在里面进行调整了。默认创建的该移植合约如下：<br>
文件地址：<strong>项目根目录/contracts/Migrations.sol</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.17;</span><br><span class="line"></span><br><span class="line">contract Migrations &#123;</span><br><span class="line">  address public owner;</span><br><span class="line">  uint public last_completed_migration;</span><br><span class="line"></span><br><span class="line">  modifier restricted() &#123;</span><br><span class="line">    if (msg.sender == owner) _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function Migrations() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function setCompleted(uint completed) public restricted &#123;</span><br><span class="line">    last_completed_migration = completed;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function upgrade(address new_address) public restricted &#123;</span><br><span class="line">    Migrations upgraded = Migrations(new_address);</span><br><span class="line">    upgraded.setCompleted(last_completed_migration);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>请注意！：<br>
你必须在你第一次发布时候，部署上面的Migrations合约，这样才能移植功能才能生效。为此，你必须创建一个移植文件，类似如下：<br>
<strong>文件名：migrations/1_initial_migration.js</strong> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Migrations</span> = artifacts.<span class="built_in">require</span>(<span class="string">&quot;./Migrations.sol&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params">deployer</span>) &#123;</span><br><span class="line">  deployer.<span class="title function_">deploy</span>(<span class="title class_">Migrations</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<strong>备注</strong>：
<ol>
<li>文件名需要以数字开头，之后的文件名随意。需要数字编号，才能知道记录迁移是否成功。</li>
<li>artifacts.require(“MyContract”)：<br>
在开始移植前，我们会通过该方法告诉Truffle，我们想和哪个合约进行交互。这个方法类似于nodejs中的require，但是在这里，它可以返回一个合约的抽象层，我们可以在我们发布的其余脚本中使用该合约抽象层。</li>
<li>注意：传入的MyContract必须是指具体的合约，而不是一个合约文件名（因为一个文中可能有多个合约）。</li>
<li>module.exports：<br>
所有的迁移必须通过module.exports语法导出一个函数。每个导出的函数必须接受一个deployer对象作为它的第一个参数。该对象提供了一个清晰的语法结构，同时提供了一些通用的职责（比如保存发布的文件，以备稍后使用）</li>
<li>deployer对象是用来缓存发布任务的主要操作接口，这些接口稍后介绍。</li>
</ol>
</li>
<li>可以依照编号继续创建新的发布</li>
</ol>
<h2 id="部署">部署</h2>
<ol>
<li>你的迁移文件被deployer放到部署任务中，，你可以同步编写部署任务，deployer将会按照顺序继续执行： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deployer.deploy(A);</span><br><span class="line">deployer.deploy(B);</span><br></pre></td></tr></table></figure>
</li>
<li>或者也可以按照如下方式进行部署 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Deploy A, then deploy B, passing in A&#x27;s newly deployed address</span></span><br><span class="line">deployer.<span class="title function_">deploy</span>(A).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> deployer.<span class="title function_">deploy</span>(B, A.<span class="property">address</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="网络考虑">网络考虑</h2>
<ol>
<li>根据网络条件部署，这是一项高级功能，请先参考：第15讲 网络和app发布</li>
<li>要考虑网络，则需要按如下编写迁移文件 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params">deployer, network</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (network == <span class="string">&quot;live&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// Do something specific to the network named &quot;live&quot;.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Perform a different step otherwise.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="可用账户">可用账户</h2>
<p>移植文件可以通过客户端或者web3返回一些账户列表如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params">deployer, network, accounts</span>) &#123;</span><br><span class="line">  <span class="comment">// Use the accounts within your migrations.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="api">API</h2>
<p>deployer中包含有很多可以简化移植的功能</p>
<ol>
<li>deployer.deploy(合同，参数…选项)<br>
用于部署一个具体的合同，其中涉及到传入一个合约，还有一些特定的参数。这对单例合约是很有用的，在整个dapp中，只会被实例化一次。</li>
<li>你可以部署一个或者一组合约，以便加速合约的部署。对于第二个参数，可以包含指定的键名（例如：overwrite）或者别的参数(如：gas、from)，如果overwrite设置为false，则表示不会覆盖，不执行该合约。</li>
<li>请注意，在调用deploy部署前，你需要先部署和链接（关于链接，看下一节）好你所依赖的库， <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Deploy a single contract without constructor arguments</span></span><br><span class="line">deployer.<span class="title function_">deploy</span>(A);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Deploy a single contract with constructor arguments</span></span><br><span class="line">deployer.<span class="title function_">deploy</span>(A, arg1, arg2, ...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don&#x27;t deploy this contract if it has already been deployed</span></span><br><span class="line">deployer.<span class="title function_">deploy</span>(A, &#123;<span class="attr">overwrite</span>: <span class="literal">false</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set a maximum amount of gas and `from` address for the deployment</span></span><br><span class="line">deployer.<span class="title function_">deploy</span>(A, &#123;<span class="attr">gas</span>: <span class="number">4612388</span>, <span class="attr">from</span>: <span class="string">&quot;0x....&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Deploy multiple contracts, some with arguments and some without.</span></span><br><span class="line"><span class="comment">// This is quicker than writing three `deployer.deploy()` statements as the deployer</span></span><br><span class="line"><span class="comment">// can perform the deployment as a single batched request.</span></span><br><span class="line">deployer.<span class="title function_">deploy</span>([</span><br><span class="line">  [A, arg1, arg2, ...],</span><br><span class="line">   B,</span><br><span class="line">  [C, arg1]</span><br><span class="line">]);  </span><br><span class="line"><span class="comment">// External dependency example:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For this example, our dependency provides an address when we&#x27;re deploying to the</span></span><br><span class="line"><span class="comment">// live network, but not for any other networks like testing and development.</span></span><br><span class="line"><span class="comment">// When we&#x27;re deploying to the live network we want it to use that address, but in</span></span><br><span class="line"><span class="comment">// testing and development we need to deploy a version of our own. Instead of writing</span></span><br><span class="line"><span class="comment">// a bunch of conditionals, we can simply use the `overwrite` key.</span></span><br><span class="line">deployer.<span class="title function_">deploy</span>(<span class="title class_">SomeDependency</span>, &#123;<span class="attr">overwrite</span>: <span class="literal">false</span>&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li>deployer.link(library,destinations)用于将一个已经部署的library连接到一个或者多个合约。<br>
destinations，目的地，可以是一个或者多个合约，如果目的地不含有效的库，则忽略 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Deploy library LibA, then link LibA to contract B, then deploy B.</span></span><br><span class="line">deployer.<span class="title function_">deploy</span>(<span class="title class_">LibA</span>);</span><br><span class="line">deployer.<span class="title function_">link</span>(<span class="title class_">LibA</span>, B);</span><br><span class="line">deployer.<span class="title function_">deploy</span>(B);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Link LibA to many contracts</span></span><br><span class="line">deployer.<span class="title function_">link</span>(<span class="title class_">LibA</span>, [B, C, D]);</span><br></pre></td></tr></table></figure>
</li>
<li>deployer.then(function(){…})<br>
运行任意一个步骤。在移植过程中使用它来调用特定的合同功能，以添加，编辑和重新组织合同数据。 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line">deployer.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// Create a new version of A</span></span><br><span class="line">  <span class="keyword">return</span> A.<span class="title function_">new</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">instance</span>) &#123;</span><br><span class="line">  a = instance;</span><br><span class="line">  <span class="comment">// Get the deployed instance of B</span></span><br><span class="line">  <span class="keyword">return</span> B.<span class="title function_">deployed</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">instance</span>) &#123;</span><br><span class="line">  b = instance;</span><br><span class="line">  <span class="comment">// Set the new instance of A&#x27;s address on B via B&#x27;s setA() function.</span></span><br><span class="line">  <span class="keyword">return</span> b.<span class="title function_">setA</span>(a.<span class="property">address</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>truffle</category>
        <category>官翻</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>truffle</tag>
      </tags>
  </entry>
  <entry>
    <title>(truffle官翻)第5讲 编译合约</title>
    <url>/articles/fad85707/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="概述">概述</h2>
<p>小编使用的是Truffle Develope环境，因此，关于项目编译的命令，都没有加上前缀truffle，若使用Ganache环境，请加上该前缀，具体可参考其中的描述：第4讲 选择一个以太坊客户端</p>
<h2 id="位置">位置</h2>
<ul>
<li>在/contracts中，所有的智能合约原文件都在这里（后缀为.sol的文件）</li>
<li>在/contracts中，有一个默认的Migrations.sol文件，它是用来协助部署的。</li>
</ul>
<h2 id="命令行">命令行</h2>
<p>为了编译truffle项目，需要先进入到项目根目录，然后输入如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">truffle develop  //进入环境</span><br><span class="line">compile  //该环境中编译</span><br></pre></td></tr></table></figure>
<p>当你第一次编译的时候，所有的合约都会被编译；<br>
当再次编译的时候，只会编译改动过的合约文件；<br>
如果要覆盖重新编译，则需要输入配置项：–all</p>
<h2 id="编译出的文件">编译出的文件</h2>
<p>编译生成的文件会被放在/build/contracts目录中，不可以修改其中的文件</p>
<h2 id="依赖">依赖</h2>
<p>可以使用import命令来申明合约的依赖关系，truffle会依照正确的顺序编译合同，并且确保所有的依赖关系发送给编译器，可以使用两种方式指定依赖</p>
<ol>
<li>通过文件名导入依赖<br>
要从单独的文件导入别的合约，需要填入如下代码到你的当前合约源文件中： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import <span class="string">&quot;./AnotherContract.sol&quot;</span></span><br></pre></td></tr></table></figure>
这将会使得AnotherContract.sol中的合约都生效</li>
<li>从现有的包中导入合约，
<ol>
<li>truffle支持从EthPM或者npm安装的包文件中导入的合约，在你当前编辑的合约中加入（编译时，truffle会先检索EthPM的包，然后才是npm的）：<pre><code>import &quot;somepackage/SomeContract.sol&quot;
</code></pre>
</li>
<li>EthPM没用过。。。自行网上搜索吧</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>truffle</category>
        <category>官翻</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>truffle</tag>
      </tags>
  </entry>
  <entry>
    <title>(truffle官翻)第3讲 创建项目</title>
    <url>/articles/39ce2b06/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="概述">概述</h2>
<p>官方和社区已有项目应用地址：<a href="http://truffleframework.com/boxes/metacoin">http://truffleframework.com/boxes/metacoin</a></p>
<h2 id="安装">安装</h2>
<ul>
<li>从头开始项目建立空项目
<ol>
<li>创建和初始化： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> testproject</span><br><span class="line"><span class="built_in">cd</span> testproject</span><br><span class="line">truffle init</span><br></pre></td></tr></table></figure>
</li>
<li>目录结构： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -<span class="built_in">print</span> | sed -e <span class="string">&#x27;s;[^/]*/;|____;g;s;____|; |;g’ //mac环境</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>truffle</category>
        <category>官翻</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>truffle</tag>
      </tags>
  </entry>
  <entry>
    <title>(truffle官翻)第4讲 选择一个以太坊客户端</title>
    <url>/articles/dbe1bf88/</url>
    <content><![CDATA[<h1>第4讲_选择一个以太坊客户端</h1>
<span id="more"></span>
<h2 id="概述">概述</h2>
<p>需要选择一个以太坊客户端环境来测试truffle项目</p>
<h2 id="环境介绍">环境介绍</h2>
<p>truffle推荐我们使用三种测试使用的客户端（小编选择第二种方式了，再安装别的，电脑就要爆了）</p>
<ol>
<li>Ganache（图形界面）
<ol>
<li>以前我们使用的是testrpc环境，但是Truffle建议我们使用Ganache，也就是testrpc的升级版，它已经取代了testrpc</li>
<li>需要单独安装，安装地址：<a href="http://truffleframework.com/ganache">http://truffleframework.com/ganache</a></li>
<li>Ganache优点
<ol>
<li>它简化了dapp的开发，可以快速的了解truffle项目是怎样影响区块链，</li>
<li>查看账户、余额、合同创建以及gas成本等细节。</li>
<li>可以对挖矿进行微调</li>
</ol>
</li>
<li>启动后，Ganache是运行在：http://127.0.0.1:7545地址下。它将会展示前10个默认账户以及每个账户对应的助记符（mnemonic，毕竟原始账户一个那么长的字符串，很难记忆，改成助记符得方便很多）</li>
<li>另外：
<ol>
<li>不要在公网使用助记符，会丢失你的财产</li>
<li>助记符参考地址：<a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki</a></li>
</ol>
</li>
</ol>
</li>
<li>Truffle Develop
<ol>
<li>默认端口号是9545</li>
<li>Truffle内置的一个客户端，不需要单独安装，使用如下命令即可进入该环境：<pre><code class="language-bash">truffle develop
</code></pre>
 <img src="/articles/dbe1bf88/1.png" class="" title="启动界面">
</li>
<li>启动后，就像前面提到的Ganache，同样会给出助记符</li>
<li>之后就可以输入truffle相关命令了<br>
注意：Ganache中环境中，每个命令都要加上前缀truffle，但是在Truffle Develop环境中，不需要。</li>
</ol>
</li>
<li>Ganache 命令行<br>
略，小编用第二种方式就够了</li>
</ol>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>truffle</category>
        <category>官翻</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>truffle</tag>
      </tags>
  </entry>
  <entry>
    <title>(truffle官翻)第2讲 安装</title>
    <url>/articles/4926f4e0/</url>
    <content><![CDATA[<ul>
<li>这是mac版安装方式，其余linux可参考</li>
</ul>
<span id="more"></span>
<ul>
<li>是以太坊最受欢迎的一个框架，需要nodejs支持，安装nodejs
<ul>
<li>nodejs安装  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install nodejs</span><br></pre></td></tr></table></figure>
</li>
<li>使用npm安装到所有model都在这个路径路径：/usr/lib/node_modules</li>
<li>下载并安装truffle  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g truffle  //其中-g参数指定将包安装到全局环境中。</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>查看truffle版本  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">truffle version</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>truffle</category>
        <category>官翻</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>truffle</tag>
      </tags>
  </entry>
  <entry>
    <title>(truffle官翻)第1讲 概述</title>
    <url>/articles/1e5b5f1/</url>
    <content><![CDATA[<span id="more"></span>
<ul>
<li>参考官网文档：<a href="http://truffleframework.com/docs/">http://truffleframework.com/docs/</a></li>
<li>truffle的作用，基本一句话：是用来编译、测试、部署智能合约的工具，使用起来非常方便。</li>
<li>建议有智能合约编写基础再来看本教程，参考官网：<a href="http://truffleframework.com/">http://truffleframework.com/</a></li>
<li>truffle版本：4.1.3</li>
<li>solidity:0.4.19</li>
</ul>
]]></content>
      <categories>
        <category>区块链</category>
        <category>ethereum</category>
        <category>truffle</category>
        <category>官翻</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>truffle</tag>
      </tags>
  </entry>
</search>
